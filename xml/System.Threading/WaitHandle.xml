<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3118dc18b7fa730ca98fb9d4d7f20a2a31bb502" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48765176" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="ce6e1-101">Hermetyzuje obiekty specyficzne dla systemu operacyjnego, które poczekaj, aż wyłącznego dostępu do udostępnionych zasobów.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce6e1-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-102"><xref:System.Threading.WaitHandle> Klasa hermetyzuje dojście synchronizacji macierzystego systemu operacyjnego i jest używana do reprezentowania wszystkich obiektów synchronizacji w środowisku uruchomieniowym, zezwalających na wiele operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="ce6e1-103">Dla porównania uchwytami oczekiwania z innymi obiektami synchronizacji, zobacz [Przegląd podstawowych synchronizacji](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="ce6e1-104"><xref:System.Threading.WaitHandle> Sama klasa jest abstrakcyjna.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="ce6e1-105">Klasy pochodne <xref:System.Threading.WaitHandle> zdefiniowanie sygnalizowanie zasad, aby wskazać, biorąc lub zwalnianie dostęp do udostępnionego zasobu, ale używają dziedziczonego <xref:System.Threading.WaitHandle> metody, aby zablokować podczas oczekiwania na dostęp do zasobów udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="ce6e1-106">Klasy pochodne <xref:System.Threading.WaitHandle> obejmują:</span><span class="sxs-lookup"><span data-stu-id="ce6e1-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="ce6e1-107"><xref:System.Threading.Mutex> Klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="ce6e1-108">Zobacz [muteksy](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="ce6e1-109"><xref:System.Threading.EventWaitHandle> Klasa i jej klasy pochodne <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="ce6e1-110">Zobacz [EventWaitHandle, autoresetevent —, CountdownEvent ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="ce6e1-111"><xref:System.Threading.Semaphore> Klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="ce6e1-112">Zobacz [Semaphore i SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="ce6e1-113">Wątki, można zablokować na dojście oczekiwania poszczególnych przez wywołanie metody wystąpienia <xref:System.Threading.WaitHandle.WaitOne%2A>, który jest dziedziczone przez klasy pochodne <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="ce6e1-114">Klasy pochodne z <xref:System.Threading.WaitHandle> różnią się w ich koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="ce6e1-115">Uchwyty oczekiwania zdarzeń (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, i <xref:System.Threading.ManualResetEvent>) i semaforów nie mają koligacji wątku; wątek może sygnał dojście oczekiwania zdarzeń lub semafor.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="ce6e1-116">Muteksy, z drugiej strony, pozostają w koligacji wątku; Wątek, który jest właścicielem obiektu mutex musi zwolnić go, a wyjątek jest generowany, jeśli wątek wywołuje <xref:System.Threading.Mutex.ReleaseMutex%2A> metody na element mutex, który nie jest właścicielem.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="ce6e1-117">Ponieważ <xref:System.Threading.WaitHandle> klasa pochodzi od <xref:System.MarshalByRefObject>, te klasy mogą być używane do synchronizowania działania wątków poza granice domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="ce6e1-118">Oprócz jej klasy pochodne <xref:System.Threading.WaitHandle> klasa ma szereg metod statycznych, które blokują wątek, dopóki jedna lub więcej obiektów synchronizacji odebrania sygnału.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="ce6e1-119">Należą do nich następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="ce6e1-119">These include:</span></span>  
  
-   <span data-ttu-id="ce6e1-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, co pozwala wątku w celu zasygnalizowania określonego dojścia oczekiwania i natychmiast czekać na innym.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="ce6e1-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, pozwalający wątku, poczekać, aż wszystkie dojścia oczekiwania w tablicy odbioru sygnału.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="ce6e1-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, pozwalający wątku, poczekać, aż zasygnalizują któregokolwiek z określonego zestawu dojść oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="ce6e1-123">Przeciążenia metody te zawierają interwałów limitu czasu dla porzucenie czas oczekiwania i możliwość zamknąć kontekstu synchronizacji przed wejściem czas oczekiwania, dzięki czemu inne wątki używać kontekstu synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ce6e1-124">Ten typ implementuje <xref:System.IDisposable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="ce6e1-125">Po zakończeniu przy użyciu typu lub typ pochodzący od niego bezpośrednio lub pośrednio należy usunąć z niej.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="ce6e1-126">Do usuwania tego typu, należy wywołać jej <xref:System.Threading.WaitHandle.Close%2A> method in Class metoda `try` / `catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="ce6e1-127">Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="ce6e1-128">Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="ce6e1-129"><xref:System.Threading.WaitHandle> implementuje <xref:System.IDisposable.Dispose%2A> wzorca.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="ce6e1-130">Zobacz [wzorca usuwania](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="ce6e1-131">Po utworzeniu klasy pochodnej z <xref:System.Threading.WaitHandle>, użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwość, aby przechowywać swoje dojście macierzystego systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="ce6e1-132">Nie trzeba zastąpić chronionego <xref:System.Threading.WaitHandle.Dispose%2A> metoda chyba że są używane dodatkowe zasoby niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-133">Poniższy kod przedstawia przykład jak dwa wątki mogą wykonaj zadania w tle podczas główny wątek czeka na zadania do wykonania przy użyciu statycznych <xref:System.Threading.WaitHandle.WaitAny%2A> i <xref:System.Threading.WaitHandle.WaitAll%2A> metody <xref:System.Threading.WaitHandle> klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="ce6e1-134">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce6e1-134">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="ce6e1-135">Wątkowość</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce6e1-135">Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">
      <span data-ttu-id="ce6e1-136">Wątkowość obiektów i funkcji</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce6e1-136">Threading Objects and Features</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">
      <span data-ttu-id="ce6e1-137">Muteksy</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce6e1-137">Mutexes</span>
      </span>
    </related>
    <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
      <span data-ttu-id="ce6e1-138">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce6e1-138">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
      <span data-ttu-id="ce6e1-139">Semaforów</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce6e1-139">Semaphores</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-140">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-140">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-141">Zwalnia wszystkie zasoby zajmowane przez bieżącą <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-141">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-142">Ta metoda jest implementacją publicznych <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodę <xref:System.Threading.WaitHandle> klasy i jej klasy pochodne.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-142">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="ce6e1-143">Zapewnia standardową implementację, która wywołuje `Dispose(Boolean)` przeciążenia z `true` argument, a następnie wywołania <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-143">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ce6e1-144">Wywołaj tę metodę, aby zwolnić wszystkie zasoby zajmowane przez wystąpienia `WaitHandle` lub klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-144">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="ce6e1-145">Gdy ta metoda jest wywoływana, odwołania do bieżącego wystąpienia spowodować niezdefiniowane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-145">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce6e1-146">Zawsze wywołuj <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed publikacją swoje ostatnie odwołanie do <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-146">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="ce6e1-147">W przeciwnym razie nie zostanie zwolniona przez nią zasoby.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-147">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="ce6e1-148">Należy zastąpić <see langword="Dispose(Boolean)" /> metodę, aby zwolnić zasoby przydzielone w klasach pochodnych.</span>
            <span class="sxs-lookup">
              <span data-stu-id="ce6e1-148">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="ce6e1-149">Implementacja metody Dispose</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-149">Implementing a Dispose Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-150">Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.WaitHandle" /> klasy</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-151">Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.WaitHandle" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-151">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-152">Ta metoda jest odpowiednikiem <xref:System.Threading.WaitHandle.Close%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-152">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce6e1-153">Zawsze wywołuj <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed publikacją swoje ostatnie odwołanie do <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-153">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="ce6e1-154">W przeciwnym razie nie zostanie zwolniona przez nią zasoby.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-154">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">
          <span data-ttu-id="ce6e1-155">Oczyszczanie zasobów niezarządzanych</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-155">Cleaning Up Unmanaged Resources</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="ce6e1-156">
            <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-156">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-157">W przypadku przesłonięcia w klasie pochodnej, zwalnia zasoby niezarządzane używane przez <see cref="T:System.Threading.WaitHandle" />i opcjonalnie zwalnia zasoby zarządzane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-157">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-158">Ta metoda jest wywoływana <xref:System.Threading.WaitHandle.Close%2A> i <xref:System.Threading.WaitHandle.Dispose> metod z `explicitDisposing` parametr `true`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-158">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="ce6e1-159">Gdy `explicitDisposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.Threading.WaitHandle> obiektu odwołania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-159">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="ce6e1-160">Należy zastąpić <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> metodę, aby zwolnić zasoby przydzielone w klasach pochodnych.</span>
            <span class="sxs-lookup">
              <span data-stu-id="ce6e1-160">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
            <span data-ttu-id="ce6e1-161">
              <see cref="M:System.Threading.WaitHandle.Close" /> Lub <see cref="M:System.Threading.WaitHandle.Dispose" /> metoda może być wywoływana wiele razy przez inne obiekty.</span>
            <span class="sxs-lookup">
              <span data-stu-id="ce6e1-161">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="ce6e1-162">W przypadku przesłaniania tej metody należy uważać, aby nie odwołują się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see langword="Dispose" /> lub <see langword="Close" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="ce6e1-162">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="ce6e1-163">Implementacja metody Dispose</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-163">Implementing a Dispose Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-164">Pobiera lub ustawia uchwyt macierzystego systemu operacyjnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-164">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ce6e1-165">
            <see langword="IntPtr" /> Reprezentujący dojście macierzystego systemu operacyjnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-165">An <see langword="IntPtr" /> representing the native operating system handle.</span>
          </span>
          <span data-ttu-id="ce6e1-166">Wartość domyślna to wartość <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-166">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-167">Przypisywanie nową wartość do <xref:System.Threading.WaitHandle.Handle%2A> właściwości nie zamyka uchwyt poprzedniego.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-167">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="ce6e1-168">Może to spowodować, że ujawnione dojście.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-168">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="ce6e1-169">Nie należy używać tej właściwości w .NET Framework w wersji 2.0 lub nowszy; Użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-169">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="ce6e1-170">Ustawienie tej właściwości na prawidłowy uchwyt również zestawów <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości, ale ustawienie <xref:System.Threading.WaitHandle.InvalidHandle> może spowodować ujawnione dojście.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-170">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="ce6e1-171">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego, można ustawić wartości właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-171">Requires full trust for the immediate caller to set the property value.</span>
          </span>
          <span data-ttu-id="ce6e1-172">Nie można ustawić tego elementu członkowskiego przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-172">This member cannot be set by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="ce6e1-173">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> można ustawić wartości właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-173">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-174">Reprezentuje uchwyt nieprawidłowy macierzystego systemu operacyjnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-174">Represents an invalid native operating system handle.</span>
          </span>
          <span data-ttu-id="ce6e1-175">To pole jest tylko do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-175">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-176">Używana wewnętrznie w celu zainicjowania <xref:System.Threading.WaitHandle.Handle%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-176">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="ce6e1-177">Tej wartości można użyć, aby określić, czy <see cref="P:System.Threading.WaitHandle.Handle" /> właściwość zawiera uchwyt prawidłowego macierzystego systemu operacyjnego.</span>
            <span class="sxs-lookup">
              <span data-stu-id="ce6e1-177">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-178">Pobiera lub ustawia uchwyt macierzystego systemu operacyjnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-178">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ce6e1-179">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> reprezentujący dojście macierzystego systemu operacyjnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-179">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-180">Podczas przypisywania nową wartość do <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości poprzedniego uchwyt zostaną zamknięte, kiedy poprzednie <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> obiektu są zbierane.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-180">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="ce6e1-181">Nie ręcznie zamknąć dojście, ponieważ powoduje to <xref:System.ObjectDisposedException> podczas <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> próbuje zamknąć dojście.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-181">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="ce6e1-182"><xref:System.Threading.WaitHandle> implementuje <xref:System.IDisposable.Dispose%2A> wzorca.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-182"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="ce6e1-183">Zobacz [wzorca usuwania](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-183">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="ce6e1-184">Po utworzeniu klasy pochodnej z <xref:System.Threading.WaitHandle>, użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwość, aby przechowywać swoje dojście systemu operacyjnego uchwyt macierzysty.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-184">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="ce6e1-185">Nie trzeba zastąpić chronionego <xref:System.Threading.WaitHandle.Dispose%2A> metoda chyba że są używane dodatkowe zasoby niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-185">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="ce6e1-186">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-186">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="ce6e1-187">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-187">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="ce6e1-188">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> do wywoływania tego elementu członkowskiego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-188">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-189">Sygnalizuje jeden <see cref="T:System.Threading.WaitHandle" /> i czeka na innym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-189">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="ce6e1-190">
            <see cref="T:System.Threading.WaitHandle" /> Na sygnał.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-190">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="ce6e1-191">
            <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-191">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-192">Sygnalizuje jeden <see cref="T:System.Threading.WaitHandle" /> i czeka na innym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-192">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-193">
            <see langword="true" /> Jeśli zarówno sygnałem, jak i czas oczekiwania zakończy się pomyślnie; Jeśli czas oczekiwania nie zostanie ukończone, metoda nie zwraca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-193">
              <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-194">Ta operacja nie jest gwarantowana niepodzielnych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-194">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="ce6e1-195">Po bieżącym sygnały wątku `toSignal` , ale przed jego czeka `toWaitOn`, wątek, który działa na inny procesor może być sygnał `toWaitOn` lub zaczekaj na nim.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-195">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-196">Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenia metody, aby zezwolić na wątek główny sygnał zablokowany wątek i poczekać, aż wątek kończy zadanie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-196">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="ce6e1-197">Przykład rozpoczyna pięć wątków, pozwala na ich blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flaga, a następnie jeden wątek wersji czasu użytkownik naciśnie klawisz ENTER.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-197">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="ce6e1-198">Przykład następnie kolejkuje innego pięć wątków i zwalnia je za pomocą <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-198">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-199">
            <paramref name="toSignal" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-199">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-200">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-200">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-201">
            <paramref name="toWaitOn" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-201">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-202">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-202">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="ce6e1-203">Ta metoda nie jest obsługiwana na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-203">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-204">
            <paramref name="toSignal" /> jest semafor i jest już pełna liczba.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-204">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-205">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-205">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-206">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-206">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="ce6e1-207">
            <see cref="T:System.Threading.WaitHandle" /> Na sygnał.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-207">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="ce6e1-208">
            <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-208">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ce6e1-209">Liczba całkowita, która reprezentuje interwałem oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-209">An integer that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="ce6e1-210">Jeśli wartość jest <see cref="F:System.Threading.Timeout.Infinite" />, -1, czas oczekiwania jest nieskończona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-210">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ce6e1-211">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-211">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-212">Sygnalizuje jeden <see cref="T:System.Threading.WaitHandle" /> i czeka na innym, określając interwał limitu czasu jako liczba całkowita 32-bitowe podpisane i określeniu, czy zakończyć domeny synchronizacji dla kontekstu przed wejściem czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-212">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-213">
            <see langword="true" /> Jeśli zarówno sygnałem, jak i czas oczekiwania zakończone pomyślnie, lub <see langword="false" /> Jeśli sygnału ukończone, ale czas oczekiwania upłynął limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-213">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-214">Ta operacja nie jest gwarantowana niepodzielnych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-214">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="ce6e1-215">Po bieżącym sygnały wątku `toSignal` , ale przed jego czeka `toWaitOn`, wątek, który działa na inny procesor może być sygnał `toWaitOn` lub zaczekaj na nim.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-215">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="ce6e1-216">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-216">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-217">Sprawdza stan `toWaitOn` i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-217">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ce6e1-218">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="ce6e1-218">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ce6e1-219">`exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-219">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ce6e1-220">Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-220">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ce6e1-221">Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-221">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ce6e1-222">Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-222">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="ce6e1-223">Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.SignalAndWait%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-223">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="ce6e1-224">Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-224">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ce6e1-225">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-225">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ce6e1-226">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-226">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ce6e1-227">Gdy <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-227">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-228">
            <paramref name="toSignal" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-228">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-229">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-229">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-230">
            <paramref name="toWaitOn" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-230">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-231">Metoda jest wywoływana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-231">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="ce6e1-232">Ta metoda nie jest obsługiwana na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-232">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-233">
            <see cref="T:System.Threading.WaitHandle" /> Nie sygnalizowane, ponieważ może to spowodować przekroczenie jego maksymalną liczbę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-233">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-234">
            <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-234">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-235">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-235">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-236">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-236">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="ce6e1-237">
            <see cref="T:System.Threading.WaitHandle" /> Na sygnał.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-237">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="ce6e1-238">
            <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-238">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="ce6e1-239">A <see cref="T:System.TimeSpan" /> reprezentujący interwał oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-239">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="ce6e1-240">Jeśli wartość wynosi -1, czas oczekiwania jest nieskończona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-240">If the value is -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ce6e1-241">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-241">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-242">Sygnalizuje jeden <see cref="T:System.Threading.WaitHandle" /> i czeka na innym, określając interwał limitu czasu jako <see cref="T:System.TimeSpan" /> i określenie, czy chcesz zamknąć domeny synchronizacji dla kontekstu przed wejściem czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-242">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-243">
            <see langword="true" /> Jeśli zarówno sygnałem, jak i czas oczekiwania zakończone pomyślnie, lub <see langword="false" /> Jeśli sygnału ukończone, ale czas oczekiwania upłynął limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-243">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-244">Ta operacja nie jest gwarantowana niepodzielnych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-244">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="ce6e1-245">Po bieżącym sygnały wątku `toSignal` , ale przed jego czeka `toWaitOn`, wątek, który działa na inny procesor może być sygnał `toWaitOn` lub zaczekaj na nim.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-245">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="ce6e1-246">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-246">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ce6e1-247">Jeśli `timeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-247">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-248">Sprawdza stan `toWaitOn` i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-248">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ce6e1-249">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="ce6e1-249">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ce6e1-250">`exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-250">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ce6e1-251">Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-251">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ce6e1-252">Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-252">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ce6e1-253">Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-253">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="ce6e1-254">Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.SignalAndWait%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-254">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="ce6e1-255">Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-255">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ce6e1-256">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-256">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ce6e1-257">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-257">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ce6e1-258">Gdy <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-258">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-259">
            <paramref name="toSignal" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-259">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-260">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-260">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-261">
            <paramref name="toWaitOn" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-261">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-262">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-262">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="ce6e1-263">Ta metoda nie jest obsługiwana na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-263">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-264">
            <paramref name="toSignal" /> jest semafor i jest już pełna liczba.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-264">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-265">
            <paramref name="timeout" /> Zwraca ujemną liczbę milisekund od-1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-265">
              <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          </span>
          <span data-ttu-id="ce6e1-266">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-266">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-267">
            <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-267">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-268">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-268">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-269">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-269">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-270">Czeka, aż wszystkie elementy w wybranej tablicy do otrzymania sygnału.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-270">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ce6e1-271">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-271">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="ce6e1-272">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-272">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-273">Czeka, aż wszystkie elementy w wybranej tablicy do otrzymania sygnału.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-273">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-274">
            <see langword="true" /> gdy każdy element w kolekcji <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie metoda nigdy nie zwraca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-274">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-275"><xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-275"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ce6e1-276">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` po mutex zostanie porzucony.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-276">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ce6e1-277">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-277">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ce6e1-278">W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-278">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ce6e1-279">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-279">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ce6e1-280"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy są sygnalizowane wszystkie uchwyty.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-280">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="ce6e1-281">W niektórych implementacjach obsługuje więcej niż 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-281">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="ce6e1-282">Jeśli tablica zawiera duplikaty, wywołanie zakończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-282">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce6e1-283"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-283">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="ce6e1-284">Wywołanie tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenie metody i określając wartość -1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-284">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-285">Poniższy przykład kodu pokazuje, jak używać puli wątków, aby asynchronicznie tworzyć i zapisywać grupy plików.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-285">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="ce6e1-286">Po zakończeniu każdej operacji zapisu jest w kolejce jako element roboczy i sygnałów.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-286">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="ce6e1-287">Główny wątek czeka, aż wszystkie elementy do sygnalizowania, a następnie kończy działanie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-287">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-288">
            <paramref name="waitHandles" /> Parametr <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-288">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-289">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-289">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-290">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablicy są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-290">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-291">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-291">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-292">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-292">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="ce6e1-293">W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.ArgumentException" />, a zamiast tego.</span>
              <span class="sxs-lookup">
                <span data-stu-id="ce6e1-293">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="ce6e1-294">
            <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-294">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-295">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-295">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="ce6e1-296">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-296">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-297">
            <see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-297">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ce6e1-298">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-298">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-299">Czas oczekiwania zakończone, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-299">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-300">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-300">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-301">
            <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-301">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ce6e1-302">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-302">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="ce6e1-303">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu (duplikatów).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-303">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ce6e1-304">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-304">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-305">Czeka, aż wszystkie elementy w określonej tablicy, aby otrzymać sygnał, za pomocą <see cref="T:System.Int32" /> wartość, aby określić interwał czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-305">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-306">
            <see langword="true" /> gdy każdy element w kolekcji <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-306">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-307">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-307">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-308">Testuje, stan uchwytami oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-308">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-309"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania skończy się, co oznacza, że gdy wszystkie uchwyty są sygnalizowane lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-309">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="ce6e1-310">W niektórych implementacjach obsługuje więcej niż 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-310">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="ce6e1-311">Jeśli istnieją duplikaty w tablicy, wywołania kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-311">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce6e1-312"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-312">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="ce6e1-313">Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-313">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-314">
            <paramref name="waitHandles" /> Parametr <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-314">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-315">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-315">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-316">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-316">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-317">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-317">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-318">
            <paramref name="waitHandles" /> jest tablicą bez elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-318">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="ce6e1-319">W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.ArgumentException" />, a zamiast tego.</span>
              <span class="sxs-lookup">
                <span data-stu-id="ce6e1-319">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="ce6e1-320">
            <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-320">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-321">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-321">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="ce6e1-322">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-322">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-323">
            <see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-323">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-324">
            <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-324">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-325">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-325">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-326">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-326">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-327">
            <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-327">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ce6e1-328">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-328">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="ce6e1-329">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-329">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="ce6e1-330">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund-1, aby czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-330">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-331">Czeka, aż wszystkie elementy w określonej tablicy, aby otrzymać sygnał, za pomocą <see cref="T:System.TimeSpan" /> wartość, aby określić interwał czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-331">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-332">
            <see langword="true" /> gdy każdy element w kolekcji <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-332">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-333">Jeśli `timeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-333">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-334">Testuje, stan uchwytami oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-334">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-335"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania skończy, co oznacza, że są sygnalizowane albo wszystkie dojścia lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-335">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="ce6e1-336">W niektórych implementacjach obsługuje więcej niż 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-336">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="ce6e1-337">Jeśli tablica zawiera duplikaty, wywołanie zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-337">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce6e1-338"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-338">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="ce6e1-339">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-339">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ce6e1-340">Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-340">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-341">
            <paramref name="waitHandles" /> Parametr <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-341">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-342">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-342">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-343">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-343">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-344">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-344">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-345">
            <paramref name="waitHandles" /> jest tablicą bez elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-345">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="ce6e1-346">W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.ArgumentException" />, a zamiast tego.</span>
              <span class="sxs-lookup">
                <span data-stu-id="ce6e1-346">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="ce6e1-347">
            <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-347">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-348">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-348">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="ce6e1-349">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-349">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-350">
            <see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-350">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-351">
            <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-351">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="ce6e1-352">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-352">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-353">
            <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-353">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-354">Czas oczekiwania zakończone, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-354">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-355">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-355">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-356">
            <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-356">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ce6e1-357">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-357">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="ce6e1-358">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu (duplikatów).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-358">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ce6e1-359">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-359">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ce6e1-360">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-360">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-361">Czeka, aż wszystkie elementy w określonej tablicy, aby otrzymać sygnał, za pomocą <see cref="T:System.Int32" /> wartością do określenia interwału czasu i określeniu, czy zakończyć domeny synchronizacji przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-361">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-362">
            <see langword="true" /> gdy każdy element w kolekcji <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-362">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-363">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-363">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-364">Testuje, stan uchwytami oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-364">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-365"><xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-365"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ce6e1-366">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` po mutex zostanie porzucony.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-366">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ce6e1-367">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-367">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ce6e1-368">W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-368">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ce6e1-369">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-369">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ce6e1-370"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania skończy się, co oznacza, że gdy wszystkie uchwyty są sygnalizowane lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-370">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="ce6e1-371">W niektórych implementacjach obsługuje więcej niż 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-371">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="ce6e1-372">Jeśli istnieją duplikaty w tablicy, wywołania kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-372">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce6e1-373"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-373">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ce6e1-374">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="ce6e1-374">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ce6e1-375">`exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitAll%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-375">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ce6e1-376">Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-376">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ce6e1-377">Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-377">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ce6e1-378">Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-378">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="ce6e1-379">Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitAll%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-379">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="ce6e1-380">Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-380">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="ce6e1-381">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-381">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ce6e1-382">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-382">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ce6e1-383">Gdy <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-383">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-384">Poniższy przykład kodu pokazuje, jak używać puli wątków, aby asynchronicznie tworzyć i zapisywać grupy plików.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-384">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="ce6e1-385">Po zakończeniu każdej operacji zapisu jest w kolejce jako element roboczy i sygnałów.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-385">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="ce6e1-386">Główny wątek czeka, aż wszystkie elementy do sygnalizowania, a następnie kończy działanie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-386">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-387">
            <paramref name="waitHandles" /> Parametr <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-387">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-388">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-388">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-389">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-389">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-390">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-390">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-391">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-391">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="ce6e1-392">
            <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-392">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-393">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-393">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="ce6e1-394">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-394">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-395">
            <see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-395">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ce6e1-396">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-396">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-397">
            <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-397">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-398">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-398">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-399">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-399">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-400">
            <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-400">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ce6e1-401">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-401">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="ce6e1-402">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-402">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="ce6e1-403">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund-1, aby czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-403">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ce6e1-404">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-404">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-405">Czeka, aż wszystkie elementy w określonej tablicy, aby otrzymać sygnał, za pomocą <see cref="T:System.TimeSpan" /> wartość do określenia interwału czasu, a określająca, czy zakończyć domeny synchronizacji przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-405">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-406">
            <see langword="true" /> gdy każdy element w kolekcji <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-406">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-407">Jeśli `timeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-407">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-408">Testuje, stan uchwytami oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-408">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-409"><xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-409"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ce6e1-410">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` po mutex zostanie porzucony.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-410">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ce6e1-411">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-411">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ce6e1-412">W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-412">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ce6e1-413">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-413">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ce6e1-414"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania skończy, co oznacza, że są sygnalizowane albo wszystkie dojścia lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-414">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="ce6e1-415">W niektórych implementacjach obsługuje więcej niż 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-415">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="ce6e1-416">Jeśli tablica zawiera duplikaty, wywołanie zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-416">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce6e1-417"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-417">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="ce6e1-418">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-418">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ce6e1-419">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="ce6e1-419">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ce6e1-420">`exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitAll%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-420">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ce6e1-421">Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-421">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ce6e1-422">Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-422">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ce6e1-423">Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-423">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="ce6e1-424">Zwraca do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitAll%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-424">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="ce6e1-425">Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-425">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ce6e1-426">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-426">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ce6e1-427">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-427">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ce6e1-428">Gdy <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-428">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-429">Poniższy przykład kodu pokazuje, jak używać puli wątków, aby asynchronicznie tworzyć i zapisywać grupy plików.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-429">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="ce6e1-430">Po zakończeniu każdej operacji zapisu jest w kolejce jako element roboczy i sygnałów.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-430">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="ce6e1-431">Główny wątek czeka, aż wszystkie elementy do sygnalizowania, a następnie kończy działanie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-431">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-432">
            <paramref name="waitHandles" /> Parametr <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-432">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-433">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-433">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-434">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-434">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-435">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-435">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-436">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-436">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="ce6e1-437">
            <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-437">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-438">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-438">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="ce6e1-439">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-439">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-440">
            <see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-440">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ce6e1-441">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-441">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-442">
            <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-442">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="ce6e1-443">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-443">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-444">
            <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-444">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-445">Czas oczekiwania zakończone, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-445">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-446">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-446">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-447">
            <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-447">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-448">Czeka na dowolne elementy w wybranej tablicy do otrzymania sygnału.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-448">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ce6e1-449">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-449">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-450">Czeka na dowolne elementy w wybranej tablicy do otrzymania sygnału.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-450">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-451">Indeks tablicy obiektu spełniającego oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-451">The array index of the object that satisfied the wait.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-452"><xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-452"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ce6e1-453">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` po ukończeniu czas oczekiwania, ponieważ element mutex zostanie porzucony.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-453">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="ce6e1-454">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-454">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ce6e1-455">W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-455">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ce6e1-456">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-456">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ce6e1-457"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza wyjątek <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-457">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="ce6e1-458">Jeśli `waitHandles` zawiera wydana obiektu mutex z mniejszą liczbą indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zakończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-458">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce6e1-459">W wersjach programu .NET Framework wcześniejszych niż wersja 2.0, jeśli wątek zamyka lub przerywa bez jawnie zwalniania <xref:System.Threading.Mutex>oraz że `Mutex` pod indeksem 0 (zero) trwa `WaitAny` tablicy na inny wątek, wskaźnik zwracany przez `WaitAny` jest 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-459">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="ce6e1-460">Ta metoda zwraca, jeśli dowolny uchwyt jest sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-460">This method returns when any handle is signaled.</span></span> <span data-ttu-id="ce6e1-461">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, wartość zwracana jest indeks tablicy obiektu sygnałowego mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-461">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="ce6e1-462">W niektórych implementacjach, jeśli inne, które obsługuje 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-462">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="ce6e1-463">Wywołanie tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenie metody i określając wartość -1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-463">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-464">Poniższy przykład kodu demonstruje wywołanie <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-464">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-465">
            <paramref name="waitHandles" /> Parametr <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-465">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-466">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-466">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-467">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-467">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-468">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-468">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ce6e1-469">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-469">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-470">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-470">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-471">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-471">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce6e1-472">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-472">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-473">
            <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-473">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ce6e1-474">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-474">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ce6e1-475">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-475">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-476">Czeka na dowolne elementy w wybranej tablicy do otrzymania sygnału, przy użyciu całkowita 32-bitowych, aby określić interwał czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-476">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-477">Indeks tablicy obiektu spełniającego oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie ustali, czas oczekiwania i przedział czasu jest odpowiednikiem <paramref name="millisecondsTimeout" /> został przekazany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-477">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-478">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-478">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-479">Testuje, stan uchwytami oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-479">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-480"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza wyjątek <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-480">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="ce6e1-481">Jeśli `waitHandles` zawiera wydana obiektu mutex z mniejszą liczbą indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zakończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-481">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="ce6e1-482">Ta metoda zwraca wartość, gdy czas oczekiwania skończy, gdy jeden z uchwytów są sygnalizowane lub zostanie przekroczony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-482">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="ce6e1-483">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, wartość zwracana jest indeks tablicy obiektu sygnałowego mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-483">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="ce6e1-484">W niektórych implementacjach, jeśli inne, które obsługuje 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-484">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="ce6e1-485">Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-485">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-486">
            <paramref name="waitHandles" /> Parametr <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-486">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-487">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-487">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-488">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-488">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-489">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-489">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-490">
            <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-490">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-491">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-491">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-492">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-492">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce6e1-493">
            <paramref name="waitHandles" /> jest tablicą bez elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-493">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-494">
            <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-494">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ce6e1-495">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-495">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="ce6e1-496">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-496">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-497">Czeka na dowolne elementy w wybranej tablicy do otrzymania sygnału, za pomocą <see cref="T:System.TimeSpan" /> do określenia interwału czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-497">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-498">Indeks tablicy obiektu spełniającego oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie ustali, czas oczekiwania i przedział czasu jest odpowiednikiem <paramref name="timeout" /> został przekazany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-498">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-499">Jeśli `timeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-499">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-500">Testuje, stan uchwytami oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-500">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-501"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza wyjątek <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-501">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="ce6e1-502">Jeśli `waitHandles` zawiera wydana obiektu mutex z mniejszą liczbą indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zakończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-502">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="ce6e1-503">Ta metoda zwraca, gdy czas oczekiwania skończy, gdy jeden z uchwytów są sygnalizowane lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-503">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="ce6e1-504">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, wartość zwracana jest indeks tablicy obiektu sygnałowego mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-504">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="ce6e1-505">W niektórych implementacjach, jeśli inne, które obsługuje 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-505">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="ce6e1-506">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-506">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ce6e1-507">Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-507">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-508">
            <paramref name="waitHandles" /> Parametr <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-508">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-509">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-509">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-510">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-510">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-511">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-511">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-512">
            <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-512">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="ce6e1-513">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-513">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-514">
            <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-514">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-515">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-515">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-516">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-516">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce6e1-517">
            <paramref name="waitHandles" /> jest tablicą bez elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-517">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-518">
            <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-518">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ce6e1-519">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-519">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ce6e1-520">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-520">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ce6e1-521">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-521">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-522">Czeka na dowolne elementy w określonej tablicy, aby otrzymać przy użyciu całkowita 32-bitowych, aby określić interwał czasu i określeniu, czy zakończyć domeny synchronizacji przed czas oczekiwania na sygnał.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-522">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-523">Indeks tablicy obiektu spełniającego oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie ustali, czas oczekiwania i przedział czasu jest odpowiednikiem <paramref name="millisecondsTimeout" /> został przekazany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-523">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-524">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-524">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-525">Testuje, stan uchwytami oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-525">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-526"><xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-526"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ce6e1-527">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` po ukończeniu czas oczekiwania, ponieważ element mutex zostanie porzucony.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-527">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="ce6e1-528">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-528">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ce6e1-529">W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-529">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ce6e1-530">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-530">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ce6e1-531"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza wyjątek <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-531">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="ce6e1-532">Jeśli `waitHandles` zawiera wydana obiektu mutex z mniejszą liczbą indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zakończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-532">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce6e1-533">W wersjach programu .NET Framework wcześniejszych niż wersja 2.0, jeśli wątek zamyka lub przerywa bez jawnie zwalniania <xref:System.Threading.Mutex>oraz że `Mutex` pod indeksem 0 (zero) trwa `WaitAny` tablicy na inny wątek, wskaźnik zwracany przez `WaitAny` jest 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-533">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="ce6e1-534">Ta metoda zwraca wartość, gdy czas oczekiwania skończy, gdy jeden z uchwytów są sygnalizowane lub zostanie przekroczony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-534">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="ce6e1-535">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, wartość zwracana jest indeks tablicy obiektu sygnałowego mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-535">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="ce6e1-536">W niektórych implementacjach, jeśli inne, które obsługuje 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-536">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ce6e1-537">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="ce6e1-537">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ce6e1-538">`exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitAny%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-538">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ce6e1-539">Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-539">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ce6e1-540">Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-540">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ce6e1-541">Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-541">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="ce6e1-542">Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitAny%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-542">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="ce6e1-543">Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-543">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ce6e1-544">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-544">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ce6e1-545">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-545">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ce6e1-546">Gdy <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-546">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-547">Poniższy przykład kodu demonstruje sposób używania puli wątków jednocześnie wyszukiwania plików na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-547">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="ce6e1-548">Kwestie związane z miejsca przeszukiwany jest tylko katalog główny każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-548">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-549">
            <paramref name="waitHandles" /> Parametr <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-549">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-550">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-550">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-551">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-551">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-552">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-552">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ce6e1-553">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-553">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-554">
            <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-554">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-555">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-555">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-556">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-556">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce6e1-557">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-557">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-558">
            <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-558">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="ce6e1-559">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-559">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="ce6e1-560">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-560">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ce6e1-561">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-561">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-562">Czeka na dowolne elementy w wybranej tablicy do otrzymania sygnału, za pomocą <see cref="T:System.TimeSpan" /> do określenia interwału czasu i określeniu, czy zakończyć domeny synchronizacji przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-562">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-563">Indeks tablicy obiektu spełniającego oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie ustali, czas oczekiwania i przedział czasu jest odpowiednikiem <paramref name="timeout" /> został przekazany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-563">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-564">Jeśli `timeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-564">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-565">Testuje, stan uchwytami oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-565">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-566"><xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-566"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ce6e1-567">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` po ukończeniu czas oczekiwania, ponieważ element mutex zostanie porzucony.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-567">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="ce6e1-568">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-568">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ce6e1-569">W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-569">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ce6e1-570">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-570">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ce6e1-571"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza wyjątek <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-571">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="ce6e1-572">Jeśli `waitHandles` zawiera wydana obiektu mutex z mniejszą liczbą indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zakończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-572">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce6e1-573">W wersjach programu .NET Framework wcześniejszych niż wersja 2.0, jeśli wątek zamyka lub przerywa bez jawnie zwalniania <xref:System.Threading.Mutex>oraz że `Mutex` pod indeksem 0 (zero) trwa `WaitAny` tablicy na inny wątek, wskaźnik zwracany przez `WaitAny` jest 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-573">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="ce6e1-574">Ta metoda zwraca, gdy czas oczekiwania skończy, gdy jeden z uchwytów są sygnalizowane lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-574">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="ce6e1-575">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, wartość zwracana jest indeks tablicy obiektu sygnałowego mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-575">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="ce6e1-576">W niektórych implementacjach, jeśli inne, które obsługuje 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-576">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="ce6e1-577">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-577">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ce6e1-578">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="ce6e1-578">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ce6e1-579">`exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitAny%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-579">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ce6e1-580">Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-580">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ce6e1-581">Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-581">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ce6e1-582">Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-582">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="ce6e1-583">Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitAny%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-583">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="ce6e1-584">Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-584">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ce6e1-585">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-585">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ce6e1-586">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-586">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ce6e1-587">Gdy <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-587">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-588">Poniższy przykład kodu demonstruje sposób używania puli wątków jednocześnie wyszukiwania plików na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-588">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="ce6e1-589">Kwestie związane z miejsca przeszukiwany jest tylko katalog główny każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-589">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce6e1-590">
            <paramref name="waitHandles" /> Parametr <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-590">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce6e1-591">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-591">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-592">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-592">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce6e1-593">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-593">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="ce6e1-594">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-594">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-595">
            <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-595">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="ce6e1-596">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-596">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-597">
            <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-597">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-598">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-598">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-599">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-599">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce6e1-600">
            <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-600">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-601">
            <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-601">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-602">Blokuje bieżący wątek do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-602">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-603">Blokuje bieżący wątek do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-603">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-604">
            <see langword="true" /> Jeśli bieżące wystąpienie odbiera sygnał.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-604">
              <see langword="true" /> if the current instance receives a signal.</span>
          </span>
          <span data-ttu-id="ce6e1-605">Jeśli bieżące wystąpienie nigdy nie jest sygnalizowane, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nigdy nie zwraca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-605">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-606"><xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-606"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ce6e1-607">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` po mutex zostanie porzucony.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-607">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ce6e1-608">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-608">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ce6e1-609">W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-609">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ce6e1-610">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-610">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ce6e1-611">Obiekt wywołujący bloków tej metody na czas nieokreślony, aż bieżące wystąpienie odbiera sygnał.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-611">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="ce6e1-612">Ta metoda służy do blokowania aż <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-612">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="ce6e1-613">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-613">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="ce6e1-614">Wywołanie tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenie metody i określając wartość -1 lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> jako pierwszy parametr i `false` dla drugiego parametru.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-614">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="ce6e1-615">Zastępuje tę metodę, aby dostosować zachowanie w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-615">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-616">W poniższym przykładzie kodu pokazano, jak zachować procesu z przerywa podczas oczekiwania na zakończenie wykonywania wątku w tle za pomocą dojście oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-616">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="ce6e1-617">Bieżące wystąpienie został już usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-617">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-618">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-618">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-619">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-619">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-620">Bieżące wystąpienie jest przezroczysty serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-620">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ce6e1-621">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-621">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-622">Blokuje bieżący wątek do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał, za pomocą całkowita 32-bitowych, aby określić interwał czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-622">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-623">
            <see langword="true" /> Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-623">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-624">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-624">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-625">Testuje, stan dojście oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-625">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-626">Występuje, obiekt wywołujący tego bloków metody, dopóki bieżącego wystąpienia otrzymuje sygnał lub limit czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-626">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="ce6e1-627">Ta metoda służy do blokowania aż <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-627">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="ce6e1-628">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-628">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="ce6e1-629">Zastępuje tę metodę, aby dostosować zachowanie w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-629">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="ce6e1-630">Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-630">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-631">W poniższym przykładzie kodu pokazano, jak zachować procesu z przerywa podczas oczekiwania na zakończenie wykonywania wątku w tle za pomocą dojście oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-631">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="ce6e1-632">Bieżące wystąpienie został już usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-632">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-633">
            <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-633">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-634">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-634">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-635">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-635">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-636">Bieżące wystąpienie jest przezroczysty serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-636">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="ce6e1-637">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-637">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-638">Blokuje bieżący wątek, aż bieżące wystąpienie odbiera sygnał, za pomocą <see cref="T:System.TimeSpan" /> do określenia interwału czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-638">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-639">
            <see langword="true" /> Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-639">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-640">Jeśli `timeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-640">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-641">Testuje, stan dojście oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-641">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-642">Występuje, obiekt wywołujący tego bloków metody, dopóki bieżącego wystąpienia otrzymuje sygnał lub limit czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-642">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="ce6e1-643">Ta metoda służy do blokowania aż <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-643">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="ce6e1-644">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-644">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="ce6e1-645">Zastępuje tę metodę, aby dostosować zachowanie w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-645">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="ce6e1-646">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-646">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ce6e1-647">Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-647">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="ce6e1-648">Bieżące wystąpienie został już usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-648">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-649">
            <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-649">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="ce6e1-650">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-650">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-651">
            <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-651">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-652">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-652">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-653">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-653">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-654">Bieżące wystąpienie jest przezroczysty serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-654">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="ce6e1-655">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-655">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ce6e1-656">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-656">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-657">Blokuje bieżący wątek do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał, przy użyciu całkowita 32-bitowych, aby określić interwał czasu i określeniu, czy zakończyć domeny synchronizacji przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-657">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-658">
            <see langword="true" /> Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-658">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-659">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-659">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-660">Testuje, stan dojście oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-660">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-661"><xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-661"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ce6e1-662">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` po mutex zostanie porzucony.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-662">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ce6e1-663">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-663">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ce6e1-664">W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-664">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ce6e1-665">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-665">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ce6e1-666">Występuje, obiekt wywołujący tego bloków metody, dopóki bieżącego wystąpienia otrzymuje sygnał lub limit czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-666">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="ce6e1-667">Ta metoda służy do blokowania aż <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-667">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="ce6e1-668">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-668">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="ce6e1-669">Zastępuje tę metodę, aby dostosować zachowanie w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-669">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ce6e1-670">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="ce6e1-670">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ce6e1-671">`exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitOne%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-671">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ce6e1-672">Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-672">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ce6e1-673">Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-673">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ce6e1-674">Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-674">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="ce6e1-675">Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-675">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="ce6e1-676">Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-676">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ce6e1-677">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-677">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ce6e1-678">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-678">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ce6e1-679">Gdy <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-679">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-680">W poniższym przykładzie pokazano sposób, w jaki <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenie metody zachowuje się wywołanego w ramach domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-680">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="ce6e1-681">Po pierwsze, wątek czeka z `exitContext` równa `false` i blokuje, dopóki nie upłynie limit czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-681">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="ce6e1-682">Drugi wątek wykonuje po pierwszym wątek kończy działanie i czeka z `exitContext` równa `true`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-682">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="ce6e1-683">Wywołanie w celu sygnalizowania, że dojście oczekiwania dla tego drugiego wątku nie jest zablokowany, a wątek kończy się przed upływem limitu czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-683">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="ce6e1-684">Bieżące wystąpienie został już usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-684">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-685">
            <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-685">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-686">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-686">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-687">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-687">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-688">Bieżące wystąpienie jest przezroczysty serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-688">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="ce6e1-689">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-689">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="ce6e1-690">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-690">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce6e1-691">Blokuje bieżący wątek, aż bieżące wystąpienie odbiera sygnał, za pomocą <see cref="T:System.TimeSpan" /> do określenia interwału czasu i określeniu, czy zakończyć domeny synchronizacji przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-691">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce6e1-692">
            <see langword="true" /> Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-692">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-693">Jeśli `timeout` wynosi zero, nie są blokowane w metodzie.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-693">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="ce6e1-694">Testuje, stan dojście oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-694">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="ce6e1-695"><xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-695"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="ce6e1-696">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` po mutex zostanie porzucony.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-696">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="ce6e1-697">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-697">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="ce6e1-698">W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows).</span><span class="sxs-lookup"><span data-stu-id="ce6e1-698">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="ce6e1-699">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-699">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="ce6e1-700">Występuje, obiekt wywołujący tego bloków metody, dopóki bieżącego wystąpienia otrzymuje sygnał lub limit czasu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-700">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="ce6e1-701">Ta metoda służy do blokowania aż <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-701">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="ce6e1-702">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-702">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="ce6e1-703">Zastępuje tę metodę, aby dostosować zachowanie w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-703">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="ce6e1-704">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-704">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="ce6e1-705">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="ce6e1-705">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="ce6e1-706">`exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitOne%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-706">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="ce6e1-707">Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-707">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="ce6e1-708">Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-708">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="ce6e1-709">Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-709">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="ce6e1-710">Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-710">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="ce6e1-711">Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-711">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="ce6e1-712">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-712">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="ce6e1-713">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-713">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="ce6e1-714">Gdy <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-714">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-715">W poniższym przykładzie kodu pokazano, jak zachować procesu z przerywa podczas oczekiwania na zakończenie wykonywania wątku w tle za pomocą dojście oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-715">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="ce6e1-716">Bieżące wystąpienie został już usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-716">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ce6e1-717">
            <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-717">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="ce6e1-718">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-718">-or-</span>
          </span>
          <span data-ttu-id="ce6e1-719">
            <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-719">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="ce6e1-720">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-720">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="ce6e1-721">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-721">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ce6e1-722">Bieżące wystąpienie jest przezroczysty serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-722">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="ce6e1-723">Oznacza to, że <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> upłynął limit czasu operacji przed dowolnego z uchwytami oczekiwania zostały zasygnalizowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-723">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          </span>
          <span data-ttu-id="ce6e1-724">To pole jest stałe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce6e1-724">This field is constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce6e1-725">To pole jest jedną z możliwych wartości zwracanych z `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-725">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce6e1-726">Poniższy przykład kodu demonstruje sposób używania puli wątków jednocześnie wyszukiwania plików na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-726">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="ce6e1-727">Kwestie związane z miejsca przeszukiwany jest tylko katalog główny każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="ce6e1-727">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
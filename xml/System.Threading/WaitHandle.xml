<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7e662ed5dda251c583c6d82a839ce57c9d160f65" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49131111" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Hermetyzuje obiekty specyficzne dla systemu operacyjnego, które poczekaj, aż wyłącznego dostępu do udostępnionych zasobów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle> Klasa hermetyzuje dojście synchronizacji macierzystego systemu operacyjnego i jest używana do reprezentowania wszystkich obiektów synchronizacji w środowisku uruchomieniowym, zezwalających na wiele operacji oczekiwania. Dla porównania uchwytami oczekiwania z innymi obiektami synchronizacji, zobacz [Przegląd podstawowych synchronizacji](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 <xref:System.Threading.WaitHandle> Sama klasa jest abstrakcyjna. Klasy pochodne <xref:System.Threading.WaitHandle> zdefiniowanie sygnalizowanie zasad, aby wskazać, biorąc lub zwalnianie dostęp do udostępnionego zasobu, ale używają dziedziczonego <xref:System.Threading.WaitHandle> metody, aby zablokować podczas oczekiwania na dostęp do zasobów udostępnionych. Klasy pochodne <xref:System.Threading.WaitHandle> obejmują:  
  
-   <xref:System.Threading.Mutex> Klasy. Zobacz [muteksy](~/docs/standard/threading/mutexes.md).  
  
-   <xref:System.Threading.EventWaitHandle> Klasa i jej klasy pochodne <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent>. Zobacz [EventWaitHandle, autoresetevent —, CountdownEvent ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   <xref:System.Threading.Semaphore> Klasy. Zobacz [Semaphore i SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Wątki, można zablokować na dojście oczekiwania poszczególnych przez wywołanie metody wystąpienia <xref:System.Threading.WaitHandle.WaitOne%2A>, który jest dziedziczone przez klasy pochodne <xref:System.Threading.WaitHandle>.  
  
 Klasy pochodne z <xref:System.Threading.WaitHandle> różnią się w ich koligacji wątku. Uchwyty oczekiwania zdarzeń (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, i <xref:System.Threading.ManualResetEvent>) i semaforów nie mają koligacji wątku; wątek może sygnał dojście oczekiwania zdarzeń lub semafor. Muteksy, z drugiej strony, pozostają w koligacji wątku; Wątek, który jest właścicielem obiektu mutex musi zwolnić go, a wyjątek jest generowany, jeśli wątek wywołuje <xref:System.Threading.Mutex.ReleaseMutex%2A> metody na element mutex, który nie jest właścicielem.  
  
 Ponieważ <xref:System.Threading.WaitHandle> klasa pochodzi od <xref:System.MarshalByRefObject>, te klasy mogą być używane do synchronizowania działania wątków poza granice domeny aplikacji.  
  
 Oprócz jej klasy pochodne <xref:System.Threading.WaitHandle> klasa ma szereg metod statycznych, które blokują wątek, dopóki jedna lub więcej obiektów synchronizacji odebrania sygnału. Należą do nich następujące elementy:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, co pozwala wątku w celu zasygnalizowania określonego dojścia oczekiwania i natychmiast czekać na innym.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, pozwalający wątku, poczekać, aż wszystkie dojścia oczekiwania w tablicy odbioru sygnału.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, pozwalający wątku, poczekać, aż zasygnalizują któregokolwiek z określonego zestawu dojść oczekiwania.  
  
 Przeciążenia metody te zawierają interwałów limitu czasu dla porzucenie czas oczekiwania i możliwość zamknąć kontekstu synchronizacji przed wejściem czas oczekiwania, dzięki czemu inne wątki używać kontekstu synchronizacji.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu lub typ pochodzący od niego bezpośrednio lub pośrednio należy usunąć z niej. Do usuwania tego typu, należy wywołać jej <xref:System.Threading.WaitHandle.Close%2A> method in Class metoda `try` / `catch` bloku. Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.  
  
 <xref:System.Threading.WaitHandle> implementuje <xref:System.IDisposable.Dispose%2A> wzorca. Zobacz [wzorca usuwania](~/docs/standard/design-guidelines/dispose-pattern.md). Po utworzeniu klasy pochodnej z <xref:System.Threading.WaitHandle>, użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwość, aby przechowywać swoje dojście macierzystego systemu operacyjnego. Nie trzeba zastąpić chronionego <xref:System.Threading.WaitHandle.Dispose%2A> metoda chyba że są używane dodatkowe zasoby niezarządzane.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład jak dwa wątki mogą wykonaj zadania w tle podczas główny wątek czeka na zadania do wykonania przy użyciu statycznych <xref:System.Threading.WaitHandle.WaitAny%2A> i <xref:System.Threading.WaitHandle.WaitAll%2A> metody <xref:System.Threading.WaitHandle> klasy.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Wątkowość obiektów i funkcji</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
    <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaforów</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby zajmowane przez bieżącą <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementacją publicznych <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodę <xref:System.Threading.WaitHandle> klasy i jej klasy pochodne. Zapewnia standardową implementację, która wywołuje `Dispose(Boolean)` przeciążenia z `true` argument, a następnie wywołania <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody. Wywołaj tę metodę, aby zwolnić wszystkie zasoby zajmowane przez wystąpienia `WaitHandle` lub klasę pochodną.  
  
 Gdy ta metoda jest wywoływana, odwołania do bieżącego wystąpienia spowodować niezdefiniowane zachowanie.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed publikacją swoje ostatnie odwołanie do <xref:System.Threading.WaitHandle>. W przeciwnym razie nie zostanie zwolniona przez nią zasoby.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy zastąpić <see langword="Dispose(Boolean)" /> metodę, aby zwolnić zasoby przydzielone w klasach pochodnych.</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementacja metody Dispose</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.WaitHandle" /> klasy</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.WaitHandle" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest odpowiednikiem <xref:System.Threading.WaitHandle.Close%2A> metody.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed publikacją swoje ostatnie odwołanie do <xref:System.Threading.WaitHandle>. W przeciwnym razie nie zostanie zwolniona przez nią zasoby.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Oczyszczanie zasobów niezarządzanych</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zwalnia zasoby niezarządzane używane przez <see cref="T:System.Threading.WaitHandle" />i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana <xref:System.Threading.WaitHandle.Close%2A> i <xref:System.Threading.WaitHandle.Dispose> metod z `explicitDisposing` parametr `true`.  Gdy `explicitDisposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.Threading.WaitHandle> obiektu odwołania.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy zastąpić <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> metodę, aby zwolnić zasoby przydzielone w klasach pochodnych.  
  
<see cref="M:System.Threading.WaitHandle.Close" /> Lub <see cref="M:System.Threading.WaitHandle.Dispose" /> metoda może być wywoływana wiele razy przez inne obiekty. W przypadku przesłaniania tej metody należy uważać, aby nie odwołują się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see langword="Dispose" /> lub <see langword="Close" />.</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementacja metody Dispose</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia uchwyt macierzystego systemu operacyjnego.</summary>
        <value>
          <see langword="IntPtr" /> Reprezentujący dojście macierzystego systemu operacyjnego. Wartość domyślna to wartość <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> pola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przypisywanie nową wartość do <xref:System.Threading.WaitHandle.Handle%2A> właściwości nie zamyka uchwyt poprzedniego. Może to spowodować, że ujawnione dojście.  
  
 Nie należy używać tej właściwości w .NET Framework w wersji 2.0 lub nowszy; Użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości zamiast tego. Ustawienie tej właściwości na prawidłowy uchwyt również zestawów <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości, ale ustawienie <xref:System.Threading.WaitHandle.InvalidHandle> może spowodować ujawnione dojście.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego, można ustawić wartości właściwości. Nie można ustawić tego elementu członkowskiego przez częściowo zaufany lub przejrzysty kod.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> można ustawić wartości właściwości.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje uchwyt nieprawidłowy macierzystego systemu operacyjnego. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używana wewnętrznie w celu zainicjowania <xref:System.Threading.WaitHandle.Handle%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Tej wartości można użyć, aby określić, czy <see cref="P:System.Threading.WaitHandle.Handle" /> właściwość zawiera uchwyt prawidłowego macierzystego systemu operacyjnego.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia uchwyt macierzystego systemu operacyjnego.</summary>
        <value>A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> reprezentujący dojście macierzystego systemu operacyjnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przypisywania nową wartość do <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości poprzedniego uchwyt zostaną zamknięte, kiedy poprzednie <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> obiektu są zbierane. Nie ręcznie zamknąć dojście, ponieważ powoduje to <xref:System.ObjectDisposedException> podczas <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> próbuje zamknąć dojście.  
  
 <xref:System.Threading.WaitHandle> implementuje <xref:System.IDisposable.Dispose%2A> wzorca. Zobacz [wzorca usuwania](~/docs/standard/design-guidelines/dispose-pattern.md). Po utworzeniu klasy pochodnej z <xref:System.Threading.WaitHandle>, użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwość, aby przechowywać swoje dojście systemu operacyjnego uchwyt macierzysty. Nie trzeba zastąpić chronionego <xref:System.Threading.WaitHandle.Dispose%2A> metoda chyba że są używane dodatkowe zasoby niezarządzane.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> do wywoływania tego elementu członkowskiego.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sygnalizuje jeden <see cref="T:System.Threading.WaitHandle" /> i czeka na innym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> Na sygnał.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</param>
        <summary>Sygnalizuje jeden <see cref="T:System.Threading.WaitHandle" /> i czeka na innym.</summary>
        <returns>
          <see langword="true" /> Jeśli zarówno sygnałem, jak i czas oczekiwania zakończy się pomyślnie; Jeśli czas oczekiwania nie zostanie ukończone, metoda nie zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie jest gwarantowana niepodzielnych. Po bieżącym sygnały wątku `toSignal` , ale przed jego czeka `toWaitOn`, wątek, który działa na inny procesor może być sygnał `toWaitOn` lub zaczekaj na nim.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenia metody, aby zezwolić na wątek główny sygnał zablokowany wątek i poczekać, aż wątek kończy zadanie.  
  
 Przykład rozpoczyna pięć wątków, pozwala na ich blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flaga, a następnie jeden wątek wersji czasu użytkownik naciśnie klawisz ENTER. Przykład następnie kolejkuje innego pięć wątków i zwalnia je za pomocą <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="toWaitOn" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda nie jest obsługiwana na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> jest semafor i jest już pełna liczba.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> Na sygnał.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</param>
        <param name="millisecondsTimeout">Liczba całkowita, która reprezentuje interwałem oczekiwania. Jeśli wartość jest <see cref="F:System.Threading.Timeout.Infinite" />, -1, czas oczekiwania jest nieskończona.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</param>
        <summary>Sygnalizuje jeden <see cref="T:System.Threading.WaitHandle" /> i czeka na innym, określając interwał limitu czasu jako liczba całkowita 32-bitowe podpisane i określeniu, czy zakończyć domeny synchronizacji dla kontekstu przed wejściem czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Jeśli zarówno sygnałem, jak i czas oczekiwania zakończone pomyślnie, lub <see langword="false" /> Jeśli sygnału ukończone, ale czas oczekiwania upłynął limit czasu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie jest gwarantowana niepodzielnych. Po bieżącym sygnały wątku `toSignal` , ale przed jego czeka `toWaitOn`, wątek, który działa na inny procesor może być sygnał `toWaitOn` lub zaczekaj na nim.  
  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie. Sprawdza stan `toWaitOn` i zwraca natychmiast.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych. Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody. Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.SignalAndWait%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="toWaitOn" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Metoda jest wywoływana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda nie jest obsługiwana na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.WaitHandle" /> Nie sygnalizowane, ponieważ może to spowodować przekroczenie jego maksymalną liczbę.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> Na sygnał.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący interwał oczekiwania. Jeśli wartość wynosi -1, czas oczekiwania jest nieskończona.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</param>
        <summary>Sygnalizuje jeden <see cref="T:System.Threading.WaitHandle" /> i czeka na innym, określając interwał limitu czasu jako <see cref="T:System.TimeSpan" /> i określenie, czy chcesz zamknąć domeny synchronizacji dla kontekstu przed wejściem czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Jeśli zarówno sygnałem, jak i czas oczekiwania zakończone pomyślnie, lub <see langword="false" /> Jeśli sygnału ukończone, ale czas oczekiwania upłynął limit czasu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie jest gwarantowana niepodzielnych. Po bieżącym sygnały wątku `toSignal` , ale przed jego czeka `toWaitOn`, wątek, który działa na inny procesor może być sygnał `toWaitOn` lub zaczekaj na nim.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Jeśli `timeout` wynosi zero, nie są blokowane w metodzie. Sprawdza stan `toWaitOn` i zwraca natychmiast.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych. Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody. Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.SignalAndWait%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="toWaitOn" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda nie jest obsługiwana na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> jest semafor i jest już pełna liczba.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> Zwraca ujemną liczbę milisekund od-1.  
  
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka, aż wszystkie elementy w wybranej tablicy do otrzymania sygnału.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia. Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</param>
        <summary>Czeka, aż wszystkie elementy w wybranej tablicy do otrzymania sygnału.</summary>
        <returns>
          <see langword="true" /> gdy każdy element w kolekcji <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie metoda nigdy nie zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` po mutex zostanie porzucony. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy są sygnalizowane wszystkie uchwyty. W niektórych implementacjach obsługuje więcej niż 64 są przekazywane <xref:System.NotSupportedException> zgłaszany. Jeśli tablica zawiera duplikaty, wywołanie zakończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.  
  
 Wywołanie tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenie metody i określając wartość -1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać puli wątków, aby asynchronicznie tworzyć i zapisywać grupy plików. Po zakończeniu każdej operacji zapisu jest w kolejce jako element roboczy i sygnałów. Główny wątek czeka, aż wszystkie elementy do sygnalizowania, a następnie kończy działanie.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr <see langword="null" />. —lub— 
Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablicy są <see langword="null" />.  
  
—lub— 
 <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.ArgumentException" />, a zamiast tego.  
  
</para>
          </block>
          <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.  
  
—lub— 
<see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończone, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia. Ta tablica nie może zawierać wiele odwołań do tego samego obiektu (duplikatów).</param>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <summary>Czeka, aż wszystkie elementy w określonej tablicy, aby otrzymać sygnał, za pomocą <see cref="T:System.Int32" /> wartość, aby określić interwał czasu.</summary>
        <returns>
          <see langword="true" /> gdy każdy element w kolekcji <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan uchwytami oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania skończy się, co oznacza, że gdy wszystkie uchwyty są sygnalizowane lub przekroczenia limitu czasu. W niektórych implementacjach obsługuje więcej niż 64 są przekazywane <xref:System.NotSupportedException> zgłaszany. Jeśli istnieją duplikaty w tablicy, wywołania kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.  
  
 Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr <see langword="null" />.  
  
—lub— 
Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.  
  
—lub— 
 <paramref name="waitHandles" /> jest tablicą bez elementów.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.ArgumentException" />, a zamiast tego.  
  
</para>
          </block>
          <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.  
  
—lub— 
<see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia. Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund-1, aby czekać w nieskończoność.</param>
        <summary>Czeka, aż wszystkie elementy w określonej tablicy, aby otrzymać sygnał, za pomocą <see cref="T:System.TimeSpan" /> wartość, aby określić interwał czasu.</summary>
        <returns>
          <see langword="true" /> gdy każdy element w kolekcji <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan uchwytami oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania skończy, co oznacza, że są sygnalizowane albo wszystkie dojścia lub przekroczenia limitu czasu. W niektórych implementacjach obsługuje więcej niż 64 są przekazywane <xref:System.NotSupportedException> zgłaszany. Jeśli tablica zawiera duplikaty, wywołanie zakończy się niepowodzeniem.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr <see langword="null" />.  
  
—lub— 
Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.  
  
—lub— 
 <paramref name="waitHandles" /> jest tablicą bez elementów.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.ArgumentException" />, a zamiast tego.  
  
</para>
          </block>
          <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.  
  
—lub— 
<see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończone, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia. Ta tablica nie może zawierać wiele odwołań do tego samego obiektu (duplikatów).</param>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</param>
        <summary>Czeka, aż wszystkie elementy w określonej tablicy, aby otrzymać sygnał, za pomocą <see cref="T:System.Int32" /> wartością do określenia interwału czasu i określeniu, czy zakończyć domeny synchronizacji przed czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> gdy każdy element w kolekcji <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan uchwytami oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` po mutex zostanie porzucony. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania skończy się, co oznacza, że gdy wszystkie uchwyty są sygnalizowane lub przekroczenia limitu czasu. W niektórych implementacjach obsługuje więcej niż 64 są przekazywane <xref:System.NotSupportedException> zgłaszany. Jeśli istnieją duplikaty w tablicy, wywołania kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitAll%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych. Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAll%2A> metody. Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitAll%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atrybutu. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać puli wątków, aby asynchronicznie tworzyć i zapisywać grupy plików. Po zakończeniu każdej operacji zapisu jest w kolejce jako element roboczy i sygnałów. Główny wątek czeka, aż wszystkie elementy do sygnalizowania, a następnie kończy działanie.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr <see langword="null" />.  
  
—lub— 
Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.  
  
—lub— 
 <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.  
  
—lub— 
<see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia. Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund-1, aby czekać w nieskończoność.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</param>
        <summary>Czeka, aż wszystkie elementy w określonej tablicy, aby otrzymać sygnał, za pomocą <see cref="T:System.TimeSpan" /> wartość do określenia interwału czasu, a określająca, czy zakończyć domeny synchronizacji przed czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> gdy każdy element w kolekcji <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan uchwytami oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` po mutex zostanie porzucony. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania skończy, co oznacza, że są sygnalizowane albo wszystkie dojścia lub przekroczenia limitu czasu. W niektórych implementacjach obsługuje więcej niż 64 są przekazywane <xref:System.NotSupportedException> zgłaszany. Jeśli tablica zawiera duplikaty, wywołanie zakończy się niepowodzeniem.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitAll%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych. Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAll%2A> metody. Zwraca do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitAll%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać puli wątków, aby asynchronicznie tworzyć i zapisywać grupy plików. Po zakończeniu każdej operacji zapisu jest w kolejce jako element roboczy i sygnałów. Główny wątek czeka, aż wszystkie elementy do sygnalizowania, a następnie kończy działanie.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr <see langword="null" />.  
  
—lub— 
Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.  
  
—lub— 
 <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.  
  
—lub— 
<see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończone, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na dowolne elementy w wybranej tablicy do otrzymania sygnału.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</param>
        <summary>Czeka na dowolne elementy w wybranej tablicy do otrzymania sygnału.</summary>
        <returns>Indeks tablicy obiektu spełniającego oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` po ukończeniu czas oczekiwania, ponieważ element mutex zostanie porzucony. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza wyjątek <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex. Jeśli `waitHandles` zawiera wydana obiektu mutex z mniejszą liczbą indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zakończy się normalnie i nie jest zgłaszany wyjątek.  
  
> [!NOTE]
>  W wersjach programu .NET Framework wcześniejszych niż wersja 2.0, jeśli wątek zamyka lub przerywa bez jawnie zwalniania <xref:System.Threading.Mutex>oraz że `Mutex` pod indeksem 0 (zero) trwa `WaitAny` tablicy na inny wątek, wskaźnik zwracany przez `WaitAny` jest 128 zamiast 0.  
  
 Ta metoda zwraca, jeśli dowolny uchwyt jest sygnalizowane. Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, wartość zwracana jest indeks tablicy obiektu sygnałowego mający najmniejszą wartość indeksu sygnałowego obiektów. W niektórych implementacjach, jeśli inne, które obsługuje 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.  
  
 Wywołanie tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenie metody i określając wartość -1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie <xref:System.Threading.WaitHandle.WaitAny%2A> metody.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr <see langword="null" />.  
  
—lub— 
Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</param>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <summary>Czeka na dowolne elementy w wybranej tablicy do otrzymania sygnału, przy użyciu całkowita 32-bitowych, aby określić interwał czasu.</summary>
        <returns>Indeks tablicy obiektu spełniającego oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie ustali, czas oczekiwania i przedział czasu jest odpowiednikiem <paramref name="millisecondsTimeout" /> został przekazany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan uchwytami oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza wyjątek <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex. Jeśli `waitHandles` zawiera wydana obiektu mutex z mniejszą liczbą indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zakończy się normalnie i nie jest zgłaszany wyjątek.  
  
 Ta metoda zwraca wartość, gdy czas oczekiwania skończy, gdy jeden z uchwytów są sygnalizowane lub zostanie przekroczony limit czasu. Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, wartość zwracana jest indeks tablicy obiektu sygnałowego mający najmniejszą wartość indeksu sygnałowego obiektów. W niektórych implementacjach, jeśli inne, które obsługuje 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.  
  
 Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr <see langword="null" />.  
  
—lub— 
Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> jest tablicą bez elementów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</param>
        <summary>Czeka na dowolne elementy w wybranej tablicy do otrzymania sygnału, za pomocą <see cref="T:System.TimeSpan" /> do określenia interwału czasu.</summary>
        <returns>Indeks tablicy obiektu spełniającego oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie ustali, czas oczekiwania i przedział czasu jest odpowiednikiem <paramref name="timeout" /> został przekazany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan uchwytami oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza wyjątek <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex. Jeśli `waitHandles` zawiera wydana obiektu mutex z mniejszą liczbą indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zakończy się normalnie i nie jest zgłaszany wyjątek.  
  
 Ta metoda zwraca, gdy czas oczekiwania skończy, gdy jeden z uchwytów są sygnalizowane lub przekroczenia limitu czasu. Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, wartość zwracana jest indeks tablicy obiektu sygnałowego mający najmniejszą wartość indeksu sygnałowego obiektów. W niektórych implementacjach, jeśli inne, które obsługuje 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr <see langword="null" />.  
  
—lub— 
Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> jest tablicą bez elementów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</param>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</param>
        <summary>Czeka na dowolne elementy w określonej tablicy, aby otrzymać przy użyciu całkowita 32-bitowych, aby określić interwał czasu i określeniu, czy zakończyć domeny synchronizacji przed czas oczekiwania na sygnał.</summary>
        <returns>Indeks tablicy obiektu spełniającego oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie ustali, czas oczekiwania i przedział czasu jest odpowiednikiem <paramref name="millisecondsTimeout" /> został przekazany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan uchwytami oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` po ukończeniu czas oczekiwania, ponieważ element mutex zostanie porzucony. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza wyjątek <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex. Jeśli `waitHandles` zawiera wydana obiektu mutex z mniejszą liczbą indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zakończy się normalnie i nie jest zgłaszany wyjątek.  
  
> [!NOTE]
>  W wersjach programu .NET Framework wcześniejszych niż wersja 2.0, jeśli wątek zamyka lub przerywa bez jawnie zwalniania <xref:System.Threading.Mutex>oraz że `Mutex` pod indeksem 0 (zero) trwa `WaitAny` tablicy na inny wątek, wskaźnik zwracany przez `WaitAny` jest 128 zamiast 0.  
  
 Ta metoda zwraca wartość, gdy czas oczekiwania skończy, gdy jeden z uchwytów są sygnalizowane lub zostanie przekroczony limit czasu. Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, wartość zwracana jest indeks tablicy obiektu sygnałowego mający najmniejszą wartość indeksu sygnałowego obiektów. W niektórych implementacjach, jeśli inne, które obsługuje 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitAny%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych. Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAny%2A> metody. Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitAny%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania puli wątków jednocześnie wyszukiwania plików na wielu dyskach. Kwestie związane z miejsca przeszukiwany jest tylko katalog główny każdego dysku.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr <see langword="null" />.  
  
—lub— 
Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</param>
        <summary>Czeka na dowolne elementy w wybranej tablicy do otrzymania sygnału, za pomocą <see cref="T:System.TimeSpan" /> do określenia interwału czasu i określeniu, czy zakończyć domeny synchronizacji przed czas oczekiwania.</summary>
        <returns>Indeks tablicy obiektu spełniającego oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie ustali, czas oczekiwania i przedział czasu jest odpowiednikiem <paramref name="timeout" /> został przekazany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan uchwytami oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` po ukończeniu czas oczekiwania, ponieważ element mutex zostanie porzucony. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza wyjątek <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex. Jeśli `waitHandles` zawiera wydana obiektu mutex z mniejszą liczbą indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zakończy się normalnie i nie jest zgłaszany wyjątek.  
  
> [!NOTE]
>  W wersjach programu .NET Framework wcześniejszych niż wersja 2.0, jeśli wątek zamyka lub przerywa bez jawnie zwalniania <xref:System.Threading.Mutex>oraz że `Mutex` pod indeksem 0 (zero) trwa `WaitAny` tablicy na inny wątek, wskaźnik zwracany przez `WaitAny` jest 128 zamiast 0.  
  
 Ta metoda zwraca, gdy czas oczekiwania skończy, gdy jeden z uchwytów są sygnalizowane lub przekroczenia limitu czasu. Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, wartość zwracana jest indeks tablicy obiektu sygnałowego mający najmniejszą wartość indeksu sygnałowego obiektów. W niektórych implementacjach, jeśli inne, które obsługuje 64 są przekazywane <xref:System.NotSupportedException> zgłaszany.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitAny%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych. Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAny%2A> metody. Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitAny%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania puli wątków jednocześnie wyszukiwania plików na wielu dyskach. Kwestie związane z miejsca przeszukiwany jest tylko katalog główny każdego dysku.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr <see langword="null" />.  
  
—lub— 
Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa niż zezwala na system.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> jest tablicą bez elementów i wersji programu .NET Framework jest 2.0 lub nowszej.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczyste serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blokuje bieżący wątek do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blokuje bieżący wątek do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie odbiera sygnał. Jeśli bieżące wystąpienie nigdy nie jest sygnalizowane, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nigdy nie zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` po mutex zostanie porzucony. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 Obiekt wywołujący bloków tej metody na czas nieokreślony, aż bieżące wystąpienie odbiera sygnał. Ta metoda służy do blokowania aż <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.  
  
 Wywołanie tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenie metody i określając wartość -1 lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> jako pierwszy parametr i `false` dla drugiego parametru.  
  
 Zastępuje tę metodę, aby dostosować zachowanie w klasach pochodnych.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak zachować procesu z przerywa podczas oczekiwania na zakończenie wykonywania wątku w tle za pomocą dojście oczekiwania.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczysty serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <summary>Blokuje bieżący wątek do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał, za pomocą całkowita 32-bitowych, aby określić interwał czasu w milisekundach.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan dojście oczekiwania i zwraca natychmiast.  
  
 Występuje, obiekt wywołujący tego bloków metody, dopóki bieżącego wystąpienia otrzymuje sygnał lub limit czasu. Ta metoda służy do blokowania aż <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.  
  
 Zastępuje tę metodę, aby dostosować zachowanie w klasach pochodnych.  
  
 Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak zachować procesu z przerywa podczas oczekiwania na zakończenie wykonywania wątku w tle za pomocą dojście oczekiwania.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczysty serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</param>
        <summary>Blokuje bieżący wątek, aż bieżące wystąpienie odbiera sygnał, za pomocą <see cref="T:System.TimeSpan" /> do określenia interwału czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan dojście oczekiwania i zwraca natychmiast.  
  
 Występuje, obiekt wywołujący tego bloków metody, dopóki bieżącego wystąpienia otrzymuje sygnał lub limit czasu. Ta metoda służy do blokowania aż <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.  
  
 Zastępuje tę metodę, aby dostosować zachowanie w klasach pochodnych.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczysty serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</param>
        <summary>Blokuje bieżący wątek do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał, przy użyciu całkowita 32-bitowych, aby określić interwał czasu i określeniu, czy zakończyć domeny synchronizacji przed czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan dojście oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` po mutex zostanie porzucony. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 Występuje, obiekt wywołujący tego bloków metody, dopóki bieżącego wystąpienia otrzymuje sygnał lub limit czasu. Ta metoda służy do blokowania aż <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.  
  
 Zastępuje tę metodę, aby dostosować zachowanie w klasach pochodnych.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitOne%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych. Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitOne%2A> metody. Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób, w jaki <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenie metody zachowuje się wywołanego w ramach domeny synchronizacji. Po pierwsze, wątek czeka z `exitContext` równa `false` i blokuje, dopóki nie upłynie limit czasu oczekiwania. Drugi wątek wykonuje po pierwszym wątek kończy działanie i czeka z `exitContext` równa `true`. Wywołanie w celu sygnalizowania, że dojście oczekiwania dla tego drugiego wątku nie jest zablokowany, a wątek kończy się przed upływem limitu czasu oczekiwania.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczysty serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pobrać w przeciwnym razie <see langword="false" />.</param>
        <summary>Blokuje bieżący wątek, aż bieżące wystąpienie odbiera sygnał, za pomocą <see cref="T:System.TimeSpan" /> do określenia interwału czasu i określeniu, czy zakończyć domeny synchronizacji przed czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane w metodzie. Testuje, stan dojście oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` po mutex zostanie porzucony. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku elementu mutex całego systemu może wskazywać, że aplikacja został zakończony nagle (na przykład przy użyciu Menedżera zadań Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 Występuje, obiekt wywołujący tego bloków metody, dopóki bieżącego wystąpienia otrzymuje sygnał lub limit czasu. Ta metoda służy do blokowania aż <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.  
  
 Zastępuje tę metodę, aby dostosować zachowanie w klasach pochodnych.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.WaitHandle.WaitOne%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych. Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitOne%2A> metody. Wątek jest zwracany do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak zachować procesu z przerywa podczas oczekiwania na zakończenie wykonywania wątku w tle za pomocą dojście oczekiwania.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Czas oczekiwania zakończyć, ponieważ wątek został zakończony bez zwalniania elementu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczysty serwera proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Oznacza to, że <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> upłynął limit czasu operacji przed dowolnego z uchwytami oczekiwania zostały zasygnalizowane. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole jest jedną z możliwych wartości zwracanych z `WaitAny`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania puli wątków jednocześnie wyszukiwania plików na wielu dyskach. Kwestie związane z miejsca przeszukiwany jest tylko katalog główny każdego dysku.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
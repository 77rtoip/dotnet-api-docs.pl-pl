<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5b0250cf5d94f2e2dd11058978329bf6d723a3d8" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69098405" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Hermetyzuje obiekty specyficzne dla systemu operacyjnego, które oczekują na wyłączny dostęp do udostępnionych zasobów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle> Klasa hermetyzuje natywny uchwyt synchronizacji systemu operacyjnego i służy do reprezentowania wszystkich obiektów synchronizacji w środowisku uruchomieniowym, które zezwalają na wiele operacji oczekiwania. Porównanie dojścia oczekiwania z innymi obiektami synchronizacji zawiera temat [Omówienie elementów pierwotnych synchronizacji](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 Sama <xref:System.Threading.WaitHandle> Klasa jest abstrakcyjna. Klasy pochodzące od <xref:System.Threading.WaitHandle> definiują mechanizm sygnalizujący, aby wskazać pobieranie lub zwalnianie dostępu do zasobu udostępnionego, ale używają metod dziedziczonych <xref:System.Threading.WaitHandle> , aby blokować czas oczekiwania na dostęp do udostępnionych zasobów. Klasy pochodne <xref:System.Threading.WaitHandle> obejmują:  
  
-   <xref:System.Threading.Mutex> Klasa. Zobacz [muteksy](~/docs/standard/threading/mutexes.md).  
  
-   Klasa i jej <xref:System.Threading.AutoResetEvent> klasy pochodne i <xref:System.Threading.ManualResetEvent>. <xref:System.Threading.EventWaitHandle>  
  
-   <xref:System.Threading.Semaphore> Klasa. Zobacz [Semafor i SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Wątki mogą blokować pojedyncze dojście oczekiwania, wywołując metodę <xref:System.Threading.WaitHandle.WaitOne%2A>wystąpienia, która jest dziedziczona przez klasy pochodne od. <xref:System.Threading.WaitHandle>  
  
 Klasy pochodne różnią <xref:System.Threading.WaitHandle> się w zależności od ich wątku. Dojścia oczekiwania zdarzeń<xref:System.Threading.EventWaitHandle>( <xref:System.Threading.AutoResetEvent>, i <xref:System.Threading.ManualResetEvent>) i semafory nie mają koligacji wątku; dowolny wątek może sygnalizować uchwyt oczekiwania lub semafor zdarzenia. Muteksy, z drugiej strony, mają koligację wątku; wątek, który jest właścicielem obiektu mutex, musi go zwolnić i wyjątek jest zgłaszany, jeśli wątek wywołuje <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę na elemencie mutex, który nie jest właścicielem.  
  
 Ponieważ Klasa pochodzi od <xref:System.MarshalByRefObject>, te klasy mogą służyć do synchronizowania działań wątków między granicami domeny aplikacji. <xref:System.Threading.WaitHandle>  
  
 Oprócz klas pochodnych <xref:System.Threading.WaitHandle> Klasa ma wiele metod statycznych, które blokują wątek do momentu, gdy jeden lub więcej obiektów synchronizacji odbierze sygnał. Należą do nich następujące elementy:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, co umożliwia wątek sygnalizujący jedno dojście oczekiwania i od razu czeka na inne.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, dzięki czemu wątek czeka, aż wszystkie uchwyty oczekiwania w tablicy otrzymają sygnał.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, dzięki czemu wątek czeka na zasygnalizowanie dowolnego jednego z określonych dojść oczekiwania.  
  
 Przeciążenia tych metod zapewniają przedziały czasu, w których porzucane są oczekiwania, oraz możliwość wyjścia kontekstu synchronizacji przed wprowadzeniem oczekiwania, zezwalając innym wątkom na korzystanie z kontekstu synchronizacji.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejs. Po zakończeniu korzystania z typu lub typu pochodnego należy usunąć jego wartość bezpośrednio lub pośrednio. Aby usunąć typ bezpośrednio <xref:System.Threading.WaitHandle.Close%2A> , wywołaj jego metodę `try` / `catch` w bloku. Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.  
  
 <xref:System.Threading.WaitHandle><xref:System.IDisposable.Dispose%2A> implementuje wzorzec. Zobacz [implementowanie metody Dispose] (~/docs/Standard/garbage-collection/Implementing-Dispose. MD). Gdy pochodzą z <xref:System.Threading.WaitHandle>programu, <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Użyj właściwości do przechowywania natywnego uchwytu systemu operacyjnego. Nie musisz przesłonić metody chronionej <xref:System.Threading.WaitHandle.Dispose%2A> , chyba że używasz dodatkowych zasobów niezarządzanych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak dwa wątki mogą wykonywać zadania w tle, podczas gdy główny wątek czeka na ukończenie zadań przy użyciu statycznych <xref:System.Threading.WaitHandle.WaitAny%2A> i <xref:System.Threading.WaitHandle.WaitAll%2A> metod <xref:System.Threading.WaitHandle> klasy.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Wątkowość obiektów i funkcji</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent i ManualResetEvent</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaforów</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby przechowywane przez bieżące <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest publiczną implementacją <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metody <xref:System.Threading.WaitHandle> klasy i jej klas pochodnych. Zapewnia standardową implementację, która wywołuje `Dispose(Boolean)` Przeciążenie `true` z <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> argumentem, a następnie wywołuje metodę. Wywołaj tę metodę, aby zwolnić wszystkie zasoby znajdujące się `WaitHandle` w wystąpieniu lub klasy pochodnej.  
  
 Po wywołaniu tej metody odwołania do bieżącego wystąpienia powodują niezdefiniowane zachowanie.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed wydaniem ostatniego odwołania do <xref:System.Threading.WaitHandle>. W przeciwnym razie używane zasoby nie zostaną zwolnione.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Należy zastąpić metodę, <see langword="Dispose(Boolean)" /> aby zwolnić zasoby przydzieloną w klasach pochodnych.</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementacja metody Dispose</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.WaitHandle" /> klasy</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.WaitHandle" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważna <xref:System.Threading.WaitHandle.Close%2A> z metodą.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed wydaniem ostatniego odwołania do <xref:System.Threading.WaitHandle>. W przeciwnym razie używane zasoby nie zostaną zwolnione.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Oczyszczanie zasobów niezarządzanych</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwalnia niezarządzane zasoby używane przez <see cref="T:System.Threading.WaitHandle" />program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta <xref:System.Threading.WaitHandle.Close%2A> Metoda jest wywoływana przez <xref:System.Threading.WaitHandle.Dispose> i metody z `explicitDisposing` parametrem ustawionym na `true`.  Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Threading.WaitHandle> których odwołuje się ten obiekt. `explicitDisposing`  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Należy zastąpić metodę, <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> aby zwolnić zasoby przydzieloną w klasach pochodnych.  
  
Metoda <see cref="M:System.Threading.WaitHandle.Close" /> or<see cref="M:System.Threading.WaitHandle.Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania tej metody należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej <see langword="Dispose" /> usunięte <see langword="Close" />we wcześniejszej wywołaniu lub.</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementacja metody Dispose</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby blokowane przez bieżące wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> Ten element członkowski został usunięty z .NET Framework w wersji 2,0 i w kolejnych wersjach. Ten temat dotyczy tylko wersji wymienionych w sekcji "informacje o wersji" w dalszej części tego tematu.


Metoda nie jest wywoływana przez kod aplikacji, ale automatycznie podczas wyrzucania elementów bezużytecznych, chyba że moduł wyrzucania elementów bezużytecznych wyłączył finalizację. Aby uzyskać więcej informacji, zobacz <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> i <xref:System.Object.Finalize>. Ta metoda przesłania <xref:System.Object.Finalize>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia natywne dojście systemu operacyjnego.</summary>
        <value><see langword="IntPtr" /> Reprezentujący natywny uchwyt systemu operacyjnego. Wartością domyślną jest wartość <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> pola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przypisanie nowej wartości do <xref:System.Threading.WaitHandle.Handle%2A> właściwości nie powoduje zamknięcia poprzedniego dojścia. Może to spowodować przeciek dojść.  
  
 Nie należy używać tej właściwości w .NET Framework w wersji 2,0 lub nowszej. Zamiast tego użyj właściwości. <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Ustawienie tej właściwości na prawidłowe dojście powoduje również <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> ustawienie właściwości, ale ustawienie <xref:System.Threading.WaitHandle.InvalidHandle> jej w taki sposób, że może spowodować przeciek.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego w celu ustawienia wartości właściwości. Ten element członkowski nie może być ustawiony przez częściowo zaufany lub przezroczysty kod.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> ustawioną wartość właściwości.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje nieprawidłowe natywne dojście systemu operacyjnego. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używane wewnętrznie do inicjowania <xref:System.Threading.WaitHandle.Handle%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Możesz użyć tej wartości, aby określić, <see cref="P:System.Threading.WaitHandle.Handle" /> czy właściwość zawiera prawidłowe natywne dojście systemu operacyjnego.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia natywne dojście systemu operacyjnego.</summary>
        <value><see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> Reprezentujący natywny uchwyt systemu operacyjnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po przypisaniu nowej wartości do <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości, poprzednie dojście zostanie zamknięte po zebraniu poprzedniego <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> obiektu. Nie zamykaj ręcznie dojścia, ponieważ powoduje <xref:System.ObjectDisposedException> to, <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> kiedy próbuje zamknąć uchwyt.  
  
 <xref:System.Threading.WaitHandle><xref:System.IDisposable.Dispose%2A> implementuje wzorzec. Zobacz [implementowanie metody Dispose] (~/docs/Standard/garbage-collection/Implementing-Dispose. MD). Gdy pochodzą z <xref:System.Threading.WaitHandle>programu, <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Użyj właściwości do przechowywania natywnego uchwytu systemu operacyjnego. Nie musisz przesłonić metody chronionej <xref:System.Threading.WaitHandle.Dispose%2A> , chyba że używasz dodatkowych zasobów niezarządzanych.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> wywołania tego elementu członkowskiego.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sygnalizuje <see cref="T:System.Threading.WaitHandle" /> jeden i czeka na inny.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><see cref="T:System.Threading.WaitHandle" /> Do sygnału.</param>
        <param name="toWaitOn">, <see cref="T:System.Threading.WaitHandle" /> Aby czekać.</param>
        <summary>Sygnalizuje <see cref="T:System.Threading.WaitHandle" /> jeden i czeka na inny.</summary>
        <returns><see langword="true" />Jeśli zarówno sygnał, jak i oczekiwanie zakończyło się pomyślnie; Jeśli oczekiwanie nie zostanie zakończone, metoda nie zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie gwarantuje, że jest niepodzielna. Gdy bieżący wątek sygnalizuje `toSignal` `toWaitOn`, ale przed odczekaniem, wątek, który jest uruchomiony na innym procesorze `toWaitOn` , może sygnalizować lub oczekiwać na niego.  
  
   
  
## Examples  
 Poniższy przykład kodu używa przeciążenia metody <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> , aby umożliwić głównemu wątkowi sygnalizowanie zablokowanego wątku, a następnie zaczekać, aż wątek zakończy zadanie.  
  
 Przykład rozpoczyna pięć wątków, umożliwia ich blokowanie na <xref:System.Threading.EventWaitHandle> utworzonej <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> z flagą, a następnie zwalnia jeden wątek za każdym razem, gdy użytkownik naciśnie klawisz ENTER. W tym przykładzie kolejka będzie kolejkować kolejne pięć wątków i zwalnia <xref:System.Threading.EventWaitHandle> je wszystkie przy <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> użyciu flagi utworzony z flagą.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="toWaitOn" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="toSignal" />jest semaforem i ma już pełną liczbę.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><see cref="T:System.Threading.WaitHandle" /> Do sygnału.</param>
        <param name="toWaitOn">, <see cref="T:System.Threading.WaitHandle" /> Aby czekać.</param>
        <param name="millisecondsTimeout">Liczba całkowita, która reprezentuje interwał oczekiwania. Jeśli wartość to <see cref="F:System.Threading.Timeout.Infinite" />, czyli-1, czas oczekiwania jest nieskończony.</param>
        <param name="exitContext"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></param>
        <summary>Sygnalizuje <see cref="T:System.Threading.WaitHandle" /> jeden i czeka na inny, określając interwał limitu czasu jako 32-bitową liczbę całkowitą ze znakiem i określając, czy zamknąć domenę synchronizacji kontekstu przed wprowadzeniem oczekiwania.</summary>
        <returns><see langword="true" />Jeśli zarówno sygnał, jak i oczekiwanie zakończono pomyślnie <see langword="false" /> , lub jeśli sygnał zakończył się, ale upłynął limit czasu oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie gwarantuje, że jest niepodzielna. Gdy bieżący wątek sygnalizuje `toSignal` `toWaitOn`, ale przed odczekaniem, wątek, który jest uruchomiony na innym procesorze `toWaitOn` , może sygnalizować lub oczekiwać na niego.  
  
 Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana. Sprawdza stan `toWaitOn` i natychmiast wraca.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 Parametr nie działa, <xref:System.Threading.WaitHandle.SignalAndWait%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext` Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.SignalAndWait%2A> kontekstu) przed wykonaniem metody. Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.  
  
 Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma. W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację. <xref:System.Threading.WaitHandle.SignalAndWait%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="toWaitOn" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Metoda jest wywoływana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Nie <see cref="T:System.Threading.WaitHandle" /> można zasygnalizować, ponieważ spowodowałoby to przekroczenie maksymalnej liczby.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><see cref="T:System.Threading.WaitHandle" /> Do sygnału.</param>
        <param name="toWaitOn">, <see cref="T:System.Threading.WaitHandle" /> Aby czekać.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Reprezentuje interwał oczekiwania. Jeśli wartość to-1, czas oczekiwania jest nieskończony.</param>
        <param name="exitContext"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></param>
        <summary>Sygnalizuje <see cref="T:System.Threading.WaitHandle" /> jeden i czeka na inne określenie interwału limitu czasu <see cref="T:System.TimeSpan" /> jako i określenie, czy należy zamknąć domenę synchronizacji kontekstu przed wprowadzeniem oczekiwania.</summary>
        <returns><see langword="true" />Jeśli zarówno sygnał, jak i oczekiwanie zakończono pomyślnie <see langword="false" /> , lub jeśli sygnał zakończył się, ale upłynął limit czasu oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie gwarantuje, że jest niepodzielna. Gdy bieżący wątek sygnalizuje `toSignal` `toWaitOn`, ale przed odczekaniem, wątek, który jest uruchomiony na innym procesorze `toWaitOn` , może sygnalizować lub oczekiwać na niego.  
  
 Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Jeśli `timeout` jest równa zero, metoda nie jest blokowana. Sprawdza stan `toWaitOn` i natychmiast wraca.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 Parametr nie działa, <xref:System.Threading.WaitHandle.SignalAndWait%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext` Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.SignalAndWait%2A> kontekstu) przed wykonaniem metody. Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.  
  
 Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma. W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację. <xref:System.Threading.WaitHandle.SignalAndWait%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="toWaitOn" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="toSignal" />jest semaforem i ma już pełną liczbę.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />daje w wyniku ujemną liczbę milisekund inną niż-1.  
  
—lub— 
 <paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.Threading.WaitHandle" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Wywołanie `Dispose` zezwala na przydzielenie zasobów używanych <xref:System.Threading.WaitHandle> przez program do innych celów. Aby uzyskać więcej informacji `Dispose`na temat, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać. Ta tablica nie może zawierać wielu odwołań do tego samego obiektu.</param>
        <summary>Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał.</summary>
        <returns><see langword="true" />gdy każdy element w <paramref name="waitHandles" /> odebrał sygnał; w przeciwnym razie Metoda nigdy nie zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony. Porzucony obiekt mutex często wskazuje na poważny błąd kodowania. W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 Metoda <xref:System.Threading.WaitHandle.WaitAll%2A> zwraca, gdy wszystkie uchwyty są sygnalizowane. W przypadku niektórych implementacji, jeśli przechodzą więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany. Jeśli tablica zawiera duplikaty, wywołanie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Metoda nie jest obsługiwana w wątkach, które <xref:System.STAThreadAttribute>mają. <xref:System.Threading.WaitHandle.WaitAll%2A>  
  
 Wywołanie tego przeciążenia <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> metody jest równoważne wywołaniu metody przeciążenia i określania-1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać puli wątków do asynchronicznego tworzenia i zapisu do grupy plików. Każda operacja zapisu jest umieszczana w kolejce jako element roboczy i sygnalizuje po zakończeniu. Główny wątek czeka na wszystkie elementy do sygnalizowania, a następnie opuszcza.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /> —lub— 
Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" />  
  
—lub— 
 <paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 2,0 lub nowsza.</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.ArgumentException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.  
  
—lub— 
Ten <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 1,0 lub 1,1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać. Ta tablica nie może zawierać wielu odwołań do tego samego obiektu (duplikatów).</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <summary>Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał przy użyciu <see cref="T:System.Int32" /> wartości, aby określić interwał czasu.</summary>
        <returns><see langword="true" />gdy każdy element w <paramref name="waitHandles" /> programie otrzymał sygnał; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana. Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca po zakończeniu oczekiwania, co oznacza, gdy wszystkie uchwyty są sygnalizowane lub gdy upłynie limit czasu. W przypadku niektórych implementacji, jeśli przechodzą więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany. Jeśli w tablicy znajdują się duplikaty, wywołanie kończy się niepowodzeniem <xref:System.DuplicateWaitObjectException>z.  
  
> [!NOTE]
>  Metoda nie jest obsługiwana w wątkach, które <xref:System.STAThreadAttribute>mają. <xref:System.Threading.WaitHandle.WaitAll%2A>  
  
 Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" />  
  
—lub— 
Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" />  
  
—lub— 
 <paramref name="waitHandles" />jest tablicą bez elementów.</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.ArgumentException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.  
  
—lub— 
Ten <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać. Ta tablica nie może zawierać wielu odwołań do tego samego obiektu.</param>
        <param name="timeout">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></param>
        <summary>Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał, przy użyciu <see cref="T:System.TimeSpan" /> wartości, aby określić interwał czasu.</summary>
        <returns><see langword="true" />gdy każdy element w <paramref name="waitHandles" /> programie otrzymał sygnał; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest równa zero, metoda nie jest blokowana. Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca po zakończeniu oczekiwania, co oznacza, że wszystkie uchwyty są sygnalizowane lub przekroczenia limitu czasu. W przypadku niektórych implementacji, jeśli przechodzą więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany. Jeśli tablica zawiera duplikaty, wywołanie zakończy się niepowodzeniem.  
  
> [!NOTE]
>  Metoda nie jest obsługiwana w wątkach, które <xref:System.STAThreadAttribute>mają. <xref:System.Threading.WaitHandle.WaitAll%2A>  
  
 Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" />  
  
—lub— 
Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" />  
  
—lub— 
 <paramref name="waitHandles" />jest tablicą bez elementów.</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.ArgumentException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.  
  
—lub— 
Ten <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać. Ta tablica nie może zawierać wielu odwołań do tego samego obiektu (duplikatów).</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <param name="exitContext"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></param>
        <summary>Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał, przy użyciu <see cref="T:System.Int32" /> wartości, aby określić przedział czasu i określać, czy zamknąć domenę synchronizacji przed oczekiwaniem.</summary>
        <returns><see langword="true" />gdy każdy element w <paramref name="waitHandles" /> programie otrzymał sygnał; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana. Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony. Porzucony obiekt mutex często wskazuje na poważny błąd kodowania. W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca po zakończeniu oczekiwania, co oznacza, gdy wszystkie uchwyty są sygnalizowane lub gdy upłynie limit czasu. W przypadku niektórych implementacji, jeśli przechodzą więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany. Jeśli w tablicy znajdują się duplikaty, wywołanie kończy się niepowodzeniem <xref:System.DuplicateWaitObjectException>z.  
  
> [!NOTE]
>  Metoda nie jest obsługiwana w wątkach, które <xref:System.STAThreadAttribute>mają. <xref:System.Threading.WaitHandle.WaitAll%2A>  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 Parametr nie działa, <xref:System.Threading.WaitHandle.WaitAll%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext` Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitAll%2A> kontekstu) przed wykonaniem metody. Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitAll%2A> metody.  
  
 Może to być przydatne, gdy klasa związana z kontekstem ma <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atrybut. W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację. <xref:System.Threading.WaitHandle.WaitAll%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać puli wątków do asynchronicznego tworzenia i zapisu do grupy plików. Każda operacja zapisu jest umieszczana w kolejce jako element roboczy i sygnalizuje po zakończeniu. Główny wątek czeka na wszystkie elementy do sygnalizowania, a następnie opuszcza.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" />  
  
—lub— 
Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" />  
  
—lub— 
 <paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 2,0 lub nowsza.</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.  
  
—lub— 
Ten <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 1,0 lub 1,1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać. Ta tablica nie może zawierać wielu odwołań do tego samego obiektu.</param>
        <param name="timeout">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></param>
        <param name="exitContext"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></param>
        <summary>Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał, przy użyciu <see cref="T:System.TimeSpan" /> wartości, aby określić przedział czasu, i określić, czy zamknąć domenę synchronizacji przed oczekiwaniem.</summary>
        <returns><see langword="true" />gdy każdy element w <paramref name="waitHandles" /> programie otrzymał sygnał; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest równa zero, metoda nie jest blokowana. Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony. Porzucony obiekt mutex często wskazuje na poważny błąd kodowania. W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca po zakończeniu oczekiwania, co oznacza, że wszystkie uchwyty są sygnalizowane lub przekroczenia limitu czasu. W przypadku niektórych implementacji, jeśli przechodzą więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany. Jeśli tablica zawiera duplikaty, wywołanie zakończy się niepowodzeniem.  
  
> [!NOTE]
>  Metoda nie jest obsługiwana w wątkach, które <xref:System.STAThreadAttribute>mają. <xref:System.Threading.WaitHandle.WaitAll%2A>  
  
 Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 Parametr nie działa, <xref:System.Threading.WaitHandle.WaitAll%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext` Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitAll%2A> kontekstu) przed wykonaniem metody. Powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitAll%2A> metody.  
  
 Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma. W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację. <xref:System.Threading.WaitHandle.WaitAll%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać puli wątków do asynchronicznego tworzenia i zapisu do grupy plików. Każda operacja zapisu jest umieszczana w kolejce jako element roboczy i sygnalizuje po zakończeniu. Główny wątek czeka na wszystkie elementy do sygnalizowania, a następnie opuszcza.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" />  
  
—lub— 
Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" />  
  
—lub— 
 <paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 2,0 lub nowsza.</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.  
  
—lub— 
Ten <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 1,0 lub 1,1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na dowolny element w określonej tablicy, aby otrzymać sygnał.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</param>
        <summary>Czeka na dowolny element w określonej tablicy, aby otrzymać sygnał.</summary>
        <returns>Indeks tablicy obiektu spełniającego oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zwraca `true` , jeśli oczekiwanie zakończy się, ponieważ obiekt mutex został porzucony. Porzucony obiekt mutex często wskazuje na poważny błąd kodowania. W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda<xref:System.Threading.AbandonedMutexException> zgłasza tylko po zakończeniu oczekiwania z powodu porzuconego obiektu mutex. Jeśli `waitHandles` zawiera wydanego obiektu mutex o niższym indeksie niż porzucony element <xref:System.Threading.WaitHandle.WaitAny%2A> mutex, Metoda zostanie zakończona normalnie, a wyjątek nie zostanie zgłoszony.  
  
> [!NOTE]
>  W wersjach .NET Framework w wersji starszej niż 2,0, jeśli wątek zostanie zakończony lub przerwany bez <xref:System.Threading.Mutex>jawnie wydawania, a który `Mutex` jest przy indeksie 0 `WaitAny` (zero) w tablicy w innym wątku, indeks zwrócony przez `WaitAny` to 128 zamiast 0.  
  
 Ta metoda zwraca po zasygnalizowaniu dojścia. Jeśli więcej niż jeden obiekt zostanie zasygnalizowani w trakcie wywołania, wartość zwracana jest indeksem tablicy obiektu sygnalizującego z najmniejszą wartością indeksu wszystkich obiektów sygnalizujących. W przypadku niektórych implementacji, jeśli są spełnione więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.  
  
 Wywołanie tego przeciążenia <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> metody jest równoważne wywołaniu metody przeciążenia i określania-1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie <xref:System.Threading.WaitHandle.WaitAny%2A> metody.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" />  
  
—lub— 
Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 1,0 lub 1,1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 2,0 lub nowsza.</exception>
        <exception cref="T:System.InvalidOperationException">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <summary>Czeka na dowolny element w określonej tablicy, aby otrzymać sygnał, przy użyciu 32-bitowej ze znakiem liczby całkowitej, aby określić interwał czasu.</summary>
        <returns>Indeks tablicy obiektu, który zakończył oczekiwanie, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie spełnił oczekiwań i przedział czasu <paramref name="millisecondsTimeout" /> odpowiada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana. Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda<xref:System.Threading.AbandonedMutexException> zgłasza tylko po zakończeniu oczekiwania z powodu porzuconego obiektu mutex. Jeśli `waitHandles` zawiera wydanego obiektu mutex o niższym indeksie niż porzucony element <xref:System.Threading.WaitHandle.WaitAny%2A> mutex, Metoda zostanie zakończona normalnie, a wyjątek nie zostanie zgłoszony.  
  
 Ta metoda zwraca czas zakończenia oczekiwania, gdy dowolna z uchwytów jest zasygnalizowania lub gdy wystąpi limit czasu. Jeśli więcej niż jeden obiekt zostanie zasygnalizowani w trakcie wywołania, wartość zwracana jest indeksem tablicy obiektu sygnalizującego z najmniejszą wartością indeksu wszystkich obiektów sygnalizujących. W przypadku niektórych implementacji, jeśli są spełnione więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.  
  
 Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" />  
  
—lub— 
Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" />jest tablicą bez elementów.</exception>
        <exception cref="T:System.InvalidOperationException">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</param>
        <param name="timeout">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></param>
        <summary>Czeka na dowolny element w określonej tablicy, aby otrzymać sygnał, przy użyciu parametru <see cref="T:System.TimeSpan" /> do określenia interwału czasu.</summary>
        <returns>Indeks tablicy obiektu, który zakończył oczekiwanie, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie spełnił oczekiwań i przedział czasu <paramref name="timeout" /> odpowiada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest równa zero, metoda nie jest blokowana. Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda<xref:System.Threading.AbandonedMutexException> zgłasza tylko po zakończeniu oczekiwania z powodu porzuconego obiektu mutex. Jeśli `waitHandles` zawiera wydanego obiektu mutex o niższym indeksie niż porzucony element <xref:System.Threading.WaitHandle.WaitAny%2A> mutex, Metoda zostanie zakończona normalnie, a wyjątek nie zostanie zgłoszony.  
  
 Ta metoda zwraca czas zakończenia oczekiwania, gdy dowolna z uchwytów jest zasygnalizowania lub gdy występuje limit czasu. Jeśli więcej niż jeden obiekt zostanie zasygnalizowani w trakcie wywołania, wartość zwracana jest indeksem tablicy obiektu sygnalizującego z najmniejszą wartością indeksu wszystkich obiektów sygnalizujących. W przypadku niektórych implementacji, jeśli są spełnione więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.  
  
 Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" />  
  
—lub— 
Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" />jest tablicą bez elementów.</exception>
        <exception cref="T:System.InvalidOperationException">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <param name="exitContext"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></param>
        <summary>Czeka, aż którykolwiek z elementów w określonej tablicy otrzyma sygnał przy użyciu 32-bitowej ze znakiem liczby całkowitej, aby określić przedział czasu, i określić, czy zamknąć domenę synchronizacji przed oczekiwaniem.</summary>
        <returns>Indeks tablicy obiektu, który zakończył oczekiwanie, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie spełnił oczekiwań i przedział czasu <paramref name="millisecondsTimeout" /> odpowiada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana. Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zwraca `true` , jeśli oczekiwanie zakończy się, ponieważ obiekt mutex został porzucony. Porzucony obiekt mutex często wskazuje na poważny błąd kodowania. W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda<xref:System.Threading.AbandonedMutexException> zgłasza tylko po zakończeniu oczekiwania z powodu porzuconego obiektu mutex. Jeśli `waitHandles` zawiera wydanego obiektu mutex o niższym indeksie niż porzucony element <xref:System.Threading.WaitHandle.WaitAny%2A> mutex, Metoda zostanie zakończona normalnie, a wyjątek nie zostanie zgłoszony.  
  
> [!NOTE]
>  W wersjach .NET Framework w wersji starszej niż 2,0, jeśli wątek zostanie zakończony lub przerwany bez <xref:System.Threading.Mutex>jawnie wydawania, a który `Mutex` jest przy indeksie 0 `WaitAny` (zero) w tablicy w innym wątku, indeks zwrócony przez `WaitAny` to 128 zamiast 0.  
  
 Ta metoda zwraca czas zakończenia oczekiwania, gdy dowolna z uchwytów jest zasygnalizowania lub gdy wystąpi limit czasu. Jeśli więcej niż jeden obiekt zostanie zasygnalizowani w trakcie wywołania, wartość zwracana jest indeksem tablicy obiektu sygnalizującego z najmniejszą wartością indeksu wszystkich obiektów sygnalizujących. W przypadku niektórych implementacji, jeśli są spełnione więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 Parametr nie działa, <xref:System.Threading.WaitHandle.WaitAny%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext` Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitAny%2A> kontekstu) przed wykonaniem metody. Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitAny%2A> metody.  
  
 Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma. W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację. <xref:System.Threading.WaitHandle.WaitAny%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać puli wątków do jednoczesnego wyszukania pliku na wielu dyskach. W przypadku zagadnień dotyczących miejsca przeszukiwany jest tylko katalog główny każdego dysku.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" />  
  
—lub— 
Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 1,0 lub 1,1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 2,0 lub nowsza.</exception>
        <exception cref="T:System.InvalidOperationException">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</param>
        <param name="timeout">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></param>
        <param name="exitContext"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></param>
        <summary>Czeka na dowolne elementy w określonej tablicy, aby otrzymać sygnał, przy użyciu parametru <see cref="T:System.TimeSpan" /> do określenia interwału czasu i określenia, czy zamknąć domenę synchronizacji przed oczekiwaniem.</summary>
        <returns>Indeks tablicy obiektu, który zakończył oczekiwanie, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie spełnił oczekiwań i przedział czasu <paramref name="timeout" /> odpowiada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest równa zero, metoda nie jest blokowana. Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zwraca `true` , jeśli oczekiwanie zakończy się, ponieważ obiekt mutex został porzucony. Porzucony obiekt mutex często wskazuje na poważny błąd kodowania. W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda<xref:System.Threading.AbandonedMutexException> zgłasza tylko po zakończeniu oczekiwania z powodu porzuconego obiektu mutex. Jeśli `waitHandles` zawiera wydanego obiektu mutex o niższym indeksie niż porzucony element <xref:System.Threading.WaitHandle.WaitAny%2A> mutex, Metoda zostanie zakończona normalnie, a wyjątek nie zostanie zgłoszony.  
  
> [!NOTE]
>  W wersjach .NET Framework w wersji starszej niż 2,0, jeśli wątek zostanie zakończony lub przerwany bez <xref:System.Threading.Mutex>jawnie wydawania, a który `Mutex` jest przy indeksie 0 `WaitAny` (zero) w tablicy w innym wątku, indeks zwrócony przez `WaitAny` to 128 zamiast 0.  
  
 Ta metoda zwraca czas zakończenia oczekiwania, gdy dowolna z uchwytów jest zasygnalizowania lub gdy występuje limit czasu. Jeśli więcej niż jeden obiekt zostanie zasygnalizowani w trakcie wywołania, wartość zwracana jest indeksem tablicy obiektu sygnalizującego z najmniejszą wartością indeksu wszystkich obiektów sygnalizujących. W przypadku niektórych implementacji, jeśli są spełnione więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.  
  
 Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 Parametr nie działa, <xref:System.Threading.WaitHandle.WaitAny%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext` Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitAny%2A> kontekstu) przed wykonaniem metody. Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitAny%2A> metody.  
  
 Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma. W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację. <xref:System.Threading.WaitHandle.WaitAny%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać puli wątków do jednoczesnego wyszukania pliku na wielu dyskach. W przypadku zagadnień dotyczących miejsca przeszukiwany jest tylko katalog główny każdego dysku.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" />  
  
—lub— 
Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 1,0 lub 1,1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 2,0 lub nowsza.</exception>
        <exception cref="T:System.InvalidOperationException">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blokuje bieżący wątek do momentu <see cref="T:System.Threading.WaitHandle" /> odebrania sygnału.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blokuje bieżący wątek do momentu <see cref="T:System.Threading.WaitHandle" /> odebrania sygnału.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie odbiera sygnał. Jeśli bieżące wystąpienie nigdy nie jest sygnalizowane, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nigdy nie zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony. Porzucony obiekt mutex często wskazuje na poważny błąd kodowania. W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 Obiekt wywołujący tę metodę jest blokowany w nieskończoność do momentu odebrania sygnału przez bieżące wystąpienie. Użyj tej metody, aby zablokować do <xref:System.Threading.WaitHandle> momentu odebrania sygnału z innego wątku, takiego jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejs.  
  
 Wywołanie tego przeciążenia metody jest równoważne wywołaniu <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> metody przeciążenia i określania-1 lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> pierwszego parametru oraz `false` dla drugiego parametru.  
  
 Zastąp tę metodę, aby dostosować zachowanie klas pochodnych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać dojścia oczekiwania, aby zapobiec zakończeniu procesu podczas oczekiwania na zakończenie wykonywania wątku w tle.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczystym serwerem proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <summary>Blokuje bieżący wątek do momentu <see cref="T:System.Threading.WaitHandle" /> odebrania sygnału przy użyciu 32-bitowej podpisanej liczby całkowitej w celu określenia interwału czasu w milisekundach.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana. Testuje stan uchwytu oczekiwania i natychmiast wraca.  
  
 Obiekt wywołujący tę metodę jest blokowany do momentu odebrania sygnału lub przekroczenia limitu czasu przez bieżące wystąpienie. Użyj tej metody, aby zablokować do <xref:System.Threading.WaitHandle> momentu odebrania sygnału z innego wątku, takiego jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejs.  
  
 Zastąp tę metodę, aby dostosować zachowanie klas pochodnych.  
  
 Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać dojścia oczekiwania, aby zapobiec zakończeniu procesu podczas oczekiwania na zakończenie wykonywania wątku w tle.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczystym serwerem proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></param>
        <summary>Blokuje bieżący wątek do momentu otrzymania przez bieżące wystąpienie sygnału przy użyciu <see cref="T:System.TimeSpan" /> do określenia interwału czasu.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest równa zero, metoda nie jest blokowana. Testuje stan uchwytu oczekiwania i natychmiast wraca.  
  
 Obiekt wywołujący tę metodę jest blokowany do momentu odebrania sygnału lub przekroczenia limitu czasu przez bieżące wystąpienie. Użyj tej metody, aby zablokować do <xref:System.Threading.WaitHandle> momentu odebrania sygnału z innego wątku, takiego jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejs.  
  
 Zastąp tę metodę, aby dostosować zachowanie klas pochodnych.  
  
 Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczystym serwerem proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <param name="exitContext"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></param>
        <summary>Blokuje bieżący wątek do momentu <see cref="T:System.Threading.WaitHandle" /> odebrania sygnału przy użyciu 32-bitowej podpisanej liczby całkowitej w celu określenia interwału czasu i określenia, czy zamknąć domenę synchronizacji przed oczekiwaniem.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana. Testuje stan uchwytu oczekiwania i natychmiast wraca.  
  
 <xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony. Porzucony obiekt mutex często wskazuje na poważny błąd kodowania. W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 Obiekt wywołujący tę metodę jest blokowany do momentu odebrania sygnału lub przekroczenia limitu czasu przez bieżące wystąpienie. Użyj tej metody, aby zablokować do <xref:System.Threading.WaitHandle> momentu odebrania sygnału z innego wątku, takiego jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejs.  
  
 Zastąp tę metodę, aby dostosować zachowanie klas pochodnych.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 Parametr nie działa, <xref:System.Threading.WaitHandle.WaitOne%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext` Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitOne%2A> kontekstu) przed wykonaniem metody. Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> metody.  
  
 Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma. W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację. <xref:System.Threading.WaitHandle.WaitOne%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak działa <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> Przeciążenie metody, gdy jest wywoływana w domenie synchronizacji. Najpierw wątek czeka z `exitContext` ustawionym na `false` i bloki do momentu wygaśnięcia limitu czasu oczekiwania. Drugi wątek jest wykonywany po zakończeniu pierwszego wątku i czeka `exitContext` na wartość ustawioną na. `true` Wywołanie sygnalizujące dojście oczekiwania dla drugiego wątku nie jest blokowane i wątek zostaje zakończony przed upływem limitu czasu oczekiwania.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczystym serwerem proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></param>
        <param name="exitContext"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></param>
        <summary>Blokuje bieżący wątek do momentu odebrania przez bieżące wystąpienie sygnału przy użyciu <see cref="T:System.TimeSpan" /> do określenia interwału czasu i określenia, czy zamknąć domenę synchronizacji przed oczekiwaniem.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest równa zero, metoda nie jest blokowana. Testuje stan uchwytu oczekiwania i natychmiast wraca.  
  
 <xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony. Porzucony obiekt mutex często wskazuje na poważny błąd kodowania. W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 Obiekt wywołujący tę metodę jest blokowany do momentu odebrania sygnału lub przekroczenia limitu czasu przez bieżące wystąpienie. Użyj tej metody, aby zablokować do <xref:System.Threading.WaitHandle> momentu odebrania sygnału z innego wątku, takiego jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejs.  
  
 Zastąp tę metodę, aby dostosować zachowanie klas pochodnych.  
  
 Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 Parametr nie działa, <xref:System.Threading.WaitHandle.WaitOne%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext` Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitOne%2A> kontekstu) przed wykonaniem metody. Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> metody.  
  
 Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma. W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację. <xref:System.Threading.WaitHandle.WaitOne%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać dojścia oczekiwania, aby zapobiec zakończeniu procesu podczas oczekiwania na zakończenie wykonywania wątku w tle.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex. Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczystym serwerem proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Wskazuje, że <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> upłynął limit czasu operacji przed zasygnalizowaniem dowolnego z dojść oczekiwania. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole jest jedną z możliwych wartości `WaitAny`zwracanych.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać puli wątków do jednoczesnego wyszukania pliku na wielu dyskach. W przypadku zagadnień dotyczących miejsca przeszukiwany jest tylko katalog główny każdego dysku.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

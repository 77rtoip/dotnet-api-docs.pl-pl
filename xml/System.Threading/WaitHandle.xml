<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="c76cd-101">Hermetyzuje obiekty specyficzne dla systemu operacyjnego, które poczekaj, aż wyłącznego dostępu do zasobów udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-102"><xref:System.Threading.WaitHandle> Klasa hermetyzuje dojścia synchronizacji Win32 i jest używana do reprezentowania wszystkich obiektów synchronizacji w czasie wykonywania, które umożliwiają wielu operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-102">The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="c76cd-103">Porównanie uchwyty oczekiwania z innymi obiektami synchronizacji, zobacz [podstawowych Omówienie synchronizacji](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="c76cd-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="c76cd-104"><xref:System.Threading.WaitHandle> Sama klasa jest abstrakcyjna.</span><span class="sxs-lookup"><span data-stu-id="c76cd-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="c76cd-105">Klasy wyprowadzone z <xref:System.Threading.WaitHandle> zdefiniować mechanizm sygnalizowania biorąc lub zwalniania dostęp do udostępnionych zasobów, ale korzystają z dziedziczonego <xref:System.Threading.WaitHandle> metod, które mają być blokowane podczas oczekiwania na dostęp do zasobów udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="c76cd-106">Klasy pochodne <xref:System.Threading.WaitHandle> obejmują:</span><span class="sxs-lookup"><span data-stu-id="c76cd-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="c76cd-107"><xref:System.Threading.Mutex> Klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="c76cd-108">Zobacz [muteksy](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="c76cd-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="c76cd-109"><xref:System.Threading.EventWaitHandle> Klasy i jej klas pochodnych <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="c76cd-110">Zobacz [EventWaitHandle, autoresetevent —, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="c76cd-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="c76cd-111"><xref:System.Threading.Semaphore> Klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="c76cd-112">Zobacz [semafor i klasa SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="c76cd-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="c76cd-113">Zablokować wątków w dojściu do poszczególnych oczekiwania przez wywołanie metody wystąpienia <xref:System.Threading.WaitHandle.WaitOne%2A>, który jest dziedziczone przez klasy pochodzące od <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="c76cd-114">Klasy pochodne <xref:System.Threading.WaitHandle> różnią się w ich koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="c76cd-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="c76cd-115">Uchwyty oczekiwania zdarzenia (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, i <xref:System.Threading.ManualResetEvent>) i semaforów nie mają koligacji wątku; którymkolwiek wątku można zasygnalizować dojście oczekiwania zdarzenia lub semafora.</span><span class="sxs-lookup"><span data-stu-id="c76cd-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="c76cd-116">Z drugiej strony, muteksy, mają koligacji wątku; Wątek, który jest właścicielem obiektu mutex musi zwolnić go i jest zwracany wyjątek, jeśli wątek wywołuje <xref:System.Threading.Mutex.ReleaseMutex%2A> metody dla obiektu mutex, który nie jest właścicielem.</span><span class="sxs-lookup"><span data-stu-id="c76cd-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="c76cd-117">Ponieważ <xref:System.Threading.WaitHandle> pochodną klasy <xref:System.MarshalByRefObject>, te klasy mogą być używane do synchronizowania działania wątków poza granice domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="c76cd-118">Oprócz jej klas pochodnych <xref:System.Threading.WaitHandle> klasa ma kilka metod statycznych, które blokują wątku, dopóki jedna lub więcej obiektów synchronizacji odebrał sygnału.</span><span class="sxs-lookup"><span data-stu-id="c76cd-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</span></span> <span data-ttu-id="c76cd-119">Należą do nich następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="c76cd-119">These include:</span></span>  
  
-   <span data-ttu-id="c76cd-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, dzięki czemu wątek sygnału jeden dojście oczekiwania i natychmiast czekać na innym.</span><span class="sxs-lookup"><span data-stu-id="c76cd-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="c76cd-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, dzięki czemu wątek poczekać, aż wszystkie dojścia oczekiwania w tablicy odebrał sygnału.</span><span class="sxs-lookup"><span data-stu-id="c76cd-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="c76cd-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, dzięki czemu wątek poczekać, aż któregokolwiek z określonego zestawu uchwyty oczekiwania został sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="c76cd-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="c76cd-123">Przeciążenia metody te zapewniają interwałów limitu czasu dla porzucanie czas oczekiwania oraz możliwość zakończyć kontekstu synchronizacji przed wprowadzeniem czas oczekiwania, dzięki czemu inne wątki używać kontekstu synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c76cd-124">Ten typ implementuje <xref:System.IDisposable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="c76cd-125">Po zakończeniu przy użyciu tego typu lub typu pochodnego w bezpośrednio lub pośrednio należy usunąć z niego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="c76cd-126">Do usuwania tego typu, należy wywołać jej <xref:System.Threading.WaitHandle.Close%2A> metody w `try` / `catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="c76cd-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="c76cd-127">Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="c76cd-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="c76cd-128">Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="c76cd-129"><xref:System.Threading.WaitHandle> implementuje <xref:System.IDisposable.Dispose%2A> wzorca.</span><span class="sxs-lookup"><span data-stu-id="c76cd-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="c76cd-130">Zobacz [wzorzec Dispose](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="c76cd-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="c76cd-131">Jeśli pochodzi od <xref:System.Threading.WaitHandle>, użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości do przechowywania uchwyt macierzysty uchwyt systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="c76cd-132">Nie trzeba zastąpić chronionej <xref:System.Threading.WaitHandle.Dispose%2A> metody chyba że są używane dodatkowe zasoby niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="c76cd-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-133">Poniższy kod przedstawia przykład jak dwa wątki można wykonać zadania w tle podczas głównym wątku czeka na zakończenie przy użyciu statycznych zadań <xref:System.Threading.WaitHandle.WaitAny%2A> i <xref:System.Threading.WaitHandle.WaitAll%2A> metody <xref:System.Threading.WaitHandle> klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="c76cd-134">Ten typ jest bezpieczny wątkowo.</span><span class="sxs-lookup"><span data-stu-id="c76cd-134">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c76cd-135">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c76cd-136">Zwalnia wszystkie zasoby zajmowane przez bieżące <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-137">Ta metoda jest implementacją publicznego <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodę <xref:System.Threading.WaitHandle> klasy i jej klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-137">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="c76cd-138">Zapewnia standardowej implementacji, która wywołuje `Dispose(Boolean)` przeciążenia z `true` argument, a następnie wywołania <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-138">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c76cd-139">Wywołanie tej metody, aby zwolnić wszystkie zasoby zajmowane przez wystąpienia `WaitHandle` lub klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-139">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="c76cd-140">Gdy ta metoda jest wywoływana, odwołania do bieżącego wystąpienia spowodować niezdefiniowane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="c76cd-140">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c76cd-141">Wywoływanie zawsze <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed zwolnieniem ostatniego odwołania do <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-141">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c76cd-142">W przeciwnym razie zasoby, które używa nie zostanie zwolniona.</span><span class="sxs-lookup"><span data-stu-id="c76cd-142">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c76cd-143">Należy zastąpić <see langword="Dispose(Boolean)" /> metodę, aby zwolnić zasoby przydzielone w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-143">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c76cd-144">Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> — klasa</span><span class="sxs-lookup"><span data-stu-id="c76cd-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c76cd-145">Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-146">Ta metoda jest odpowiednikiem <xref:System.Threading.WaitHandle.Close%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-146">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c76cd-147">Wywoływanie zawsze <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed zwolnieniem ostatniego odwołania do <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-147">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c76cd-148">W przeciwnym razie zasoby, które używa nie zostanie zwolniona.</span><span class="sxs-lookup"><span data-stu-id="c76cd-148">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="c76cd-149"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="c76cd-149"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="c76cd-150">W przypadku przesłonięcia w klasie pochodnej, zwalnia zasoby niezarządzane używane przez <see cref="T:System.Threading.WaitHandle" />i opcjonalnie zwalnia zasoby zarządzane.</span><span class="sxs-lookup"><span data-stu-id="c76cd-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-151">Ta metoda jest wywoływana przez <xref:System.Threading.WaitHandle.Close%2A> i <xref:System.Threading.WaitHandle.Dispose> metod `explicitDisposing` ustawiono parametr `true`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-151">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="c76cd-152">Gdy `explicitDisposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Threading.WaitHandle> obiektu odwołania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-152">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c76cd-153">Należy zastąpić <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> metodę, aby zwolnić zasoby przydzielone w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-153">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
 <span data-ttu-id="c76cd-154"><see cref="M:System.Threading.WaitHandle.Close" /> Lub <see cref="M:System.Threading.WaitHandle.Dispose" /> metodę można wywoływać wielokrotnie przez inne obiekty.</span><span class="sxs-lookup"><span data-stu-id="c76cd-154">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="c76cd-155">W przypadku przesłaniania tej metody, należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" /> lub <see langword="Close" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-155">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c76cd-156">Pobiera lub ustawia uchwyt macierzysty system operacyjny.</span><span class="sxs-lookup"><span data-stu-id="c76cd-156">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="c76cd-157"><see langword="IntPtr" /> Reprezentujący uchwyt macierzysty system operacyjny.</span><span class="sxs-lookup"><span data-stu-id="c76cd-157">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="c76cd-158">Wartość domyślna to wartość <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> pola.</span><span class="sxs-lookup"><span data-stu-id="c76cd-158">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-159">Przypisywanie nową wartość do <xref:System.Threading.WaitHandle.Handle%2A> właściwości nie zamyka poprzedniej dojścia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-159">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="c76cd-160">Może to spowodować, że ujawnione dojścia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-160">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="c76cd-161">Nie należy używać tej właściwości w programie .NET Framework w wersji 2.0 lub nowszy; Użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-161">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="c76cd-162">Ustawienie tej właściwości na prawidłowy uchwyt również zestawy <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości, ale ustawieniem dla niego <xref:System.Threading.WaitHandle.InvalidHandle> może spowodować uchwyt ujawnione.</span><span class="sxs-lookup"><span data-stu-id="c76cd-162">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c76cd-163">Wymagane jest pełne zaufanie do bezpośredniego obiektu wywołującego można ustawić wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="c76cd-163">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="c76cd-164">Nie można ustawić tego elementu członkowskiego przez kod częściowo zaufany lub przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="c76cd-164">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="c76cd-165">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> można ustawić wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="c76cd-165">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c76cd-166">Reprezentuje dojścia nieprawidłowy natywnego systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-166">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="c76cd-167">To pole jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-167">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-168">Używana wewnętrznie w celu zainicjowania <xref:System.Threading.WaitHandle.Handle%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="c76cd-168">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c76cd-169">Tej wartości można użyć, aby określić, czy <see cref="P:System.Threading.WaitHandle.Handle" /> właściwość zawiera dojście prawidłowego natywnego systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-169">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c76cd-170">Pobiera lub ustawia uchwyt macierzysty system operacyjny.</span><span class="sxs-lookup"><span data-stu-id="c76cd-170">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="c76cd-171">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> reprezentujący uchwyt macierzysty system operacyjny.</span><span class="sxs-lookup"><span data-stu-id="c76cd-171">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-172">Po przypisaniu nową wartość do <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwość poprzedniej dojście zostanie zamknięty kiedy poprzedniej <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> zbieranych obiektu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-172">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="c76cd-173">Nie ręcznie zamknąć uchwytu, ponieważ powoduje to <xref:System.ObjectDisposedException> podczas <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> próbuje zamknąć dojścia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-173">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="c76cd-174"><xref:System.Threading.WaitHandle> implementuje <xref:System.IDisposable.Dispose%2A> wzorca.</span><span class="sxs-lookup"><span data-stu-id="c76cd-174"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="c76cd-175">Zobacz [wzorzec Dispose](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="c76cd-175">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="c76cd-176">Jeśli pochodzi od <xref:System.Threading.WaitHandle>, użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości do przechowywania uchwyt macierzysty uchwyt systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-176">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="c76cd-177">Nie trzeba zastąpić chronionej <xref:System.Threading.WaitHandle.Dispose%2A> metody chyba że są używane dodatkowe zasoby niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="c76cd-177">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c76cd-178">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-178">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c76cd-179">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="c76cd-179">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="c76cd-180">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> do wywołania tego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-180">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c76cd-181">Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym.</span><span class="sxs-lookup"><span data-stu-id="c76cd-181">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="c76cd-182"><see cref="T:System.Threading.WaitHandle" /> Sygnalizują.</span><span class="sxs-lookup"><span data-stu-id="c76cd-182">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="c76cd-183"><see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-183">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="c76cd-184">Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym.</span><span class="sxs-lookup"><span data-stu-id="c76cd-184">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-185"><see langword="true" /> Jeśli zarówno sygnał, jak i czas oczekiwania zakończy się pomyślnie; Jeśli czas oczekiwania nie zostanie ukończone, metoda zwraca.</span><span class="sxs-lookup"><span data-stu-id="c76cd-185"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-186">Ta operacja nie jest gwarantowana niepodzielnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-186">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="c76cd-187">Po bieżącym wątku sygnały `toSignal` , ale przed oczekuje `toWaitOn`, wątku, który działa na innego procesora może sygnalizować `toWaitOn` lub zaczekaj na nim.</span><span class="sxs-lookup"><span data-stu-id="c76cd-187">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-188">Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenie metody, aby zezwolić na sygnał zablokowanych wątków, a następnie poczekaj zakończenie wątku zadania głównego wątku.</span><span class="sxs-lookup"><span data-stu-id="c76cd-188">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="c76cd-189">Przykład rozpoczyna pięć wątków, pozwala na blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flagi, a następnie jeden wątek wersjach czasu naciśnięciu klawisza ENTER.</span><span class="sxs-lookup"><span data-stu-id="c76cd-189">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="c76cd-190">W przykładzie następnie kolejki innego pięć wątków i zwalnia wszystkie przy użyciu <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="c76cd-190">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c76cd-191"><paramref name="toSignal" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-191"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-192">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-192">-or-</span></span>  
  
 <span data-ttu-id="c76cd-193"><paramref name="toWaitOn" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-193"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-194">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-194">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="c76cd-195">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-195">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="c76cd-196"><paramref name="toSignal" /> jest semafora i jest już pełna count.</span><span class="sxs-lookup"><span data-stu-id="c76cd-196"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-197">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-197">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-198">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-198">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="c76cd-199"><see cref="T:System.Threading.WaitHandle" /> Sygnalizują.</span><span class="sxs-lookup"><span data-stu-id="c76cd-199">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="c76cd-200"><see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-200">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="c76cd-201">Liczba całkowita, która reprezentuje interwału oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-201">An integer that represents the interval to wait.</span></span> <span data-ttu-id="c76cd-202">Jeśli wartość jest <see cref="F:System.Threading.Timeout.Infinite" />, -1, czas oczekiwania jest nieograniczony.</span><span class="sxs-lookup"><span data-stu-id="c76cd-202">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="c76cd-203"><see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-203"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="c76cd-204">Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym określająca interwał limitu czasu, całkowita 32-bitowe i określanie, czy zamknąć domeny synchronizacji w kontekście przed wejściem czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-204">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-205"><see langword="true" /> Jeśli zarówno sygnał, jak i czas oczekiwania ukończone pomyślnie, lub <see langword="false" /> jeśli sygnał ukończone, ale czas oczekiwania upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-205"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-206">Ta operacja nie jest gwarantowana niepodzielnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-206">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="c76cd-207">Po bieżącym wątku sygnały `toSignal` , ale przed oczekuje `toWaitOn`, wątku, który działa na innego procesora może sygnalizować `toWaitOn` lub zaczekaj na nim.</span><span class="sxs-lookup"><span data-stu-id="c76cd-207">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="c76cd-208">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-208">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-209">Sprawdza on stan `toWaitOn` i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-209">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="c76cd-210">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="c76cd-210">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="c76cd-211">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-211">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="c76cd-212">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-212">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="c76cd-213">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-213">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="c76cd-214">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-214">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="c76cd-215">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.SignalAndWait%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-215">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="c76cd-216">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-216">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="c76cd-217">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-217">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="c76cd-218">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="c76cd-218">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="c76cd-219">Gdy <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-219">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c76cd-220"><paramref name="toSignal" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-220"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-221">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-221">-or-</span></span>  
  
 <span data-ttu-id="c76cd-222"><paramref name="toWaitOn" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-222"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-223">Metoda jest wywoływana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-223">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="c76cd-224">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-224">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-225"><see cref="T:System.Threading.WaitHandle" /> Nie może zostać zgłoszony, ponieważ zostałaby przekroczona maksymalna wartość licznika.</span><span class="sxs-lookup"><span data-stu-id="c76cd-225">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-226"><paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-226"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-227">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-227">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-228">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-228">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="c76cd-229"><see cref="T:System.Threading.WaitHandle" /> Sygnalizują.</span><span class="sxs-lookup"><span data-stu-id="c76cd-229">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="c76cd-230"><see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-230">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="c76cd-231">A <see cref="T:System.TimeSpan" /> reprezentujący interwał oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-231">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="c76cd-232">Jeśli wartość wynosi -1, czas oczekiwania to nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="c76cd-232">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="c76cd-233"><see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-233"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="c76cd-234">Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym Określanie limitu czasu jako <see cref="T:System.TimeSpan" /> i określanie, czy należy zakończyć domeny synchronizacji w kontekście przed wejściem czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-234">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-235"><see langword="true" /> Jeśli zarówno sygnał, jak i czas oczekiwania ukończone pomyślnie, lub <see langword="false" /> jeśli sygnał ukończone, ale czas oczekiwania upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-235"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-236">Ta operacja nie jest gwarantowana niepodzielnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-236">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="c76cd-237">Po bieżącym wątku sygnały `toSignal` , ale przed oczekuje `toWaitOn`, wątku, który działa na innego procesora może sygnalizować `toWaitOn` lub zaczekaj na nim.</span><span class="sxs-lookup"><span data-stu-id="c76cd-237">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="c76cd-238">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-238">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c76cd-239">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-239">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-240">Sprawdza on stan `toWaitOn` i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-240">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="c76cd-241">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="c76cd-241">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="c76cd-242">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-242">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="c76cd-243">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-243">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="c76cd-244">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-244">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="c76cd-245">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-245">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="c76cd-246">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.SignalAndWait%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-246">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="c76cd-247">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-247">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="c76cd-248">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-248">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="c76cd-249">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="c76cd-249">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="c76cd-250">Gdy <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-250">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c76cd-251"><paramref name="toSignal" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-251"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-252">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-252">-or-</span></span>  
  
 <span data-ttu-id="c76cd-253"><paramref name="toWaitOn" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-253"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-254">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-254">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="c76cd-255">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-255">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="c76cd-256"><paramref name="toSignal" /> jest semafora i jest już pełna count.</span><span class="sxs-lookup"><span data-stu-id="c76cd-256"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-257"><paramref name="timeout" /> daje w wyniku ujemną liczbę milisekund niż -1.</span><span class="sxs-lookup"><span data-stu-id="c76cd-257"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
 <span data-ttu-id="c76cd-258">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-258">-or-</span></span>  
  
 <span data-ttu-id="c76cd-259"><paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-259"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-260">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-260">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-261">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-261">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c76cd-262">Czeka na wszystkie elementy w określonej tablicy na odebrał sygnału.</span><span class="sxs-lookup"><span data-stu-id="c76cd-262">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="c76cd-263">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-263">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="c76cd-264">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-264">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="c76cd-265">Czeka na wszystkie elementy w określonej tablicy na odebrał sygnału.</span><span class="sxs-lookup"><span data-stu-id="c76cd-265">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-266"><see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie metoda zwraca nigdy nie.</span><span class="sxs-lookup"><span data-stu-id="c76cd-266"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-267"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-267"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="c76cd-268">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-268">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="c76cd-269">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-269">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="c76cd-270">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="c76cd-270">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="c76cd-271">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-271">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="c76cd-272"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy wszystkie dojścia są sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="c76cd-272">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="c76cd-273">W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c76cd-273">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="c76cd-274">Jeśli tablica zawiera duplikaty, połączenie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-274">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c76cd-275"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-275">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="c76cd-276">Wywołanie metody przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenie metody i określając -1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-276">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-277">Poniższy przykład kodu pokazuje, jak za pomocą puli wątków asynchronicznie utworzyć i zapisać do grupy plików.</span><span class="sxs-lookup"><span data-stu-id="c76cd-277">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="c76cd-278">Po zakończeniu każdej operacji zapisu jest w kolejce elementu roboczego i sygnałów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-278">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="c76cd-279">Główny wątek oczekuje dla wszystkich elementów, które sygnalizują i kończy pracę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-279">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c76cd-280"><paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-280">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="c76cd-281">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-281">-or-</span></span>  
  
 <span data-ttu-id="c76cd-282">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-282">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-283">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-283">-or-</span></span>  
  
 <span data-ttu-id="c76cd-284"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-284"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="c76cd-285">W [.NET dla Sklepu Windows apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośnej biblioteki klas](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch wyjątku klasy podstawowej <see cref="T:System.ArgumentException" />, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-285">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="c76cd-286"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span><span class="sxs-lookup"><span data-stu-id="c76cd-286">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-287">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span><span class="sxs-lookup"><span data-stu-id="c76cd-287">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="c76cd-288">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-288">-or-</span></span>  
  
 <span data-ttu-id="c76cd-289"><see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="c76cd-289">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="c76cd-290"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span><span class="sxs-lookup"><span data-stu-id="c76cd-290"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-291">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-291">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-292">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-292">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-293"><paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-293">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="c76cd-294">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-294">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="c76cd-295">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu (duplikatów).</span><span class="sxs-lookup"><span data-stu-id="c76cd-295">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="c76cd-296">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="c76cd-296">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c76cd-297">Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.Int32" /> wartość, aby określić interwał czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-297">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-298"><see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-298"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-299">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-299">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-300">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-300">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-301"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania zakończenie, co oznacza, że gdy są sygnalizowane wszystkie dojścia lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-301">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="c76cd-302">W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c76cd-302">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="c76cd-303">Jeśli istnieją duplikaty w tablicy, połączenie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-303">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c76cd-304"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-304">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="c76cd-305">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-305">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c76cd-306"><paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-306">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-307">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-307">-or-</span></span>  
  
 <span data-ttu-id="c76cd-308">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-308">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-309">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-309">-or-</span></span>  
  
 <span data-ttu-id="c76cd-310"><paramref name="waitHandles" /> jest tablicą o żadnych elementów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-310"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="c76cd-311">W [.NET dla Sklepu Windows apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośnej biblioteki klas](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch wyjątku klasy podstawowej <see cref="T:System.ArgumentException" />, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-311">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="c76cd-312"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span><span class="sxs-lookup"><span data-stu-id="c76cd-312">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-313">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span><span class="sxs-lookup"><span data-stu-id="c76cd-313">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="c76cd-314">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-314">-or-</span></span>  
  
 <span data-ttu-id="c76cd-315"><see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="c76cd-315">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-316"><paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-316"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-317">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-317">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-318">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-318">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-319"><paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-319">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="c76cd-320">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-320">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="c76cd-321">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-321">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="c76cd-322">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund, będzie czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="c76cd-322">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c76cd-323">Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> wartość, aby określić interwał czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-323">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-324"><see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-324"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-325">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-325">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-326">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-326">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-327"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca kończy czas oczekiwania, co oznacza, że są sygnalizowane albo wszystkie dojścia lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-327">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="c76cd-328">W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c76cd-328">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="c76cd-329">Jeśli tablica zawiera duplikaty, połączenie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="c76cd-329">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c76cd-330"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-330">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="c76cd-331">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-331">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c76cd-332">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-332">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c76cd-333"><paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-333">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-334">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-334">-or-</span></span>  
  
 <span data-ttu-id="c76cd-335">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-335">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-336">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-336">-or-</span></span>  
  
 <span data-ttu-id="c76cd-337"><paramref name="waitHandles" /> jest tablicą o żadnych elementów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-337"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="c76cd-338">W [.NET dla Sklepu Windows apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośnej biblioteki klas](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch wyjątku klasy podstawowej <see cref="T:System.ArgumentException" />, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="c76cd-338">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="c76cd-339"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span><span class="sxs-lookup"><span data-stu-id="c76cd-339">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-340">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span><span class="sxs-lookup"><span data-stu-id="c76cd-340">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="c76cd-341">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-341">-or-</span></span>  
  
 <span data-ttu-id="c76cd-342"><see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="c76cd-342">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-343"><paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-343"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="c76cd-344">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-344">-or-</span></span>  
  
 <span data-ttu-id="c76cd-345"><paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-345"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-346">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-346">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-347">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-347">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-348"><paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-348">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="c76cd-349">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-349">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="c76cd-350">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu (duplikatów).</span><span class="sxs-lookup"><span data-stu-id="c76cd-350">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="c76cd-351">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="c76cd-351">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="c76cd-352"><see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-352"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="c76cd-353">Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.Int32" /> wartość, aby określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-353">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-354"><see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-354"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-355">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-355">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-356">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-356">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-357"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-357"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="c76cd-358">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-358">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="c76cd-359">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-359">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="c76cd-360">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="c76cd-360">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="c76cd-361">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-361">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="c76cd-362"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania zakończenie, co oznacza, że gdy są sygnalizowane wszystkie dojścia lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-362">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="c76cd-363">W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c76cd-363">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="c76cd-364">Jeśli istnieją duplikaty w tablicy, połączenie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-364">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c76cd-365"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-365">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="c76cd-366">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="c76cd-366">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="c76cd-367">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAll%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-367">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="c76cd-368">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-368">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="c76cd-369">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie jest pochodną <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-369">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="c76cd-370">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-370">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="c76cd-371">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAll%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-371">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="c76cd-372">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-372">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="c76cd-373">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-373">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="c76cd-374">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="c76cd-374">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="c76cd-375">Gdy <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-375">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-376">Poniższy przykład kodu pokazuje, jak za pomocą puli wątków asynchronicznie utworzyć i zapisać do grupy plików.</span><span class="sxs-lookup"><span data-stu-id="c76cd-376">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="c76cd-377">Po zakończeniu każdej operacji zapisu jest w kolejce elementu roboczego i sygnałów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-377">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="c76cd-378">Główny wątek oczekuje dla wszystkich elementów, które sygnalizują i kończy pracę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-378">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c76cd-379"><paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-379">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-380">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-380">-or-</span></span>  
  
 <span data-ttu-id="c76cd-381">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-381">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-382">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-382">-or-</span></span>  
  
 <span data-ttu-id="c76cd-383"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-383"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="c76cd-384"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span><span class="sxs-lookup"><span data-stu-id="c76cd-384">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-385">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span><span class="sxs-lookup"><span data-stu-id="c76cd-385">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="c76cd-386">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-386">-or-</span></span>  
  
 <span data-ttu-id="c76cd-387"><see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="c76cd-387">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="c76cd-388"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span><span class="sxs-lookup"><span data-stu-id="c76cd-388"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-389"><paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-389"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-390">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-390">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-391">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-391">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-392"><paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-392">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="c76cd-393">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-393">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="c76cd-394">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-394">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="c76cd-395">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund, będzie czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="c76cd-395">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="c76cd-396"><see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-396"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="c76cd-397">Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> wartość, aby określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-397">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-398"><see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-398"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-399">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-399">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-400">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-400">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-401"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-401"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="c76cd-402">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-402">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="c76cd-403">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-403">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="c76cd-404">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="c76cd-404">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="c76cd-405">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-405">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="c76cd-406"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca kończy czas oczekiwania, co oznacza, że są sygnalizowane albo wszystkie dojścia lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-406">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="c76cd-407">W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c76cd-407">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="c76cd-408">Jeśli tablica zawiera duplikaty, połączenie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="c76cd-408">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c76cd-409"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-409">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="c76cd-410">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-410">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="c76cd-411">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="c76cd-411">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="c76cd-412">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAll%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-412">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="c76cd-413">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-413">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="c76cd-414">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie jest pochodną <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-414">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="c76cd-415">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-415">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="c76cd-416">Zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAll%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-416">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="c76cd-417">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-417">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="c76cd-418">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-418">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="c76cd-419">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="c76cd-419">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="c76cd-420">Gdy <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-420">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-421">Poniższy przykład kodu pokazuje, jak za pomocą puli wątków asynchronicznie utworzyć i zapisać do grupy plików.</span><span class="sxs-lookup"><span data-stu-id="c76cd-421">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="c76cd-422">Po zakończeniu każdej operacji zapisu jest w kolejce elementu roboczego i sygnałów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-422">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="c76cd-423">Główny wątek oczekuje dla wszystkich elementów, które sygnalizują i kończy pracę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-423">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c76cd-424"><paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-424">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-425">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-425">-or-</span></span>  
  
 <span data-ttu-id="c76cd-426">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-426">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-427">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-427">-or-</span></span>  
  
 <span data-ttu-id="c76cd-428"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-428"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="c76cd-429"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span><span class="sxs-lookup"><span data-stu-id="c76cd-429">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-430">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span><span class="sxs-lookup"><span data-stu-id="c76cd-430">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="c76cd-431">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-431">-or-</span></span>  
  
 <span data-ttu-id="c76cd-432"><see cref="T:System.STAThreadAttribute" /> Atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="c76cd-432">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="c76cd-433"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span><span class="sxs-lookup"><span data-stu-id="c76cd-433"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-434"><paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-434"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="c76cd-435">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-435">-or-</span></span>  
  
 <span data-ttu-id="c76cd-436"><paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-436"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-437">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-437">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-438">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-438">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-439"><paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-439">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c76cd-440">Czeka na jeden z elementów w określonej tablicy na odebrał sygnału.</span><span class="sxs-lookup"><span data-stu-id="c76cd-440">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="c76cd-441">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-441">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="c76cd-442">Czeka na jeden z elementów w określonej tablicy na odebrał sygnału.</span><span class="sxs-lookup"><span data-stu-id="c76cd-442">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="c76cd-443">Indeks tablicy obiektu spełniającego oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-443">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-444"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-444"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="c76cd-445">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` wykona czas oczekiwania, ponieważ obiektu mutex zostanie zaniechana.</span><span class="sxs-lookup"><span data-stu-id="c76cd-445">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="c76cd-446">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-446">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="c76cd-447">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="c76cd-447">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="c76cd-448">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-448">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="c76cd-449"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-449">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="c76cd-450">Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="c76cd-450">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c76cd-451">W wersjach wcześniejszych niż wersja 2.0, jeśli wątek kończy działanie lub przerwanie bez jawnego zwolnienia programu .NET Framework <xref:System.Threading.Mutex>oraz że `Mutex` znajduje się pod indeksem 0 (zero) w `WaitAny` tablicy w innym wątku, indeks zwrócony przez `WaitAny` jest 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-451">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="c76cd-452">Ta metoda zwraca, jeśli zostanie zasygnalizowane dowolny uchwyt.</span><span class="sxs-lookup"><span data-stu-id="c76cd-452">This method returns when any handle is signaled.</span></span> <span data-ttu-id="c76cd-453">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-453">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="c76cd-454">W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c76cd-454">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="c76cd-455">Wywołanie metody przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenie metody i określając -1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-455">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-456">Poniższy przykład kodu pokazuje wywołanie <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-456">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c76cd-457"><paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-457">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-458">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-458">-or-</span></span>  
  
 <span data-ttu-id="c76cd-459">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-459">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-460">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span><span class="sxs-lookup"><span data-stu-id="c76cd-460">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="c76cd-461"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span><span class="sxs-lookup"><span data-stu-id="c76cd-461"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-462">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-462">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-463">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-463">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="c76cd-464"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-464"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-465"><paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-465">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="c76cd-466">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-466">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="c76cd-467">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="c76cd-467">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c76cd-468">Czeka na jeden z elementów w określonej tablicy na sygnał, za pomocą całkowita 32-bitowy, aby określić interwał czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-468">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="c76cd-469">Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="millisecondsTimeout" /> minął.</span><span class="sxs-lookup"><span data-stu-id="c76cd-469">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-470">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-470">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-471">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-471">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-472"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-472">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="c76cd-473">Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="c76cd-473">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="c76cd-474">Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub zostanie przekroczony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-474">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="c76cd-475">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-475">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="c76cd-476">W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c76cd-476">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="c76cd-477">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-477">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c76cd-478"><paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-478">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-479">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-479">-or-</span></span>  
  
 <span data-ttu-id="c76cd-480">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-480">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-481">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span><span class="sxs-lookup"><span data-stu-id="c76cd-481">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-482"><paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-482"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-483">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-483">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-484">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-484">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="c76cd-485"><paramref name="waitHandles" /> jest tablicą o żadnych elementów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-485"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-486"><paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-486">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="c76cd-487">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-487">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="c76cd-488">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="c76cd-488">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c76cd-489">Czeka na jeden z elementów w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> Aby określić interwał czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-489">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="c76cd-490">Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="timeout" /> minął.</span><span class="sxs-lookup"><span data-stu-id="c76cd-490">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-491">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-491">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-492">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-492">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-493"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-493">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="c76cd-494">Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="c76cd-494">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="c76cd-495">Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-495">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="c76cd-496">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-496">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="c76cd-497">W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c76cd-497">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="c76cd-498">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-498">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c76cd-499">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-499">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c76cd-500"><paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-500">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-501">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-501">-or-</span></span>  
  
 <span data-ttu-id="c76cd-502">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-502">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-503">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span><span class="sxs-lookup"><span data-stu-id="c76cd-503">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-504"><paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-504"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="c76cd-505">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-505">-or-</span></span>  
  
 <span data-ttu-id="c76cd-506"><paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-506"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-507">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-507">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-508">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-508">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="c76cd-509"><paramref name="waitHandles" /> jest tablicą o żadnych elementów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-509"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-510"><paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-510">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="c76cd-511">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-511">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="c76cd-512">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="c76cd-512">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="c76cd-513"><see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-513"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="c76cd-514">Czeka na jeden z elementów w określonej tablicy na sygnał, za pomocą całkowita 32-bitowy, aby określić przedział czasu i określająca, czy zakończyć działanie synchronizacji domeny przed czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-514">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="c76cd-515">Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="millisecondsTimeout" /> minął.</span><span class="sxs-lookup"><span data-stu-id="c76cd-515">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-516">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-516">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-517">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-517">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-518"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-518"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="c76cd-519">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` wykona czas oczekiwania, ponieważ obiektu mutex zostanie zaniechana.</span><span class="sxs-lookup"><span data-stu-id="c76cd-519">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="c76cd-520">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-520">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="c76cd-521">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="c76cd-521">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="c76cd-522">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-522">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="c76cd-523"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-523">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="c76cd-524">Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="c76cd-524">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c76cd-525">W wersjach wcześniejszych niż wersja 2.0, jeśli wątek kończy działanie lub przerwanie bez jawnego zwolnienia programu .NET Framework <xref:System.Threading.Mutex>oraz że `Mutex` znajduje się pod indeksem 0 (zero) w `WaitAny` tablicy w innym wątku, indeks zwrócony przez `WaitAny` jest 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-525">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="c76cd-526">Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub zostanie przekroczony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-526">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="c76cd-527">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-527">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="c76cd-528">W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c76cd-528">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="c76cd-529">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="c76cd-529">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="c76cd-530">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAny%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-530">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="c76cd-531">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-531">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="c76cd-532">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-532">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="c76cd-533">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-533">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="c76cd-534">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAny%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-534">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="c76cd-535">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-535">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="c76cd-536">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-536">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="c76cd-537">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="c76cd-537">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="c76cd-538">Gdy <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-538">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-539">Poniższy przykład kodu pokazuje, jak używać puli wątków jednocześnie wyszukiwania plików na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="c76cd-539">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="c76cd-540">Zagadnienia miejsca przeszukiwane będą tylko w katalogu głównym każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="c76cd-540">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c76cd-541"><paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-541">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-542">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-542">-or-</span></span>  
  
 <span data-ttu-id="c76cd-543">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-543">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-544">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span><span class="sxs-lookup"><span data-stu-id="c76cd-544">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="c76cd-545"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span><span class="sxs-lookup"><span data-stu-id="c76cd-545"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-546"><paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-546"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-547">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-547">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-548">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-548">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="c76cd-549"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-549"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-550"><paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-550">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="c76cd-551">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c76cd-551">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="c76cd-552">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="c76cd-552">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="c76cd-553"><see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-553"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="c76cd-554">Czeka na jeden z elementów w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-554">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="c76cd-555">Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="timeout" /> minął.</span><span class="sxs-lookup"><span data-stu-id="c76cd-555">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-556">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-556">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-557">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-557">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-558"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-558"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="c76cd-559">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` wykona czas oczekiwania, ponieważ obiektu mutex zostanie zaniechana.</span><span class="sxs-lookup"><span data-stu-id="c76cd-559">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="c76cd-560">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-560">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="c76cd-561">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="c76cd-561">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="c76cd-562">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-562">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="c76cd-563"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-563">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="c76cd-564">Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="c76cd-564">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c76cd-565">W wersjach wcześniejszych niż wersja 2.0, jeśli wątek kończy działanie lub przerwanie bez jawnego zwolnienia programu .NET Framework <xref:System.Threading.Mutex>oraz że `Mutex` znajduje się pod indeksem 0 (zero) w `WaitAny` tablicy w innym wątku, indeks zwrócony przez `WaitAny` jest 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-565">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="c76cd-566">Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-566">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="c76cd-567">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="c76cd-567">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="c76cd-568">W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c76cd-568">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="c76cd-569">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-569">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="c76cd-570">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="c76cd-570">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="c76cd-571">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAny%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-571">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="c76cd-572">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-572">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="c76cd-573">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-573">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="c76cd-574">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-574">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="c76cd-575">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAny%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-575">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="c76cd-576">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-576">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="c76cd-577">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-577">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="c76cd-578">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="c76cd-578">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="c76cd-579">Gdy <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-579">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-580">Poniższy przykład kodu pokazuje, jak używać puli wątków jednocześnie wyszukiwania plików na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="c76cd-580">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="c76cd-581">Zagadnienia miejsca przeszukiwane będą tylko w katalogu głównym każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="c76cd-581">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c76cd-582"><paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-582">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="c76cd-583">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-583">-or-</span></span>  
  
 <span data-ttu-id="c76cd-584">Co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-584">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c76cd-585">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span><span class="sxs-lookup"><span data-stu-id="c76cd-585">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="c76cd-586"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span><span class="sxs-lookup"><span data-stu-id="c76cd-586"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-587"><paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-587"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="c76cd-588">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-588">-or-</span></span>  
  
 <span data-ttu-id="c76cd-589"><paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-589"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-590">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-590">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-591">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-591">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="c76cd-592"><paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-592"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-593"><paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-593">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c76cd-594">Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał.</span><span class="sxs-lookup"><span data-stu-id="c76cd-594">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c76cd-595">Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał.</span><span class="sxs-lookup"><span data-stu-id="c76cd-595">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-596"><see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału.</span><span class="sxs-lookup"><span data-stu-id="c76cd-596"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="c76cd-597">Jeśli bieżące wystąpienie nigdy nie zostanie zasygnalizowane, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nigdy nie zwraca.</span><span class="sxs-lookup"><span data-stu-id="c76cd-597">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-598"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-598"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="c76cd-599">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-599">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="c76cd-600">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-600">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="c76cd-601">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="c76cd-601">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="c76cd-602">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-602">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="c76cd-603">Element wywołujący tego bloków metody do czasu bieżącego wystąpienia odbiera sygnał.</span><span class="sxs-lookup"><span data-stu-id="c76cd-603">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="c76cd-604">Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-604">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="c76cd-605">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-605">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="c76cd-606">Wywołanie metody przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenie metody i określając -1 lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> jako pierwszy parametr i `false` dla drugiego parametru.</span><span class="sxs-lookup"><span data-stu-id="c76cd-606">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="c76cd-607">Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-607">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-608">Poniższy przykład kodu pokazuje, jak zapobiec proces przerywanie podczas oczekiwania na zakończenie wykonywania wątku w tle przy użyciu dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-608">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c76cd-609">Bieżące wystąpienie został już usunięty.</span><span class="sxs-lookup"><span data-stu-id="c76cd-609">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-610">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-610">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-611">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-611">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-612">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-612">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="c76cd-613">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="c76cd-613">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c76cd-614">Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał, aby określić interwał czasu w milisekundach przy użyciu całkowita 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-614">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-615"><see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-615"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-616">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-616">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-617">Sprawdza stan dojście oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-617">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-618">Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c76cd-618">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="c76cd-619">Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-619">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="c76cd-620">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-620">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="c76cd-621">Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-621">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="c76cd-622">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-622">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-623">Poniższy przykład kodu pokazuje, jak zapobiec proces przerywanie podczas oczekiwania na zakończenie wykonywania wątku w tle przy użyciu dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-623">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c76cd-624">Bieżące wystąpienie został już usunięty.</span><span class="sxs-lookup"><span data-stu-id="c76cd-624">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-625"><paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-625"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-626">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-627">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-628">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="c76cd-629">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="c76cd-629">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c76cd-630">Blokuje bieżący wątek, do momentu otrzymania przez bieżące wystąpienie sygnał, przy użyciu <see cref="T:System.TimeSpan" /> Aby określić interwał czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-630">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-631"><see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-632">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-632">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-633">Sprawdza stan dojście oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-634">Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c76cd-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="c76cd-635">Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="c76cd-636">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="c76cd-637">Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="c76cd-638">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-638">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c76cd-639">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-639">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c76cd-640">Bieżące wystąpienie został już usunięty.</span><span class="sxs-lookup"><span data-stu-id="c76cd-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-641"><paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-641"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="c76cd-642">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-642">-or-</span></span>  
  
 <span data-ttu-id="c76cd-643"><paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-643"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-644">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-644">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-645">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-645">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-646">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-646">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="c76cd-647">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="c76cd-647">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="c76cd-648"><see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-648"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="c76cd-649">Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał, za pomocą całkowita 32-bitowy, aby określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-649">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-650"><see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-650"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-651">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-651">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-652">Sprawdza stan dojście oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-652">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-653"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-653"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="c76cd-654">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-654">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="c76cd-655">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-655">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="c76cd-656">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="c76cd-656">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="c76cd-657">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-657">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="c76cd-658">Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c76cd-658">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="c76cd-659">Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-659">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="c76cd-660">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-660">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="c76cd-661">Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-661">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="c76cd-662">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="c76cd-662">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="c76cd-663">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitOne%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-663">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="c76cd-664">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-664">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="c76cd-665">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-665">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="c76cd-666">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-666">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="c76cd-667">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-667">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="c76cd-668">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-668">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="c76cd-669">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-669">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="c76cd-670">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="c76cd-670">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="c76cd-671">Gdy <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-671">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-672">W poniższym przykładzie przedstawiono sposób <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenie metody ma zachowywać się, gdy jest wywoływana w domenie synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-672">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="c76cd-673">Po pierwsze, wątek oczekuje z `exitContext` ustawioną `false` i blokuje do chwili osiągnięcia limitu czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-673">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="c76cd-674">Drugi wątek wykonuje po pierwszym wątkiem kończy i czeka z `exitContext` ustawioną `true`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-674">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="c76cd-675">Wywołanie sygnału dojście oczekiwania dla tego drugiego wątku nie jest blokowane i zakończeniu przed upływem limitu czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-675">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c76cd-676">Bieżące wystąpienie został już usunięty.</span><span class="sxs-lookup"><span data-stu-id="c76cd-676">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-677"><paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-677"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-678">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-678">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-679">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-679">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-680">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-680">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="c76cd-681">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="c76cd-681">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="c76cd-682"><see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-682"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="c76cd-683">Blokuje bieżący wątek, do momentu otrzymania przez bieżące wystąpienie sygnał, przy użyciu <see cref="T:System.TimeSpan" /> określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-683">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="c76cd-684"><see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-684"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-685">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="c76cd-685">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="c76cd-686">Sprawdza stan dojście oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="c76cd-686">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="c76cd-687"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="c76cd-687"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="c76cd-688">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-688">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="c76cd-689">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-689">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="c76cd-690">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="c76cd-690">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="c76cd-691">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-691">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="c76cd-692">Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c76cd-692">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="c76cd-693">Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c76cd-693">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="c76cd-694">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-694">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="c76cd-695">Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="c76cd-695">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="c76cd-696">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-696">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="c76cd-697">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="c76cd-697">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="c76cd-698">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitOne%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-698">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="c76cd-699">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-699">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="c76cd-700">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-700">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="c76cd-701">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-701">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="c76cd-702">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="c76cd-702">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="c76cd-703">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c76cd-703">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="c76cd-704">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="c76cd-704">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="c76cd-705">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="c76cd-705">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="c76cd-706">Gdy <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-706">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-707">Poniższy przykład kodu pokazuje, jak zapobiec proces przerywanie podczas oczekiwania na zakończenie wykonywania wątku w tle przy użyciu dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="c76cd-707">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c76cd-708">Bieżące wystąpienie został już usunięty.</span><span class="sxs-lookup"><span data-stu-id="c76cd-708">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="c76cd-709"><paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="c76cd-709"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="c76cd-710">—lub—</span><span class="sxs-lookup"><span data-stu-id="c76cd-710">-or-</span></span>  
  
 <span data-ttu-id="c76cd-711"><paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c76cd-711"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="c76cd-712">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="c76cd-712">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="c76cd-713">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c76cd-713">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c76cd-714">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c76cd-714">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="c76cd-715">Oznacza to, że <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> upłynął limit czasu operacji przed żadnego uchwyty oczekiwania były sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="c76cd-715">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="c76cd-716">To pole jest stałe.</span><span class="sxs-lookup"><span data-stu-id="c76cd-716">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c76cd-717">To pole jest jedną z możliwych wartości zwracanych metody `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="c76cd-717">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c76cd-718">Poniższy przykład kodu pokazuje, jak używać puli wątków jednocześnie wyszukiwania plików na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="c76cd-718">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="c76cd-719">Zagadnienia miejsca przeszukiwane będą tylko w katalogu głównym każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="c76cd-719">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
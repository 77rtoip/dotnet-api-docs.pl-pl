<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0b6e3dd3b2837ebe70209ea950a3414c4d7dd591" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407233" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="f988b-101">Hermetyzuje obiekty specyficzne dla systemu operacyjnego, które poczekaj, aż wyłącznego dostępu do zasobów udostępnionych.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f988b-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-102"><xref:System.Threading.WaitHandle> Klasa hermetyzuje dojścia synchronizacji Win32 i jest używana do reprezentowania wszystkich obiektów synchronizacji w czasie wykonywania, które umożliwiają wielu operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="f988b-102">The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="f988b-103">Porównanie uchwyty oczekiwania z innymi obiektami synchronizacji, zobacz [podstawowych Omówienie synchronizacji](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="f988b-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="f988b-104"><xref:System.Threading.WaitHandle> Sama klasa jest abstrakcyjna.</span><span class="sxs-lookup"><span data-stu-id="f988b-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="f988b-105">Klasy wyprowadzone z <xref:System.Threading.WaitHandle> zdefiniować mechanizm sygnalizowania biorąc lub zwalniania dostęp do udostępnionych zasobów, ale korzystają z dziedziczonego <xref:System.Threading.WaitHandle> metod, które mają być blokowane podczas oczekiwania na dostęp do zasobów udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="f988b-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="f988b-106">Klasy pochodne <xref:System.Threading.WaitHandle> obejmują:</span><span class="sxs-lookup"><span data-stu-id="f988b-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="f988b-107"><xref:System.Threading.Mutex> Klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="f988b-108">Zobacz [muteksy](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="f988b-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="f988b-109"><xref:System.Threading.EventWaitHandle> Klasy i jej klas pochodnych <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="f988b-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="f988b-110">Zobacz [EventWaitHandle, autoresetevent —, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="f988b-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="f988b-111"><xref:System.Threading.Semaphore> Klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="f988b-112">Zobacz [semafor i klasa SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="f988b-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="f988b-113">Zablokować wątków w dojściu do poszczególnych oczekiwania przez wywołanie metody wystąpienia <xref:System.Threading.WaitHandle.WaitOne%2A>, który jest dziedziczone przez klasy pochodzące od <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="f988b-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="f988b-114">Klasy pochodne <xref:System.Threading.WaitHandle> różnią się w ich koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="f988b-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="f988b-115">Uchwyty oczekiwania zdarzenia (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, i <xref:System.Threading.ManualResetEvent>) i semaforów nie mają koligacji wątku; którymkolwiek wątku można zasygnalizować dojście oczekiwania zdarzenia lub semafora.</span><span class="sxs-lookup"><span data-stu-id="f988b-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="f988b-116">Z drugiej strony, muteksy, mają koligacji wątku; Wątek, który jest właścicielem obiektu mutex musi zwolnić go i jest zwracany wyjątek, jeśli wątek wywołuje <xref:System.Threading.Mutex.ReleaseMutex%2A> metody dla obiektu mutex, który nie jest właścicielem.</span><span class="sxs-lookup"><span data-stu-id="f988b-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="f988b-117">Ponieważ <xref:System.Threading.WaitHandle> pochodną klasy <xref:System.MarshalByRefObject>, te klasy mogą być używane do synchronizowania działania wątków poza granice domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="f988b-118">Oprócz jej klas pochodnych <xref:System.Threading.WaitHandle> klasa ma kilka metod statycznych, które blokują wątku, dopóki jedna lub więcej obiektów synchronizacji odebrał sygnału.</span><span class="sxs-lookup"><span data-stu-id="f988b-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</span></span> <span data-ttu-id="f988b-119">Należą do nich następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="f988b-119">These include:</span></span>  
  
-   <span data-ttu-id="f988b-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, dzięki czemu wątek sygnału jeden dojście oczekiwania i natychmiast czekać na innym.</span><span class="sxs-lookup"><span data-stu-id="f988b-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="f988b-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, dzięki czemu wątek poczekać, aż wszystkie dojścia oczekiwania w tablicy odebrał sygnału.</span><span class="sxs-lookup"><span data-stu-id="f988b-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="f988b-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, dzięki czemu wątek poczekać, aż któregokolwiek z określonego zestawu uchwyty oczekiwania został sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="f988b-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="f988b-123">Przeciążenia metody te zapewniają interwałów limitu czasu dla porzucanie czas oczekiwania oraz możliwość zakończyć kontekstu synchronizacji przed wprowadzeniem czas oczekiwania, dzięki czemu inne wątki używać kontekstu synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f988b-124">Ten typ implementuje <xref:System.IDisposable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f988b-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="f988b-125">Po zakończeniu przy użyciu tego typu lub typu pochodnego w bezpośrednio lub pośrednio należy usunąć z niego.</span><span class="sxs-lookup"><span data-stu-id="f988b-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="f988b-126">Do usuwania tego typu, należy wywołać jej <xref:System.Threading.WaitHandle.Close%2A> metody w `try` / `catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="f988b-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="f988b-127">Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="f988b-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="f988b-128">Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.</span><span class="sxs-lookup"><span data-stu-id="f988b-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="f988b-129"><xref:System.Threading.WaitHandle> implementuje <xref:System.IDisposable.Dispose%2A> wzorca.</span><span class="sxs-lookup"><span data-stu-id="f988b-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="f988b-130">Zobacz [wzorzec Dispose](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="f988b-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="f988b-131">Jeśli pochodzi od <xref:System.Threading.WaitHandle>, użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości do przechowywania uchwyt macierzysty uchwyt systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="f988b-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="f988b-132">Nie trzeba zastąpić chronionej <xref:System.Threading.WaitHandle.Dispose%2A> metody chyba że są używane dodatkowe zasoby niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="f988b-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-133">Poniższy kod przedstawia przykład jak dwa wątki można wykonać zadania w tle podczas głównym wątku czeka na zakończenie przy użyciu statycznych zadań <xref:System.Threading.WaitHandle.WaitAny%2A> i <xref:System.Threading.WaitHandle.WaitAll%2A> metody <xref:System.Threading.WaitHandle> klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="f988b-134">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f988b-134">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f988b-135">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f988b-136">Zwalnia wszystkie zasoby zajmowane przez bieżące <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-137">Ta metoda jest implementacją publicznego <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodę <xref:System.Threading.WaitHandle> klasy i jej klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="f988b-137">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="f988b-138">Zapewnia standardowej implementacji, która wywołuje `Dispose(Boolean)` przeciążenia z `true` argument, a następnie wywołania <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-138">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f988b-139">Wywołanie tej metody, aby zwolnić wszystkie zasoby zajmowane przez wystąpienia `WaitHandle` lub klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="f988b-139">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="f988b-140">Gdy ta metoda jest wywoływana, odwołania do bieżącego wystąpienia spowodować niezdefiniowane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="f988b-140">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f988b-141">Wywoływanie zawsze <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed zwolnieniem ostatniego odwołania do <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="f988b-141">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f988b-142">W przeciwnym razie zasoby, które używa nie zostanie zwolniona.</span><span class="sxs-lookup"><span data-stu-id="f988b-142">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="f988b-143">
            <para>Należy zastąpić <see langword="Dispose(Boolean)" /> metodę, aby zwolnić zasoby przydzielone w klasach pochodnych.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-143">
              <para>You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f988b-144">Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> — klasa</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f988b-145">Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-146">Ta metoda jest odpowiednikiem <xref:System.Threading.WaitHandle.Close%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-146">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f988b-147">Wywoływanie zawsze <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed zwolnieniem ostatniego odwołania do <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="f988b-147">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f988b-148">W przeciwnym razie zasoby, które używa nie zostanie zwolniona.</span><span class="sxs-lookup"><span data-stu-id="f988b-148">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="f988b-149">
            <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-149">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-150">W przypadku przesłonięcia w klasie pochodnej, zwalnia zasoby niezarządzane używane przez <see cref="T:System.Threading.WaitHandle" />i opcjonalnie zwalnia zasoby zarządzane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-151">Ta metoda jest wywoływana przez <xref:System.Threading.WaitHandle.Close%2A> i <xref:System.Threading.WaitHandle.Dispose> metod `explicitDisposing` ustawiono parametr `true`.</span><span class="sxs-lookup"><span data-stu-id="f988b-151">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="f988b-152">Gdy `explicitDisposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Threading.WaitHandle> obiektu odwołania.</span><span class="sxs-lookup"><span data-stu-id="f988b-152">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="f988b-153">
            <para>Należy zastąpić <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> metodę, aby zwolnić zasoby przydzielone w klasach pochodnych.  <see cref="M:System.Threading.WaitHandle.Close" /> Lub <see cref="M:System.Threading.WaitHandle.Dispose" /> metodę można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania tej metody, należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" /> lub <see langword="Close" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-153">
              <para>You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.  The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects. When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f988b-154">Pobiera lub ustawia uchwyt macierzysty system operacyjny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-154">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f988b-155">
            <see langword="IntPtr" /> Reprezentujący uchwyt macierzysty system operacyjny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-155">An <see langword="IntPtr" /> representing the native operating system handle.</span>
          </span>
          <span data-ttu-id="f988b-156">Wartość domyślna to wartość <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-156">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-157">Przypisywanie nową wartość do <xref:System.Threading.WaitHandle.Handle%2A> właściwości nie zamyka poprzedniej dojścia.</span><span class="sxs-lookup"><span data-stu-id="f988b-157">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="f988b-158">Może to spowodować, że ujawnione dojścia.</span><span class="sxs-lookup"><span data-stu-id="f988b-158">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="f988b-159">Nie należy używać tej właściwości w programie .NET Framework w wersji 2.0 lub nowszy; Użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="f988b-159">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="f988b-160">Ustawienie tej właściwości na prawidłowy uchwyt również zestawy <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości, ale ustawieniem dla niego <xref:System.Threading.WaitHandle.InvalidHandle> może spowodować uchwyt ujawnione.</span><span class="sxs-lookup"><span data-stu-id="f988b-160">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f988b-161">Wymagane jest pełne zaufanie do bezpośredniego obiektu wywołującego można ustawić wartości właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-161">Requires full trust for the immediate caller to set the property value.</span>
          </span>
          <span data-ttu-id="f988b-162">Nie można ustawić tego elementu członkowskiego przez kod częściowo zaufany lub przezroczyste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-162">This member cannot be set by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="f988b-163">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> można ustawić wartości właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-163">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f988b-164">Reprezentuje dojścia nieprawidłowy natywnego systemu operacyjnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-164">Represents an invalid native operating system handle.</span>
          </span>
          <span data-ttu-id="f988b-165">To pole jest tylko do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-165">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-166">Używana wewnętrznie w celu zainicjowania <xref:System.Threading.WaitHandle.Handle%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="f988b-166">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="f988b-167">
            <para>Tej wartości można użyć, aby określić, czy <see cref="P:System.Threading.WaitHandle.Handle" /> właściwość zawiera dojście prawidłowego natywnego systemu operacyjnego.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-167">
              <para>You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f988b-168">Pobiera lub ustawia uchwyt macierzysty system operacyjny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-168">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f988b-169">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> reprezentujący uchwyt macierzysty system operacyjny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-169">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-170">Po przypisaniu nową wartość do <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwość poprzedniej dojście zostanie zamknięty kiedy poprzedniej <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> zbieranych obiektu.</span><span class="sxs-lookup"><span data-stu-id="f988b-170">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="f988b-171">Nie ręcznie zamknąć uchwytu, ponieważ powoduje to <xref:System.ObjectDisposedException> podczas <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> próbuje zamknąć dojścia.</span><span class="sxs-lookup"><span data-stu-id="f988b-171">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="f988b-172"><xref:System.Threading.WaitHandle> implementuje <xref:System.IDisposable.Dispose%2A> wzorca.</span><span class="sxs-lookup"><span data-stu-id="f988b-172"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="f988b-173">Zobacz [wzorzec Dispose](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="f988b-173">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="f988b-174">Jeśli pochodzi od <xref:System.Threading.WaitHandle>, użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości do przechowywania uchwyt macierzysty uchwyt systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="f988b-174">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="f988b-175">Nie trzeba zastąpić chronionej <xref:System.Threading.WaitHandle.Dispose%2A> metody chyba że są używane dodatkowe zasoby niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="f988b-175">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f988b-176">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-176">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f988b-177">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-177">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="f988b-178">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> do wywołania tego elementu członkowskiego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f988b-179">Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-179">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="f988b-180">
            <see cref="T:System.Threading.WaitHandle" /> Sygnalizują.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-180">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="f988b-181">
            <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-181">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-182">Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-182">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-183">
            <see langword="true" /> Jeśli zarówno sygnał, jak i czas oczekiwania zakończy się pomyślnie; Jeśli czas oczekiwania nie zostanie ukończone, metoda zwraca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-183">
              <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-184">Ta operacja nie jest gwarantowana niepodzielnych.</span><span class="sxs-lookup"><span data-stu-id="f988b-184">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f988b-185">Po bieżącym wątku sygnały `toSignal` , ale przed oczekuje `toWaitOn`, wątku, który działa na innego procesora może sygnalizować `toWaitOn` lub zaczekaj na nim.</span><span class="sxs-lookup"><span data-stu-id="f988b-185">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-186">Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenie metody, aby zezwolić na sygnał zablokowanych wątków, a następnie poczekaj zakończenie wątku zadania głównego wątku.</span><span class="sxs-lookup"><span data-stu-id="f988b-186">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="f988b-187">Przykład rozpoczyna pięć wątków, pozwala na blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flagi, a następnie jeden wątek wersjach czasu naciśnięciu klawisza ENTER.</span><span class="sxs-lookup"><span data-stu-id="f988b-187">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="f988b-188">W przykładzie następnie kolejki innego pięć wątków i zwalnia wszystkie przy użyciu <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="f988b-188">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-189">
            <paramref name="toSignal" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-189">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-190">- lub - <paramref name="toWaitOn" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-190">-or-  <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-191">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-191">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="f988b-192">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-192">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-193">
            <paramref name="toSignal" /> jest semafora i jest już pełna count.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-193">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-194">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-194">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-195">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-195">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="f988b-196">
            <see cref="T:System.Threading.WaitHandle" /> Sygnalizują.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-196">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="f988b-197">
            <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-197">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f988b-198">Liczba całkowita, która reprezentuje interwału oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-198">An integer that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="f988b-199">Jeśli wartość jest <see cref="F:System.Threading.Timeout.Infinite" />, -1, czas oczekiwania jest nieograniczony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-199">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f988b-200">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-200">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-201">Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym określająca interwał limitu czasu, całkowita 32-bitowe i określanie, czy zamknąć domeny synchronizacji w kontekście przed wejściem czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-201">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-202">
            <see langword="true" /> Jeśli zarówno sygnał, jak i czas oczekiwania ukończone pomyślnie, lub <see langword="false" /> jeśli sygnał ukończone, ale czas oczekiwania upłynął limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-202">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-203">Ta operacja nie jest gwarantowana niepodzielnych.</span><span class="sxs-lookup"><span data-stu-id="f988b-203">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f988b-204">Po bieżącym wątku sygnały `toSignal` , ale przed oczekuje `toWaitOn`, wątku, który działa na innego procesora może sygnalizować `toWaitOn` lub zaczekaj na nim.</span><span class="sxs-lookup"><span data-stu-id="f988b-204">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="f988b-205">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-205">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-206">Sprawdza on stan `toWaitOn` i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-206">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f988b-207">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="f988b-207">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f988b-208">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="f988b-208">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f988b-209">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f988b-209">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f988b-210">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-210">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f988b-211">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-211">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="f988b-212">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.SignalAndWait%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-212">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="f988b-213">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-213">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f988b-214">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-214">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f988b-215">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="f988b-215">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f988b-216">Gdy <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-216">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-217">
            <paramref name="toSignal" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-217">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-218">- lub - <paramref name="toWaitOn" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-218">-or-  <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-219">Metoda jest wywoływana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-219">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="f988b-220">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-220">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-221">
            <see cref="T:System.Threading.WaitHandle" /> Nie może zostać zgłoszony, ponieważ zostałaby przekroczona maksymalna wartość licznika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-221">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-222">
            <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-222">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-223">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-223">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-224">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-224">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="f988b-225">
            <see cref="T:System.Threading.WaitHandle" /> Sygnalizują.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-225">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="f988b-226">
            <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-226">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f988b-227">A <see cref="T:System.TimeSpan" /> reprezentujący interwał oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-227">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="f988b-228">Jeśli wartość wynosi -1, czas oczekiwania to nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-228">If the value is -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f988b-229">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-229">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-230">Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym Określanie limitu czasu jako <see cref="T:System.TimeSpan" /> i określanie, czy należy zakończyć domeny synchronizacji w kontekście przed wejściem czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-230">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-231">
            <see langword="true" /> Jeśli zarówno sygnał, jak i czas oczekiwania ukończone pomyślnie, lub <see langword="false" /> jeśli sygnał ukończone, ale czas oczekiwania upłynął limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-231">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-232">Ta operacja nie jest gwarantowana niepodzielnych.</span><span class="sxs-lookup"><span data-stu-id="f988b-232">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f988b-233">Po bieżącym wątku sygnały `toSignal` , ale przed oczekuje `toWaitOn`, wątku, który działa na innego procesora może sygnalizować `toWaitOn` lub zaczekaj na nim.</span><span class="sxs-lookup"><span data-stu-id="f988b-233">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="f988b-234">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f988b-234">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f988b-235">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-235">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-236">Sprawdza on stan `toWaitOn` i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-236">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f988b-237">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="f988b-237">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f988b-238">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="f988b-238">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f988b-239">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f988b-239">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f988b-240">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-240">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f988b-241">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-241">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="f988b-242">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.SignalAndWait%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-242">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="f988b-243">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-243">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f988b-244">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-244">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f988b-245">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="f988b-245">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f988b-246">Gdy <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-246">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-247">
            <paramref name="toSignal" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-247">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-248">- lub - <paramref name="toWaitOn" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-248">-or-  <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-249">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-249">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="f988b-250">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-250">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-251">
            <paramref name="toSignal" /> jest semafora i jest już pełna count.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-251">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-252">
            <paramref name="timeout" /> daje w wyniku ujemną liczbę milisekund niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-252">
              <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          </span>
          <span data-ttu-id="f988b-253">- lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-253">-or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-254">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-254">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-255">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-255">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f988b-256">Czeka na wszystkie elementy w określonej tablicy na odebrał sygnału.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-256">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f988b-257">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-257">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="f988b-258">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-258">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-259">Czeka na wszystkie elementy w określonej tablicy na odebrał sygnału.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-259">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-260">
            <see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie metoda zwraca nigdy nie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-260">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-261"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="f988b-261"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f988b-262">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-262">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f988b-263">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-263">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f988b-264">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="f988b-264">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f988b-265">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-265">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f988b-266"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy wszystkie dojścia są sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="f988b-266">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="f988b-267">W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="f988b-267">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f988b-268">Jeśli tablica zawiera duplikaty, połączenie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="f988b-268">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f988b-269"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-269">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="f988b-270">Wywołanie metody przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenie metody i określając -1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f988b-270">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-271">Poniższy przykład kodu pokazuje, jak za pomocą puli wątków asynchronicznie utworzyć i zapisać do grupy plików.</span><span class="sxs-lookup"><span data-stu-id="f988b-271">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f988b-272">Po zakończeniu każdej operacji zapisu jest w kolejce elementu roboczego i sygnałów.</span><span class="sxs-lookup"><span data-stu-id="f988b-272">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f988b-273">Główny wątek oczekuje dla wszystkich elementów, które sygnalizują i kończy pracę.</span><span class="sxs-lookup"><span data-stu-id="f988b-273">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-274">
            <paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-274">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-275">- lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-275">-or-  One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-276">- lub - <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-276">-or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="f988b-277">
            <block subset="none" type="note">
              <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.ArgumentException" />, zamiast tego.  </para>
            </block>
            <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-277">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
              </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-278">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-278">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="f988b-279">- lub - <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-279">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f988b-280">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-280">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-281">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-281">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-282">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-282">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-283">
            <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-283">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f988b-284">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-284">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="f988b-285">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu (duplikatów).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-285">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f988b-286">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-286">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-287">Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.Int32" /> wartość, aby określić interwał czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-287">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-288">
            <see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-288">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-289">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-289">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-290">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-290">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-291"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania zakończenie, co oznacza, że gdy są sygnalizowane wszystkie dojścia lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="f988b-291">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="f988b-292">W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="f988b-292">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f988b-293">Jeśli istnieją duplikaty w tablicy, połączenie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="f988b-293">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f988b-294"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-294">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="f988b-295">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f988b-295">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-296">
            <paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-296">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-297">- lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-297">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-298">- lub - <paramref name="waitHandles" /> jest tablicą o żadnych elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-298">-or-  <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="f988b-299">
            <block subset="none" type="note">
              <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.ArgumentException" />, zamiast tego.  </para>
            </block>
            <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-299">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
              </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-300">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-300">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="f988b-301">- lub - <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-301">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-302">
            <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-302">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-303">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-303">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-304">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-304">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-305">
            <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-305">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f988b-306">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-306">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="f988b-307">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-307">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f988b-308">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund, będzie czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-308">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-309">Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> wartość, aby określić interwał czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-309">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-310">
            <see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-310">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-311">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-311">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-312">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-312">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-313"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca kończy czas oczekiwania, co oznacza, że są sygnalizowane albo wszystkie dojścia lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="f988b-313">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="f988b-314">W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="f988b-314">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f988b-315">Jeśli tablica zawiera duplikaty, połączenie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="f988b-315">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f988b-316"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-316">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="f988b-317">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f988b-317">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f988b-318">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f988b-318">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-319">
            <paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-319">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-320">- lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-320">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-321">- lub - <paramref name="waitHandles" /> jest tablicą o żadnych elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-321">-or-  <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="f988b-322">
            <block subset="none" type="note">
              <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.ArgumentException" />, zamiast tego.  </para>
            </block>
            <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-322">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
              </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-323">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-323">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="f988b-324">- lub - <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-324">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-325">
            <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-325">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-326">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-326">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-327">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-327">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-328">
            <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-328">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f988b-329">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-329">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="f988b-330">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu (duplikatów).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-330">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f988b-331">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-331">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f988b-332">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-332">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-333">Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.Int32" /> wartość, aby określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-333">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-334">
            <see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-334">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-335">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-335">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-336">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-336">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-337"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="f988b-337"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f988b-338">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-338">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f988b-339">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-339">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f988b-340">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="f988b-340">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f988b-341">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-341">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f988b-342"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania zakończenie, co oznacza, że gdy są sygnalizowane wszystkie dojścia lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="f988b-342">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="f988b-343">W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="f988b-343">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f988b-344">Jeśli istnieją duplikaty w tablicy, połączenie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="f988b-344">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f988b-345"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-345">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f988b-346">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="f988b-346">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f988b-347">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAll%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="f988b-347">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f988b-348">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f988b-348">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f988b-349">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie jest pochodną <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-349">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f988b-350">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-350">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="f988b-351">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAll%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-351">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="f988b-352">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="f988b-352">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="f988b-353">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-353">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f988b-354">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="f988b-354">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f988b-355">Gdy <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-355">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-356">Poniższy przykład kodu pokazuje, jak za pomocą puli wątków asynchronicznie utworzyć i zapisać do grupy plików.</span><span class="sxs-lookup"><span data-stu-id="f988b-356">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f988b-357">Po zakończeniu każdej operacji zapisu jest w kolejce elementu roboczego i sygnałów.</span><span class="sxs-lookup"><span data-stu-id="f988b-357">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f988b-358">Główny wątek oczekuje dla wszystkich elementów, które sygnalizują i kończy pracę.</span><span class="sxs-lookup"><span data-stu-id="f988b-358">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-359">
            <paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-359">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-360">- lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-360">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-361">- lub - <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-361">-or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="f988b-362">
            <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-362">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-363">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-363">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="f988b-364">- lub - <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-364">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f988b-365">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-365">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-366">
            <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-366">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-367">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-367">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-368">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-368">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-369">
            <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-369">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f988b-370">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-370">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="f988b-371">Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-371">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f988b-372">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund, będzie czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-372">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f988b-373">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-373">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-374">Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> wartość, aby określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-374">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-375">
            <see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-375">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-376">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-376">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-377">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-377">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-378"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="f988b-378"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f988b-379">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-379">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f988b-380">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-380">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f988b-381">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="f988b-381">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f988b-382">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-382">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f988b-383"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca kończy czas oczekiwania, co oznacza, że są sygnalizowane albo wszystkie dojścia lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="f988b-383">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="f988b-384">W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="f988b-384">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f988b-385">Jeśli tablica zawiera duplikaty, połączenie nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="f988b-385">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f988b-386"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-386">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="f988b-387">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f988b-387">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f988b-388">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="f988b-388">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f988b-389">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAll%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="f988b-389">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f988b-390">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f988b-390">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f988b-391">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie jest pochodną <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-391">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f988b-392">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-392">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="f988b-393">Zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAll%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-393">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="f988b-394">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-394">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f988b-395">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-395">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f988b-396">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="f988b-396">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f988b-397">Gdy <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-397">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-398">Poniższy przykład kodu pokazuje, jak za pomocą puli wątków asynchronicznie utworzyć i zapisać do grupy plików.</span><span class="sxs-lookup"><span data-stu-id="f988b-398">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f988b-399">Po zakończeniu każdej operacji zapisu jest w kolejce elementu roboczego i sygnałów.</span><span class="sxs-lookup"><span data-stu-id="f988b-399">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f988b-400">Główny wątek oczekuje dla wszystkich elementów, które sygnalizują i kończy pracę.</span><span class="sxs-lookup"><span data-stu-id="f988b-400">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-401">
            <paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-401">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-402">- lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-402">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-403">- lub - <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-403">-or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="f988b-404">
            <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-404">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-405">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-405">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="f988b-406">- lub - <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-406">-or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f988b-407">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-407">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-408">
            <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-408">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-409">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-409">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-410">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-410">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-411">
            <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-411">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f988b-412">Czeka na jeden z elementów w określonej tablicy na odebrał sygnału.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-412">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f988b-413">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-413">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-414">Czeka na jeden z elementów w określonej tablicy na odebrał sygnału.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-414">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-415">Indeks tablicy obiektu spełniającego oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-415">The array index of the object that satisfied the wait.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-416"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="f988b-416"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f988b-417">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` wykona czas oczekiwania, ponieważ obiektu mutex zostanie zaniechana.</span><span class="sxs-lookup"><span data-stu-id="f988b-417">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f988b-418">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-418">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f988b-419">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="f988b-419">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f988b-420">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-420">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f988b-421"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-421">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f988b-422">Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f988b-422">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f988b-423">W wersjach wcześniejszych niż wersja 2.0, jeśli wątek kończy działanie lub przerwanie bez jawnego zwolnienia programu .NET Framework <xref:System.Threading.Mutex>oraz że `Mutex` znajduje się pod indeksem 0 (zero) w `WaitAny` tablicy w innym wątku, indeks zwrócony przez `WaitAny` jest 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="f988b-423">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f988b-424">Ta metoda zwraca, jeśli zostanie zasygnalizowane dowolny uchwyt.</span><span class="sxs-lookup"><span data-stu-id="f988b-424">This method returns when any handle is signaled.</span></span> <span data-ttu-id="f988b-425">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="f988b-425">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="f988b-426">W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="f988b-426">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="f988b-427">Wywołanie metody przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenie metody i określając -1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f988b-427">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-428">Poniższy przykład kodu pokazuje wywołanie <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-428">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-429">
            <paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-429">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-430">- lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-430">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-431">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-431">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f988b-432">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-432">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-433">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-433">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-434">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-434">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f988b-435">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-435">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-436">
            <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-436">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f988b-437">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-437">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f988b-438">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-438">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-439">Czeka na jeden z elementów w określonej tablicy na sygnał, za pomocą całkowita 32-bitowy, aby określić interwał czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-439">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-440">Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="millisecondsTimeout" /> minął.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-440">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-441">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-441">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-442">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-442">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-443"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-443">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f988b-444">Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f988b-444">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="f988b-445">Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub zostanie przekroczony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="f988b-445">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="f988b-446">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="f988b-446">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="f988b-447">W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="f988b-447">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="f988b-448">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f988b-448">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-449">
            <paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-449">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-450">- lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-450">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-451">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-451">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-452">
            <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-452">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-453">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-453">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-454">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-454">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f988b-455">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-455">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-456">
            <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-456">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f988b-457">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-457">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f988b-458">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-458">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-459">Czeka na jeden z elementów w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> Aby określić interwał czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-459">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-460">Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="timeout" /> minął.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-460">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-461">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-461">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-462">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-462">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-463"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-463">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f988b-464">Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f988b-464">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="f988b-465">Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="f988b-465">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="f988b-466">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="f988b-466">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="f988b-467">W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="f988b-467">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="f988b-468">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f988b-468">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f988b-469">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f988b-469">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-470">
            <paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-470">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-471">- lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-471">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-472">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-472">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-473">
            <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-473">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-474">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-474">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-475">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-475">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f988b-476">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-476">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-477">
            <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-477">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f988b-478">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-478">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f988b-479">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-479">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f988b-480">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-480">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-481">Czeka na jeden z elementów w określonej tablicy na sygnał, za pomocą całkowita 32-bitowy, aby określić przedział czasu i określająca, czy zakończyć działanie synchronizacji domeny przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-481">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-482">Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="millisecondsTimeout" /> minął.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-482">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-483">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-483">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-484">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-484">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-485"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="f988b-485"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f988b-486">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` wykona czas oczekiwania, ponieważ obiektu mutex zostanie zaniechana.</span><span class="sxs-lookup"><span data-stu-id="f988b-486">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f988b-487">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-487">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f988b-488">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="f988b-488">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f988b-489">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-489">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f988b-490"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-490">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f988b-491">Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f988b-491">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f988b-492">W wersjach wcześniejszych niż wersja 2.0, jeśli wątek kończy działanie lub przerwanie bez jawnego zwolnienia programu .NET Framework <xref:System.Threading.Mutex>oraz że `Mutex` znajduje się pod indeksem 0 (zero) w `WaitAny` tablicy w innym wątku, indeks zwrócony przez `WaitAny` jest 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="f988b-492">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f988b-493">Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub zostanie przekroczony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="f988b-493">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="f988b-494">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="f988b-494">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="f988b-495">W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="f988b-495">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f988b-496">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="f988b-496">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f988b-497">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAny%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="f988b-497">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f988b-498">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f988b-498">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f988b-499">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-499">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f988b-500">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-500">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="f988b-501">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAny%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-501">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="f988b-502">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-502">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f988b-503">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-503">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f988b-504">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="f988b-504">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f988b-505">Gdy <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-505">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-506">Poniższy przykład kodu pokazuje, jak używać puli wątków jednocześnie wyszukiwania plików na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="f988b-506">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f988b-507">Zagadnienia miejsca przeszukiwane będą tylko w katalogu głównym każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="f988b-507">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-508">
            <paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-508">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-509">- lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-509">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-510">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-510">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f988b-511">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-511">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-512">
            <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-512">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-513">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-513">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-514">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-514">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f988b-515">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-515">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-516">
            <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-516">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f988b-517">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-517">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f988b-518">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-518">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f988b-519">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-519">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-520">Czeka na jeden z elementów w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-520">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-521">Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="timeout" /> minął.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-521">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-522">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-522">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-523">Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-523">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-524"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="f988b-524"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f988b-525">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` wykona czas oczekiwania, ponieważ obiektu mutex zostanie zaniechana.</span><span class="sxs-lookup"><span data-stu-id="f988b-525">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f988b-526">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-526">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f988b-527">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="f988b-527">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f988b-528">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-528">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f988b-529"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-529">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f988b-530">Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f988b-530">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f988b-531">W wersjach wcześniejszych niż wersja 2.0, jeśli wątek kończy działanie lub przerwanie bez jawnego zwolnienia programu .NET Framework <xref:System.Threading.Mutex>oraz że `Mutex` znajduje się pod indeksem 0 (zero) w `WaitAny` tablicy w innym wątku, indeks zwrócony przez `WaitAny` jest 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="f988b-531">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f988b-532">Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="f988b-532">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="f988b-533">Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów.</span><span class="sxs-lookup"><span data-stu-id="f988b-533">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="f988b-534">W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="f988b-534">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="f988b-535">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f988b-535">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f988b-536">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="f988b-536">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f988b-537">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAny%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="f988b-537">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f988b-538">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f988b-538">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f988b-539">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-539">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f988b-540">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-540">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="f988b-541">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAny%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-541">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="f988b-542">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-542">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f988b-543">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-543">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f988b-544">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="f988b-544">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f988b-545">Gdy <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-545">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-546">Poniższy przykład kodu pokazuje, jak używać puli wątków jednocześnie wyszukiwania plików na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="f988b-546">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f988b-547">Zagadnienia miejsca przeszukiwane będą tylko w katalogu głównym każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="f988b-547">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f988b-548">
            <paramref name="waitHandles" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-548">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f988b-549">- lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-549">-or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f988b-550">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-550">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f988b-551">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-551">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-552">
            <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-552">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-553">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-553">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-554">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-554">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f988b-555">
            <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-555">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-556">
            <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-556">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f988b-557">Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-557">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f988b-558">Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-558">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-559">
            <see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-559">
              <see langword="true" /> if the current instance receives a signal.</span>
          </span>
          <span data-ttu-id="f988b-560">Jeśli bieżące wystąpienie nigdy nie zostanie zasygnalizowane, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nigdy nie zwraca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-560">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-561"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="f988b-561"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f988b-562">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-562">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f988b-563">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-563">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f988b-564">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="f988b-564">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f988b-565">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-565">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f988b-566">Element wywołujący tego bloków metody do czasu bieżącego wystąpienia odbiera sygnał.</span><span class="sxs-lookup"><span data-stu-id="f988b-566">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="f988b-567">Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="f988b-567">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f988b-568">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f988b-568">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f988b-569">Wywołanie metody przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenie metody i określając -1 lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> jako pierwszy parametr i `false` dla drugiego parametru.</span><span class="sxs-lookup"><span data-stu-id="f988b-569">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="f988b-570">Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="f988b-570">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-571">Poniższy przykład kodu pokazuje, jak zapobiec proces przerywanie podczas oczekiwania na zakończenie wykonywania wątku w tle przy użyciu dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="f988b-571">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f988b-572">Bieżące wystąpienie został już usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-572">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-573">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-573">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-574">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-574">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-575">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-575">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f988b-576">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-576">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-577">Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał, aby określić interwał czasu w milisekundach przy użyciu całkowita 32-bitowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-577">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-578">
            <see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-578">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-579">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-579">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-580">Sprawdza stan dojście oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-580">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-581">Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="f988b-581">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f988b-582">Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="f988b-582">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f988b-583">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f988b-583">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f988b-584">Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="f988b-584">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f988b-585">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f988b-585">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-586">Poniższy przykład kodu pokazuje, jak zapobiec proces przerywanie podczas oczekiwania na zakończenie wykonywania wątku w tle przy użyciu dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="f988b-586">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f988b-587">Bieżące wystąpienie został już usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-587">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-588">
            <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-588">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-589">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-589">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-590">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-590">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-591">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-591">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="f988b-592">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-592">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-593">Blokuje bieżący wątek, do momentu otrzymania przez bieżące wystąpienie sygnał, przy użyciu <see cref="T:System.TimeSpan" /> Aby określić interwał czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-593">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-594">
            <see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-594">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-595">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-595">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-596">Sprawdza stan dojście oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-596">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-597">Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="f988b-597">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f988b-598">Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="f988b-598">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f988b-599">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f988b-599">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f988b-600">Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="f988b-600">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f988b-601">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f988b-601">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f988b-602">Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f988b-602">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f988b-603">Bieżące wystąpienie został już usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-603">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-604">
            <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-604">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-605">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-605">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-606">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-606">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-607">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-607">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f988b-608">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-608">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f988b-609">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-609">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-610">Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał, za pomocą całkowita 32-bitowy, aby określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-610">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-611">
            <see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-611">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-612">Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-612">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-613">Sprawdza stan dojście oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-613">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-614"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="f988b-614"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f988b-615">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-615">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f988b-616">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-616">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f988b-617">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="f988b-617">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f988b-618">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-618">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f988b-619">Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="f988b-619">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f988b-620">Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="f988b-620">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f988b-621">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f988b-621">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f988b-622">Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="f988b-622">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f988b-623">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="f988b-623">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f988b-624">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitOne%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="f988b-624">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f988b-625">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f988b-625">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f988b-626">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-626">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f988b-627">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-627">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f988b-628">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-628">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="f988b-629">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-629">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f988b-630">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-630">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f988b-631">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="f988b-631">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f988b-632">Gdy <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-632">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-633">W poniższym przykładzie przedstawiono sposób <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenie metody ma zachowywać się, gdy jest wywoływana w domenie synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-633">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="f988b-634">Po pierwsze, wątek oczekuje z `exitContext` ustawioną `false` i blokuje do chwili osiągnięcia limitu czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="f988b-634">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="f988b-635">Drugi wątek wykonuje po pierwszym wątkiem kończy i czeka z `exitContext` ustawioną `true`.</span><span class="sxs-lookup"><span data-stu-id="f988b-635">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="f988b-636">Wywołanie sygnału dojście oczekiwania dla tego drugiego wątku nie jest blokowane i zakończeniu przed upływem limitu czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="f988b-636">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f988b-637">Bieżące wystąpienie został już usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-637">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-638">
            <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-638">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-639">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-639">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-640">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-640">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-641">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-641">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="f988b-642">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-642">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f988b-643">
            <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-643">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f988b-644">Blokuje bieżący wątek, do momentu otrzymania przez bieżące wystąpienie sygnał, przy użyciu <see cref="T:System.TimeSpan" /> określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-644">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f988b-645">
            <see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-645">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-646">Jeśli `timeout` wynosi zero, nie są blokowane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="f988b-646">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f988b-647">Sprawdza stan dojście oczekiwania, a zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f988b-647">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f988b-648"><xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="f988b-648"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f988b-649">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="f988b-649">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f988b-650">Porzuconego elementu mutex często oznacza to poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-650">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f988b-651">W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="f988b-651">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f988b-652">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="f988b-652">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f988b-653">Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="f988b-653">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f988b-654">Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="f988b-654">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f988b-655">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f988b-655">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f988b-656">Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="f988b-656">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f988b-657">Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f988b-657">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f988b-658">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="f988b-658">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f988b-659">`exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitOne%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy.</span><span class="sxs-lookup"><span data-stu-id="f988b-659">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f988b-660">Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f988b-660">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f988b-661">Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-661">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f988b-662">Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-662">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f988b-663">Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="f988b-663">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="f988b-664">Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f988b-664">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f988b-665">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy.</span><span class="sxs-lookup"><span data-stu-id="f988b-665">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f988b-666">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="f988b-666">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f988b-667">Gdy <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f988b-667">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-668">Poniższy przykład kodu pokazuje, jak zapobiec proces przerywanie podczas oczekiwania na zakończenie wykonywania wątku w tle przy użyciu dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="f988b-668">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f988b-669">Bieżące wystąpienie został już usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-669">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f988b-670">
            <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-670">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f988b-671">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-671">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f988b-672">Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-672">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f988b-673">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-673">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="f988b-674">Oznacza to, że <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> upłynął limit czasu operacji przed żadnego uchwyty oczekiwania były sygnalizowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-674">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          </span>
          <span data-ttu-id="f988b-675">To pole jest stałe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f988b-675">This field is constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f988b-676">To pole jest jedną z możliwych wartości zwracanych metody `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="f988b-676">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f988b-677">Poniższy przykład kodu pokazuje, jak używać puli wątków jednocześnie wyszukiwania plików na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="f988b-677">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f988b-678">Zagadnienia miejsca przeszukiwane będą tylko w katalogu głównym każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="f988b-678">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
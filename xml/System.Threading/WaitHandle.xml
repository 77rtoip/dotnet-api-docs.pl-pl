<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5b0250cf5d94f2e2dd11058978329bf6d723a3d8" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69098405" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="bd5b0-101">Hermetyzuje obiekty specyficzne dla systemu operacyjnego, które oczekują na wyłączny dostęp do udostępnionych zasobów.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-101">Encapsulates operating system-specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-102"><xref:System.Threading.WaitHandle> Klasa hermetyzuje natywny uchwyt synchronizacji systemu operacyjnego i służy do reprezentowania wszystkich obiektów synchronizacji w środowisku uruchomieniowym, które zezwalają na wiele operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="bd5b0-103">Porównanie dojścia oczekiwania z innymi obiektami synchronizacji zawiera temat [Omówienie elementów pierwotnych synchronizacji](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="bd5b0-104">Sama <xref:System.Threading.WaitHandle> Klasa jest abstrakcyjna.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="bd5b0-105">Klasy pochodzące od <xref:System.Threading.WaitHandle> definiują mechanizm sygnalizujący, aby wskazać pobieranie lub zwalnianie dostępu do zasobu udostępnionego, ale używają metod dziedziczonych <xref:System.Threading.WaitHandle> , aby blokować czas oczekiwania na dostęp do udostępnionych zasobów.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="bd5b0-106">Klasy pochodne <xref:System.Threading.WaitHandle> obejmują:</span><span class="sxs-lookup"><span data-stu-id="bd5b0-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="bd5b0-107"><xref:System.Threading.Mutex> Klasa.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="bd5b0-108">Zobacz [muteksy](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="bd5b0-109">Klasa i jej <xref:System.Threading.AutoResetEvent> klasy pochodne i <xref:System.Threading.ManualResetEvent>. <xref:System.Threading.EventWaitHandle></span><span class="sxs-lookup"><span data-stu-id="bd5b0-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span>  
  
-   <span data-ttu-id="bd5b0-110"><xref:System.Threading.Semaphore> Klasa.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-110">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="bd5b0-111">Zobacz [Semafor i SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-111">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="bd5b0-112">Wątki mogą blokować pojedyncze dojście oczekiwania, wywołując metodę <xref:System.Threading.WaitHandle.WaitOne%2A>wystąpienia, która jest dziedziczona przez klasy pochodne od. <xref:System.Threading.WaitHandle></span><span class="sxs-lookup"><span data-stu-id="bd5b0-112">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="bd5b0-113">Klasy pochodne różnią <xref:System.Threading.WaitHandle> się w zależności od ich wątku.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-113">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="bd5b0-114">Dojścia oczekiwania zdarzeń<xref:System.Threading.EventWaitHandle>( <xref:System.Threading.AutoResetEvent>, i <xref:System.Threading.ManualResetEvent>) i semafory nie mają koligacji wątku; dowolny wątek może sygnalizować uchwyt oczekiwania lub semafor zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-114">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="bd5b0-115">Muteksy, z drugiej strony, mają koligację wątku; wątek, który jest właścicielem obiektu mutex, musi go zwolnić i wyjątek jest zgłaszany, jeśli wątek wywołuje <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę na elemencie mutex, który nie jest właścicielem.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-115">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="bd5b0-116">Ponieważ Klasa pochodzi od <xref:System.MarshalByRefObject>, te klasy mogą służyć do synchronizowania działań wątków między granicami domeny aplikacji. <xref:System.Threading.WaitHandle></span><span class="sxs-lookup"><span data-stu-id="bd5b0-116">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="bd5b0-117">Oprócz klas pochodnych <xref:System.Threading.WaitHandle> Klasa ma wiele metod statycznych, które blokują wątek do momentu, gdy jeden lub więcej obiektów synchronizacji odbierze sygnał.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-117">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="bd5b0-118">Należą do nich następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="bd5b0-118">These include:</span></span>  
  
-   <span data-ttu-id="bd5b0-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, co umożliwia wątek sygnalizujący jedno dojście oczekiwania i od razu czeka na inne.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="bd5b0-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, dzięki czemu wątek czeka, aż wszystkie uchwyty oczekiwania w tablicy otrzymają sygnał.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="bd5b0-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, dzięki czemu wątek czeka na zasygnalizowanie dowolnego jednego z określonych dojść oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled.</span></span>  
  
 <span data-ttu-id="bd5b0-122">Przeciążenia tych metod zapewniają przedziały czasu, w których porzucane są oczekiwania, oraz możliwość wyjścia kontekstu synchronizacji przed wprowadzeniem oczekiwania, zezwalając innym wątkom na korzystanie z kontekstu synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-122">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="bd5b0-123">Ten typ implementuje <xref:System.IDisposable> interfejs.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-123">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="bd5b0-124">Po zakończeniu korzystania z typu lub typu pochodnego należy usunąć jego wartość bezpośrednio lub pośrednio.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-124">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="bd5b0-125">Aby usunąć typ bezpośrednio <xref:System.Threading.WaitHandle.Close%2A> , wywołaj jego metodę `try` / `catch` w bloku.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-125">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="bd5b0-126">Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-126">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="bd5b0-127">Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-127">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="bd5b0-128"><xref:System.Threading.WaitHandle><xref:System.IDisposable.Dispose%2A> implementuje wzorzec.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-128"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="bd5b0-129">Zobacz [implementowanie metody Dispose] (~/docs/Standard/garbage-collection/Implementing-Dispose. MD).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-129">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="bd5b0-130">Gdy pochodzą z <xref:System.Threading.WaitHandle>programu, <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Użyj właściwości do przechowywania natywnego uchwytu systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-130">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="bd5b0-131">Nie musisz przesłonić metody chronionej <xref:System.Threading.WaitHandle.Dispose%2A> , chyba że używasz dodatkowych zasobów niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-131">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-132">Poniższy przykład kodu pokazuje, jak dwa wątki mogą wykonywać zadania w tle, podczas gdy główny wątek czeka na ukończenie zadań przy użyciu statycznych <xref:System.Threading.WaitHandle.WaitAny%2A> i <xref:System.Threading.WaitHandle.WaitAll%2A> metod <xref:System.Threading.WaitHandle> klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-132">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="bd5b0-133">Ten typ jest bezpieczny wątkowo.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-133">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="bd5b0-134">Wątkowość</span><span class="sxs-lookup"><span data-stu-id="bd5b0-134">Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="bd5b0-135">Wątkowość obiektów i funkcji</span><span class="sxs-lookup"><span data-stu-id="bd5b0-135">Threading Objects and Features</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="bd5b0-136">Muteksy</span><span class="sxs-lookup"><span data-stu-id="bd5b0-136">Mutexes</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d"><span data-ttu-id="bd5b0-137">EventWaitHandle, AutoResetEvent i ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="bd5b0-137">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="bd5b0-138">Semaforów</span><span class="sxs-lookup"><span data-stu-id="bd5b0-138">Semaphores</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bd5b0-139">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-139">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bd5b0-140">Zwalnia wszystkie zasoby przechowywane przez bieżące <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-140">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-141">Ta metoda jest publiczną implementacją <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metody <xref:System.Threading.WaitHandle> klasy i jej klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-141">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="bd5b0-142">Zapewnia standardową implementację, która wywołuje `Dispose(Boolean)` Przeciążenie `true` z <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> argumentem, a następnie wywołuje metodę.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-142">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bd5b0-143">Wywołaj tę metodę, aby zwolnić wszystkie zasoby znajdujące się `WaitHandle` w wystąpieniu lub klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-143">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="bd5b0-144">Po wywołaniu tej metody odwołania do bieżącego wystąpienia powodują niezdefiniowane zachowanie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-144">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bd5b0-145">Zawsze wywołuj <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed wydaniem ostatniego odwołania do <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-145">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="bd5b0-146">W przeciwnym razie używane zasoby nie zostaną zwolnione.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-146">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="bd5b0-147">Należy zastąpić metodę, <see langword="Dispose(Boolean)" /> aby zwolnić zasoby przydzieloną w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-147">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="bd5b0-148">Implementacja metody Dispose</span><span class="sxs-lookup"><span data-stu-id="bd5b0-148">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bd5b0-149">Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.WaitHandle" /> klasy</span><span class="sxs-lookup"><span data-stu-id="bd5b0-149">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bd5b0-150">Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.WaitHandle" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-151">Ta metoda jest równoważna <xref:System.Threading.WaitHandle.Close%2A> z metodą.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-151">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bd5b0-152">Zawsze wywołuj <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed wydaniem ostatniego odwołania do <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-152">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="bd5b0-153">W przeciwnym razie używane zasoby nie zostaną zwolnione.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-153">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="bd5b0-154">Oczyszczanie zasobów niezarządzanych</span><span class="sxs-lookup"><span data-stu-id="bd5b0-154">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><span data-ttu-id="bd5b0-155"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-155"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="bd5b0-156">Gdy jest zastępowany w klasie pochodnej, zwalnia niezarządzane zasoby używane przez <see cref="T:System.Threading.WaitHandle" />program i opcjonalnie zwalnia zarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-156">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-157">Ta <xref:System.Threading.WaitHandle.Close%2A> Metoda jest wywoływana przez <xref:System.Threading.WaitHandle.Dispose> i metody z `explicitDisposing` parametrem ustawionym na `true`.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-157">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="bd5b0-158">Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Threading.WaitHandle> których odwołuje się ten obiekt. `explicitDisposing`</span><span class="sxs-lookup"><span data-stu-id="bd5b0-158">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="bd5b0-159">Należy zastąpić metodę, <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> aby zwolnić zasoby przydzieloną w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-159">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
<span data-ttu-id="bd5b0-160">Metoda <see cref="M:System.Threading.WaitHandle.Close" /> or<see cref="M:System.Threading.WaitHandle.Dispose" /> może być wywoływana wiele razy przez inne obiekty.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-160">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="bd5b0-161">Podczas zastępowania tej metody należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej <see langword="Dispose" /> usunięte <see langword="Close" />we wcześniejszej wywołaniu lub.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-161">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="bd5b0-162">Implementacja metody Dispose</span><span class="sxs-lookup"><span data-stu-id="bd5b0-162">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bd5b0-163">Zwalnia zasoby blokowane przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-163">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="bd5b0-164">Ten element członkowski został usunięty z .NET Framework w wersji 2,0 i w kolejnych wersjach.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-164">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="bd5b0-165">Ten temat dotyczy tylko wersji wymienionych w sekcji "informacje o wersji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-165">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="bd5b0-166">Metoda nie jest wywoływana przez kod aplikacji, ale automatycznie podczas wyrzucania elementów bezużytecznych, chyba że moduł wyrzucania elementów bezużytecznych wyłączył finalizację.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-166">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="bd5b0-167">Aby uzyskać więcej informacji, zobacz <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> i <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-167">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="bd5b0-168">Ta metoda przesłania <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-168">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bd5b0-169">Pobiera lub ustawia natywne dojście systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-169">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="bd5b0-170"><see langword="IntPtr" /> Reprezentujący natywny uchwyt systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-170">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="bd5b0-171">Wartością domyślną jest wartość <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> pola.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-171">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-172">Przypisanie nowej wartości do <xref:System.Threading.WaitHandle.Handle%2A> właściwości nie powoduje zamknięcia poprzedniego dojścia.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-172">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="bd5b0-173">Może to spowodować przeciek dojść.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-173">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="bd5b0-174">Nie należy używać tej właściwości w .NET Framework w wersji 2,0 lub nowszej. Zamiast tego użyj właściwości. <xref:System.Threading.WaitHandle.SafeWaitHandle%2A></span><span class="sxs-lookup"><span data-stu-id="bd5b0-174">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="bd5b0-175">Ustawienie tej właściwości na prawidłowe dojście powoduje również <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> ustawienie właściwości, ale ustawienie <xref:System.Threading.WaitHandle.InvalidHandle> jej w taki sposób, że może spowodować przeciek.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-175">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="bd5b0-176">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego w celu ustawienia wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-176">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="bd5b0-177">Ten element członkowski nie może być ustawiony przez częściowo zaufany lub przezroczysty kod.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-177">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="bd5b0-178">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> ustawioną wartość właściwości.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bd5b0-179">Reprezentuje nieprawidłowe natywne dojście systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-179">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="bd5b0-180">To pole jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-180">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-181">Używane wewnętrznie do inicjowania <xref:System.Threading.WaitHandle.Handle%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-181">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="bd5b0-182">Możesz użyć tej wartości, aby określić, <see cref="P:System.Threading.WaitHandle.Handle" /> czy właściwość zawiera prawidłowe natywne dojście systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-182">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bd5b0-183">Pobiera lub ustawia natywne dojście systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-183">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="bd5b0-184"><see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> Reprezentujący natywny uchwyt systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-184">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-185">Po przypisaniu nowej wartości do <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości, poprzednie dojście zostanie zamknięte po zebraniu poprzedniego <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> obiektu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-185">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="bd5b0-186">Nie zamykaj ręcznie dojścia, ponieważ powoduje <xref:System.ObjectDisposedException> to, <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> kiedy próbuje zamknąć uchwyt.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-186">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="bd5b0-187"><xref:System.Threading.WaitHandle><xref:System.IDisposable.Dispose%2A> implementuje wzorzec.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-187"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="bd5b0-188">Zobacz [implementowanie metody Dispose] (~/docs/Standard/garbage-collection/Implementing-Dispose. MD).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-188">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="bd5b0-189">Gdy pochodzą z <xref:System.Threading.WaitHandle>programu, <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> Użyj właściwości do przechowywania natywnego uchwytu systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-189">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="bd5b0-190">Nie musisz przesłonić metody chronionej <xref:System.Threading.WaitHandle.Dispose%2A> , chyba że używasz dodatkowych zasobów niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-190">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="bd5b0-191">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-191">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="bd5b0-192">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-192">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="bd5b0-193">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> wywołania tego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-193">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bd5b0-194">Sygnalizuje <see cref="T:System.Threading.WaitHandle" /> jeden i czeka na inny.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-194">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="bd5b0-195"><see cref="T:System.Threading.WaitHandle" /> Do sygnału.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-195">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="bd5b0-196">, <see cref="T:System.Threading.WaitHandle" /> Aby czekać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-196">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="bd5b0-197">Sygnalizuje <see cref="T:System.Threading.WaitHandle" /> jeden i czeka na inny.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-197">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-198"><see langword="true" />Jeśli zarówno sygnał, jak i oczekiwanie zakończyło się pomyślnie; Jeśli oczekiwanie nie zostanie zakończone, metoda nie zwraca.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-198"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-199">Ta operacja nie gwarantuje, że jest niepodzielna.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-199">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="bd5b0-200">Gdy bieżący wątek sygnalizuje `toSignal` `toWaitOn`, ale przed odczekaniem, wątek, który jest uruchomiony na innym procesorze `toWaitOn` , może sygnalizować lub oczekiwać na niego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-200">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-201">Poniższy przykład kodu używa przeciążenia metody <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> , aby umożliwić głównemu wątkowi sygnalizowanie zablokowanego wątku, a następnie zaczekać, aż wątek zakończy zadanie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-201">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="bd5b0-202">Przykład rozpoczyna pięć wątków, umożliwia ich blokowanie na <xref:System.Threading.EventWaitHandle> utworzonej <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> z flagą, a następnie zwalnia jeden wątek za każdym razem, gdy użytkownik naciśnie klawisz ENTER.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-202">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="bd5b0-203">W tym przykładzie kolejka będzie kolejkować kolejne pięć wątków i zwalnia <xref:System.Threading.EventWaitHandle> je wszystkie przy <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> użyciu flagi utworzony z flagą.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-203">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-204"><paramref name="toSignal" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-204"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-205">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-205">-or-</span></span> 
 <span data-ttu-id="bd5b0-206"><paramref name="toWaitOn" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-206"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-207">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-207">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="bd5b0-208">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-208">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-209"><paramref name="toSignal" />jest semaforem i ma już pełną liczbę.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-209"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-210">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-210">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-211">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-211">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="bd5b0-212"><see cref="T:System.Threading.WaitHandle" /> Do sygnału.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-212">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="bd5b0-213">, <see cref="T:System.Threading.WaitHandle" /> Aby czekać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-213">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="bd5b0-214">Liczba całkowita, która reprezentuje interwał oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-214">An integer that represents the interval to wait.</span></span> <span data-ttu-id="bd5b0-215">Jeśli wartość to <see cref="F:System.Threading.Timeout.Infinite" />, czyli-1, czas oczekiwania jest nieskończony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-215">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="bd5b0-216"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-216"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="bd5b0-217">Sygnalizuje <see cref="T:System.Threading.WaitHandle" /> jeden i czeka na inny, określając interwał limitu czasu jako 32-bitową liczbę całkowitą ze znakiem i określając, czy zamknąć domenę synchronizacji kontekstu przed wprowadzeniem oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-217">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-218"><see langword="true" />Jeśli zarówno sygnał, jak i oczekiwanie zakończono pomyślnie <see langword="false" /> , lub jeśli sygnał zakończył się, ale upłynął limit czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-218"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-219">Ta operacja nie gwarantuje, że jest niepodzielna.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-219">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="bd5b0-220">Gdy bieżący wątek sygnalizuje `toSignal` `toWaitOn`, ale przed odczekaniem, wątek, który jest uruchomiony na innym procesorze `toWaitOn` , może sygnalizować lub oczekiwać na niego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-220">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="bd5b0-221">Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-221">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-222">Sprawdza stan `toWaitOn` i natychmiast wraca.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-222">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bd5b0-223">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="bd5b0-223">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bd5b0-224">Parametr nie działa, <xref:System.Threading.WaitHandle.SignalAndWait%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext`</span><span class="sxs-lookup"><span data-stu-id="bd5b0-224">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bd5b0-225">Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-225">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bd5b0-226">Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-226">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bd5b0-227">Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.SignalAndWait%2A> kontekstu) przed wykonaniem metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-227">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="bd5b0-228">Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-228">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="bd5b0-229">Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-229">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bd5b0-230">W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-230">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bd5b0-231">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-231">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bd5b0-232"><xref:System.Threading.WaitHandle.SignalAndWait%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-232">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-233"><paramref name="toSignal" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-233"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-234">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-234">-or-</span></span> 
 <span data-ttu-id="bd5b0-235"><paramref name="toWaitOn" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-235"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-236">Metoda jest wywoływana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-236">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="bd5b0-237">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-237">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-238">Nie <see cref="T:System.Threading.WaitHandle" /> można zasygnalizować, ponieważ spowodowałoby to przekroczenie maksymalnej liczby.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-238">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-239"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-239"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-240">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-240">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-241">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-241">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="bd5b0-242"><see cref="T:System.Threading.WaitHandle" /> Do sygnału.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-242">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="bd5b0-243">, <see cref="T:System.Threading.WaitHandle" /> Aby czekać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-243">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="bd5b0-244"><see cref="T:System.TimeSpan" /> Reprezentuje interwał oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-244">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="bd5b0-245">Jeśli wartość to-1, czas oczekiwania jest nieskończony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-245">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="bd5b0-246"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-246"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="bd5b0-247">Sygnalizuje <see cref="T:System.Threading.WaitHandle" /> jeden i czeka na inne określenie interwału limitu czasu <see cref="T:System.TimeSpan" /> jako i określenie, czy należy zamknąć domenę synchronizacji kontekstu przed wprowadzeniem oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-247">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-248"><see langword="true" />Jeśli zarówno sygnał, jak i oczekiwanie zakończono pomyślnie <see langword="false" /> , lub jeśli sygnał zakończył się, ale upłynął limit czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-248"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-249">Ta operacja nie gwarantuje, że jest niepodzielna.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-249">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="bd5b0-250">Gdy bieżący wątek sygnalizuje `toSignal` `toWaitOn`, ale przed odczekaniem, wątek, który jest uruchomiony na innym procesorze `toWaitOn` , może sygnalizować lub oczekiwać na niego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-250">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="bd5b0-251">Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-251">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bd5b0-252">Jeśli `timeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-252">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-253">Sprawdza stan `toWaitOn` i natychmiast wraca.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-253">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bd5b0-254">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="bd5b0-254">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bd5b0-255">Parametr nie działa, <xref:System.Threading.WaitHandle.SignalAndWait%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext`</span><span class="sxs-lookup"><span data-stu-id="bd5b0-255">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bd5b0-256">Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-256">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bd5b0-257">Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-257">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bd5b0-258">Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.SignalAndWait%2A> kontekstu) przed wykonaniem metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-258">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="bd5b0-259">Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-259">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="bd5b0-260">Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-260">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bd5b0-261">W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-261">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bd5b0-262">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-262">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bd5b0-263"><xref:System.Threading.WaitHandle.SignalAndWait%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-263">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-264"><paramref name="toSignal" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-264"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-265">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-265">-or-</span></span> 
 <span data-ttu-id="bd5b0-266"><paramref name="toWaitOn" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-266"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-267">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-267">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="bd5b0-268">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-268">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-269"><paramref name="toSignal" />jest semaforem i ma już pełną liczbę.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-269"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-270"><paramref name="timeout" />daje w wyniku ujemną liczbę milisekund inną niż-1.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-270"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
<span data-ttu-id="bd5b0-271">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-271">-or-</span></span> 
 <span data-ttu-id="bd5b0-272"><paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-272"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-273">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-273">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-274">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-274">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bd5b0-275">Zwalnia wszystkie zasoby używane przez <see cref="T:System.Threading.WaitHandle" />program.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-275">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="bd5b0-276">Wywołanie `Dispose` zezwala na przydzielenie zasobów używanych <xref:System.Threading.WaitHandle> przez program do innych celów.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-276">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="bd5b0-277">Aby uzyskać więcej informacji `Dispose`na temat, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-277">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bd5b0-278">Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-278">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="bd5b0-279"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-279">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="bd5b0-280">Ta tablica nie może zawierać wielu odwołań do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-280">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="bd5b0-281">Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-281">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-282"><see langword="true" />gdy każdy element w <paramref name="waitHandles" /> odebrał sygnał; w przeciwnym razie Metoda nigdy nie zwraca.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-282"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-283"><xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-283"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bd5b0-284">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-284">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bd5b0-285">Porzucony obiekt mutex często wskazuje na poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-285">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bd5b0-286">W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-286">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bd5b0-287">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-287">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bd5b0-288">Metoda <xref:System.Threading.WaitHandle.WaitAll%2A> zwraca, gdy wszystkie uchwyty są sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-288">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="bd5b0-289">W przypadku niektórych implementacji, jeśli przechodzą więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-289">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="bd5b0-290">Jeśli tablica zawiera duplikaty, wywołanie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-290">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bd5b0-291">Metoda nie jest obsługiwana w wątkach, które <xref:System.STAThreadAttribute>mają. <xref:System.Threading.WaitHandle.WaitAll%2A></span><span class="sxs-lookup"><span data-stu-id="bd5b0-291">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="bd5b0-292">Wywołanie tego przeciążenia <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> metody jest równoważne wywołaniu metody przeciążenia i określania-1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-292">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-293">Poniższy przykład kodu pokazuje, jak używać puli wątków do asynchronicznego tworzenia i zapisu do grupy plików.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-293">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="bd5b0-294">Każda operacja zapisu jest umieszczana w kolejce jako element roboczy i sygnalizuje po zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-294">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="bd5b0-295">Główny wątek czeka na wszystkie elementy do sygnalizowania, a następnie opuszcza.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-295">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-296">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-296">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="bd5b0-297">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-297">-or-</span></span> 
<span data-ttu-id="bd5b0-298">Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-298">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-299">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-299">-or-</span></span> 
 <span data-ttu-id="bd5b0-300"><paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 2,0 lub nowsza.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-300"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="bd5b0-301">W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.ArgumentException" />klasy bazowej, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-301">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="bd5b0-302"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-302">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-303">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-303">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="bd5b0-304">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-304">-or-</span></span> 
<span data-ttu-id="bd5b0-305">Ten <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-305">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="bd5b0-306"><paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 1,0 lub 1,1.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-306"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-307">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-307">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-308">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-308">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-309">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-309">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="bd5b0-310"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-310">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="bd5b0-311">Ta tablica nie może zawierać wielu odwołań do tego samego obiektu (duplikatów).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-311">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="bd5b0-312">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-312">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bd5b0-313">Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał przy użyciu <see cref="T:System.Int32" /> wartości, aby określić interwał czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-313">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-314"><see langword="true" />gdy każdy element w <paramref name="waitHandles" /> programie otrzymał sygnał; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-314"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-315">Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-315">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-316">Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-316">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-317"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca po zakończeniu oczekiwania, co oznacza, gdy wszystkie uchwyty są sygnalizowane lub gdy upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-317">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="bd5b0-318">W przypadku niektórych implementacji, jeśli przechodzą więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-318">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="bd5b0-319">Jeśli w tablicy znajdują się duplikaty, wywołanie kończy się niepowodzeniem <xref:System.DuplicateWaitObjectException>z.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-319">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bd5b0-320">Metoda nie jest obsługiwana w wątkach, które <xref:System.STAThreadAttribute>mają. <xref:System.Threading.WaitHandle.WaitAll%2A></span><span class="sxs-lookup"><span data-stu-id="bd5b0-320">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="bd5b0-321">Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-321">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-322">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-322">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-323">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-323">-or-</span></span> 
<span data-ttu-id="bd5b0-324">Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-324">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-325">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-325">-or-</span></span> 
 <span data-ttu-id="bd5b0-326"><paramref name="waitHandles" />jest tablicą bez elementów.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-326"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="bd5b0-327">W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.ArgumentException" />klasy bazowej, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-327">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="bd5b0-328"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-328">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-329">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-329">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="bd5b0-330">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-330">-or-</span></span> 
<span data-ttu-id="bd5b0-331">Ten <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-331">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-332"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-332"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-333">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-333">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-334">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-334">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-335">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-335">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="bd5b0-336"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-336">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="bd5b0-337">Ta tablica nie może zawierać wielu odwołań do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-337">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="bd5b0-338">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-338">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bd5b0-339">Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał, przy użyciu <see cref="T:System.TimeSpan" /> wartości, aby określić interwał czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-339">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-340"><see langword="true" />gdy każdy element w <paramref name="waitHandles" /> programie otrzymał sygnał; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-340"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-341">Jeśli `timeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-341">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-342">Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-342">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-343"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca po zakończeniu oczekiwania, co oznacza, że wszystkie uchwyty są sygnalizowane lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-343">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="bd5b0-344">W przypadku niektórych implementacji, jeśli przechodzą więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-344">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="bd5b0-345">Jeśli tablica zawiera duplikaty, wywołanie zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-345">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bd5b0-346">Metoda nie jest obsługiwana w wątkach, które <xref:System.STAThreadAttribute>mają. <xref:System.Threading.WaitHandle.WaitAll%2A></span><span class="sxs-lookup"><span data-stu-id="bd5b0-346">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="bd5b0-347">Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-347">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bd5b0-348">Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-348">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-349">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-349">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-350">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-350">-or-</span></span> 
<span data-ttu-id="bd5b0-351">Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-351">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-352">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-352">-or-</span></span> 
 <span data-ttu-id="bd5b0-353"><paramref name="waitHandles" />jest tablicą bez elementów.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-353"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="bd5b0-354">W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.ArgumentException" />klasy bazowej, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-354">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="bd5b0-355"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-355">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-356">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-356">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="bd5b0-357">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-357">-or-</span></span> 
<span data-ttu-id="bd5b0-358">Ten <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-358">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-359"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-359"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="bd5b0-360">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-360">-or-</span></span> 
 <span data-ttu-id="bd5b0-361"><paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-361"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-362">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-362">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-363">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-363">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-364">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-364">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="bd5b0-365"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-365">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="bd5b0-366">Ta tablica nie może zawierać wielu odwołań do tego samego obiektu (duplikatów).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-366">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="bd5b0-367">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-367">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="bd5b0-368"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-368"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="bd5b0-369">Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał, przy użyciu <see cref="T:System.Int32" /> wartości, aby określić przedział czasu i określać, czy zamknąć domenę synchronizacji przed oczekiwaniem.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-369">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-370"><see langword="true" />gdy każdy element w <paramref name="waitHandles" /> programie otrzymał sygnał; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-370"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-371">Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-371">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-372">Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-372">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-373"><xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-373"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bd5b0-374">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-374">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bd5b0-375">Porzucony obiekt mutex często wskazuje na poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-375">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bd5b0-376">W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-376">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bd5b0-377">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-377">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bd5b0-378"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca po zakończeniu oczekiwania, co oznacza, gdy wszystkie uchwyty są sygnalizowane lub gdy upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-378">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="bd5b0-379">W przypadku niektórych implementacji, jeśli przechodzą więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-379">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="bd5b0-380">Jeśli w tablicy znajdują się duplikaty, wywołanie kończy się niepowodzeniem <xref:System.DuplicateWaitObjectException>z.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-380">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bd5b0-381">Metoda nie jest obsługiwana w wątkach, które <xref:System.STAThreadAttribute>mają. <xref:System.Threading.WaitHandle.WaitAll%2A></span><span class="sxs-lookup"><span data-stu-id="bd5b0-381">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bd5b0-382">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="bd5b0-382">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bd5b0-383">Parametr nie działa, <xref:System.Threading.WaitHandle.WaitAll%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext`</span><span class="sxs-lookup"><span data-stu-id="bd5b0-383">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bd5b0-384">Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-384">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bd5b0-385">Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-385">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bd5b0-386">Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitAll%2A> kontekstu) przed wykonaniem metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-386">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="bd5b0-387">Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-387">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="bd5b0-388">Może to być przydatne, gdy klasa związana z kontekstem ma <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atrybut.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-388">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="bd5b0-389">W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-389">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bd5b0-390">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-390">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bd5b0-391"><xref:System.Threading.WaitHandle.WaitAll%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-391">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-392">Poniższy przykład kodu pokazuje, jak używać puli wątków do asynchronicznego tworzenia i zapisu do grupy plików.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-392">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="bd5b0-393">Każda operacja zapisu jest umieszczana w kolejce jako element roboczy i sygnalizuje po zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-393">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="bd5b0-394">Główny wątek czeka na wszystkie elementy do sygnalizowania, a następnie opuszcza.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-394">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-395">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-395">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-396">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-396">-or-</span></span> 
<span data-ttu-id="bd5b0-397">Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-397">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-398">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-398">-or-</span></span> 
 <span data-ttu-id="bd5b0-399"><paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 2,0 lub nowsza.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-399"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="bd5b0-400"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-400">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-401">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-401">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="bd5b0-402">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-402">-or-</span></span> 
<span data-ttu-id="bd5b0-403">Ten <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-403">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="bd5b0-404"><paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 1,0 lub 1,1.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-404"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-405"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-405"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-406">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-406">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-407">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-407">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-408">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-408">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="bd5b0-409"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-409">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="bd5b0-410">Ta tablica nie może zawierać wielu odwołań do tego samego obiektu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-410">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="bd5b0-411">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-411">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="bd5b0-412"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-412"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="bd5b0-413">Czeka, aż wszystkie elementy w określonej tablicy otrzymają sygnał, przy użyciu <see cref="T:System.TimeSpan" /> wartości, aby określić przedział czasu, i określić, czy zamknąć domenę synchronizacji przed oczekiwaniem.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-413">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-414"><see langword="true" />gdy każdy element w <paramref name="waitHandles" /> programie otrzymał sygnał; w przeciwnym <see langword="false" />razie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-414"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-415">Jeśli `timeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-415">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-416">Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-416">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-417"><xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-417"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bd5b0-418">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-418">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bd5b0-419">Porzucony obiekt mutex często wskazuje na poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-419">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bd5b0-420">W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-420">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bd5b0-421">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-421">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bd5b0-422"><xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca po zakończeniu oczekiwania, co oznacza, że wszystkie uchwyty są sygnalizowane lub przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-422">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="bd5b0-423">W przypadku niektórych implementacji, jeśli przechodzą więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-423">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="bd5b0-424">Jeśli tablica zawiera duplikaty, wywołanie zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-424">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bd5b0-425">Metoda nie jest obsługiwana w wątkach, które <xref:System.STAThreadAttribute>mają. <xref:System.Threading.WaitHandle.WaitAll%2A></span><span class="sxs-lookup"><span data-stu-id="bd5b0-425">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="bd5b0-426">Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-426">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bd5b0-427">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="bd5b0-427">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bd5b0-428">Parametr nie działa, <xref:System.Threading.WaitHandle.WaitAll%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext`</span><span class="sxs-lookup"><span data-stu-id="bd5b0-428">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bd5b0-429">Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-429">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bd5b0-430">Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-430">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bd5b0-431">Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitAll%2A> kontekstu) przed wykonaniem metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-431">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="bd5b0-432">Powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-432">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="bd5b0-433">Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-433">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bd5b0-434">W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-434">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bd5b0-435">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-435">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bd5b0-436"><xref:System.Threading.WaitHandle.WaitAll%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-436">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-437">Poniższy przykład kodu pokazuje, jak używać puli wątków do asynchronicznego tworzenia i zapisu do grupy plików.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-437">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="bd5b0-438">Każda operacja zapisu jest umieszczana w kolejce jako element roboczy i sygnalizuje po zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-438">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="bd5b0-439">Główny wątek czeka na wszystkie elementy do sygnalizowania, a następnie opuszcza.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-439">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-440">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-440">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-441">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-441">-or-</span></span> 
<span data-ttu-id="bd5b0-442">Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-442">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-443">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-443">-or-</span></span> 
 <span data-ttu-id="bd5b0-444"><paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 2,0 lub nowsza.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-444"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="bd5b0-445"><paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-445">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-446">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-446">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="bd5b0-447">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-447">-or-</span></span> 
<span data-ttu-id="bd5b0-448">Ten <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-448">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="bd5b0-449"><paramref name="waitHandles" />jest tablicą bez elementów, a .NET Framework wersja to 1,0 lub 1,1.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-449"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-450"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-450"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="bd5b0-451">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-451">-or-</span></span> 
 <span data-ttu-id="bd5b0-452"><paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-452"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-453">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-453">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-454">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-454">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-455">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-455">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bd5b0-456">Czeka na dowolny element w określonej tablicy, aby otrzymać sygnał.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-456">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="bd5b0-457"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-457">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="bd5b0-458">Czeka na dowolny element w określonej tablicy, aby otrzymać sygnał.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-458">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-459">Indeks tablicy obiektu spełniającego oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-459">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-460"><xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-460"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bd5b0-461">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zwraca `true` , jeśli oczekiwanie zakończy się, ponieważ obiekt mutex został porzucony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-461">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="bd5b0-462">Porzucony obiekt mutex często wskazuje na poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-462">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bd5b0-463">W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-463">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bd5b0-464">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-464">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bd5b0-465"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda<xref:System.Threading.AbandonedMutexException> zgłasza tylko po zakończeniu oczekiwania z powodu porzuconego obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-465">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="bd5b0-466">Jeśli `waitHandles` zawiera wydanego obiektu mutex o niższym indeksie niż porzucony element <xref:System.Threading.WaitHandle.WaitAny%2A> mutex, Metoda zostanie zakończona normalnie, a wyjątek nie zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-466">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bd5b0-467">W wersjach .NET Framework w wersji starszej niż 2,0, jeśli wątek zostanie zakończony lub przerwany bez <xref:System.Threading.Mutex>jawnie wydawania, a który `Mutex` jest przy indeksie 0 `WaitAny` (zero) w tablicy w innym wątku, indeks zwrócony przez `WaitAny` to 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-467">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="bd5b0-468">Ta metoda zwraca po zasygnalizowaniu dojścia.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-468">This method returns when any handle is signaled.</span></span> <span data-ttu-id="bd5b0-469">Jeśli więcej niż jeden obiekt zostanie zasygnalizowani w trakcie wywołania, wartość zwracana jest indeksem tablicy obiektu sygnalizującego z najmniejszą wartością indeksu wszystkich obiektów sygnalizujących.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-469">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="bd5b0-470">W przypadku niektórych implementacji, jeśli są spełnione więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-470">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="bd5b0-471">Wywołanie tego przeciążenia <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> metody jest równoważne wywołaniu metody przeciążenia i określania-1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-471">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-472">Poniższy przykład kodu demonstruje wywołanie <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-472">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-473">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-473">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-474">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-474">-or-</span></span> 
<span data-ttu-id="bd5b0-475">Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-475">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-476">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-476">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="bd5b0-477"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 1,0 lub 1,1.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-477"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-478">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-478">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-479">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-479">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bd5b0-480"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 2,0 lub nowsza.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-480"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-481">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-481">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="bd5b0-482"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-482">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="bd5b0-483">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-483">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bd5b0-484">Czeka na dowolny element w określonej tablicy, aby otrzymać sygnał, przy użyciu 32-bitowej ze znakiem liczby całkowitej, aby określić interwał czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-484">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-485">Indeks tablicy obiektu, który zakończył oczekiwanie, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie spełnił oczekiwań i przedział czasu <paramref name="millisecondsTimeout" /> odpowiada.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-485">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-486">Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-486">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-487">Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-487">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-488"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda<xref:System.Threading.AbandonedMutexException> zgłasza tylko po zakończeniu oczekiwania z powodu porzuconego obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-488">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="bd5b0-489">Jeśli `waitHandles` zawiera wydanego obiektu mutex o niższym indeksie niż porzucony element <xref:System.Threading.WaitHandle.WaitAny%2A> mutex, Metoda zostanie zakończona normalnie, a wyjątek nie zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-489">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="bd5b0-490">Ta metoda zwraca czas zakończenia oczekiwania, gdy dowolna z uchwytów jest zasygnalizowania lub gdy wystąpi limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-490">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="bd5b0-491">Jeśli więcej niż jeden obiekt zostanie zasygnalizowani w trakcie wywołania, wartość zwracana jest indeksem tablicy obiektu sygnalizującego z najmniejszą wartością indeksu wszystkich obiektów sygnalizujących.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-491">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="bd5b0-492">W przypadku niektórych implementacji, jeśli są spełnione więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-492">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="bd5b0-493">Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-493">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-494">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-494">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-495">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-495">-or-</span></span> 
<span data-ttu-id="bd5b0-496">Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-496">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-497">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-497">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-498"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-498"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-499">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-499">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-500">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-500">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bd5b0-501"><paramref name="waitHandles" />jest tablicą bez elementów.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-501"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-502">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-502">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="bd5b0-503"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-503">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="bd5b0-504">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-504">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bd5b0-505">Czeka na dowolny element w określonej tablicy, aby otrzymać sygnał, przy użyciu parametru <see cref="T:System.TimeSpan" /> do określenia interwału czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-505">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-506">Indeks tablicy obiektu, który zakończył oczekiwanie, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie spełnił oczekiwań i przedział czasu <paramref name="timeout" /> odpowiada.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-506">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-507">Jeśli `timeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-507">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-508">Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-508">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-509"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda<xref:System.Threading.AbandonedMutexException> zgłasza tylko po zakończeniu oczekiwania z powodu porzuconego obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-509">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="bd5b0-510">Jeśli `waitHandles` zawiera wydanego obiektu mutex o niższym indeksie niż porzucony element <xref:System.Threading.WaitHandle.WaitAny%2A> mutex, Metoda zostanie zakończona normalnie, a wyjątek nie zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-510">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="bd5b0-511">Ta metoda zwraca czas zakończenia oczekiwania, gdy dowolna z uchwytów jest zasygnalizowania lub gdy występuje limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-511">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="bd5b0-512">Jeśli więcej niż jeden obiekt zostanie zasygnalizowani w trakcie wywołania, wartość zwracana jest indeksem tablicy obiektu sygnalizującego z najmniejszą wartością indeksu wszystkich obiektów sygnalizujących.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-512">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="bd5b0-513">W przypadku niektórych implementacji, jeśli są spełnione więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-513">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="bd5b0-514">Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-514">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bd5b0-515">Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-515">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-516">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-516">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-517">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-517">-or-</span></span> 
<span data-ttu-id="bd5b0-518">Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-518">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-519">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-519">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-520"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-520"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="bd5b0-521">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-521">-or-</span></span> 
 <span data-ttu-id="bd5b0-522"><paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-522"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-523">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-523">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-524">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-524">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bd5b0-525"><paramref name="waitHandles" />jest tablicą bez elementów.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-525"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-526">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-526">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="bd5b0-527"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-527">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="bd5b0-528">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-528">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="bd5b0-529"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-529"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="bd5b0-530">Czeka, aż którykolwiek z elementów w określonej tablicy otrzyma sygnał przy użyciu 32-bitowej ze znakiem liczby całkowitej, aby określić przedział czasu, i określić, czy zamknąć domenę synchronizacji przed oczekiwaniem.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-530">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-531">Indeks tablicy obiektu, który zakończył oczekiwanie, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie spełnił oczekiwań i przedział czasu <paramref name="millisecondsTimeout" /> odpowiada.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-531">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-532">Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-532">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-533">Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-533">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-534"><xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-534"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bd5b0-535">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zwraca `true` , jeśli oczekiwanie zakończy się, ponieważ obiekt mutex został porzucony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-535">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="bd5b0-536">Porzucony obiekt mutex często wskazuje na poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-536">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bd5b0-537">W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-537">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bd5b0-538">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-538">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bd5b0-539"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda<xref:System.Threading.AbandonedMutexException> zgłasza tylko po zakończeniu oczekiwania z powodu porzuconego obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-539">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="bd5b0-540">Jeśli `waitHandles` zawiera wydanego obiektu mutex o niższym indeksie niż porzucony element <xref:System.Threading.WaitHandle.WaitAny%2A> mutex, Metoda zostanie zakończona normalnie, a wyjątek nie zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-540">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bd5b0-541">W wersjach .NET Framework w wersji starszej niż 2,0, jeśli wątek zostanie zakończony lub przerwany bez <xref:System.Threading.Mutex>jawnie wydawania, a który `Mutex` jest przy indeksie 0 `WaitAny` (zero) w tablicy w innym wątku, indeks zwrócony przez `WaitAny` to 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-541">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="bd5b0-542">Ta metoda zwraca czas zakończenia oczekiwania, gdy dowolna z uchwytów jest zasygnalizowania lub gdy wystąpi limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-542">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="bd5b0-543">Jeśli więcej niż jeden obiekt zostanie zasygnalizowani w trakcie wywołania, wartość zwracana jest indeksem tablicy obiektu sygnalizującego z najmniejszą wartością indeksu wszystkich obiektów sygnalizujących.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-543">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="bd5b0-544">W przypadku niektórych implementacji, jeśli są spełnione więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-544">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bd5b0-545">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="bd5b0-545">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bd5b0-546">Parametr nie działa, <xref:System.Threading.WaitHandle.WaitAny%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext`</span><span class="sxs-lookup"><span data-stu-id="bd5b0-546">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bd5b0-547">Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-547">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bd5b0-548">Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-548">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bd5b0-549">Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitAny%2A> kontekstu) przed wykonaniem metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-549">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="bd5b0-550">Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-550">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="bd5b0-551">Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-551">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bd5b0-552">W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-552">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bd5b0-553">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-553">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bd5b0-554"><xref:System.Threading.WaitHandle.WaitAny%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-554">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-555">Poniższy przykład kodu demonstruje, jak używać puli wątków do jednoczesnego wyszukania pliku na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-555">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="bd5b0-556">W przypadku zagadnień dotyczących miejsca przeszukiwany jest tylko katalog główny każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-556">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-557">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-557">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-558">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-558">-or-</span></span> 
<span data-ttu-id="bd5b0-559">Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-559">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-560">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-560">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="bd5b0-561"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 1,0 lub 1,1.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-561"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-562"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-562"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-563">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-563">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-564">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-564">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bd5b0-565"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 2,0 lub nowsza.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-565"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-566">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-566">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="bd5b0-567"><see langword="WaitHandle" /> Tablica zawierająca obiekty, dla których bieżące wystąpienie będzie oczekiwać.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-567">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="bd5b0-568">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-568">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="bd5b0-569"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-569"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="bd5b0-570">Czeka na dowolne elementy w określonej tablicy, aby otrzymać sygnał, przy użyciu parametru <see cref="T:System.TimeSpan" /> do określenia interwału czasu i określenia, czy zamknąć domenę synchronizacji przed oczekiwaniem.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-570">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-571">Indeks tablicy obiektu, który zakończył oczekiwanie, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt nie spełnił oczekiwań i przedział czasu <paramref name="timeout" /> odpowiada.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-571">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-572">Jeśli `timeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-572">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-573">Sprawdza stan uchwytów oczekiwania i zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-573">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-574"><xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-574"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bd5b0-575">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zwraca `true` , jeśli oczekiwanie zakończy się, ponieważ obiekt mutex został porzucony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-575">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="bd5b0-576">Porzucony obiekt mutex często wskazuje na poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-576">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bd5b0-577">W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-577">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bd5b0-578">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-578">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bd5b0-579"><xref:System.Threading.WaitHandle.WaitAny%2A> Metoda<xref:System.Threading.AbandonedMutexException> zgłasza tylko po zakończeniu oczekiwania z powodu porzuconego obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-579">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="bd5b0-580">Jeśli `waitHandles` zawiera wydanego obiektu mutex o niższym indeksie niż porzucony element <xref:System.Threading.WaitHandle.WaitAny%2A> mutex, Metoda zostanie zakończona normalnie, a wyjątek nie zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-580">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bd5b0-581">W wersjach .NET Framework w wersji starszej niż 2,0, jeśli wątek zostanie zakończony lub przerwany bez <xref:System.Threading.Mutex>jawnie wydawania, a który `Mutex` jest przy indeksie 0 `WaitAny` (zero) w tablicy w innym wątku, indeks zwrócony przez `WaitAny` to 128 zamiast 0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-581">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="bd5b0-582">Ta metoda zwraca czas zakończenia oczekiwania, gdy dowolna z uchwytów jest zasygnalizowania lub gdy występuje limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-582">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="bd5b0-583">Jeśli więcej niż jeden obiekt zostanie zasygnalizowani w trakcie wywołania, wartość zwracana jest indeksem tablicy obiektu sygnalizującego z najmniejszą wartością indeksu wszystkich obiektów sygnalizujących.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-583">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="bd5b0-584">W przypadku niektórych implementacji, jeśli są spełnione więcej niż 64 dojść, <xref:System.NotSupportedException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-584">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="bd5b0-585">Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-585">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bd5b0-586">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="bd5b0-586">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bd5b0-587">Parametr nie działa, <xref:System.Threading.WaitHandle.WaitAny%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext`</span><span class="sxs-lookup"><span data-stu-id="bd5b0-587">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bd5b0-588">Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-588">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bd5b0-589">Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-589">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bd5b0-590">Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitAny%2A> kontekstu) przed wykonaniem metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-590">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="bd5b0-591">Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitAny%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-591">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="bd5b0-592">Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-592">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bd5b0-593">W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-593">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bd5b0-594">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-594">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bd5b0-595"><xref:System.Threading.WaitHandle.WaitAny%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-595">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-596">Poniższy przykład kodu demonstruje, jak używać puli wątków do jednoczesnego wyszukania pliku na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-596">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="bd5b0-597">W przypadku zagadnień dotyczących miejsca przeszukiwany jest tylko katalog główny każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-597">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bd5b0-598">Parametr ma wartość <see langword="null" />. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-598">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="bd5b0-599">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-599">-or-</span></span> 
<span data-ttu-id="bd5b0-600">Co najmniej jeden obiekt w <paramref name="waitHandles" /> tablicy jest. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-600">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="bd5b0-601">Liczba obiektów w programie <paramref name="waitHandles" /> jest większa niż zezwala na system.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-601">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="bd5b0-602"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 1,0 lub 1,1.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-602"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-603"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-603"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="bd5b0-604">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-604">-or-</span></span> 
 <span data-ttu-id="bd5b0-605"><paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-605"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-606">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-606">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-607">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-607">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="bd5b0-608"><paramref name="waitHandles" />jest tablicą bez elementów, a wersja .NET Framework to 2,0 lub nowsza.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-608"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-609">Tablica zawiera przezroczysty serwer proxy <see cref="T:System.Threading.WaitHandle" /> dla w innej domenie aplikacji. <paramref name="waitHandles" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-609">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bd5b0-610">Blokuje bieżący wątek do momentu <see cref="T:System.Threading.WaitHandle" /> odebrania sygnału.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-610">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bd5b0-611">Blokuje bieżący wątek do momentu <see cref="T:System.Threading.WaitHandle" /> odebrania sygnału.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-611">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-612"><see langword="true" />Jeśli bieżące wystąpienie odbiera sygnał.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-612"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="bd5b0-613">Jeśli bieżące wystąpienie nigdy nie jest sygnalizowane, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nigdy nie zwraca.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-613">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-614"><xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-614"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bd5b0-615">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-615">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bd5b0-616">Porzucony obiekt mutex często wskazuje na poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-616">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bd5b0-617">W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-617">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bd5b0-618">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-618">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bd5b0-619">Obiekt wywołujący tę metodę jest blokowany w nieskończoność do momentu odebrania sygnału przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-619">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="bd5b0-620">Użyj tej metody, aby zablokować do <xref:System.Threading.WaitHandle> momentu odebrania sygnału z innego wątku, takiego jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-620">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="bd5b0-621">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejs.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-621">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="bd5b0-622">Wywołanie tego przeciążenia metody jest równoważne wywołaniu <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> metody przeciążenia i określania-1 lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> pierwszego parametru oraz `false` dla drugiego parametru.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-622">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="bd5b0-623">Zastąp tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-623">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-624">Poniższy przykład kodu pokazuje, jak używać dojścia oczekiwania, aby zapobiec zakończeniu procesu podczas oczekiwania na zakończenie wykonywania wątku w tle.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-624">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bd5b0-625">Bieżące wystąpienie zostało już usunięte.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-625">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-626">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-627">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-628">Bieżące wystąpienie jest przezroczystym serwerem proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="bd5b0-629">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-629">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bd5b0-630">Blokuje bieżący wątek do momentu <see cref="T:System.Threading.WaitHandle" /> odebrania sygnału przy użyciu 32-bitowej podpisanej liczby całkowitej w celu określenia interwału czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-630">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-631"><see langword="true" />Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-632">Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-632">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-633">Testuje stan uchwytu oczekiwania i natychmiast wraca.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-634">Obiekt wywołujący tę metodę jest blokowany do momentu odebrania sygnału lub przekroczenia limitu czasu przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="bd5b0-635">Użyj tej metody, aby zablokować do <xref:System.Threading.WaitHandle> momentu odebrania sygnału z innego wątku, takiego jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="bd5b0-636">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejs.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="bd5b0-637">Zastąp tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="bd5b0-638">Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-638">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-639">Poniższy przykład kodu pokazuje, jak używać dojścia oczekiwania, aby zapobiec zakończeniu procesu podczas oczekiwania na zakończenie wykonywania wątku w tle.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-639">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bd5b0-640">Bieżące wystąpienie zostało już usunięte.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-641"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-641"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-642">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-642">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-643">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-643">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-644">Bieżące wystąpienie jest przezroczystym serwerem proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-644">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="bd5b0-645">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-645">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="bd5b0-646">Blokuje bieżący wątek do momentu otrzymania przez bieżące wystąpienie sygnału przy użyciu <see cref="T:System.TimeSpan" /> do określenia interwału czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-646">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-647"><see langword="true" />Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-647"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-648">Jeśli `timeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-648">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-649">Testuje stan uchwytu oczekiwania i natychmiast wraca.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-649">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-650">Obiekt wywołujący tę metodę jest blokowany do momentu odebrania sygnału lub przekroczenia limitu czasu przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-650">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="bd5b0-651">Użyj tej metody, aby zablokować do <xref:System.Threading.WaitHandle> momentu odebrania sygnału z innego wątku, takiego jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-651">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="bd5b0-652">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejs.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-652">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="bd5b0-653">Zastąp tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-653">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="bd5b0-654">Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-654">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bd5b0-655">Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> przeciążenia i określanie `false` dla `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-655">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bd5b0-656">Bieżące wystąpienie zostało już usunięte.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-656">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-657"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-657"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="bd5b0-658">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-658">-or-</span></span> 
 <span data-ttu-id="bd5b0-659"><paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-659"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-660">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-660">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-661">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-661">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-662">Bieżące wystąpienie jest przezroczystym serwerem proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-662">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="bd5b0-663">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-663">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="bd5b0-664"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-664"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="bd5b0-665">Blokuje bieżący wątek do momentu <see cref="T:System.Threading.WaitHandle" /> odebrania sygnału przy użyciu 32-bitowej podpisanej liczby całkowitej w celu określenia interwału czasu i określenia, czy zamknąć domenę synchronizacji przed oczekiwaniem.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-665">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-666"><see langword="true" />Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-666"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-667">Jeśli `millisecondsTimeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-667">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-668">Testuje stan uchwytu oczekiwania i natychmiast wraca.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-668">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-669"><xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-669"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bd5b0-670">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-670">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bd5b0-671">Porzucony obiekt mutex często wskazuje na poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-671">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bd5b0-672">W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-672">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bd5b0-673">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-673">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bd5b0-674">Obiekt wywołujący tę metodę jest blokowany do momentu odebrania sygnału lub przekroczenia limitu czasu przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-674">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="bd5b0-675">Użyj tej metody, aby zablokować do <xref:System.Threading.WaitHandle> momentu odebrania sygnału z innego wątku, takiego jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-675">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="bd5b0-676">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejs.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-676">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="bd5b0-677">Zastąp tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-677">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bd5b0-678">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="bd5b0-678">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bd5b0-679">Parametr nie działa, <xref:System.Threading.WaitHandle.WaitOne%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext`</span><span class="sxs-lookup"><span data-stu-id="bd5b0-679">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bd5b0-680">Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-680">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bd5b0-681">Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-681">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bd5b0-682">Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitOne%2A> kontekstu) przed wykonaniem metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-682">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="bd5b0-683">Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-683">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="bd5b0-684">Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-684">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bd5b0-685">W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-685">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bd5b0-686">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-686">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bd5b0-687"><xref:System.Threading.WaitHandle.WaitOne%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-687">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-688">Poniższy przykład pokazuje, jak działa <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> Przeciążenie metody, gdy jest wywoływana w domenie synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-688">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="bd5b0-689">Najpierw wątek czeka z `exitContext` ustawionym na `false` i bloki do momentu wygaśnięcia limitu czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-689">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="bd5b0-690">Drugi wątek jest wykonywany po zakończeniu pierwszego wątku i czeka `exitContext` na wartość ustawioną na. `true`</span><span class="sxs-lookup"><span data-stu-id="bd5b0-690">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="bd5b0-691">Wywołanie sygnalizujące dojście oczekiwania dla drugiego wątku nie jest blokowane i wątek zostaje zakończony przed upływem limitu czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-691">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bd5b0-692">Bieżące wystąpienie zostało już usunięte.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-692">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-693"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-693"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-694">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-694">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-695">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-695">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-696">Bieżące wystąpienie jest przezroczystym serwerem proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-696">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="bd5b0-697">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-697">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="bd5b0-698"><see langword="true" />Aby wyjść z domeny synchronizacji kontekstu przed oczekiwaniem (jeśli znajduje się w synchronizowanym kontekście) i ponownie pobrać go później; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-698"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="bd5b0-699">Blokuje bieżący wątek do momentu odebrania przez bieżące wystąpienie sygnału przy użyciu <see cref="T:System.TimeSpan" /> do określenia interwału czasu i określenia, czy zamknąć domenę synchronizacji przed oczekiwaniem.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-699">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="bd5b0-700"><see langword="true" />Jeśli bieżące wystąpienie odbiera sygnał; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="bd5b0-700"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-701">Jeśli `timeout` jest równa zero, metoda nie jest blokowana.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-701">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bd5b0-702">Testuje stan uchwytu oczekiwania i natychmiast wraca.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-702">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="bd5b0-703"><xref:System.Threading.AbandonedMutexException>Nowość w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-703"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bd5b0-704">W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> Metoda zwraca `true` , gdy obiekt mutex został porzucony.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-704">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bd5b0-705">Porzucony obiekt mutex często wskazuje na poważny błąd kodowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-705">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bd5b0-706">W przypadku obiektu mutex w całym systemie może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="bd5b0-706">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bd5b0-707">Wyjątek zawiera informacje przydatne podczas debugowania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-707">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bd5b0-708">Obiekt wywołujący tę metodę jest blokowany do momentu odebrania sygnału lub przekroczenia limitu czasu przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-708">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="bd5b0-709">Użyj tej metody, aby zablokować do <xref:System.Threading.WaitHandle> momentu odebrania sygnału z innego wątku, takiego jak jest generowany po zakończeniu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-709">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="bd5b0-710">Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejs.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-710">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="bd5b0-711">Zastąp tę metodę, aby dostosować zachowanie klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-711">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="bd5b0-712">Maksymalna wartość parametru `timeout` to <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-712">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bd5b0-713">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="bd5b0-713">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bd5b0-714">Parametr nie działa, <xref:System.Threading.WaitHandle.WaitOne%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego. `exitContext`</span><span class="sxs-lookup"><span data-stu-id="bd5b0-714">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bd5b0-715">Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-715">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bd5b0-716">Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-716">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bd5b0-717">Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.WaitHandle.WaitOne%2A> kontekstu) przed wykonaniem metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-717">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="bd5b0-718">Wątek powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-718">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="bd5b0-719">Może to być przydatne, gdy klasa związana z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>ma.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-719">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bd5b0-720">W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-720">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bd5b0-721">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-721">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bd5b0-722"><xref:System.Threading.WaitHandle.WaitOne%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-722">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-723">Poniższy przykład kodu pokazuje, jak używać dojścia oczekiwania, aby zapobiec zakończeniu procesu podczas oczekiwania na zakończenie wykonywania wątku w tle.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-723">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="bd5b0-724">Bieżące wystąpienie zostało już usunięte.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-724">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="bd5b0-725"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-725"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="bd5b0-726">—lub—</span><span class="sxs-lookup"><span data-stu-id="bd5b0-726">-or-</span></span> 
 <span data-ttu-id="bd5b0-727"><paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-727"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="bd5b0-728">Oczekiwanie zakończono, ponieważ wątek zakończył pracę bez zwalniania elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-728">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="bd5b0-729">Ten wyjątek nie jest zgłaszany w systemie Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-729">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="bd5b0-730">Bieżące wystąpienie jest przezroczystym serwerem proxy dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-730">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="bd5b0-731">Wskazuje, że <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> upłynął limit czasu operacji przed zasygnalizowaniem dowolnego z dojść oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-731">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="bd5b0-732">To pole jest stałe.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-732">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd5b0-733">To pole jest jedną z możliwych wartości `WaitAny`zwracanych.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-733">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bd5b0-734">Poniższy przykład kodu demonstruje, jak używać puli wątków do jednoczesnego wyszukania pliku na wielu dyskach.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-734">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="bd5b0-735">W przypadku zagadnień dotyczących miejsca przeszukiwany jest tylko katalog główny każdego dysku.</span><span class="sxs-lookup"><span data-stu-id="bd5b0-735">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

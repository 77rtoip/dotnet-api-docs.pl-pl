<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="092df8a132c6280f7c2111bcb3ab0226334bc0f4" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407057" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Podstawowy synchronizacji, które może być również używane do synchronizacji międzyprocesowej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po dwóch lub więcej wątków muszą uzyskać dostęp do udostępnionego zasobu w tym samym czasie, których system potrzebuje mechanizm synchronizacji, aby upewnić się, że tylko jeden wątek jednocześnie używa zasobu. <xref:System.Threading.Mutex> Synchronizacja jest pierwotnych, który daje wyłącznego dostępu do udostępnionego zasobu tylko jednego wątku. Wątek nabędzie obiektu mutex, drugi wątku, który chce uzyskać tego obiektu mutex został wstrzymany, dopóki pierwszym wątkiem zwalnia obiektu mutex.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 Można użyć <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metoda żądania własności obiektu mutex. Wywołania wątku bloki dopóki nie wystąpi jedno z następujących czynności:  
  
-   Obiektu mutex jest informowany wskazują, że nie jest właścicielem. W takim przypadku <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true`, a wątek wywołujący przejmuje obiektu mutex i uzyskuje dostęp do zasobów chronionych przez obiektu mutex. Po zakończeniu dostęp do zasobu, należy wywołać wątku <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę, aby zwolnić prawo własności obiektu mutex. W sekcji przykładów w pierwszym przykładzie przedstawiono tego wzorca.  
  
-   Limit czasu określony w wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> metodę, która ma `millisecondsTimeout` lub `timeout` parametru upłynął. W takim przypadku <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `false`, a wątek wywołujący sprawia, że dalsze próby uzyskania prawa własności obiektu mutex. W takim przypadku należy struktury kodu tak, aby w wątku wywołującym odmówiono dostępu do zasobu, która jest chroniona przez obiektu mutex. Ponieważ wątek nigdy nie uzyskać prawo własności obiektu mutex, nie należy wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metody. W sekcji przykładów w drugim przykładzie przedstawiono tego wzorca.  
  
 <xref:System.Threading.Mutex> Klasy wymusza tożsamości wątku, dlatego może być zwolnione obiektu mutex tylko przez wątek, do którego został uzyskany. Z kolei <xref:System.Threading.Semaphore> klasa nie obsługuje wymuszania tożsamości wątku. Mutex również mogą być przekazywane między granicami domeny aplikacji.  
  
 Wątek, który jest właścicielem obiektu mutex może zażądać tego samego obiektu mutex w wywołaniach powtarzane <xref:System.Threading.WaitHandle.WaitOne%2A> bez blokowanie jego wykonania. Jednak należy wywołać wątku <xref:System.Threading.Mutex.ReleaseMutex%2A> metody taką samą liczbę razy, aby zwolnić prawo własności obiektu mutex.  
  
 Ponieważ <xref:System.Threading.Mutex> klasa dziedziczy <xref:System.Threading.WaitHandle>, możesz także wywołać statycznych <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> i <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metody synchronizujący dostęp do chronionych zasobów.  
  
 Zakończenie wątku podczas będący właścicielem obiektu mutex, jest nazywany porzucony obiektu mutex. Stan obiektu mutex ustawiono sygnalizowane i następnego wątku oczekiwania pobiera własności. Począwszy od wersji 2.0 programu .NET Framework, <xref:System.Threading.AbandonedMutexException> jest zgłaszany w następnym wątku, który uzyskuje porzuconego elementu mutex. Przed programu .NET Framework w wersji 2.0 nie zgłoszono wyjątek.  
  
> [!CAUTION]
>  Porzuconego elementu mutex często oznacza to poważny błąd w kodzie. Wątek kończy działanie bez zwolnienia obiektu mutex, struktur danych chronionych przez obiektu mutex może być w stanie spójności. Następnego wątku własności obiektu mutex żądania obsługi tego wyjątku i kontynuować, jeśli można sprawdzić integralność struktury danych.  
  
 W przypadku obiektu mutex systemowe porzuconego elementu mutex może wskazywać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).  
  
 Istnieją dwa typy muteksy: muteksy lokalne, które nienazwanych i nazwanych muteksy systemu. Mutex lokalny istnieje tylko w ramach procesu. Może służyć przez wszystkie wątki procesu, który zawiera odwołanie do <xref:System.Threading.Mutex> obiekt, który reprezentuje obiektu mutex. Każdy nienazwane <xref:System.Threading.Mutex> obiekt reprezentuje oddzielny lokalny obiektu mutex.  
  
 O nazwie system Muteksy są widoczne w systemie operacyjnym i może służyć do synchronizowania działania procesów. Można utworzyć <xref:System.Threading.Mutex> obiekt, który reprezentuje system nazwanego obiektu mutex przy użyciu konstruktora akceptującego nazwę. Obiekt systemu operacyjnego można tworzyć w tym samym czasie lub może istnieć przed tworzeniem <xref:System.Threading.Mutex> obiektu. Możesz utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują takie same nazwanego obiektu mutex systemu i może używać <xref:System.Threading.Mutex.OpenExisting%2A> metodę, aby otworzyć istniejące nazwanego obiektu mutex systemu.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe system nazwanego obiektu mutex ma dwa poziomy widoczności. Jeśli jej nazwa rozpoczyna się od prefiksu "Global\\", jest widoczne we wszystkich sesjach serwera terminali obiektu mutex. Jeśli jej nazwa rozpoczyna się od prefiksu "lokalnego\\", obiektu mutex jest widoczna tylko w sesji serwera terminali, której został utworzony. W takim przypadku oddzielnego obiektu mutex o takiej samej nazwie może istnieć w każdym z innych sesji serwera terminali na serwerze. Jeżeli nie określisz prefiksu, podczas tworzenia nazwanego obiektu mutex, trwa prefiks "lokalnego\\". W sesji serwera terminali dwóch muteksy, których nazwy różnią się tylko wielkością ich prefiksów są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksu "Global\\" i "lokalnego\\" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, a nie względem procesów.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 W tym przykładzie pokazano, jak lokalnie <xref:System.Threading.Mutex> obiektu służy do synchronizowania dostępu do chronionego zasobu. Ponieważ każdy wątek wywołujący jest zablokowany do czasu jej uzyskuje prawo własności obiektu mutex, należy wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę, aby zwolnić własność wątku.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 W poniższym przykładzie wywołanie każdy wątek <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> metody można uzyskać obiektu mutex. Jeśli upłynie limit czasu, metoda zwraca `false`, i wątku nie uzyskuje obiektu mutex ani uzyskuje dostęp do zasobów chroni obiektu mutex. <xref:System.Threading.Mutex.ReleaseMutex%2A> Metoda jest wywoływana tylko przez wątek, który uzyskuje obiektu mutex.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasy przy użyciu domyślnej właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tego przeciążenia konstruktora jest taka sama jak wywołanie <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> przeładowania konstruktora i określając `false` dla początkowego własności obiektu mutex. Oznacza to, że wątek wywołujący nie jest właścicielem obiektu mutex.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu lokalnego <xref:System.Threading.Mutex> obiektu służy do synchronizowania dostępu do chronionego zasobu. Wątek, który tworzy obiektu mutex nie ma ona początkowo.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> Aby zapewnić wywołania wątku początkowej prawo własności obiektu mutex; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasy z wartość logiczną wskazującą, czy wątek wywołujący powinien mieć początkowej własności obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przedstawia przykład sposobu lokalnego <xref:System.Threading.Mutex> obiektu służy do synchronizowania dostępu do chronionego zasobu. Wątek, który tworzy <xref:System.Threading.Mutex> początkowo jest właścicielem.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> Aby zapewnić wywoływania własność początkowej wątku systemu nazwanego obiektu mutex mutex systemu o nazwie zostanie utworzony w wyniku tego wywołania; w przeciwnym razie <see langword="false" />.</param>
        <param name="name">Nazwa <see cref="T:System.Threading.Mutex" />. Jeśli wartość jest <see langword="null" />, <see cref="T:System.Threading.Mutex" /> jest bez nazwy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasy z wartość logiczną wskazującą, czy wątek wywołujący powinien mieć początkowej własności obiektu mutex i ciąg, który jest nazwą obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` nie jest `null` i `initiallyOwned` jest `true`, wątek wywołujący jest właścicielem obiektu mutex tylko wtedy, gdy system nazwanego obiektu mutex został utworzony w wyniku tego wywołania. Ponieważ nie ma mechanizmu ustalania, czy system nazwanego obiektu mutex został utworzony, to lepiej określić `false` dla `initiallyOwned` podczas wywoływania tej przeładowania konstruktora. Można użyć <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> konstruktora, jeśli trzeba określić własność początkowej.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt, który reprezentuje system nazwanego obiektu mutex. Możesz utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują takie same nazwanego obiektu mutex systemu.  
  
 Jeśli nazwanego obiektu mutex została już utworzona z kontrolę dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, jest zgłaszany wyjątek. Aby otworzyć istniejące nazwanego obiektu mutex tylko uprawnienia niezbędne do synchronizowania wątku działań, zobacz <xref:System.Threading.Mutex.OpenExisting%2A> metody.  
  
 Jeśli określisz `null` lub pusty ciąg `name`, lokalnego obiektu mutex jest tworzony tak, jakby były nazywane <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> konstruktora. W takim przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ są one systemowe, muteksy nazwanego może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe system nazwanego obiektu mutex ma dwa poziomy widoczności. Jeśli jej nazwa rozpoczyna się od prefiksu "Global\\", jest widoczne we wszystkich sesjach serwera terminali obiektu mutex. Jeśli jej nazwa rozpoczyna się od prefiksu "lokalnego\\", obiektu mutex jest widoczna tylko w sesji serwera terminali, której został utworzony. W takim przypadku oddzielnego obiektu mutex o takiej samej nazwie może istnieć w każdym z innych sesji serwera terminali na serwerze. Jeżeli nie określisz prefiksu, podczas tworzenia nazwanego obiektu mutex, trwa prefiks "lokalnego\\". W sesji serwera terminali dwóch muteksy, których nazwy różnią się tylko wielkością ich prefiksów są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksu "Global\\" i "lokalnego\\" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, a nie względem procesów.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 W poniższym przykładzie pokazano, jak nazwanego obiektu mutex jest używany do między wątki uruchomione w dwa osobne procesy.  
  
 Uruchom ten program z co najmniej dwa polecenia systemu windows. Każdy proces tworzy <xref:System.Threading.Mutex> obiekt, który reprezentuje nazwanego obiektu mutex `MyMutex`. Nazwanego obiektu mutex to obiekt systemowy, którego okres istnienia jest ograniczone przez okresy istnienia <xref:System.Threading.Mutex> obiektów, które reprezentują go. Nazwanego obiektu mutex jest tworzony podczas pierwszego procesu tworzy jego <xref:System.Threading.Mutex> obiektu; w tym przykładzie nazwanego obiektu mutex jest własnością pierwszego procesu, który uruchamia program. Nazwanego obiektu mutex jest niszczony podczas wszystkich <xref:System.Threading.Mutex> obiektów, które reprezentują go zostały wydane.  
  
 Przeładowania konstruktora używana w tym przykładzie nie wiadomo wątek wywołujący czy przyznano początkowej własność nazwanego obiektu mutex. Ten konstruktor nie należy używać do żądania początkowego własność, o ile nie może mieć pewność, że wątek utworzy nazwanego obiektu mutex.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Nazwanego obiektu mutex istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwanego obiektu mutex nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> Aby zapewnić wywoływania własność początkowej wątku systemu nazwanego obiektu mutex mutex systemu o nazwie zostanie utworzony w wyniku tego wywołania; w przeciwnym razie <see langword="false" />.</param>
        <param name="name">Nazwa <see cref="T:System.Threading.Mutex" />. Jeśli wartość jest <see langword="null" />, <see cref="T:System.Threading.Mutex" /> jest bez nazwy.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera wartość logiczna, która jest <see langword="true" /> Jeśli utworzono lokalnego obiektu mutex (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> lub ciąg pusty) lub jeśli utworzono określony system nazwanego obiektu mutex; <see langword="false" /> Jeśli określonego nazwanego obiektu mutex systemu już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> z wartość logiczną wskazującą, czy wątek wywołujący powinien mieć początkowej własności obiektu mutex, ciąg określający nazwę obiektu mutex i wartość logiczną wskazującą, gdy metoda zwróci wartość, Określa, czy wątek wywołujący uzyskał początkowej własności obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` nie jest `null` i `initiallyOwned` jest `true`, wątek wywołujący jest właścicielem nazwanego obiektu mutex tylko wtedy, gdy `createdNew` jest `true` po wywołaniu. W przeciwnym razie wątku mogą żądać obiektu mutex przez wywołanie metody <xref:System.Threading.WaitHandle.WaitOne%2A> metody.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt, który reprezentuje system nazwanego obiektu mutex. Możesz utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują takie same nazwanego obiektu mutex systemu.  
  
 Jeśli nazwanego obiektu mutex została już utworzona z kontrolę dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> praw, jest zgłaszany wyjątek. Aby otworzyć istniejące nazwanego obiektu mutex tylko uprawnienia niezbędne do synchronizowania wątku działań, zobacz <xref:System.Threading.Mutex.OpenExisting%2A> metody.  
  
 Jeśli określisz `null` lub pusty ciąg `name`, lokalnego obiektu mutex jest tworzony tak, jakby były nazywane <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> konstruktora. W takim przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ są one systemowe, muteksy nazwanego może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe system nazwanego obiektu mutex ma dwa poziomy widoczności. Jeśli jej nazwa rozpoczyna się od prefiksu "Global\\", jest widoczne we wszystkich sesjach serwera terminali obiektu mutex. Jeśli jej nazwa rozpoczyna się od prefiksu "lokalnego\\", obiektu mutex jest widoczna tylko w sesji serwera terminali, której został utworzony. W takim przypadku oddzielnego obiektu mutex o takiej samej nazwie może istnieć w każdym z innych sesji serwera terminali na serwerze. Jeżeli nie określisz prefiksu, podczas tworzenia nazwanego obiektu mutex, trwa prefiks "lokalnego\\". W sesji serwera terminali dwóch muteksy, których nazwy różnią się tylko wielkością ich prefiksów są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksu "Global\\" i "lokalnego\\" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, a nie względem procesów.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak nazwanego obiektu mutex jest używany do między procesów i wątków. Uruchom ten program z co najmniej dwa polecenia systemu windows. Każdy proces tworzy <xref:System.Threading.Mutex> obiekt, który reprezentuje nazwanego obiektu mutex "MyMutex". Nazwanego obiektu mutex jest obiektem systemu. W tym przykładzie jego okres istnienia jest ograniczone przez okresy istnienia <xref:System.Threading.Mutex> obiektów, które reprezentują go. Nazwanego obiektu mutex jest tworzony podczas pierwszego procesu tworzy jego lokalnego <xref:System.Threading.Mutex> obiektu i zniszczona, gdy wszystkie <xref:System.Threading.Mutex> obiektów, które reprezentują go zostały wydane. Właścicielem nazwanego obiektu mutex jest początkowo pierwszego procesu. Druga procedura i wszystkie kolejne procesy poczekaj procesów wcześniejszych wersji nazwanego obiektu mutex.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Nazwanego obiektu mutex istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwanego obiektu mutex nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> Aby zapewnić wywoływania własność początkowej wątku systemu nazwanego obiektu mutex mutex systemu o nazwie zostanie utworzony w wyniku tego wywołania; w przeciwnym razie <see langword="false" />.</param>
        <param name="name">Nazwa obiektu mutex systemu. Jeśli wartość jest <see langword="null" />, <see cref="T:System.Threading.Mutex" /> jest bez nazwy.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera wartość logiczna, która jest <see langword="true" /> Jeśli utworzono lokalnego obiektu mutex (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> lub ciąg pusty) lub jeśli utworzono określony system nazwanego obiektu mutex; <see langword="false" /> Jeśli określonego nazwanego obiektu mutex systemu już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> obiekt, który reprezentuje kontrolę dostępu ma zostać zastosowany do systemu nazwanego obiektu mutex.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasy z wartość logiczną wskazującą, czy wątek wywołujący powinien mieć początkowej prawo własności obiektu mutex, ciąg określający nazwę obiektu mutex, wskazujący, gdy metoda zwróci wartość, wartość logiczna Określa, czy wątek wywołujący uzyskał początkowej własności obiektu mutex i kontrolę dostępu ma zostać zastosowany do nazwanego obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` nie jest `null` i `initiallyOwned` jest `true`, wątek wywołujący jest właścicielem nazwanego obiektu mutex tylko wtedy, gdy `createdNew` jest `true` po wywołaniu. W przeciwnym razie wątku mogą żądać obiektu mutex przez wywołanie metody <xref:System.Threading.WaitHandle.WaitOne%2A> metody.  
  
 Użyj tego konstruktora, aby zastosować kontrolę dostępu do systemu nazwanego obiektu mutex podczas jego tworzenia, uniemożliwia pobieranie formantu obiektu mutex innego kodu.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt, który reprezentuje system nazwanego obiektu mutex. Możesz utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują takie same nazwanego obiektu mutex systemu.  
  
 Jeśli system nazwanego obiektu mutex nie istnieje, jest tworzony z określonym kontrolę dostępu. Jeśli istnieje nazwanego obiektu mutex, określony kontrolę dostępu jest ignorowane.  
  
> [!NOTE]
>  Obiekt wywołujący ma pełną kontrolę nad nowo utworzony <xref:System.Threading.Mutex> nawet wtedy, gdy obiekt `mutexSecurity` nie zezwala lub nie powiedzie się pewne prawa dostępu do bieżącego użytkownika. Jednak jeśli bieżący użytkownik próbuje pobrać inny <xref:System.Threading.Mutex> obiekt, do reprezentowania takie same nazwanego obiektu mutex, za pomocą konstruktora lub <xref:System.Threading.Mutex.OpenExisting%2A> zastosowano kontrolę dostępu w systemie Windows metody.  
  
 Jeśli nazwanego obiektu mutex została już utworzona z kontrolę dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, jest zgłaszany wyjątek. Aby otworzyć istniejące nazwanego obiektu mutex tylko uprawnienia niezbędne do synchronizowania wątku działań, zobacz <xref:System.Threading.Mutex.OpenExisting%2A> metody.  
  
 Jeśli określisz `null` lub pusty ciąg `name`, lokalnego obiektu mutex jest tworzony tak, jakby były nazywane <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> konstruktora. W takim przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ są one systemowe, muteksy nazwanego może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe system nazwanego obiektu mutex ma dwa poziomy widoczności. Jeśli jej nazwa rozpoczyna się od prefiksu "Global\\", jest widoczne we wszystkich sesjach serwera terminali obiektu mutex. Jeśli jej nazwa rozpoczyna się od prefiksu "lokalnego\\", obiektu mutex jest widoczna tylko w sesji serwera terminali, której został utworzony. W takim przypadku oddzielnego obiektu mutex o takiej samej nazwie może istnieć w każdym z innych sesji serwera terminali na serwerze. Jeżeli nie określisz prefiksu, podczas tworzenia nazwanego obiektu mutex, trwa prefiks "lokalnego\\". W sesji serwera terminali dwóch muteksy, których nazwy różnią się tylko wielkością ich prefiksów są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksu "Global\\" i "lokalnego\\" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, a nie względem procesów.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa nazwanego obiektu mutex z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenie metody, aby przetestować obecność nazwanego obiektu mutex.  
  
 Jeśli obiektu mutex nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania obiektu mutex, ale daje prawo do odczytu, a zmiana uprawnień do obiektu mutex.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenie metody można otworzyć z uprawnień niezbędnych do odczytu i zmienić uprawnienia obiektu mutex.  
  
 Po zmianie są uprawnienia obiektu mutex jest otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwanego obiektu mutex istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwanego obiektu mutex nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.MutexSecurity" /> obiekt, który reprezentuje kontrolę dostępu dla nazwanego obiektu mutex.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.MutexSecurity" /> obiekt, który reprezentuje kontrolę dostępu dla nazwanego obiektu mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A> Metoda używa następujących kombinacji flag (połączone, przy użyciu operacji bitowej OR) do wyszukania uprawnienia: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> wywołanie tej metody i obiektu mutex musi została otwarta z <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa nazwanego obiektu mutex z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenie metody, aby przetestować obecność nazwanego obiektu mutex.  
  
 Jeśli obiektu mutex nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania obiektu mutex, ale daje prawo do odczytu, a zmiana uprawnień do obiektu mutex.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenie metody, aby otworzyć obiektu mutex z uprawnień wymaganych do odczytu, a zmiana uprawnień, przy użyciu <xref:System.Threading.Mutex.GetAccessControl%2A> i <xref:System.Threading.Mutex.SetAccessControl%2A> metody.  
  
 Po zmianie są uprawnienia obiektu mutex jest otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący <see cref="T:System.Threading.Mutex" /> obiekt reprezentuje system nazwanego obiektu mutex, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  - lub - bieżącego <see cref="T:System.Threading.Mutex" /> obiekt reprezentuje system nazwanego obiektu mutex, a nie została otwarta z <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Nie jest obsługiwane dla systemu Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu mutex systemu, aby otworzyć.</param>
        <summary>Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje.</summary>
        <returns>Obiekt, który reprezentuje system nazwanego obiektu mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> Metody spróbuje otworzyć określonego nazwanego obiektu mutex systemu. Jeśli system obiektu mutex nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia obiektu systemowego. Aby utworzyć obiektu mutex systemu, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Mutex.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Tej metody należy użyć tej samej wartości dla wielu wywołań `name` nie musi zwracać taki sam <xref:System.Threading.Mutex> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego obiektu mutex systemu o nazwie.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenie metody i określając <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> praw, połączone przy użyciu operacji lub.  
  
 Określanie <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku oczekiwania na obiektu mutex i określając <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątku w celu wywołania <xref:System.Threading.Mutex.ReleaseMutex%2A> — metoda.  
  
 Ta metoda nie żąda prawo własności obiektu mutex.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa nazwanego obiektu mutex z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenie metody, aby przetestować obecność nazwanego obiektu mutex.  
  
 Jeśli obiektu mutex nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania obiektu mutex, ale daje prawo do odczytu, a zmiana uprawnień do obiektu mutex.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenie metody można otworzyć z uprawnień niezbędnych do odczytu i zmienić uprawnienia obiektu mutex.  
  
 Po zmianie są uprawnienia obiektu mutex jest otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwanego obiektu mutex nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Istnieje nazwanego obiektu mutex, ale użytkownik nie ma dostępu zabezpieczeń, trzeba go używać.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu mutex systemu, aby otworzyć.</param>
        <param name="rights">Bitowe połączenie wartości wyliczenia, które reprezentują dostęp wymaganymi.</param>
        <summary>Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje, z wymaganymi dostępu.</summary>
        <returns>Obiekt, który reprezentuje system nazwanego obiektu mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Parametr musi zawierać <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flagę wątków, aby czekać na obiektu mutex i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flagę wątków, aby wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metody.  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> Metoda próbuje otworzyć istniejące nazwanego obiektu mutex. Jeśli system obiektu mutex nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia obiektu systemowego. Aby utworzyć obiektu mutex systemu, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Mutex.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Tej metody należy użyć tej samej wartości dla wielu wywołań `name` nie musi zwracać taki sam <xref:System.Threading.Mutex> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego obiektu mutex systemu o nazwie.  
  
 Ta metoda nie żąda prawo własności obiektu mutex.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa nazwanego obiektu mutex z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenie metody, aby przetestować obecność nazwanego obiektu mutex.  
  
 Jeśli obiektu mutex nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania obiektu mutex, ale daje prawo do odczytu, a zmiana uprawnień do obiektu mutex.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenie metody można otworzyć z uprawnień niezbędnych do odczytu i zmienić uprawnienia obiektu mutex.  
  
 Po zmianie są uprawnienia obiektu mutex jest otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwanego obiektu mutex nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Istnieje nazwanego obiektu mutex, ale użytkownik nie ma dostępu do żądanego zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wersje <see cref="T:System.Threading.Mutex" /> po.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zawsze, gdy wątek uzyskuje obiektu mutex (na przykład przez wywołanie jego <xref:System.Threading.WaitHandle.WaitOne%2A> — metoda), następnie należy wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> zrzeka prawo własności obiektu mutex i odblokować innych wątków, które próbują uzyskać prawo własności obiektu mutex. Jeśli próba pobrania prawo własności obiektu mutex zakończy się niepowodzeniem (na przykład, gdy wywołanie <xref:System.Threading.WaitHandle.WaitOne%2A> metody z `millisecondsTimeout` lub `timeout` zwraca parametr `false` ponieważ limit czasu żądania), wątek nie należy wywoływać <xref:System.Threading.Mutex.ReleaseMutex%2A>, w tym przypadku wątku również nie powinien być dozwolony dostęp do zasobu chronione przez obiektu mutex, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Wątek, który jest właścicielem obiektu mutex można określić tego samego obiektu mutex oczekiwania powtarzane wywołania funkcji bez blokowania jego wykonywania. Liczba wywołań jest przechowywany przez środowisko uruchomieniowe języka wspólnego. Wątek należy wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> taką samą liczbę razy, aby zwolnić prawo własności obiektu mutex.  
  
 Zakończenie wątku podczas będący właścicielem obiektu mutex, jest nazywany porzucony obiektu mutex. Stan obiektu mutex jest ustawiona na sygnałowego i następnego wątku oczekiwania pobiera własności. Jeśli nie jest właścicielem obiektu mutex, zostanie zasygnalizowane stan obiektu mutex. Począwszy od wersji 2.0 programu .NET Framework, <xref:System.Threading.AbandonedMutexException> jest zgłaszany w następnym wątku, który uzyskuje obiektu mutex. Przed programu .NET Framework w wersji 2.0 nie zgłoszono wyjątek.  
  
> [!CAUTION]
>  Porzuconego elementu mutex często oznacza to poważny błąd w kodzie. Wątek kończy działanie bez zwolnienia obiektu mutex, struktur danych chronionych przez obiektu mutex może być w stanie spójności. Następnego wątku własności obiektu mutex żądania obsługi tego wyjątku i kontynuować, jeśli można sprawdzić integralność struktury danych.  
  
 W przypadku obiektu mutex systemowe porzuconego elementu mutex może wskazywać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak lokalnie <xref:System.Threading.Mutex> obiektu służy do synchronizowania dostępu do chronionego zasobu. Wątek, który tworzy obiektu mutex nie ma ona początkowo. <xref:System.Threading.Mutex.ReleaseMutex%2A> Metoda jest używana do zwolnienia obiektu mutex, gdy nie jest już potrzebne.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Wątek wywołujący nie jest właścicielem obiektu mutex.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> obiekt, który reprezentuje kontrolę dostępu ma zostać zastosowany do systemu nazwanego obiektu mutex.</param>
        <summary>Ustawia kontrolę dostępu do systemu nazwanego obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi mieć <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> praw, aby wywołać tę metodę i obiektu mutex musi została otwarta z <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa nazwanego obiektu mutex z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenie metody, aby przetestować obecność nazwanego obiektu mutex.  
  
 Jeśli obiektu mutex nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania obiektu mutex, ale daje prawo do odczytu, a zmiana uprawnień do obiektu mutex.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenie metody, aby otworzyć obiektu mutex z uprawnień wymaganych do odczytu, a zmiana uprawnień, przy użyciu <xref:System.Threading.Mutex.GetAccessControl%2A> i <xref:System.Threading.Mutex.SetAccessControl%2A> metody.  
  
 Po zmianie są uprawnienia obiektu mutex jest otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  - lub - obiektu mutex nie został otwarty z <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">Bieżący <see cref="T:System.Threading.Mutex" /> obiekt nie reprezentuje system nazwanego obiektu mutex.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu mutex systemu, aby otworzyć.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.Mutex" /> obiekt, który reprezentuje nazwanego obiektu mutex, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie zakończyło się niepowodzeniem. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwanego obiektu mutex została otwarta pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwanego obiektu mutex nie istnieje, ta metoda nie utworzy go. Aby utworzyć obiektu mutex systemu, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Mutex.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Jeśli masz pewności, czy istnieje nazwanego obiektu mutex, użyj tego przeciążenia metody zamiast <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenie metody, która zgłasza wyjątek, jeśli obiektu mutex nie istnieje.  
  
 Tej metody należy użyć tej samej wartości dla wielu wywołań `name` nie musi zwracać taki sam <xref:System.Threading.Mutex> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego obiektu mutex systemu o nazwie.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> przeciążenie metody i określając <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> praw, połączone przy użyciu operacji lub. Określanie <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku oczekiwania na obiektu mutex i określając <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątku w celu wywołania <xref:System.Threading.Mutex.ReleaseMutex%2A> — metoda.  
  
 Ta metoda nie żąda prawo własności obiektu mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Istnieje nazwanego obiektu mutex, ale użytkownik nie ma dostępu zabezpieczeń, trzeba go używać.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu mutex systemu, aby otworzyć.</param>
        <param name="rights">Bitowe połączenie wartości wyliczenia, które reprezentują dostęp wymaganymi.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.Mutex" /> obiekt, który reprezentuje nazwanego obiektu mutex, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie zakończyło się niepowodzeniem. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje z wymaganymi dostęp i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwanego obiektu mutex została otwarta pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwanego obiektu mutex nie istnieje, ta metoda nie utworzy go. Aby utworzyć obiektu mutex systemu, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Mutex.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Jeśli masz pewności, czy istnieje nazwanego obiektu mutex, użyj tego przeciążenia metody zamiast <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenie metody, która zgłasza wyjątek, jeśli obiektu mutex nie istnieje.  
  
 `rights` Parametr musi zawierać <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flagę wątków, aby czekać na obiektu mutex i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flagę wątków, aby wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metody.  
  
 Tej metody należy użyć tej samej wartości dla wielu wywołań `name` nie musi zwracać taki sam <xref:System.Threading.Mutex> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego obiektu mutex systemu o nazwie.  
  
 Ta metoda nie żąda prawo własności obiektu mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Istnieje nazwanego obiektu mutex, ale użytkownik nie ma dostępu zabezpieczeń, trzeba go używać.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
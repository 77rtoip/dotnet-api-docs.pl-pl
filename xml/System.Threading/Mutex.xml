<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Mutex.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac56bce0feaf14f66f8608164cfa777620d7f3b329f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6bce0feaf14f66f8608164cfa777620d7f3b329f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>A synchronization primitive that can also be used for interprocess synchronization.</source>
          <target state="translated">Podstawowy synchronizacji, które może być również używane do synchronizacji międzyprocesowej.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</source>
          <target state="translated">Po dwóch lub więcej wątków muszą uzyskać dostęp do udostępnionego zasobu w tym samym czasie, których system potrzebuje mechanizm synchronizacji, aby upewnić się, że tylko jeden wątek jednocześnie używa zasobu.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Synchronizacja jest pierwotnych, który daje wyłącznego dostępu do udostępnionego zasobu tylko jednego wątku.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</source>
          <target state="translated">Wątek nabędzie obiektu mutex, drugi wątku, który chce uzyskać tego obiektu mutex został wstrzymany, dopóki pierwszym wątkiem zwalnia obiektu mutex.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Ten typ implementuje <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Do usuwania tego typu, należy wywołać jej <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> metody w <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloku.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak <ph id="ph1">`using`</ph> (w języku C#) lub <ph id="ph2">`Using`</ph> (w języku Visual Basic).</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfejsu tematu.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method to request ownership of a mutex.</source>
          <target state="translated">Można użyć <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> metoda żądania własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The calling thread blocks until one of the following occurs:</source>
          <target state="translated">Wywołania wątku bloki dopóki nie wystąpi jedno z następujących czynności:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The mutex is signaled to indicate that it is not owned.</source>
          <target state="translated">Obiektu mutex jest informowany wskazują, że nie jest właścicielem.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`true`</ph>, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</source>
          <target state="translated">W takim przypadku <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> metoda zwraca <ph id="ph2">`true`</ph>, a wątek wywołujący przejmuje obiektu mutex i uzyskuje dostęp do zasobów chronionych przez obiektu mutex.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When it has finished accessing the resource, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the mutex.</source>
          <target state="translated">Po zakończeniu dostęp do zasobu, należy wywołać wątku <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> metodę, aby zwolnić prawo własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The first example in the Examples section illustrates this pattern.</source>
          <target state="translated">W sekcji przykładów w pierwszym przykładzie przedstawiono tego wzorca.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The time-out interval specified in the call to a <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method that has a <ph id="ph2">`millisecondsTimeout`</ph> or <ph id="ph3">`timeout`</ph> parameter has elapsed.</source>
          <target state="translated">Limit czasu określony w wywołaniu <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> metodę, która ma <ph id="ph2">`millisecondsTimeout`</ph> lub <ph id="ph3">`timeout`</ph> parametru upłynął.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`false`</ph>, and the calling thread makes no further attempt to acquire ownership of the mutex.</source>
          <target state="translated">W takim przypadku <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> metoda zwraca <ph id="ph2">`false`</ph>, a wątek wywołujący sprawia, że dalsze próby uzyskania prawa własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</source>
          <target state="translated">W takim przypadku należy struktury kodu tak, aby w wątku wywołującym odmówiono dostępu do zasobu, która jest chroniona przez obiektu mutex.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because the thread never acquired ownership of the mutex, it must not call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Ponieważ wątek nigdy nie uzyskać prawo własności obiektu mutex, nie należy wywołać <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The second example in the Examples section illustrates this pattern.</source>
          <target state="translated">W sekcji przykładów w drugim przykładzie przedstawiono tego wzorca.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> Klasy wymusza tożsamości wątku, dlatego może być zwolnione obiektu mutex tylko przez wątek, do którego został uzyskany.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>By contrast, the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity.</source>
          <target state="translated">Z kolei <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> klasa nie obsługuje wymuszania tożsamości wątku.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>A mutex can also be passed across application domain boundaries.</source>
          <target state="translated">Mutex również mogą być przekazywane między granicami domeny aplikacji.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The thread that owns a mutex can request the same mutex in repeated calls to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> without blocking its execution.</source>
          <target state="translated">Wątek, który jest właścicielem obiektu mutex może zażądać tego samego obiektu mutex w wywołaniach powtarzane <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> bez blokowanie jego wykonania.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>However, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method the same number of times to release ownership of the mutex.</source>
          <target state="translated">Jednak należy wywołać wątku <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> metody taką samą liczbę razy, aby zwolnić prawo własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class inherits from <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, you can also call the static <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods to synchronize access to a protected resource.</source>
          <target state="translated">Ponieważ <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> klasa dziedziczy <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, możesz także wywołać statycznych <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> metody synchronizujący dostęp do chronionych zasobów.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
          <target state="translated">Zakończenie wątku podczas będący właścicielem obiektu mutex, jest nazywany porzucony obiektu mutex.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The state of the mutex is set to signaled, and the next waiting thread gets ownership.</source>
          <target state="translated">Stan obiektu mutex ustawiono sygnalizowane i następnego wątku oczekiwania pobiera własności.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the abandoned mutex.</source>
          <target state="translated">Począwszy od wersji 2.0 programu .NET Framework, <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> jest zgłaszany w następnym wątku, który uzyskuje porzuconego elementu mutex.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Before version 2.0 of the .NET Framework, no exception was thrown.</source>
          <target state="translated">Przed programu .NET Framework w wersji 2.0 nie zgłoszono wyjątek.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
          <target state="translated">Porzuconego elementu mutex często oznacza to poważny błąd w kodzie.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
          <target state="translated">Wątek kończy działanie bez zwolnienia obiektu mutex, struktur danych chronionych przez obiektu mutex może być w stanie spójności.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
          <target state="translated">Następnego wątku własności obiektu mutex żądania obsługi tego wyjątku i kontynuować, jeśli można sprawdzić integralność struktury danych.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">W przypadku obiektu mutex systemowe porzuconego elementu mutex może wskazywać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</source>
          <target state="translated">Istnieją dwa typy muteksy: muteksy lokalne, które nienazwanych i nazwanych muteksy systemu.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>A local mutex exists only within your process.</source>
          <target state="translated">Mutex lokalny istnieje tylko w ramach procesu.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>It can be used by any thread in your process that has a reference to the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the mutex.</source>
          <target state="translated">Może służyć przez wszystkie wątki procesu, który zawiera odwołanie do <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiekt, który reprezentuje obiektu mutex.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Each unnamed <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object represents a separate local mutex.</source>
          <target state="translated">Każdy nienazwane <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiekt reprezentuje oddzielny lokalny obiektu mutex.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
          <target state="translated">O nazwie system Muteksy są widoczne w systemie operacyjnym i może służyć do synchronizowania działania procesów.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex by using a constructor that accepts a name.</source>
          <target state="translated">Można utworzyć <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiekt, który reprezentuje system nazwanego obiektu mutex przy użyciu konstruktora akceptującego nazwę.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The operating-system object can be created at the same time, or it can exist before the creation of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object.</source>
          <target state="translated">Obiekt systemu operacyjnego można tworzyć w tym samym czasie lub może istnieć przed tworzeniem <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex, and you can use the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method to open an existing named system mutex.</source>
          <target state="translated">Możesz utworzyć wiele <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektów, które reprezentują takie same nazwanego obiektu mutex systemu i może używać <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> metodę, aby otworzyć istniejące nazwanego obiektu mutex systemu.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">Na serwerze, na którym są uruchomione usługi terminalowe system nazwanego obiektu mutex ma dwa poziomy widoczności.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Jeśli jej nazwa rozpoczyna się od prefiksu "Global<ph id="ph1">\\</ph>", jest widoczne we wszystkich sesjach serwera terminali obiektu mutex.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Jeśli jej nazwa rozpoczyna się od prefiksu "lokalnego<ph id="ph1">\\</ph>", obiektu mutex jest widoczna tylko w sesji serwera terminali, której został utworzony.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">W takim przypadku oddzielnego obiektu mutex o takiej samej nazwie może istnieć w każdym z innych sesji serwera terminali na serwerze.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Jeżeli nie określisz prefiksu, podczas tworzenia nazwanego obiektu mutex, trwa prefiks "lokalnego<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">W sesji serwera terminali dwóch muteksy, których nazwy różnią się tylko wielkością ich prefiksów są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Oznacza to, że nazwy prefiksu "Global<ph id="ph1">\\</ph>" i "lokalnego<ph id="ph2">\\</ph>" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, a nie względem procesów.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">W tym przykładzie pokazano, jak lokalnie <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu służy do synchronizowania dostępu do chronionego zasobu.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the thread.</source>
          <target state="translated">Ponieważ każdy wątek wywołujący jest zablokowany do czasu jej uzyskuje prawo własności obiektu mutex, należy wywołać <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> metodę, aby zwolnić własność wątku.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In the following example, each thread calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29&gt;</ph> method to acquire the mutex.</source>
          <target state="translated">W poniższym przykładzie wywołanie każdy wątek <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29&gt;</ph> metody można uzyskać obiektu mutex.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If the time-out interval elapses, the method returns <ph id="ph1">`false`</ph>, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</source>
          <target state="translated">Jeśli upłynie limit czasu, metoda zwraca <ph id="ph1">`false`</ph>, i wątku nie uzyskuje obiektu mutex ani uzyskuje dostęp do zasobów chroni obiektu mutex.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method is called only by the thread that acquires the mutex.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Metoda jest wywoływana tylko przez wątek, który uzyskuje obiektu mutex.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This type is thread safe.</source>
          <target state="translated">Ten typ jest bezpieczny wątkowo.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with default properties.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> klasy przy użyciu domyślnej właściwości.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>Calling this constructor overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor overload and specifying <ph id="ph2">`false`</ph> for initial ownership of the mutex.</source>
          <target state="translated">Wywołanie tego przeciążenia konstruktora jest taka sama jak wywołanie <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> przeładowania konstruktora i określając <ph id="ph2">`false`</ph> dla początkowego własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>That is, the calling thread does not own the mutex.</source>
          <target state="translated">Oznacza to, że wątek wywołujący nie jest właścicielem obiektu mutex.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>The following code example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">Poniższy kod przedstawia przykład sposobu lokalnego <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu służy do synchronizowania dostępu do chronionego zasobu.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>The thread that creates the mutex does not own it initially.</source>
          <target state="translated">Wątek, który tworzy obiektu mutex nie ma ona początkowo.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the mutex; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Aby zapewnić wywołania wątku początkowej prawo własności obiektu mutex; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> klasy z wartość logiczną wskazującą, czy wątek wywołujący powinien mieć początkowej własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>The following code example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">Poniższy kod przedstawia przykład sposobu lokalnego <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu służy do synchronizowania dostępu do chronionego zasobu.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>The thread that creates the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> owns it initially.</source>
          <target state="translated">Wątek, który tworzy <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> początkowo jest właścicielem.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Aby zapewnić wywoływania własność początkowej wątku systemu nazwanego obiektu mutex mutex systemu o nazwie zostanie utworzony w wyniku tego wywołania; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</source>
          <target state="translated">Nazwa <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">Jeśli wartość jest <ph id="ph1">&lt;see langword="null" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> jest bez nazwy.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> klasy z wartość logiczną wskazującą, czy wątek wywołujący powinien mieć początkowej własności obiektu mutex i ciąg, który jest nazwą obiektu mutex.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</source>
          <target state="translated">Jeśli <ph id="ph1">`name`</ph> nie jest <ph id="ph2">`null`</ph> i <ph id="ph3">`initiallyOwned`</ph> jest <ph id="ph4">`true`</ph>, wątek wywołujący jest właścicielem obiektu mutex tylko wtedy, gdy system nazwanego obiektu mutex został utworzony w wyniku tego wywołania.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Since there is no mechanism for determining whether the named system mutex was created, it is better to specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initiallyOwned`</ph> when calling this constructor overload.</source>
          <target state="translated">Ponieważ nie ma mechanizmu ustalania, czy system nazwanego obiektu mutex został utworzony, to lepiej określić <ph id="ph1">`false`</ph> dla <ph id="ph2">`initiallyOwned`</ph> podczas wywoływania tej przeładowania konstruktora.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor if you need to determine initial ownership.</source>
          <target state="translated">Można użyć <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> konstruktora, jeśli trzeba określić własność początkowej.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Ten konstruktor inicjuje <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiekt, który reprezentuje system nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Możesz utworzyć wiele <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektów, które reprezentują takie same nazwanego obiektu mutex systemu.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Jeśli nazwanego obiektu mutex została już utworzona z kontrolę dostępu, a obiekt wywołujący nie ma <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, jest zgłaszany wyjątek.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Aby otworzyć istniejące nazwanego obiektu mutex tylko uprawnienia niezbędne do synchronizowania wątku działań, zobacz <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Jeśli określisz <ph id="ph1">`null`</ph> lub pusty ciąg <ph id="ph2">`name`</ph>, lokalnego obiektu mutex jest tworzony tak, jakby były nazywane <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> konstruktora.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">W takim przypadku <ph id="ph1">`createdNew`</ph> jest zawsze <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Ponieważ są one systemowe, muteksy nazwanego może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">Na serwerze, na którym są uruchomione usługi terminalowe system nazwanego obiektu mutex ma dwa poziomy widoczności.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Jeśli jej nazwa rozpoczyna się od prefiksu "Global<ph id="ph1">\\</ph>", jest widoczne we wszystkich sesjach serwera terminali obiektu mutex.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Jeśli jej nazwa rozpoczyna się od prefiksu "lokalnego<ph id="ph1">\\</ph>", obiektu mutex jest widoczna tylko w sesji serwera terminali, której został utworzony.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">W takim przypadku oddzielnego obiektu mutex o takiej samej nazwie może istnieć w każdym z innych sesji serwera terminali na serwerze.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Jeżeli nie określisz prefiksu, podczas tworzenia nazwanego obiektu mutex, trwa prefiks "lokalnego<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">W sesji serwera terminali dwóch muteksy, których nazwy różnią się tylko wielkością ich prefiksów są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Oznacza to, że nazwy prefiksu "Global<ph id="ph1">\\</ph>" i "lokalnego<ph id="ph2">\\</ph>" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, a nie względem procesów.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The following example shows how a named mutex is used to signal between threads running in two separate processes.</source>
          <target state="translated">W poniższym przykładzie pokazano, jak nazwanego obiektu mutex jest używany do między wątki uruchomione w dwa osobne procesy.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Run this program from two or more command windows.</source>
          <target state="translated">Uruchom ten program z co najmniej dwa polecenia systemu windows.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Each process creates a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the named mutex <ph id="ph2">`MyMutex`</ph>.</source>
          <target state="translated">Każdy proces tworzy <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiekt, który reprezentuje nazwanego obiektu mutex <ph id="ph2">`MyMutex`</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is a system object whose lifetime is bounded by the lifetimes of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it.</source>
          <target state="translated">Nazwanego obiektu mutex to obiekt systemowy, którego okres istnienia jest ograniczone przez okresy istnienia <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektów, które reprezentują go.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is created when the first process creates its <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object; in this example, the named mutex is owned by the first process that runs the program.</source>
          <target state="translated">Nazwanego obiektu mutex jest tworzony podczas pierwszego procesu tworzy jego <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu; w tym przykładzie nazwanego obiektu mutex jest własnością pierwszego procesu, który uruchamia program.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is destroyed when all the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it have been released.</source>
          <target state="translated">Nazwanego obiektu mutex jest niszczony podczas wszystkich <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektów, które reprezentują go zostały wydane.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</source>
          <target state="translated">Przeładowania konstruktora używana w tym przykładzie nie wiadomo wątek wywołujący czy przyznano początkowej własność nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</source>
          <target state="translated">Ten konstruktor nie należy używać do żądania początkowego własność, o ile nie może mieć pewność, że wątek utworzy nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Nazwanego obiektu mutex istnieje i ma kontrolę dostępu, ale użytkownik nie ma <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Wystąpił błąd systemu Win32.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Nazwanego obiektu mutex nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest dłuższa niż 260 znaków.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Aby zapewnić wywoływania własność początkowej wątku systemu nazwanego obiektu mutex mutex systemu o nazwie zostanie utworzony w wyniku tego wywołania; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</source>
          <target state="translated">Nazwa <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">Jeśli wartość jest <ph id="ph1">&lt;see langword="null" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> jest bez nazwy.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system mutex already existed.</source>
          <target state="translated">Po powrocie z tej metody zawiera wartość logiczna, która jest <ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli utworzono lokalnego obiektu mutex (to znaczy, jeśli <bpt id="p1">&lt;c&gt;</bpt>nazwa<ept id="p1">&lt;/c&gt;</ept> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph> lub ciąg pusty) lub jeśli utworzono określony system nazwanego obiektu mutex; <ph id="ph3">&lt;see langword="false" /&gt;</ph> Jeśli określonego nazwanego obiektu mutex systemu już istnieje.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ten parametr jest przekazywany niezainicjowany.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> z wartość logiczną wskazującą, czy wątek wywołujący powinien mieć początkowej własności obiektu mutex, ciąg określający nazwę obiektu mutex i wartość logiczną wskazującą, gdy metoda zwróci wartość, Określa, czy wątek wywołujący uzyskał początkowej własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
          <target state="translated">Jeśli <ph id="ph1">`name`</ph> nie jest <ph id="ph2">`null`</ph> i <ph id="ph3">`initiallyOwned`</ph> jest <ph id="ph4">`true`</ph>, wątek wywołujący jest właścicielem nazwanego obiektu mutex tylko wtedy, gdy <ph id="ph5">`createdNew`</ph> jest <ph id="ph6">`true`</ph> po wywołaniu.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">W przeciwnym razie wątku mogą żądać obiektu mutex przez wywołanie metody <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Ten konstruktor inicjuje <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiekt, który reprezentuje system nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Możesz utworzyć wiele <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektów, które reprezentują takie same nazwanego obiektu mutex systemu.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph> rights, an exception is thrown.</source>
          <target state="translated">Jeśli nazwanego obiektu mutex została już utworzona z kontrolę dostępu, a obiekt wywołujący nie ma <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph> praw, jest zgłaszany wyjątek.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Aby otworzyć istniejące nazwanego obiektu mutex tylko uprawnienia niezbędne do synchronizowania wątku działań, zobacz <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Jeśli określisz <ph id="ph1">`null`</ph> lub pusty ciąg <ph id="ph2">`name`</ph>, lokalnego obiektu mutex jest tworzony tak, jakby były nazywane <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> konstruktora.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">W takim przypadku <ph id="ph1">`createdNew`</ph> jest zawsze <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Ponieważ są one systemowe, muteksy nazwanego może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">Na serwerze, na którym są uruchomione usługi terminalowe system nazwanego obiektu mutex ma dwa poziomy widoczności.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Jeśli jej nazwa rozpoczyna się od prefiksu "Global<ph id="ph1">\\</ph>", jest widoczne we wszystkich sesjach serwera terminali obiektu mutex.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Jeśli jej nazwa rozpoczyna się od prefiksu "lokalnego<ph id="ph1">\\</ph>", obiektu mutex jest widoczna tylko w sesji serwera terminali, której został utworzony.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">W takim przypadku oddzielnego obiektu mutex o takiej samej nazwie może istnieć w każdym z innych sesji serwera terminali na serwerze.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Jeżeli nie określisz prefiksu, podczas tworzenia nazwanego obiektu mutex, trwa prefiks "lokalnego<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">W sesji serwera terminali dwóch muteksy, których nazwy różnią się tylko wielkością ich prefiksów są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Oznacza to, że nazwy prefiksu "Global<ph id="ph1">\\</ph>" i "lokalnego<ph id="ph2">\\</ph>" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, a nie względem procesów.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The following code example shows how a named mutex is used to signal between processes or threads.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak nazwanego obiektu mutex jest używany do między procesów i wątków.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Run this program from two or more command windows.</source>
          <target state="translated">Uruchom ten program z co najmniej dwa polecenia systemu windows.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Each process creates a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the named mutex "MyMutex".</source>
          <target state="translated">Każdy proces tworzy <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiekt, który reprezentuje nazwanego obiektu mutex "MyMutex".</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is a system object.</source>
          <target state="translated">Nazwanego obiektu mutex jest obiektem systemu.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In this example, its lifetime is bounded by the lifetimes of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it.</source>
          <target state="translated">W tym przykładzie jego okres istnienia jest ograniczone przez okresy istnienia <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektów, które reprezentują go.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is created when the first process creates its local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object, and destroyed when all the <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it have been released.</source>
          <target state="translated">Nazwanego obiektu mutex jest tworzony podczas pierwszego procesu tworzy jego lokalnego <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu i zniszczona, gdy wszystkie <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> obiektów, które reprezentują go zostały wydane.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is initially owned by the first process.</source>
          <target state="translated">Właścicielem nazwanego obiektu mutex jest początkowo pierwszego procesu.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The second process and any subsequent processes wait for earlier processes to release the named mutex.</source>
          <target state="translated">Druga procedura i wszystkie kolejne procesy poczekaj procesów wcześniejszych wersji nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Nazwanego obiektu mutex istnieje i ma kontrolę dostępu, ale użytkownik nie ma <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Wystąpił błąd systemu Win32.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Nazwanego obiektu mutex nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest dłuższa niż 260 znaków.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Aby zapewnić wywoływania własność początkowej wątku systemu nazwanego obiektu mutex mutex systemu o nazwie zostanie utworzony w wyniku tego wywołania; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The name of the system mutex.</source>
          <target state="translated">Nazwa obiektu mutex systemu.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">Jeśli wartość jest <ph id="ph1">&lt;see langword="null" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> jest bez nazwy.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system mutex already existed.</source>
          <target state="translated">Po powrocie z tej metody zawiera wartość logiczna, która jest <ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli utworzono lokalnego obiektu mutex (to znaczy, jeśli <bpt id="p1">&lt;c&gt;</bpt>nazwa<ept id="p1">&lt;/c&gt;</ept> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph> lub ciąg pusty) lub jeśli utworzono określony system nazwanego obiektu mutex; <ph id="ph3">&lt;see langword="false" /&gt;</ph> Jeśli określonego nazwanego obiektu mutex systemu już istnieje.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ten parametr jest przekazywany niezainicjowany.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> obiekt, który reprezentuje kontrolę dostępu ma zostać zastosowany do systemu nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> klasy z wartość logiczną wskazującą, czy wątek wywołujący powinien mieć początkowej prawo własności obiektu mutex, ciąg określający nazwę obiektu mutex, wskazujący, gdy metoda zwróci wartość, wartość logiczna Określa, czy wątek wywołujący uzyskał początkowej własności obiektu mutex i kontrolę dostępu ma zostać zastosowany do nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
          <target state="translated">Jeśli <ph id="ph1">`name`</ph> nie jest <ph id="ph2">`null`</ph> i <ph id="ph3">`initiallyOwned`</ph> jest <ph id="ph4">`true`</ph>, wątek wywołujący jest właścicielem nazwanego obiektu mutex tylko wtedy, gdy <ph id="ph5">`createdNew`</ph> jest <ph id="ph6">`true`</ph> po wywołaniu.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">W przeciwnym razie wątku mogą żądać obiektu mutex przez wywołanie metody <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</source>
          <target state="translated">Użyj tego konstruktora, aby zastosować kontrolę dostępu do systemu nazwanego obiektu mutex podczas jego tworzenia, uniemożliwia pobieranie formantu obiektu mutex innego kodu.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Ten konstruktor inicjuje <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiekt, który reprezentuje system nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Możesz utworzyć wiele <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektów, które reprezentują takie same nazwanego obiektu mutex systemu.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named system mutex does not exist, it is created with the specified access control security.</source>
          <target state="translated">Jeśli system nazwanego obiektu mutex nie istnieje, jest tworzony z określonym kontrolę dostępu.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named mutex exists, the specified access control security is ignored.</source>
          <target state="translated">Jeśli istnieje nazwanego obiektu mutex, określony kontrolę dostępu jest ignorowane.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object even if <ph id="ph2">`mutexSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">Obiekt wywołujący ma pełną kontrolę nad nowo utworzony <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> nawet wtedy, gdy obiekt <ph id="ph2">`mutexSecurity`</ph> nie zezwala lub nie powiedzie się pewne prawa dostępu do bieżącego użytkownika.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object to represent the same named mutex, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">Jednak jeśli bieżący użytkownik próbuje pobrać inny <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiekt, do reprezentowania takie same nazwanego obiektu mutex, za pomocą konstruktora lub <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> zastosowano kontrolę dostępu w systemie Windows metody.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Jeśli nazwanego obiektu mutex została już utworzona z kontrolę dostępu, a obiekt wywołujący nie ma <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, jest zgłaszany wyjątek.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Aby otworzyć istniejące nazwanego obiektu mutex tylko uprawnienia niezbędne do synchronizowania wątku działań, zobacz <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Jeśli określisz <ph id="ph1">`null`</ph> lub pusty ciąg <ph id="ph2">`name`</ph>, lokalnego obiektu mutex jest tworzony tak, jakby były nazywane <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> konstruktora.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">W takim przypadku <ph id="ph1">`createdNew`</ph> jest zawsze <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Ponieważ są one systemowe, muteksy nazwanego może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">Na serwerze, na którym są uruchomione usługi terminalowe system nazwanego obiektu mutex ma dwa poziomy widoczności.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Jeśli jej nazwa rozpoczyna się od prefiksu "Global<ph id="ph1">\\</ph>", jest widoczne we wszystkich sesjach serwera terminali obiektu mutex.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Jeśli jej nazwa rozpoczyna się od prefiksu "lokalnego<ph id="ph1">\\</ph>", obiektu mutex jest widoczna tylko w sesji serwera terminali, której został utworzony.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">W takim przypadku oddzielnego obiektu mutex o takiej samej nazwie może istnieć w każdym z innych sesji serwera terminali na serwerze.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Jeżeli nie określisz prefiksu, podczas tworzenia nazwanego obiektu mutex, trwa prefiks "lokalnego<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">W sesji serwera terminali dwóch muteksy, których nazwy różnią się tylko wielkością ich prefiksów są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Oznacza to, że nazwy prefiksu "Global<ph id="ph1">\\</ph>" i "lokalnego<ph id="ph2">\\</ph>" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, a nie względem procesów.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa nazwanego obiektu mutex z kontrolę dostępu.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">W przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> przeciążenie metody, aby przetestować obecność nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Jeśli obiektu mutex nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania obiektu mutex, ale daje prawo do odczytu, a zmiana uprawnień do obiektu mutex.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Wyjątek zostanie przechwycony i w przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> przeciążenie metody można otworzyć z uprawnień niezbędnych do odczytu i zmienić uprawnienia obiektu mutex.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Po zmianie są uprawnienia obiektu mutex jest otwarty z uprawnień wymaganych do wprowadzania i zwolnij go.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Wystąpił błąd systemu Win32.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Nazwanego obiektu mutex istnieje i ma kontrolę dostępu, ale użytkownik nie ma <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Nazwanego obiektu mutex nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest dłuższa niż 260 znaków.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security for the named mutex.</source>
          <target state="translated">Pobiera <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> obiekt, który reprezentuje kontrolę dostępu dla nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security for the named mutex.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> obiekt, który reprezentuje kontrolę dostępu dla nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> Metoda używa następujących kombinacji flag (połączone, przy użyciu operacji bitowej OR) do wyszukania uprawnienia: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, i <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Użytkownik musi mieć <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> wywołanie tej metody i obiektu mutex musi została otwarta z <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa nazwanego obiektu mutex z kontrolę dostępu.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">W przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> przeciążenie metody, aby przetestować obecność nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Jeśli obiektu mutex nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania obiektu mutex, ale daje prawo do odczytu, a zmiana uprawnień do obiektu mutex.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions, using the <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Wyjątek zostanie przechwycony i w przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> przeciążenie metody, aby otworzyć obiektu mutex z uprawnień wymaganych do odczytu, a zmiana uprawnień, przy użyciu <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> i <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Po zmianie są uprawnienia obiektu mutex jest otwarty z uprawnień wymaganych do wprowadzania i zwolnij go.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object represents a named system mutex, but the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">Bieżący <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> obiekt reprezentuje system nazwanego obiektu mutex, ale użytkownik nie ma <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object represents a named system mutex, and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">Bieżący <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> obiekt reprezentuje system nazwanego obiektu mutex, a nie została otwarta z <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Nie jest obsługiwane dla systemu Windows 98 lub Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Opens a specified named mutex, if it already exists.</source>
          <target state="translated">Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Nazwa obiektu mutex systemu, aby otworzyć.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Opens the specified named mutex, if it already exists.</source>
          <target state="translated">Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>An object that represents the named system mutex.</source>
          <target state="translated">Obiekt, który reprezentuje system nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open the specified named system mutex.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> Metody spróbuje otworzyć określonego nazwanego obiektu mutex systemu.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
          <target state="translated">Jeśli system obiektu mutex nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia obiektu systemowego.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Aby utworzyć obiektu mutex systemu, gdy jeszcze nie istnieje, użyj jednej z <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> ma konstruktorów <ph id="ph2">`name`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Tej metody należy użyć tej samej wartości dla wielu wywołań <ph id="ph1">`name`</ph> nie musi zwracać taki sam <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego obiektu mutex systemu o nazwie.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Przeciążenie tej metody jest odpowiednikiem wywołania <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> przeciążenie metody i określając <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> i <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> praw, połączone przy użyciu operacji lub.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Określanie <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> Flaga umożliwia wątku oczekiwania na obiektu mutex i określając <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> Flaga umożliwia wątku w celu wywołania <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> — metoda.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Ta metoda nie żąda prawo własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa nazwanego obiektu mutex z kontrolę dostępu.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">W przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> przeciążenie metody, aby przetestować obecność nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Jeśli obiektu mutex nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania obiektu mutex, ale daje prawo do odczytu, a zmiana uprawnień do obiektu mutex.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Wyjątek zostanie przechwycony i w przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> przeciążenie metody można otworzyć z uprawnień niezbędnych do odczytu i zmienić uprawnienia obiektu mutex.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Po zmianie są uprawnienia obiektu mutex jest otwarty z uprawnień wymaganych do wprowadzania i zwolnij go.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest pustym ciągiem.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest dłuższa niż 260 znaków.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The named mutex does not exist.</source>
          <target state="translated">Nazwanego obiektu mutex nie istnieje.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Wystąpił błąd systemu Win32.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Istnieje nazwanego obiektu mutex, ale użytkownik nie ma dostępu zabezpieczeń, trzeba go używać.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Nazwa obiektu mutex systemu, aby otworzyć.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Bitowe połączenie wartości wyliczenia, które reprezentują dostęp wymaganymi.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Opens the specified named mutex, if it already exists, with the desired security access.</source>
          <target state="translated">Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje, z wymaganymi dostępu.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>An object that represents the named system mutex.</source>
          <target state="translated">Obiekt, który reprezentuje system nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> Parametr musi zawierać <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flagę wątków, aby czekać na obiektu mutex i <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flagę wątków, aby wywołać <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open an existing named mutex.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> Metoda próbuje otworzyć istniejące nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
          <target state="translated">Jeśli system obiektu mutex nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia obiektu systemowego.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Aby utworzyć obiektu mutex systemu, gdy jeszcze nie istnieje, użyj jednej z <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> ma konstruktorów <ph id="ph2">`name`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Tej metody należy użyć tej samej wartości dla wielu wywołań <ph id="ph1">`name`</ph> nie musi zwracać taki sam <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego obiektu mutex systemu o nazwie.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Ta metoda nie żąda prawo własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa nazwanego obiektu mutex z kontrolę dostępu.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">W przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> przeciążenie metody, aby przetestować obecność nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Jeśli obiektu mutex nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania obiektu mutex, ale daje prawo do odczytu, a zmiana uprawnień do obiektu mutex.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Wyjątek zostanie przechwycony i w przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> przeciążenie metody można otworzyć z uprawnień niezbędnych do odczytu i zmienić uprawnienia obiektu mutex.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Po zmianie są uprawnienia obiektu mutex jest otwarty z uprawnień wymaganych do wprowadzania i zwolnij go.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest pustym ciągiem.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest dłuższa niż 260 znaków.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The named mutex does not exist.</source>
          <target state="translated">Nazwanego obiektu mutex nie istnieje.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Wystąpił błąd systemu Win32.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The named mutex exists, but the user does not have the desired security access.</source>
          <target state="translated">Istnieje nazwanego obiektu mutex, ale użytkownik nie ma dostępu do żądanego zabezpieczeń.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Releases the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> once.</source>
          <target state="translated">Wersje <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> po.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Whenever a thread acquires a mutex (for example, by calling its <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method), it must subsequently call <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</source>
          <target state="translated">Zawsze, gdy wątek uzyskuje obiektu mutex (na przykład przez wywołanie jego <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> — metoda), następnie należy wywołać <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> zrzeka prawo własności obiektu mutex i odblokować innych wątków, które próbują uzyskać prawo własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If the attempt to get ownership of the mutex fails (for example, when a call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method with a <ph id="ph2">`millisecondsTimeout`</ph> or a <ph id="ph3">`timeout`</ph> parameter returns <ph id="ph4">`false`</ph> because the request times out), the thread shouldn't call <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</source>
          <target state="translated">Jeśli próba pobrania prawo własności obiektu mutex zakończy się niepowodzeniem (na przykład, gdy wywołanie <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> metody z <ph id="ph2">`millisecondsTimeout`</ph> lub <ph id="ph3">`timeout`</ph> zwraca parametr <ph id="ph4">`false`</ph> ponieważ limit czasu żądania), wątek nie należy wywoływać <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, w tym przypadku wątku również nie powinien być dozwolony dostęp do zasobu chronione przez obiektu mutex, jak przedstawiono na poniższym przykładzie.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</source>
          <target state="translated">Wątek, który jest właścicielem obiektu mutex można określić tego samego obiektu mutex oczekiwania powtarzane wywołania funkcji bez blokowania jego wykonywania.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The number of calls is kept by the common language runtime.</source>
          <target state="translated">Liczba wywołań jest przechowywany przez środowisko uruchomieniowe języka wspólnego.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The thread must call <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> the same number of times to release ownership of the mutex.</source>
          <target state="translated">Wątek należy wywołać <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> taką samą liczbę razy, aby zwolnić prawo własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
          <target state="translated">Zakończenie wątku podczas będący właścicielem obiektu mutex, jest nazywany porzucony obiektu mutex.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The state of the mutex is set to signaled and the next waiting thread gets ownership.</source>
          <target state="translated">Stan obiektu mutex jest ustawiona na sygnałowego i następnego wątku oczekiwania pobiera własności.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If no one owns the mutex, the state of the mutex is signaled.</source>
          <target state="translated">Jeśli nie jest właścicielem obiektu mutex, zostanie zasygnalizowane stan obiektu mutex.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the mutex.</source>
          <target state="translated">Począwszy od wersji 2.0 programu .NET Framework, <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> jest zgłaszany w następnym wątku, który uzyskuje obiektu mutex.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Prior to version 2.0 of the .NET Framework, no exception was thrown.</source>
          <target state="translated">Przed programu .NET Framework w wersji 2.0 nie zgłoszono wyjątek.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
          <target state="translated">Porzuconego elementu mutex często oznacza to poważny błąd w kodzie.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
          <target state="translated">Wątek kończy działanie bez zwolnienia obiektu mutex, struktur danych chronionych przez obiektu mutex może być w stanie spójności.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
          <target state="translated">Następnego wątku własności obiektu mutex żądania obsługi tego wyjątku i kontynuować, jeśli można sprawdzić integralność struktury danych.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">W przypadku obiektu mutex systemowe porzuconego elementu mutex może wskazywać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows).</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The following example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">W poniższym przykładzie pokazano, jak lokalnie <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu służy do synchronizowania dostępu do chronionego zasobu.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The thread that creates the mutex does not own it initially.</source>
          <target state="translated">Wątek, który tworzy obiektu mutex nie ma ona początkowo.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method is used to release the mutex when it is no longer needed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> Metoda jest używana do zwolnienia obiektu mutex, gdy nie jest już potrzebne.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The calling thread does not own the mutex.</source>
          <target state="translated">Wątek wywołujący nie jest właścicielem obiektu mutex.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The current instance has already been disposed.</source>
          <target state="translated">Bieżące wystąpienie został już usunięty.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> obiekt, który reprezentuje kontrolę dostępu ma zostać zastosowany do systemu nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>Sets the access control security for a named system mutex.</source>
          <target state="translated">Ustawia kontrolę dostępu do systemu nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Użytkownik musi mieć <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> praw, aby wywołać tę metodę i obiektu mutex musi została otwarta z <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa nazwanego obiektu mutex z kontrolę dostępu.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">W przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> przeciążenie metody, aby przetestować obecność nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Jeśli obiektu mutex nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania obiektu mutex, ale daje prawo do odczytu, a zmiana uprawnień do obiektu mutex.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions, using the <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Wyjątek zostanie przechwycony i w przykładzie użyto <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> przeciążenie metody, aby otworzyć obiektu mutex z uprawnień wymaganych do odczytu, a zmiana uprawnień, przy użyciu <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> i <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Po zmianie są uprawnienia obiektu mutex jest otwarty z uprawnień wymaganych do wprowadzania i zwolnij go.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;paramref name="mutexSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mutexSecurity" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">Użytkownik nie ma <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The mutex was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">Obiektu mutex nie został otwarty z <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object does not represent a named system mutex.</source>
          <target state="translated">Bieżący <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> obiekt nie reprezentuje system nazwanego obiektu mutex.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Nazwa obiektu mutex systemu, aby otworzyć.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Po powrocie z tej metody zawiera <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> obiekt, który reprezentuje nazwanego obiektu mutex, jeśli wywołanie zakończyło się pomyślnie, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> Jeśli wywołanie zakończyło się niepowodzeniem.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Ten parametr jest traktowany jako niezainicjowany.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli nazwanego obiektu mutex została otwarta pomyślnie; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>If the named mutex does not exist, this method does not create it.</source>
          <target state="translated">Jeśli nazwanego obiektu mutex nie istnieje, ta metoda nie utworzy go.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Aby utworzyć obiektu mutex systemu, gdy jeszcze nie istnieje, użyj jednej z <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> ma konstruktorów <ph id="ph2">`name`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
          <target state="translated">Jeśli masz pewności, czy istnieje nazwanego obiektu mutex, użyj tego przeciążenia metody zamiast <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> przeciążenie metody, która zgłasza wyjątek, jeśli obiektu mutex nie istnieje.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Tej metody należy użyć tej samej wartości dla wielu wywołań <ph id="ph1">`name`</ph> nie musi zwracać taki sam <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego obiektu mutex systemu o nazwie.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Przeciążenie tej metody jest odpowiednikiem wywołania <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> przeciążenie metody i określając <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> i <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> praw, połączone przy użyciu operacji lub.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Określanie <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> Flaga umożliwia wątku oczekiwania na obiektu mutex i określając <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> Flaga umożliwia wątku w celu wywołania <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> — metoda.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Ta metoda nie żąda prawo własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest pustym ciągiem.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest dłuższa niż 260 znaków.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Wystąpił błąd systemu Win32.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Istnieje nazwanego obiektu mutex, ale użytkownik nie ma dostępu zabezpieczeń, trzeba go używać.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Nazwa obiektu mutex systemu, aby otworzyć.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Bitowe połączenie wartości wyliczenia, które reprezentują dostęp wymaganymi.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Po powrocie z tej metody zawiera <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> obiekt, który reprezentuje nazwanego obiektu mutex, jeśli wywołanie zakończyło się pomyślnie, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> Jeśli wywołanie zakończyło się niepowodzeniem.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Ten parametr jest traktowany jako niezainicjowany.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Otwiera określonego nazwanego obiektu mutex, jeśli już istnieje z wymaganymi dostęp i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli nazwanego obiektu mutex została otwarta pomyślnie; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>If the named mutex does not exist, this method does not create it.</source>
          <target state="translated">Jeśli nazwanego obiektu mutex nie istnieje, ta metoda nie utworzy go.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Aby utworzyć obiektu mutex systemu, gdy jeszcze nie istnieje, użyj jednej z <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> ma konstruktorów <ph id="ph2">`name`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
          <target state="translated">Jeśli masz pewności, czy istnieje nazwanego obiektu mutex, użyj tego przeciążenia metody zamiast <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> przeciążenie metody, która zgłasza wyjątek, jeśli obiektu mutex nie istnieje.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`rights`</ph> Parametr musi zawierać <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flagę wątków, aby czekać na obiektu mutex i <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flagę wątków, aby wywołać <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Tej metody należy użyć tej samej wartości dla wielu wywołań <ph id="ph1">`name`</ph> nie musi zwracać taki sam <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego obiektu mutex systemu o nazwie.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Ta metoda nie żąda prawo własności obiektu mutex.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest pustym ciągiem.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest dłuższa niż 260 znaków.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Wystąpił błąd systemu Win32.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Istnieje nazwanego obiektu mutex, ale użytkownik nie ma dostępu zabezpieczeń, trzeba go używać.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
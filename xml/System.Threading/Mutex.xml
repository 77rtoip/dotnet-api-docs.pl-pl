<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b9f6f3b97fec6581e9267dd0f2050265fa381f9b" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49146217" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Podstawowego synchronizacji, który może również służyć do synchronizacji międzyprocesowej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dwa lub więcej wątków muszą uzyskać dostęp do udostępnionego zasobu, w tym samym czasie, system musi mechanizm synchronizacji, aby upewnić się, że tylko jeden wątek jednocześnie korzysta z zasobów. <xref:System.Threading.Mutex> jest elementem synchronizacji pierwotnych, która przyznaje wyłączny dostęp do udostępnionego zasobu, aby tylko jeden wątek. Wątek uzyskuje mutex, drugi wątek, który chce uzyskać tego obiektu mutex jest zawieszona do czasu pierwszym wątkiem zwalnia element mutex.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niej. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> method in Class metoda `try` / `catch` bloku. Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.  
  
 Możesz użyć <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody żądania własności obiektu mutex. Wywołania wątku bloki dopóki nie wystąpi jedno z następujących czynności:  
  
-   Element mutex jest sygnalizowane, aby wskazać, że nie jest własnością. W takim przypadku <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true`, i Wątek wywołujący przejmuje element mutex i uzyskuje dostęp do zasobów chronionych przez element mutex. Po zakończeniu dostępu do zasobu, należy wywołać wątku <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę, aby zwolnić własności obiektu mutex. Pierwszy przykład w sekcji Przykłady przedstawiono tego wzorca.  
  
-   Limit czasu określony w wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> metody, która ma `millisecondsTimeout` lub `timeout` upłynął parametru. W takim przypadku <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `false`, i Wątek wywołujący sprawia, że dalsze próby uzyskania własności obiektu mutex. W takim przypadku należy strukturą kodu, tak, aby odmowa dostępu do zasobu, który jest chroniony przez element mutex do wątku wywołującego. Ponieważ wątek nigdy nie nabyty własności obiektu mutex, nie należy wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metody. Drugi przykład w sekcji Przykłady przedstawiono tego wzorca.  
  
 <xref:System.Threading.Mutex> Klasy wymusza tożsamość wątku, więc mutex będą dostępne tylko w wątku, do którego został uzyskany. Z kolei <xref:System.Threading.Semaphore> klasy nie wymusza tożsamość wątku. Mutex, również mogą być przekazywane poza granice domeny aplikacji.  
  
 Wątek, który jest właścicielem obiektu mutex można zażądać tego samego obiektu mutex w wywołaniach powtarzanych <xref:System.Threading.WaitHandle.WaitOne%2A> bez blokowania jej wykonanie. Jednakże, należy wywołać wątku <xref:System.Threading.Mutex.ReleaseMutex%2A> metoda taką samą liczbę razy, aby zwolnić własności obiektu mutex.  
  
 Ponieważ <xref:System.Threading.Mutex> klasa dziedziczy <xref:System.Threading.WaitHandle>, można również wywołać statyczną <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> i <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metody do synchronizowania dostępu do chronionego zasobu.  
  
 Wątek kończy działanie podczas będącego właścicielem elementu mutex, jest nazywany porzucone element mutex. Stan obiektu mutex ustawiono sygnalizowane i następny wątek oczekiwania uzyskuje własność. Począwszy od wersji 2.0 programu .NET Framework, <xref:System.Threading.AbandonedMutexException> jest zgłaszany w następny wątek, który uzyska element mutex porzucone. Przed wersją 2.0 platformy .NET Framework żaden wyjątek został zgłoszony.  
  
> [!CAUTION]
>  Porzuconego elementu mutex często oznacza to poważny błąd w kodzie. Jeśli wątek kończy działanie bez zwalniania element mutex, struktur danych chronionych przez element mutex może nie być w stanie spójności. Następny wątek do żądania własności obiektu mutex można obsługi tego wyjątku i kontynuować, jeśli można zweryfikować integralności struktur danych.  
  
 W przypadku elementu mutex systemowe porzuconego elementu mutex może wskazywać, że aplikacji zostało zakończone nagle (na przykład przy użyciu Menedżera zadań Windows).  
  
 Istnieją dwa typy muteksy: muteksy lokalnego, która nienazwane i o nazwie muteksy systemu. Lokalny element mutex istnieje tylko w ramach procesu. Mogą być używane w żadnym z wątków w procesie, który zawiera odwołanie do <xref:System.Threading.Mutex> obiekt, który reprezentuje element mutex. Każdy nienazwane <xref:System.Threading.Mutex> obiekt reprezentuje oddzielny lokalny element mutex.  
  
 O nazwie system Muteksy są widoczne w całym systemie operacyjnym i może służyć do synchronizowania działania procesów. Możesz utworzyć <xref:System.Threading.Mutex> obiekt, który przedstawia muteks systemu o nazwie przy użyciu konstruktora, który przyjmuje nazwę. W tym samym czasie można utworzyć obiektu systemu operacyjnego lub może istnieć przed tworzenie <xref:System.Threading.Mutex> obiektu. Możesz tworzyć wiele <xref:System.Threading.Mutex> obiekty reprezentujące takie same, o nazwie systemu element mutex i można użyć <xref:System.Threading.Mutex.OpenExisting%2A> metodę, aby otworzyć istniejący o nazwie systemu element mutex.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe mutex o nazwie system może mieć dwa poziomy widoczności. Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex są widoczne we wszystkich sesjach serwera terminali. Jeśli nazwa zaczyna się od prefiksu "lokalnego\\", element mutex jest widoczna tylko w sesji serwera terminali, której został utworzony. W takim przypadku oddzielnych mutex o takiej samej nazwie może istnieć we wszystkich innych sesji serwera terminali na serwerze. Jeśli nie określisz prefiks, podczas tworzenia nazwanego obiektu mutex, zajmuje się prefiksem "lokalnego\\". W sesji serwera terminali dwóch muteksy, których nazwy różnią się jedynie ich prefiksy są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksu "Global\\" i "lokalnego\\" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, nie względem procesów.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 W tym przykładzie pokazano, jak lokalnie <xref:System.Threading.Mutex> obiekt jest używany do synchronizowania dostępu do chronionego zasobu. Ponieważ każdy wątek wywołujący jest zablokowany do momentu jej uzyskuje własność obiektu mutex, należy wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę, aby zwolnić własności wątku.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 W poniższym przykładzie każdy wątek wywołuje <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> metodę, aby pobrać element mutex. Jeśli upłynie limit czasu, metoda zwraca `false`, i wątku nie uzyska element mutex ani nie uzyska dostęp do zasobów chroni element mutex. <xref:System.Threading.Mutex.ReleaseMutex%2A> Metoda jest wywoływana tylko przez wątek, który uzyska element mutex.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasy przy użyciu domyślnej właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tego przeciążenia konstruktora jest taka sama jak wywołanie <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> przeciążenia konstruktora i określając `false` dla początkowej własności obiektu mutex. Oznacza to, że wątek wywołujący nie jest właścicielem obiektu mutex.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład, w jaki sposób lokalny <xref:System.Threading.Mutex> obiekt jest używany do synchronizowania dostępu do chronionego zasobu. Wątek, który tworzy element mutex nie posiada ona początkowo.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> Aby dać wywołującego wątku początkowej własności obiektu mutex; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasie z atrybutem wartość logiczną, wskazującą, czy wątek wywołujący powinien mieć początkowej własności obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przedstawia przykład, w jaki sposób lokalny <xref:System.Threading.Mutex> obiekt jest używany do synchronizowania dostępu do chronionego zasobu. Wątek, który tworzy <xref:System.Threading.Mutex> początkowo jest jego właścicielem.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> Aby dać wywołującego wątku początkowej własności obiektu mutex systemu o nazwie, jeśli nazwany systemu element mutex jest tworzona w wyniku tego wywołania; w przeciwnym razie <see langword="false" />.</param>
        <param name="name">Nazwa <see cref="T:System.Threading.Mutex" />. Jeśli wartość jest <see langword="null" />, <see cref="T:System.Threading.Mutex" /> jest bez nazwy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasie z atrybutem wartość logiczną, wskazującą, czy wątek wywołujący powinien mieć początkowej własności obiektu mutex i ciąg, który jest nazwą obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` nie `null` i `initiallyOwned` jest `true`, wątek wywołujący jest właścicielem obiektu mutex, tylko wtedy, gdy element mutex o nazwie system został utworzony w wyniku tego wywołania. Ponieważ nie istnieje żaden mechanizm służący do określania, czy nazwany systemu element mutex został utworzony, to lepiej określać `false` dla `initiallyOwned` podczas wywoływania tego przeciążenia konstruktora. Możesz użyć <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> konstruktora, jeśli zachodzi potrzeba określenia własności początkowej.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt, który przedstawia muteks systemu o nazwie. Możesz tworzyć wiele <xref:System.Threading.Mutex> obiekty reprezentujące takie same, o nazwie systemu element mutex.  
  
 Jeśli nazwany element mutex został już utworzony za pomocą kontrolę dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, zgłaszany jest wyjątek. Aby otworzyć istniejący o nazwie obiektu mutex z tylko te uprawnienia, które są wymagane do zsynchronizowania działaniach, zobacz <xref:System.Threading.Mutex.OpenExisting%2A> metody.  
  
 Jeśli określisz `null` lub ciągu pustego `name`, Lokalny element mutex zostanie utworzony, tak, jakby były nazywane <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> konstruktora. W tym przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ są one całego systemu, o nazwie muteksy może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe mutex o nazwie system może mieć dwa poziomy widoczności. Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex są widoczne we wszystkich sesjach serwera terminali. Jeśli nazwa zaczyna się od prefiksu "lokalnego\\", element mutex jest widoczna tylko w sesji serwera terminali, której został utworzony. W takim przypadku oddzielnych mutex o takiej samej nazwie może istnieć we wszystkich innych sesji serwera terminali na serwerze. Jeśli nie określisz prefiks, podczas tworzenia nazwanego obiektu mutex, zajmuje się prefiksem "lokalnego\\". W sesji serwera terminali dwóch muteksy, których nazwy różnią się jedynie ich prefiksy są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksu "Global\\" i "lokalnego\\" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, nie względem procesów.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 Poniższy przykład pokazuje, jak nazwanego obiektu mutex jest używany do między wątkami w dwóch oddzielnych procesach.  
  
 Uruchom ten program z co najmniej dwa polecenia systemu windows. Każdy proces tworzy <xref:System.Threading.Mutex> obiekt, który reprezentuje nazwanego obiektu mutex `MyMutex`. Nazwany element mutex jest obiektem systemowym, którego okres istnienia jest ograniczone przez okresy istnienia <xref:System.Threading.Mutex> obiekty reprezentujące go. Nazwany element mutex jest tworzony podczas tworzenia pierwszego procesu jej <xref:System.Threading.Mutex> obiektu; w tym przykładzie nazwanego obiektu mutex jest własnością pierwszy proces, który uruchamia program. Nazwany element mutex zostanie zniszczony podczas wszystkich <xref:System.Threading.Mutex> wydano obiekty reprezentujące go.  
  
 Przeciążenia konstruktora, używany w tym przykładzie nie wiadomo wątek wywołujący, czy przyznano początkowej własności nazwanego obiektu mutex. Nie należy używać tego konstruktora, aby zażądać początkowego, własności, chyba, że można mieć pewność, że wątek utworzy nazwanego obiektu mutex.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Mutex o nazwie istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwany element mutex nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> Aby dać wywołującego wątku początkowej własności obiektu mutex systemu o nazwie, jeśli nazwany systemu element mutex jest tworzona w wyniku tego wywołania; w przeciwnym razie <see langword="false" />.</param>
        <param name="name">Nazwa <see cref="T:System.Threading.Mutex" />. Jeśli wartość jest <see langword="null" />, <see cref="T:System.Threading.Mutex" /> jest bez nazwy.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera wartość logiczna, która jest <see langword="true" /> Jeśli utworzono lokalnego obiektu mutex (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> ani być pustym ciągiem) lub jeśli utworzono określonego nazwanego systemu element mutex; <see langword="false" /> Jeśli określony o nazwie systemu element mutex już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasie z atrybutem wartość logiczną, wskazującą, czy wątek wywołujący powinien mieć początkowej własności obiektu mutex, ciąg, który jest nazwą obiektu mutex i wartość logiczną, która wskazuje, gdy metoda zwróci wartość, czy wątek wywołujący uzyskał początkowej własności obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` nie `null` i `initiallyOwned` jest `true`, wątek wywołujący posiada nazwanego obiektu mutex tylko wtedy, gdy `createdNew` jest `true` po wywołaniu. W przeciwnym razie wątek może żądać element mutex, wywołując <xref:System.Threading.WaitHandle.WaitOne%2A> metody.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt, który przedstawia muteks systemu o nazwie. Możesz tworzyć wiele <xref:System.Threading.Mutex> obiekty reprezentujące takie same, o nazwie systemu element mutex.  
  
 Jeśli nazwany element mutex został już utworzony za pomocą kontrolę dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> praw, zgłaszany jest wyjątek. Aby otworzyć istniejący o nazwie obiektu mutex z tylko te uprawnienia, które są wymagane do zsynchronizowania działaniach, zobacz <xref:System.Threading.Mutex.OpenExisting%2A> metody.  
  
 Jeśli określisz `null` lub ciągu pustego `name`, Lokalny element mutex zostanie utworzony, tak, jakby były nazywane <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> konstruktora. W tym przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ są one całego systemu, o nazwie muteksy może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe mutex o nazwie system może mieć dwa poziomy widoczności. Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex są widoczne we wszystkich sesjach serwera terminali. Jeśli nazwa zaczyna się od prefiksu "lokalnego\\", element mutex jest widoczna tylko w sesji serwera terminali, której został utworzony. W takim przypadku oddzielnych mutex o takiej samej nazwie może istnieć we wszystkich innych sesji serwera terminali na serwerze. Jeśli nie określisz prefiks, podczas tworzenia nazwanego obiektu mutex, zajmuje się prefiksem "lokalnego\\". W sesji serwera terminali dwóch muteksy, których nazwy różnią się jedynie ich prefiksy są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksu "Global\\" i "lokalnego\\" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, nie względem procesów.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak nazwanego obiektu mutex jest używany w celu sygnalizowania, że między procesów lub wątków. Uruchom ten program z co najmniej dwa polecenia systemu windows. Każdy proces tworzy <xref:System.Threading.Mutex> obiekt, który reprezentuje nazwanego obiektu mutex "MyMutex". Nazwany element mutex jest obiektem systemowym. W tym przykładzie jego okres istnienia jest ograniczone przez okresy istnienia <xref:System.Threading.Mutex> obiekty reprezentujące go. Nazwanego obiektu mutex jest tworzone, gdy pierwszy proces tworzy jego lokalnego <xref:System.Threading.Mutex> obiektu, a następnie niszczone, gdy wszystkie <xref:System.Threading.Mutex> wydano obiekty reprezentujące go. Nazwany element mutex początkowo jest własnością pierwszego procesu. Drugi procesu i wszystkie kolejne procesy poczekaj, aż procesów wcześniejszych wersji nazwanego obiektu mutex.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Mutex o nazwie istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwany element mutex nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> Aby dać wywołującego wątku początkowej własności obiektu mutex systemu o nazwie, jeśli nazwany systemu element mutex jest tworzona w wyniku tego wywołania; w przeciwnym razie <see langword="false" />.</param>
        <param name="name">Nazwa systemu element mutex. Jeśli wartość jest <see langword="null" />, <see cref="T:System.Threading.Mutex" /> jest bez nazwy.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera wartość logiczna, która jest <see langword="true" /> Jeśli utworzono lokalnego obiektu mutex (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> ani być pustym ciągiem) lub jeśli utworzono określonego nazwanego systemu element mutex; <see langword="false" /> Jeśli określony o nazwie systemu element mutex już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> obiekt, który reprezentuje kontrolę dostępu mają być stosowane do nazwanych systemu element mutex.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasie z atrybutem wartość logiczną, wskazującą, czy wątek wywołujący powinien mieć początkowej własności obiektu mutex, ciąg, który jest nazwą obiektu mutex, zmiennej typu Boolean wskazującą, gdy metoda zwróci wartość, czy wątek wywołujący uzyskał początkowej własności obiektu mutex i kontrolę dostępu stosowaną do nazwanego obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` nie `null` i `initiallyOwned` jest `true`, wątek wywołujący posiada nazwanego obiektu mutex tylko wtedy, gdy `createdNew` jest `true` po wywołaniu. W przeciwnym razie wątek może żądać element mutex, wywołując <xref:System.Threading.WaitHandle.WaitOne%2A> metody.  
  
 Użyj tego konstruktora, aby zastosować kontrolę dostępu do elementu mutex systemu o nazwie, podczas jego tworzenia, uniemożliwiając innym kodem przejmowaniu element mutex.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt, który przedstawia muteks systemu o nazwie. Możesz tworzyć wiele <xref:System.Threading.Mutex> obiekty reprezentujące takie same, o nazwie systemu element mutex.  
  
 Jeśli nazwany systemu element mutex nie istnieje, zostanie utworzony przy użyciu określonego kontrolę dostępu. Jeśli istnieje nazwanego obiektu mutex, określony kontrolę dostępu jest ignorowany.  
  
> [!NOTE]
>  Obiekt wywołujący ma pełną kontrolę nad nowo utworzony <xref:System.Threading.Mutex> nawet wtedy, gdy obiekt `mutexSecurity` nie zezwala lub nie powiedzie się pewne prawa dostępu do bieżącego użytkownika. Jednak jeśli bieżący użytkownik próbuje pobrać inny <xref:System.Threading.Mutex> obiektu, do reprezentowania takie same o nazwie obiektu mutex, za pomocą konstruktora lub <xref:System.Threading.Mutex.OpenExisting%2A> metody Windows zastosowano kontrolę dostępu.  
  
 Jeśli nazwany element mutex został już utworzony za pomocą kontrolę dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, zgłaszany jest wyjątek. Aby otworzyć istniejący o nazwie obiektu mutex z tylko te uprawnienia, które są wymagane do zsynchronizowania działaniach, zobacz <xref:System.Threading.Mutex.OpenExisting%2A> metody.  
  
 Jeśli określisz `null` lub ciągu pustego `name`, Lokalny element mutex zostanie utworzony, tak, jakby były nazywane <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> konstruktora. W tym przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ są one całego systemu, o nazwie muteksy może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe mutex o nazwie system może mieć dwa poziomy widoczności. Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex są widoczne we wszystkich sesjach serwera terminali. Jeśli nazwa zaczyna się od prefiksu "lokalnego\\", element mutex jest widoczna tylko w sesji serwera terminali, której został utworzony. W takim przypadku oddzielnych mutex o takiej samej nazwie może istnieć we wszystkich innych sesji serwera terminali na serwerze. Jeśli nie określisz prefiks, podczas tworzenia nazwanego obiektu mutex, zajmuje się prefiksem "lokalnego\\". W sesji serwera terminali dwóch muteksy, których nazwy różnią się jedynie ich prefiksy są oddzielne muteksy i obie są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksu "Global\\" i "lokalnego\\" opisuje zakres nazwa obiektu mutex względem sesje serwera terminali, nie względem procesów.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwanego obiektu mutex z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenia metody, aby przetestować obecność nazwanego obiektu mutex.  
  
 Jeśli element mutex nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, która odrzuca prawa do używania obiektu mutex bieżącego użytkownika, ale przyznaje uprawnienia do odczytu i zmienić uprawnienia do obiektu mutex.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Wyjątek, a w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, aby otworzyć element mutex za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia element mutex zostanie otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Mutex o nazwie istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwany element mutex nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.MutexSecurity" /> obiekt, który reprezentuje kontrolę dostępu do nazwanego obiektu mutex.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.MutexSecurity" /> obiekt, który reprezentuje kontrolę dostępu do nazwanego obiektu mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A> Metoda używa następujących kombinacji flag (połączone za pomocą bitowej operacji OR) do wyszukania uprawnienia: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> do wywołania tej metody, a element mutex musi została otwarta z <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwanego obiektu mutex z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenia metody, aby przetestować obecność nazwanego obiektu mutex.  
  
 Jeśli element mutex nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, która odrzuca prawa do używania obiektu mutex bieżącego użytkownika, ale przyznaje uprawnienia do odczytu i zmienić uprawnienia do obiektu mutex.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Wyjątek, a w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, aby otworzyć element mutex za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia za pomocą <xref:System.Threading.Mutex.GetAccessControl%2A> i <xref:System.Threading.Mutex.SetAccessControl%2A> metody.  
  
 Po zmianie uprawnienia element mutex zostanie otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący <see cref="T:System.Threading.Mutex" /> obiektu przedstawia muteks systemu o nazwie, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
—lub— 
Bieżący <see cref="T:System.Threading.Mutex" /> przedstawia muteks systemu o nazwie, a nie zostało otwarte z <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Nie jest obsługiwane dla Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określony element mutex o nazwie, jeśli już istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu mutex systemu, aby otworzyć.</param>
        <summary>Otwiera określony nazwany element mutex, jeśli już istnieje.</summary>
        <returns>Obiekt, który reprezentuje nazwane systemu element mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> Metoda podejmuje próbę otwarcia określonego o nazwie systemu element mutex. Jeśli systemu element mutex nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia obiektu systemowego. Aby utworzyć systemu element mutex, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.Mutex> obiektów, nawet jeśli obiekty, które są zwracane reprezentują ten sam element mutex systemu o nazwie.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenie metody i określając <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> praw, połączone za pomocą bitowej operacji OR.  
  
 Określanie <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku czekać na element mutex i określając <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątków do wywoływania <xref:System.Threading.Mutex.ReleaseMutex%2A> metody.  
  
 Ta metoda nie żąda własności obiektu mutex.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwanego obiektu mutex z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenia metody, aby przetestować obecność nazwanego obiektu mutex.  
  
 Jeśli element mutex nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, która odrzuca prawa do używania obiektu mutex bieżącego użytkownika, ale przyznaje uprawnienia do odczytu i zmienić uprawnienia do obiektu mutex.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Wyjątek, a w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, aby otworzyć element mutex za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia element mutex zostanie otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwany element mutex nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Mutex o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu mutex systemu, aby otworzyć.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują dostęp pożądanych zabezpieczeń.</param>
        <summary>Zostanie otwarty określonego nazwanego obiektu mutex, jeśli już istnieje, z dostępem do pożądanych zabezpieczeń.</summary>
        <returns>Obiekt, który reprezentuje nazwane systemu element mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Parametr musi zawierać <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flagi, aby zezwolić wątków, aby czekać na element mutex i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flagi, aby zezwolić wątków do wywoływania <xref:System.Threading.Mutex.ReleaseMutex%2A> metody.  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> Metoda próbuje otworzyć istniejący o nazwie elementu mutex. Jeśli systemu element mutex nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia obiektu systemowego. Aby utworzyć systemu element mutex, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.Mutex> obiektów, nawet jeśli obiekty, które są zwracane reprezentują ten sam element mutex systemu o nazwie.  
  
 Ta metoda nie żąda własności obiektu mutex.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwanego obiektu mutex z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenia metody, aby przetestować obecność nazwanego obiektu mutex.  
  
 Jeśli element mutex nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, która odrzuca prawa do używania obiektu mutex bieżącego użytkownika, ale przyznaje uprawnienia do odczytu i zmienić uprawnienia do obiektu mutex.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Wyjątek, a w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, aby otworzyć element mutex za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia element mutex zostanie otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwany element mutex nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Mutex o nazwie istnieje, ale użytkownik nie ma dostępu pożądanych zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wersje <see cref="T:System.Threading.Mutex" /> po.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zawsze, gdy wątek uzyskuje mutex (na przykład przez wywołanie jego <xref:System.Threading.WaitHandle.WaitOne%2A> metoda), następnie należy wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> zrzeka się własności obiektu mutex i odblokować inne wątki, które próbujesz przejęcie na własność obiektu mutex. Jeśli próba pobrania własności obiektu mutex zakończy się niepowodzeniem (na przykład, gdy wywołanie <xref:System.Threading.WaitHandle.WaitOne%2A> metody z `millisecondsTimeout` lub `timeout` parametr zwraca `false` , ponieważ upłynął limit czasu żądania), wątek nie powinien wywoływać <xref:System.Threading.Mutex.ReleaseMutex%2A>, w tym przypadek, wątek również nie powinien uzyskać dostęp do zasobu, chronione przez element mutex, co ilustruje poniższy przykład.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Wątek, który jest właścicielem obiektu mutex można określić ten sam element mutex w wywołaniach funkcji powtarzanych oczekiwania bez blokowania jej wykonanie. Liczba wywołań jest przechowywany przez środowisko uruchomieniowe języka wspólnego. Wątek musi wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> taką samą liczbę razy, aby zwolnić własności obiektu mutex.  
  
 Wątek kończy działanie podczas będącego właścicielem elementu mutex, jest nazywany porzucone element mutex. Stan obiektu mutex jest ustawiony na zasygnalizowany, a następnie następny wątek oczekiwania pobiera własności. Jeśli nie jest właścicielem obiektu mutex, jest sygnalizowane stanu obiektu mutex. Począwszy od wersji 2.0 programu .NET Framework, <xref:System.Threading.AbandonedMutexException> jest zgłaszany w następny wątek, który uzyska element mutex. Przed programu .NET Framework w wersji 2.0 żaden wyjątek został zgłoszony.  
  
> [!CAUTION]
>  Porzuconego elementu mutex często oznacza to poważny błąd w kodzie. Jeśli wątek kończy działanie bez zwalniania element mutex, struktur danych chronionych przez element mutex może nie być w stanie spójności. Następny wątek do żądania własności obiektu mutex można obsługi tego wyjątku i kontynuować, jeśli można zweryfikować integralności struktur danych.  
  
 W przypadku elementu mutex systemowe porzuconego elementu mutex może wskazywać, że aplikacji zostało zakończone nagle (na przykład przy użyciu Menedżera zadań Windows).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak lokalnie <xref:System.Threading.Mutex> obiekt jest używany do synchronizowania dostępu do chronionego zasobu. Wątek, który tworzy element mutex nie posiada ona początkowo. <xref:System.Threading.Mutex.ReleaseMutex%2A> Metoda jest używana do zwolnienia obiektu mutex, gdy nie jest już potrzebny.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Wątek wywołujący nie jest właścicielem obiektu mutex.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> obiekt, który reprezentuje kontrolę dostępu mają być stosowane do nazwanych systemu element mutex.</param>
        <summary>Ustawia kontrolę dostępu dla elementu mutex systemu o nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi mieć <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> praw do wywołania tej metody, a element mutex musi została otwarta z <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwanego obiektu mutex z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenia metody, aby przetestować obecność nazwanego obiektu mutex.  
  
 Jeśli element mutex nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, która odrzuca prawa do używania obiektu mutex bieżącego użytkownika, ale przyznaje uprawnienia do odczytu i zmienić uprawnienia do obiektu mutex.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Wyjątek, a w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, aby otworzyć element mutex za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia za pomocą <xref:System.Threading.Mutex.GetAccessControl%2A> i <xref:System.Threading.Mutex.SetAccessControl%2A> metody.  
  
 Po zmianie uprawnienia element mutex zostanie otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
—lub— 
Element mutex nie został otwarty z <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">Bieżący <see cref="T:System.Threading.Mutex" /> obiekt nie reprezentuje mutex systemu o nazwie.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określony element mutex nazwanych, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu mutex systemu, aby otworzyć.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.Mutex" /> obiekt, który reprezentuje nazwanego obiektu mutex, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Jeśli już istnieje i zwraca wartość wskazującą, czy operacja się powiedzie, zostanie otwarty określonego nazwanego obiektu mutex.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwany element mutex został otwarty pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwany element mutex nie istnieje, ta metoda nie powoduje utworzenia go. Aby utworzyć systemu element mutex, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Jeśli masz pewności, czy istnieje nazwanego obiektu mutex, użyj tego przeciążenia metody, zamiast <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenia metody, która zgłasza wyjątek, jeśli element mutex nie istnieje.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.Mutex> obiektów, nawet jeśli obiekty, które są zwracane reprezentują ten sam element mutex systemu o nazwie.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> przeciążenie metody i określając <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> praw, połączone za pomocą bitowej operacji OR. Określanie <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku czekać na element mutex i określając <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątków do wywoływania <xref:System.Threading.Mutex.ReleaseMutex%2A> metody.  
  
 Ta metoda nie żąda własności obiektu mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Mutex o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu mutex systemu, aby otworzyć.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują dostęp pożądanych zabezpieczeń.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.Mutex" /> obiekt, który reprezentuje nazwanego obiektu mutex, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Jeśli już istnieje z dostępem do pożądanych zabezpieczeń i zwraca wartość wskazującą, czy operacja się powiedzie, zostanie otwarty określonego nazwanego obiektu mutex.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwany element mutex został otwarty pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwany element mutex nie istnieje, ta metoda nie powoduje utworzenia go. Aby utworzyć systemu element mutex, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Jeśli masz pewności, czy istnieje nazwanego obiektu mutex, użyj tego przeciążenia metody, zamiast <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, która zgłasza wyjątek, jeśli element mutex nie istnieje.  
  
 `rights` Parametr musi zawierać <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flagi, aby zezwolić wątków, aby czekać na element mutex i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flagi, aby zezwolić wątków do wywoływania <xref:System.Threading.Mutex.ReleaseMutex%2A> metody.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.Mutex> obiektów, nawet jeśli obiekty, które są zwracane reprezentują ten sam element mutex systemu o nazwie.  
  
 Ta metoda nie żąda własności obiektu mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Mutex o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
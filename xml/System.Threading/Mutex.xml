<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d1155367ffed453c9616698e60c5a31d0ab90cef" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69144018" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="4ec63-101">Element podstawowy synchronizacji, który może być również używany na potrzeby synchronizacji międzyprocesowej.</span><span class="sxs-lookup"><span data-stu-id="4ec63-101">A synchronization primitive that can also be used for interprocess synchronization.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-102">Gdy co najmniej dwa wątki muszą uzyskać dostęp do udostępnionego zasobu w tym samym czasie, system wymaga mechanizmu synchronizacji, aby upewnić się, że tylko jeden wątek w danym momencie używa zasobu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-102">When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</span></span> <span data-ttu-id="4ec63-103"><xref:System.Threading.Mutex>jest pierwotną synchronizacją, która przyznaje wyłączny dostęp do zasobu udostępnionego tylko jednemu wątkowi.</span><span class="sxs-lookup"><span data-stu-id="4ec63-103"><xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</span></span> <span data-ttu-id="4ec63-104">Jeśli wątek uzyskuje mutex, drugi wątek, który chce uzyskać ten mutex, jest zawieszony do momentu, gdy pierwszy wątek zwolni element mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-104">If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4ec63-105">Ten typ implementuje <xref:System.IDisposable> interfejs.</span><span class="sxs-lookup"><span data-stu-id="4ec63-105">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="4ec63-106">Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio.</span><span class="sxs-lookup"><span data-stu-id="4ec63-106">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="4ec63-107">Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `catch` w bloku.</span><span class="sxs-lookup"><span data-stu-id="4ec63-107">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="4ec63-108">Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ec63-108">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="4ec63-109">Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-109">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="4ec63-110">Możesz użyć metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> aby zażądać własności obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-110">You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method to request ownership of a mutex.</span></span> <span data-ttu-id="4ec63-111">Bloki wywołujące wątki do jednego z następujących wystąpień:</span><span class="sxs-lookup"><span data-stu-id="4ec63-111">The calling thread blocks until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="4ec63-112">Element mutex jest sygnalizowane sygnalizowaniem wskazującym, że nie jest własnością.</span><span class="sxs-lookup"><span data-stu-id="4ec63-112">The mutex is signaled to indicate that it is not owned.</span></span> <span data-ttu-id="4ec63-113">W <xref:System.Threading.WaitHandle.WaitOne%2A> takim przypadku metoda zwraca `true`, a wątek wywołujący przyjmuje własność obiektu mutex i uzyskuje dostęp do zasobu chronionego przez mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-113">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</span></span> <span data-ttu-id="4ec63-114">Po zakończeniu uzyskiwania dostępu do zasobu wątek musi wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę, aby zwolnić własność obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-114">When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex.</span></span> <span data-ttu-id="4ec63-115">Pierwszy przykład w sekcji Przykłady ilustruje ten wzorzec.</span><span class="sxs-lookup"><span data-stu-id="4ec63-115">The first example in the Examples section illustrates this pattern.</span></span>  
  
-   <span data-ttu-id="4ec63-116">Przekroczono limit czasu określony w wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> metody, która `millisecondsTimeout` ma parametr lub `timeout` .</span><span class="sxs-lookup"><span data-stu-id="4ec63-116">The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed.</span></span> <span data-ttu-id="4ec63-117">Gdy tak się <xref:System.Threading.WaitHandle.WaitOne%2A> stanie, metoda zwraca `false`, a wątek wywołujący nie podejmuje dalszej próby uzyskania własności obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-117">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex.</span></span> <span data-ttu-id="4ec63-118">W takim przypadku należy zapewnić strukturę kodu tak, aby dostęp do zasobu, który jest chroniony przez mutex, został odrzucony do wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-118">In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</span></span> <span data-ttu-id="4ec63-119">Ponieważ wątek nigdy nie uzyskał własności elementu mutex, nie może wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4ec63-119">Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span> <span data-ttu-id="4ec63-120">Drugi przykład w sekcji Przykłady ilustruje ten wzorzec.</span><span class="sxs-lookup"><span data-stu-id="4ec63-120">The second example in the Examples section illustrates this pattern.</span></span>  
  
 <span data-ttu-id="4ec63-121"><xref:System.Threading.Mutex> Klasa wymusza tożsamość wątku, więc element mutex może być wydawany tylko przez wątek, który go pozyskuje.</span><span class="sxs-lookup"><span data-stu-id="4ec63-121">The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</span></span> <span data-ttu-id="4ec63-122">Z kolei <xref:System.Threading.Semaphore> Klasa nie wymusza tożsamości wątku.</span><span class="sxs-lookup"><span data-stu-id="4ec63-122">By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity.</span></span> <span data-ttu-id="4ec63-123">Element mutex może być również przekazywać między granicami domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4ec63-123">A mutex can also be passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="4ec63-124">Wątek, który jest właścicielem obiektu mutex, może zażądać tego samego obiektu mutex <xref:System.Threading.WaitHandle.WaitOne%2A> w powtórzonych wywołaniach do bez blokowania jego wykonywania.</span><span class="sxs-lookup"><span data-stu-id="4ec63-124">The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution.</span></span> <span data-ttu-id="4ec63-125">Jednak wątek musi wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę o tej samej liczbie razy, aby zwolnić własność obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-125">However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="4ec63-126">Ponieważ klasa dziedziczy z <xref:System.Threading.WaitHandle>, można również wywołać metody statyczne <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> i <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> , aby zsynchronizować dostęp do chronionego zasobu. <xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="4ec63-126">Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods to synchronize access to a protected resource.</span></span>  
  
 <span data-ttu-id="4ec63-127">Jeśli wątek kończy się, będąc właścicielem obiektu mutex, element mutex zostanie wskazany jako porzucony.</span><span class="sxs-lookup"><span data-stu-id="4ec63-127">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="4ec63-128">Stan obiektu mutex jest ustawiony na sygnalizowanie, a następny oczekujący wątek pobiera własność.</span><span class="sxs-lookup"><span data-stu-id="4ec63-128">The state of the mutex is set to signaled, and the next waiting thread gets ownership.</span></span> <span data-ttu-id="4ec63-129">Począwszy od wersji 2,0 .NET Framework, <xref:System.Threading.AbandonedMutexException> zostanie zgłoszony w następnym wątku, który uzyskuje porzucony obiekt mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-129">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex.</span></span> <span data-ttu-id="4ec63-130">Przed wersją 2,0 .NET Framework nie został zgłoszony żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4ec63-130">Before version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="4ec63-131">Porzucony obiekt mutex często wskazuje poważny błąd w kodzie.</span><span class="sxs-lookup"><span data-stu-id="4ec63-131">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="4ec63-132">Gdy wątek zostanie zakończony bez zwalniania obiektu mutex, struktury danych chronione przez element Mutex mogą nie być w stanie spójności.</span><span class="sxs-lookup"><span data-stu-id="4ec63-132">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="4ec63-133">Następny wątek do żądania własności obiektu mutex może obsłużyć ten wyjątek i postępować, jeśli można zweryfikować integralność struktur danych.</span><span class="sxs-lookup"><span data-stu-id="4ec63-133">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="4ec63-134">W przypadku obiektu mutex w całym systemie porzucony obiekt mutex może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="4ec63-134">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
 <span data-ttu-id="4ec63-135">Muteksy są dwa typy: lokalne muteksy, które są nienazwane i nazwane muteksy systemowe.</span><span class="sxs-lookup"><span data-stu-id="4ec63-135">Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</span></span> <span data-ttu-id="4ec63-136">Lokalny element mutex istnieje tylko w ramach procesu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-136">A local mutex exists only within your process.</span></span> <span data-ttu-id="4ec63-137">Może być używany przez dowolny wątek w procesie, który zawiera odwołanie do <xref:System.Threading.Mutex> obiektu, który reprezentuje element mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-137">It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex.</span></span> <span data-ttu-id="4ec63-138">Każdy <xref:System.Threading.Mutex> obiekt bez nazwy reprezentuje oddzielny lokalny element mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-138">Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.</span></span>  
  
 <span data-ttu-id="4ec63-139">Nazwane muteksy systemu są widoczne w całym systemie operacyjnym i mogą być używane do synchronizowania działań procesów.</span><span class="sxs-lookup"><span data-stu-id="4ec63-139">Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="4ec63-140">Można utworzyć <xref:System.Threading.Mutex> obiekt reprezentujący nazwany element mutex systemu przy użyciu konstruktora, który akceptuje nazwę.</span><span class="sxs-lookup"><span data-stu-id="4ec63-140">You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name.</span></span> <span data-ttu-id="4ec63-141">Obiekt systemu operacyjnego można utworzyć w tym samym czasie lub może istnieć przed utworzeniem <xref:System.Threading.Mutex> obiektu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-141">The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object.</span></span> <span data-ttu-id="4ec63-142">Można utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują ten sam nazwany obiekt mutex, i można <xref:System.Threading.Mutex.OpenExisting%2A> użyć metody, aby otworzyć istniejący nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-142">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ec63-143">Na serwerze, na którym są uruchomione usługi terminalowe, nazwany element mutex systemu może mieć dwa poziomy widoczności.</span><span class="sxs-lookup"><span data-stu-id="4ec63-143">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="4ec63-144">Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex jest widoczny we wszystkich sesjach serwera terminali.</span><span class="sxs-lookup"><span data-stu-id="4ec63-144">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="4ec63-145">Jeśli nazwa zaczyna się od prefiksu "Local\\", mutex jest widoczny tylko w sesji serwera terminali, w której został utworzony.</span><span class="sxs-lookup"><span data-stu-id="4ec63-145">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="4ec63-146">W takim przypadku na serwerze może istnieć oddzielny obiekt mutex o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4ec63-146">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="4ec63-147">Jeśli nie określisz prefiksu podczas tworzenia nazwanego obiektu mutex, przyjmuje prefiks "Local\\".</span><span class="sxs-lookup"><span data-stu-id="4ec63-147">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="4ec63-148">W sesji serwera terminali dwa muteksy, których nazwy różnią się tylko prefiksami, są oddzielnymi muteksami, a oba są widoczne dla wszystkich procesów w sesji serwera terminali.</span><span class="sxs-lookup"><span data-stu-id="4ec63-148">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="4ec63-149">Oznacza to, że nazwy prefiksów "\\globalne" i "\\lokalne" opisują zakres nazwy obiektu mutex względem sesji serwera terminali, a nie względem procesów.</span><span class="sxs-lookup"><span data-stu-id="4ec63-149">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 <span data-ttu-id="4ec63-150">Ten przykład pokazuje, jak obiekt <xref:System.Threading.Mutex> lokalny jest używany do synchronizowania dostępu do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-150">This example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="4ec63-151">Ponieważ każdy wywoływany wątek jest blokowany do momentu uzyskania własności obiektu mutex, musi wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę, aby zwolnić własność wątku.</span><span class="sxs-lookup"><span data-stu-id="4ec63-151">Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the thread.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="4ec63-152">W poniższym przykładzie każdy wątek wywołuje <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> metodę w celu uzyskania obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-152">In the following example, each thread calls the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> method to acquire the mutex.</span></span> <span data-ttu-id="4ec63-153">Jeśli upłynie limit czasu, metoda zwróci wartość `false`, a wątek nie uzyska obiektu mutex ani nie uzyska dostępu do zasobu, którego zabezpiecza.</span><span class="sxs-lookup"><span data-stu-id="4ec63-153">If the time-out interval elapses, the method returns `false`, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</span></span> <span data-ttu-id="4ec63-154"><xref:System.Threading.Mutex.ReleaseMutex%2A> Metoda jest wywoływana tylko przez wątek, który uzyskuje mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-154">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is called only by the thread that acquires the mutex.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="4ec63-155">Ten typ jest bezpieczny wątkowo.</span><span class="sxs-lookup"><span data-stu-id="4ec63-155">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="4ec63-156">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="4ec63-156">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="4ec63-157">Muteksy</span><span class="sxs-lookup"><span data-stu-id="4ec63-157">Mutexes</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4ec63-158">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="4ec63-158">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4ec63-159">Inicjuje nowe wystąpienie <see cref="T:System.Threading.Mutex" /> klasy z właściwościami domyślnymi.</span><span class="sxs-lookup"><span data-stu-id="4ec63-159">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-160">Wywołanie tego przeciążenia konstruktora jest takie samo jak wywołanie <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> przeciążenia konstruktora i określanie `false` początkowego własności obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-160">Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex.</span></span> <span data-ttu-id="4ec63-161">Oznacza to, że wątek wywołujący nie jest właścicielem obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-161">That is, the calling thread does not own the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ec63-162">Poniższy przykład kodu pokazuje, jak obiekt lokalny <xref:System.Threading.Mutex> jest używany do synchronizowania dostępu do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-162">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="4ec63-163">Wątek, który tworzy mutex, nie jest początkowo jego właścicielem.</span><span class="sxs-lookup"><span data-stu-id="4ec63-163">The thread that creates the mutex does not own it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="4ec63-164">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="4ec63-164">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="4ec63-165">Muteksy</span><span class="sxs-lookup"><span data-stu-id="4ec63-165">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="4ec63-166"><see langword="true" />Aby nadać wątek wywołujący początkową własność obiektu mutex; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="4ec63-166"><see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="4ec63-167">Inicjuje nowe wystąpienie <see cref="T:System.Threading.Mutex" /> klasy z wartością logiczną, która wskazuje, czy wątek wywołujący powinien mieć wstępną własność obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-167">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4ec63-168">Poniższy przykład kodu pokazuje, jak obiekt lokalny <xref:System.Threading.Mutex> jest używany do synchronizowania dostępu do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-168">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="4ec63-169">Wątek, który najpierw tworzy <xref:System.Threading.Mutex> właściciela.</span><span class="sxs-lookup"><span data-stu-id="4ec63-169">The thread that creates the <xref:System.Threading.Mutex> owns it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="4ec63-170">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="4ec63-170">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="4ec63-171">Muteksy</span><span class="sxs-lookup"><span data-stu-id="4ec63-171">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="4ec63-172"><see langword="true" />Aby nadać wątkowi wywołującemu początkową własność o nazwie systemowego obiektu mutex w przypadku utworzenia nazwanego muteksu systemu w wyniku tego wywołania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="4ec63-172"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="4ec63-173">Nazwa <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-173">The name of the <see cref="T:System.Threading.Mutex" />.</span></span> <span data-ttu-id="4ec63-174">Jeśli wartość to <see langword="null" /> <see cref="T:System.Threading.Mutex" /> , nazwa jest bez nazwy.</span><span class="sxs-lookup"><span data-stu-id="4ec63-174">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <summary><span data-ttu-id="4ec63-175">Inicjuje nowe wystąpienie <see cref="T:System.Threading.Mutex" /> klasy z wartością logiczną, która wskazuje, czy wątek wywołujący powinien mieć początkową własność obiektu mutex, oraz ciąg, który jest nazwą obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-175">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-176">Jeśli `name` nie `null` jest i `initiallyOwned` jest`true`, wątek wywołujący jest właścicielem obiektu mutex tylko wtedy, gdy obiekt mutex o nazwie system został utworzony w wyniku tego wywołania.</span><span class="sxs-lookup"><span data-stu-id="4ec63-176">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</span></span> <span data-ttu-id="4ec63-177">Ponieważ nie istnieje mechanizm określania, czy nazwany element mutex systemu został utworzony, lepiej jest określić `false` dla `initiallyOwned` podczas wywoływania tego przeciążenia konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4ec63-177">Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload.</span></span> <span data-ttu-id="4ec63-178">Można użyć konstruktora, <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> Jeśli trzeba określić wstępną własność.</span><span class="sxs-lookup"><span data-stu-id="4ec63-178">You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.</span></span>  
  
 <span data-ttu-id="4ec63-179">Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt reprezentujący nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-179">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="4ec63-180">Można utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują ten sam nazwany mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-180">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="4ec63-181">Jeśli nazwany mutex został już utworzony z zabezpieczeniami kontroli dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4ec63-181">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="4ec63-182">Aby otworzyć istniejący obiekt mutex o nazwie tylko te uprawnienia, które są konieczne do synchronizowania działań wątku <xref:System.Threading.Mutex.OpenExisting%2A> , zobacz metodę.</span><span class="sxs-lookup"><span data-stu-id="4ec63-182">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="4ec63-183">W przypadku określenia `null` lub pustego ciągu dla `name`, tworzony jest lokalny element mutex, tak jakby był wywoływany <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="4ec63-183">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="4ec63-184">W tym przypadku `createdNew` jest zawsze `true`.</span><span class="sxs-lookup"><span data-stu-id="4ec63-184">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="4ec63-185">Ponieważ są one w całym systemie, nazwane muteksy mogą służyć do koordynowania użycia zasobów w granicach procesów.</span><span class="sxs-lookup"><span data-stu-id="4ec63-185">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ec63-186">Na serwerze, na którym są uruchomione usługi terminalowe, nazwany element mutex systemu może mieć dwa poziomy widoczności.</span><span class="sxs-lookup"><span data-stu-id="4ec63-186">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="4ec63-187">Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex jest widoczny we wszystkich sesjach serwera terminali.</span><span class="sxs-lookup"><span data-stu-id="4ec63-187">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="4ec63-188">Jeśli nazwa zaczyna się od prefiksu "Local\\", mutex jest widoczny tylko w sesji serwera terminali, w której został utworzony.</span><span class="sxs-lookup"><span data-stu-id="4ec63-188">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="4ec63-189">W takim przypadku na serwerze może istnieć oddzielny obiekt mutex o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4ec63-189">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="4ec63-190">Jeśli nie określisz prefiksu podczas tworzenia nazwanego obiektu mutex, przyjmuje prefiks "Local\\".</span><span class="sxs-lookup"><span data-stu-id="4ec63-190">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="4ec63-191">W sesji serwera terminali dwa muteksy, których nazwy różnią się tylko prefiksami, są oddzielnymi muteksami, a oba są widoczne dla wszystkich procesów w sesji serwera terminali.</span><span class="sxs-lookup"><span data-stu-id="4ec63-191">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="4ec63-192">Oznacza to, że nazwy prefiksów "\\globalne" i "\\lokalne" opisują zakres nazwy obiektu mutex względem sesji serwera terminali, a nie względem procesów.</span><span class="sxs-lookup"><span data-stu-id="4ec63-192">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 <span data-ttu-id="4ec63-193">Poniższy przykład pokazuje, jak nazwany mutex jest używany do sygnalizowania między wątkami uruchomionymi w dwóch oddzielnych procesach.</span><span class="sxs-lookup"><span data-stu-id="4ec63-193">The following example shows how a named mutex is used to signal between threads running in two separate processes.</span></span>  
  
 <span data-ttu-id="4ec63-194">Uruchom ten program z dwóch lub więcej okien poleceń.</span><span class="sxs-lookup"><span data-stu-id="4ec63-194">Run this program from two or more command windows.</span></span> <span data-ttu-id="4ec63-195">Każdy proces tworzy <xref:System.Threading.Mutex> obiekt, który reprezentuje nazwany mutex `MyMutex`.</span><span class="sxs-lookup"><span data-stu-id="4ec63-195">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex `MyMutex`.</span></span> <span data-ttu-id="4ec63-196">Nazwany element mutex jest obiektem systemowym, którego okres istnienia jest ograniczony przez okresy <xref:System.Threading.Mutex> istnienia obiektów, które reprezentują tę wartość.</span><span class="sxs-lookup"><span data-stu-id="4ec63-196">The named mutex is a system object whose lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="4ec63-197">Nazwany mutex jest tworzony, gdy pierwszy proces tworzy swój <xref:System.Threading.Mutex> obiekt; w tym przykładzie nazwany mutex jest własnością pierwszego procesu, który uruchamia program.</span><span class="sxs-lookup"><span data-stu-id="4ec63-197">The named mutex is created when the first process creates its <xref:System.Threading.Mutex> object; in this example, the named mutex is owned by the first process that runs the program.</span></span> <span data-ttu-id="4ec63-198">Nazwany element mutex jest niszczony, gdy <xref:System.Threading.Mutex> wszystkie obiekty, które reprezentują tę wartość, zostały wydane.</span><span class="sxs-lookup"><span data-stu-id="4ec63-198">The named mutex is destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span>  
  
 <span data-ttu-id="4ec63-199">Przeciążenie konstruktora użyte w tym przykładzie nie może określić wątku wywołującego, czy udzielono pierwotnej własności wywołanego obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-199">The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</span></span> <span data-ttu-id="4ec63-200">Nie należy używać tego konstruktora do żądania początkowej własności, chyba że można się upewnić, że wątek utworzy nazwany mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-200">You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="4ec63-201">Nazwany mutex istnieje i ma zabezpieczenia kontroli dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-201">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="4ec63-202">Wystąpił błąd Win32.</span><span class="sxs-lookup"><span data-stu-id="4ec63-202">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="4ec63-203">Nie można utworzyć nazwanego obiektu mutex, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</span><span class="sxs-lookup"><span data-stu-id="4ec63-203">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4ec63-204"><paramref name="name" />jest dłuższa niż 260 znaków.</span><span class="sxs-lookup"><span data-stu-id="4ec63-204"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4ec63-205">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-205">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4ec63-206">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="4ec63-206">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="4ec63-207">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="4ec63-207">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="4ec63-208">Muteksy</span><span class="sxs-lookup"><span data-stu-id="4ec63-208">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="4ec63-209"><see langword="true" />Aby nadać wątkowi wywołującemu początkową własność o nazwie systemowego obiektu mutex w przypadku utworzenia nazwanego muteksu systemu w wyniku tego wywołania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="4ec63-209"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="4ec63-210">Nazwa <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-210">The name of the <see cref="T:System.Threading.Mutex" />.</span></span> <span data-ttu-id="4ec63-211">Jeśli wartość to <see langword="null" /> <see cref="T:System.Threading.Mutex" /> , nazwa jest bez nazwy.</span><span class="sxs-lookup"><span data-stu-id="4ec63-211">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <param name="createdNew"><span data-ttu-id="4ec63-212">Gdy ta metoda zwraca, zawiera wartość logiczną, która <see langword="true" /> jest w przypadku utworzenia lokalnego obiektu mutex (czyli jeśli <paramref name="name" /> jest <see langword="null" /> lub pusty ciąg) lub jeśli został utworzony określony nazwany element mutex systemu; <see langword="false" /> Jeśli określony nazwany element mutex już istnieje.</span><span class="sxs-lookup"><span data-stu-id="4ec63-212">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="4ec63-213">Ten parametr jest przekazywany niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="4ec63-213">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="4ec63-214">Inicjuje nowe wystąpienie <see cref="T:System.Threading.Mutex" /> klasy z wartością logiczną, która wskazuje, czy wątek wywołujący powinien mieć początkową własność obiektu mutex, ciąg, który jest nazwą obiektu mutex, i wartość logiczną, która po powrocie metody wskazuje czy wątek wywołujący otrzymał wstępną własność obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-214">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-215">Jeśli `name` nie `true` `createdNew` jest i `initiallyOwned` jest`true`, wątek wywołujący jest właścicielem nazwanego obiektu mutex tylko wtedy, gdy jest po wywołaniu. `null`</span><span class="sxs-lookup"><span data-stu-id="4ec63-215">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="4ec63-216">W przeciwnym razie wątek może zażądać obiektu mutex przez <xref:System.Threading.WaitHandle.WaitOne%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="4ec63-216">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="4ec63-217">Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt reprezentujący nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-217">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="4ec63-218">Można utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują ten sam nazwany mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-218">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="4ec63-219">Jeśli nazwany mutex został już utworzony z zabezpieczeniami kontroli dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> uprawnień, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4ec63-219">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> rights, an exception is thrown.</span></span> <span data-ttu-id="4ec63-220">Aby otworzyć istniejący obiekt mutex o nazwie tylko te uprawnienia, które są konieczne do synchronizowania działań wątku <xref:System.Threading.Mutex.OpenExisting%2A> , zobacz metodę.</span><span class="sxs-lookup"><span data-stu-id="4ec63-220">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="4ec63-221">W przypadku określenia `null` lub pustego ciągu dla `name`, tworzony jest lokalny element mutex, tak jakby był wywoływany <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="4ec63-221">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="4ec63-222">W tym przypadku `createdNew` jest zawsze `true`.</span><span class="sxs-lookup"><span data-stu-id="4ec63-222">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="4ec63-223">Ponieważ są one w całym systemie, nazwane muteksy mogą służyć do koordynowania użycia zasobów w granicach procesów.</span><span class="sxs-lookup"><span data-stu-id="4ec63-223">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ec63-224">Na serwerze, na którym są uruchomione usługi terminalowe, nazwany element mutex systemu może mieć dwa poziomy widoczności.</span><span class="sxs-lookup"><span data-stu-id="4ec63-224">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="4ec63-225">Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex jest widoczny we wszystkich sesjach serwera terminali.</span><span class="sxs-lookup"><span data-stu-id="4ec63-225">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="4ec63-226">Jeśli nazwa zaczyna się od prefiksu "Local\\", mutex jest widoczny tylko w sesji serwera terminali, w której został utworzony.</span><span class="sxs-lookup"><span data-stu-id="4ec63-226">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="4ec63-227">W takim przypadku na serwerze może istnieć oddzielny obiekt mutex o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4ec63-227">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="4ec63-228">Jeśli nie określisz prefiksu podczas tworzenia nazwanego obiektu mutex, przyjmuje prefiks "Local\\".</span><span class="sxs-lookup"><span data-stu-id="4ec63-228">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="4ec63-229">W sesji serwera terminali dwa muteksy, których nazwy różnią się tylko prefiksami, są oddzielnymi muteksami, a oba są widoczne dla wszystkich procesów w sesji serwera terminali.</span><span class="sxs-lookup"><span data-stu-id="4ec63-229">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="4ec63-230">Oznacza to, że nazwy prefiksów "\\globalne" i "\\lokalne" opisują zakres nazwy obiektu mutex względem sesji serwera terminali, a nie względem procesów.</span><span class="sxs-lookup"><span data-stu-id="4ec63-230">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 <span data-ttu-id="4ec63-231">Poniższy przykład kodu pokazuje, jak nazwany mutex jest używany do sygnalizowania między procesami lub wątkami.</span><span class="sxs-lookup"><span data-stu-id="4ec63-231">The following code example shows how a named mutex is used to signal between processes or threads.</span></span> <span data-ttu-id="4ec63-232">Uruchom ten program z dwóch lub więcej okien poleceń.</span><span class="sxs-lookup"><span data-stu-id="4ec63-232">Run this program from two or more command windows.</span></span> <span data-ttu-id="4ec63-233">Każdy proces tworzy <xref:System.Threading.Mutex> obiekt, który reprezentuje nazwany mutex "muteks".</span><span class="sxs-lookup"><span data-stu-id="4ec63-233">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex "MyMutex".</span></span> <span data-ttu-id="4ec63-234">Nazwany element mutex jest obiektem systemowym.</span><span class="sxs-lookup"><span data-stu-id="4ec63-234">The named mutex is a system object.</span></span> <span data-ttu-id="4ec63-235">W tym przykładzie jego okres istnienia jest ograniczony przez okres istnienia <xref:System.Threading.Mutex> obiektów, które reprezentują tę wartość.</span><span class="sxs-lookup"><span data-stu-id="4ec63-235">In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="4ec63-236">Nazwany mutex jest tworzony, gdy pierwszy proces tworzy swój obiekt lokalny <xref:System.Threading.Mutex> i niszczony, gdy <xref:System.Threading.Mutex> wszystkie obiekty, które reprezentują ten element, zostały wydane.</span><span class="sxs-lookup"><span data-stu-id="4ec63-236">The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span> <span data-ttu-id="4ec63-237">Nazwany mutex jest początkowo własnością pierwszego procesu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-237">The named mutex is initially owned by the first process.</span></span> <span data-ttu-id="4ec63-238">Drugi proces i wszystkie kolejne procesy czekają na wcześniejsze procesy w celu zwolnienia nazwanego obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-238">The second process and any subsequent processes wait for earlier processes to release the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="4ec63-239">Nazwany mutex istnieje i ma zabezpieczenia kontroli dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-239">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="4ec63-240">Wystąpił błąd Win32.</span><span class="sxs-lookup"><span data-stu-id="4ec63-240">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="4ec63-241">Nie można utworzyć nazwanego obiektu mutex, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</span><span class="sxs-lookup"><span data-stu-id="4ec63-241">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4ec63-242"><paramref name="name" />jest dłuższa niż 260 znaków.</span><span class="sxs-lookup"><span data-stu-id="4ec63-242"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4ec63-243">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-243">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4ec63-244">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="4ec63-244">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="4ec63-245">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="4ec63-245">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="4ec63-246">Muteksy</span><span class="sxs-lookup"><span data-stu-id="4ec63-246">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="4ec63-247"><see langword="true" />Aby nadać wątkowi wywołującemu początkową własność o nazwie systemowego obiektu mutex w przypadku utworzenia nazwanego muteksu systemu w wyniku tego wywołania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="4ec63-247"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="4ec63-248">Nazwa obiektu mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-248">The name of the system mutex.</span></span> <span data-ttu-id="4ec63-249">Jeśli wartość to <see langword="null" /> <see cref="T:System.Threading.Mutex" /> , nazwa jest bez nazwy.</span><span class="sxs-lookup"><span data-stu-id="4ec63-249">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <param name="createdNew"><span data-ttu-id="4ec63-250">Gdy ta metoda zwraca, zawiera wartość logiczną, która <see langword="true" /> jest w przypadku utworzenia lokalnego obiektu mutex (czyli jeśli <paramref name="name" /> jest <see langword="null" /> lub pusty ciąg) lub jeśli został utworzony określony nazwany element mutex systemu; <see langword="false" /> Jeśli określony nazwany element mutex już istnieje.</span><span class="sxs-lookup"><span data-stu-id="4ec63-250">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="4ec63-251">Ten parametr jest przekazywany niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="4ec63-251">This parameter is passed uninitialized.</span></span></param>
        <param name="mutexSecurity"><span data-ttu-id="4ec63-252"><see cref="T:System.Security.AccessControl.MutexSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu, który ma zostać zastosowany do nazwanego obiektu mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-252">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="4ec63-253">Inicjuje nowe wystąpienie <see cref="T:System.Threading.Mutex" /> klasy za pomocą wartości logicznej wskazującej, czy wątek wywołujący powinien mieć początkową własność obiektu mutex, ciąg, który jest nazwą obiektu mutex, zmienną logiczną, która po powrocie metody wskazuje czy wątek wywołujący otrzymał wstępną własność obiektu mutex, a zabezpieczenia kontroli dostępu mają być stosowane do nazwanego obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-253">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-254">Jeśli `name` nie `true` `createdNew` jest i `initiallyOwned` jest`true`, wątek wywołujący jest właścicielem nazwanego obiektu mutex tylko wtedy, gdy jest po wywołaniu. `null`</span><span class="sxs-lookup"><span data-stu-id="4ec63-254">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="4ec63-255">W przeciwnym razie wątek może zażądać obiektu mutex przez <xref:System.Threading.WaitHandle.WaitOne%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="4ec63-255">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="4ec63-256">Użyj tego konstruktora, aby zastosować zabezpieczenia kontroli dostępu do nazwanego muteksowego obiektu mutex podczas tworzenia, uniemożliwiając innemu kodowi przejęcie kontroli nad muteksem.</span><span class="sxs-lookup"><span data-stu-id="4ec63-256">Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</span></span>  
  
 <span data-ttu-id="4ec63-257">Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt reprezentujący nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-257">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="4ec63-258">Można utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują ten sam nazwany mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-258">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="4ec63-259">Jeśli element mutex o nazwie system nie istnieje, jest tworzony z określonym zabezpieczeniami kontroli dostępu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-259">If the named system mutex does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="4ec63-260">Jeśli istnieje nazwany mutex, określony zabezpieczenia kontroli dostępu jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="4ec63-260">If the named mutex exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ec63-261">Obiekt wywołujący ma pełną kontrolę nad nowo utworzonym <xref:System.Threading.Mutex> obiektem, nawet w przypadku `mutexSecurity` odmowy lub niepowodzenia udzielenia pewnych praw dostępu bieżącemu użytkownikowi.</span><span class="sxs-lookup"><span data-stu-id="4ec63-261">The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="4ec63-262">Jeśli jednak bieżący użytkownik próbuje uzyskać inny <xref:System.Threading.Mutex> obiekt reprezentujący ten sam nazwany element mutex, używając konstruktora <xref:System.Threading.Mutex.OpenExisting%2A> lub metody zabezpieczenia kontroli dostępu do systemu Windows jest stosowane.</span><span class="sxs-lookup"><span data-stu-id="4ec63-262">However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="4ec63-263">Jeśli nazwany mutex został już utworzony z zabezpieczeniami kontroli dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4ec63-263">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="4ec63-264">Aby otworzyć istniejący obiekt mutex o nazwie tylko te uprawnienia, które są konieczne do synchronizowania działań wątku <xref:System.Threading.Mutex.OpenExisting%2A> , zobacz metodę.</span><span class="sxs-lookup"><span data-stu-id="4ec63-264">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="4ec63-265">W przypadku określenia `null` lub pustego ciągu dla `name`, tworzony jest lokalny element mutex, tak jakby był wywoływany <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="4ec63-265">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="4ec63-266">W tym przypadku `createdNew` jest zawsze `true`.</span><span class="sxs-lookup"><span data-stu-id="4ec63-266">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="4ec63-267">Ponieważ są one w całym systemie, nazwane muteksy mogą służyć do koordynowania użycia zasobów w granicach procesów.</span><span class="sxs-lookup"><span data-stu-id="4ec63-267">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ec63-268">Na serwerze, na którym są uruchomione usługi terminalowe, nazwany element mutex systemu może mieć dwa poziomy widoczności.</span><span class="sxs-lookup"><span data-stu-id="4ec63-268">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="4ec63-269">Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex jest widoczny we wszystkich sesjach serwera terminali.</span><span class="sxs-lookup"><span data-stu-id="4ec63-269">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="4ec63-270">Jeśli nazwa zaczyna się od prefiksu "Local\\", mutex jest widoczny tylko w sesji serwera terminali, w której został utworzony.</span><span class="sxs-lookup"><span data-stu-id="4ec63-270">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="4ec63-271">W takim przypadku na serwerze może istnieć oddzielny obiekt mutex o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4ec63-271">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="4ec63-272">Jeśli nie określisz prefiksu podczas tworzenia nazwanego obiektu mutex, przyjmuje prefiks "Local\\".</span><span class="sxs-lookup"><span data-stu-id="4ec63-272">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="4ec63-273">W sesji serwera terminali dwa muteksy, których nazwy różnią się tylko prefiksami, są oddzielnymi muteksami, a oba są widoczne dla wszystkich procesów w sesji serwera terminali.</span><span class="sxs-lookup"><span data-stu-id="4ec63-273">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="4ec63-274">Oznacza to, że nazwy prefiksów "\\globalne" i "\\lokalne" opisują zakres nazwy obiektu mutex względem sesji serwera terminali, a nie względem procesów.</span><span class="sxs-lookup"><span data-stu-id="4ec63-274">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 <span data-ttu-id="4ec63-275">Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego obiektu mutex z zabezpieczeniami kontroli dostępu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-275">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="4ec63-276">W przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego muteksu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-276">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="4ec63-277">Jeśli mutex nie istnieje, jest tworzony z początkową własnością i zabezpieczeniami kontroli dostępu, która odmówi bieżącym użytkownikowi prawo do korzystania z elementu mutex, ale przyznaje prawo do odczytu i zmiany uprawnień do obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-277">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="4ec63-278">W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="4ec63-278">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="4ec63-279">Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> Przeciążenie metody, aby otworzyć mutex z prawami wymaganymi do odczytu i zmiany uprawnień.</span><span class="sxs-lookup"><span data-stu-id="4ec63-279">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="4ec63-280">Po zmianie uprawnień element mutex zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="4ec63-280">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="4ec63-281">W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="4ec63-281">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="4ec63-282">Wystąpił błąd Win32.</span><span class="sxs-lookup"><span data-stu-id="4ec63-282">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="4ec63-283">Nazwany mutex istnieje i ma zabezpieczenia kontroli dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-283">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="4ec63-284">Nie można utworzyć nazwanego obiektu mutex, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</span><span class="sxs-lookup"><span data-stu-id="4ec63-284">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4ec63-285"><paramref name="name" />jest dłuższa niż 260 znaków.</span><span class="sxs-lookup"><span data-stu-id="4ec63-285"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4ec63-286">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-286">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4ec63-287">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="4ec63-287">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4ec63-288"><see cref="T:System.Security.AccessControl.MutexSecurity" /> Pobiera obiekt reprezentujący zabezpieczenia kontroli dostępu dla nazwanego obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-288">Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></summary>
        <returns><span data-ttu-id="4ec63-289"><see cref="T:System.Security.AccessControl.MutexSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu dla nazwanego obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-289">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-290">Metoda używa następującej kombinacji flag (połączonych przy użyciu wartości bitowej lub operacji) do wyszukiwania uprawnień: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. <xref:System.Threading.Mutex.GetAccessControl%2A></span><span class="sxs-lookup"><span data-stu-id="4ec63-290">The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="4ec63-291">Użytkownik musi mieć <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> zawywoływanie tej metody, a element mutex musi być otwarty za pomocą <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ec63-291">The user must have <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ec63-292">Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego obiektu mutex z zabezpieczeniami kontroli dostępu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-292">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="4ec63-293">W przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego muteksu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-293">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="4ec63-294">Jeśli mutex nie istnieje, jest tworzony z początkową własnością i zabezpieczeniami kontroli dostępu, która odmówi bieżącym użytkownikowi prawo do korzystania z elementu mutex, ale przyznaje prawo do odczytu i zmiany uprawnień do obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-294">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="4ec63-295">W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="4ec63-295">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="4ec63-296">Przechwycono wyjątek, a w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, aby otworzyć mutex z prawami wymaganymi do odczytu i zmiany uprawnień <xref:System.Threading.Mutex.GetAccessControl%2A> przy użyciu metod i <xref:System.Threading.Mutex.SetAccessControl%2A> .</span><span class="sxs-lookup"><span data-stu-id="4ec63-296">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="4ec63-297">Po zmianie uprawnień element mutex zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="4ec63-297">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="4ec63-298">W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="4ec63-298">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="4ec63-299">Bieżący <see cref="T:System.Threading.Mutex" /> obiekt reprezentuje nazwany element mutex systemu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-299">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span>  
  
<span data-ttu-id="4ec63-300">—lub—</span><span class="sxs-lookup"><span data-stu-id="4ec63-300">-or-</span></span> 
<span data-ttu-id="4ec63-301">Bieżący <see cref="T:System.Threading.Mutex" /> obiekt reprezentuje nazwany element mutex systemu i nie został otwarty za pomocą <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-301">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4ec63-302">Nieobsługiwane dla systemu Windows 98 lub Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="4ec63-302">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4ec63-303">Otwiera określony nazwany obiekt mutex, jeśli już istnieje.</span><span class="sxs-lookup"><span data-stu-id="4ec63-303">Opens a specified named mutex, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="4ec63-304">Nazwa elementu mutex systemu do otwarcia.</span><span class="sxs-lookup"><span data-stu-id="4ec63-304">The name of the system mutex to open.</span></span></param>
        <summary><span data-ttu-id="4ec63-305">Otwiera określony nazwany mutex, jeśli już istnieje.</span><span class="sxs-lookup"><span data-stu-id="4ec63-305">Opens the specified named mutex, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="4ec63-306">Obiekt reprezentujący nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-306">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-307"><xref:System.Threading.Mutex.OpenExisting%2A> Metoda próbuje otworzyć określony nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-307">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex.</span></span> <span data-ttu-id="4ec63-308">Jeśli obiekt mutex systemu nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia obiektu systemowego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-308">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="4ec63-309">Aby utworzyć systemowy obiekt mutex, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które `name` mają parametr.</span><span class="sxs-lookup"><span data-stu-id="4ec63-309">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="4ec63-310">Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.Mutex> obiekt, nawet jeśli zwracane obiekty reprezentują ten sam nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-310">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="4ec63-311">To Przeciążenie metody jest równoważne wywołaniem <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody i określaniem <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> prawami, połączonymi przy użyciu bitowej lub operacji.</span><span class="sxs-lookup"><span data-stu-id="4ec63-311">This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="4ec63-312">Określenie flagi pozwala wątku czekać na element mutex, a <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> określenie flagi umożliwia wątek wywołujący <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="4ec63-312">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="4ec63-313">Ta metoda nie żąda własności obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-313">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ec63-314">Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego obiektu mutex z zabezpieczeniami kontroli dostępu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-314">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="4ec63-315">W przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego muteksu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-315">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="4ec63-316">Jeśli mutex nie istnieje, jest tworzony z początkową własnością i zabezpieczeniami kontroli dostępu, która odmówi bieżącym użytkownikowi prawo do korzystania z elementu mutex, ale przyznaje prawo do odczytu i zmiany uprawnień do obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-316">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="4ec63-317">W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="4ec63-317">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="4ec63-318">Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> Przeciążenie metody, aby otworzyć mutex z prawami wymaganymi do odczytu i zmiany uprawnień.</span><span class="sxs-lookup"><span data-stu-id="4ec63-318">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="4ec63-319">Po zmianie uprawnień element mutex zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="4ec63-319">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="4ec63-320">W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="4ec63-320">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4ec63-321"><paramref name="name" />jest pustym ciągiem.</span><span class="sxs-lookup"><span data-stu-id="4ec63-321"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="4ec63-322">—lub—</span><span class="sxs-lookup"><span data-stu-id="4ec63-322">-or-</span></span> 
 <span data-ttu-id="4ec63-323"><paramref name="name" />jest dłuższa niż 260 znaków.</span><span class="sxs-lookup"><span data-stu-id="4ec63-323"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4ec63-324"><paramref name="name" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-324"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="4ec63-325">Nazwany element mutex nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="4ec63-325">The named mutex does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="4ec63-326">Wystąpił błąd Win32.</span><span class="sxs-lookup"><span data-stu-id="4ec63-326">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="4ec63-327">Nazwany mutex istnieje, ale użytkownik nie ma wymaganego dostępu zabezpieczeń, aby go użyć.</span><span class="sxs-lookup"><span data-stu-id="4ec63-327">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4ec63-328">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-328">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4ec63-329">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="4ec63-329">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="4ec63-330">Nazwa elementu mutex systemu do otwarcia.</span><span class="sxs-lookup"><span data-stu-id="4ec63-330">The name of the system mutex to open.</span></span></param>
        <param name="rights"><span data-ttu-id="4ec63-331">Bitowa kombinacja wartości wyliczenia, które reprezentują żądany dostęp do zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="4ec63-331">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="4ec63-332">Otwiera określony nazwany mutex, jeśli już istnieje, z żądanym dostępem zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="4ec63-332">Opens the specified named mutex, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="4ec63-333">Obiekt reprezentujący nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-333">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-334">Parametr musi <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> zawierać flagę, aby umożliwić wątkom oczekiwanie na element mutex, oraz flagę, aby umożliwić wątkom <xref:System.Threading.Mutex.ReleaseMutex%2A> wywoływanie metody. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> `rights`</span><span class="sxs-lookup"><span data-stu-id="4ec63-334">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="4ec63-335"><xref:System.Threading.Mutex.OpenExisting%2A> Metoda próbuje otworzyć istniejący nazwany mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-335">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex.</span></span> <span data-ttu-id="4ec63-336">Jeśli obiekt mutex systemu nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia obiektu systemowego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-336">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="4ec63-337">Aby utworzyć systemowy obiekt mutex, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które `name` mają parametr.</span><span class="sxs-lookup"><span data-stu-id="4ec63-337">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="4ec63-338">Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.Mutex> obiekt, nawet jeśli zwracane obiekty reprezentują ten sam nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-338">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="4ec63-339">Ta metoda nie żąda własności obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-339">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ec63-340">Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego obiektu mutex z zabezpieczeniami kontroli dostępu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-340">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="4ec63-341">W przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego muteksu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-341">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="4ec63-342">Jeśli mutex nie istnieje, jest tworzony z początkową własnością i zabezpieczeniami kontroli dostępu, która odmówi bieżącym użytkownikowi prawo do korzystania z elementu mutex, ale przyznaje prawo do odczytu i zmiany uprawnień do obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-342">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="4ec63-343">W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="4ec63-343">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="4ec63-344">Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> Przeciążenie metody, aby otworzyć mutex z prawami wymaganymi do odczytu i zmiany uprawnień.</span><span class="sxs-lookup"><span data-stu-id="4ec63-344">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="4ec63-345">Po zmianie uprawnień element mutex zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="4ec63-345">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="4ec63-346">W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="4ec63-346">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4ec63-347"><paramref name="name" />jest pustym ciągiem.</span><span class="sxs-lookup"><span data-stu-id="4ec63-347"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="4ec63-348">—lub—</span><span class="sxs-lookup"><span data-stu-id="4ec63-348">-or-</span></span> 
 <span data-ttu-id="4ec63-349"><paramref name="name" />jest dłuższa niż 260 znaków.</span><span class="sxs-lookup"><span data-stu-id="4ec63-349"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4ec63-350"><paramref name="name" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-350"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="4ec63-351">Nazwany element mutex nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="4ec63-351">The named mutex does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="4ec63-352">Wystąpił błąd Win32.</span><span class="sxs-lookup"><span data-stu-id="4ec63-352">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="4ec63-353">Nazwany element mutex istnieje, ale użytkownik nie ma wymaganego dostępu do zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="4ec63-353">The named mutex exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4ec63-354">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-354">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="4ec63-355">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="4ec63-355">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4ec63-356"><see cref="T:System.Threading.Mutex" /> Zwalnia jeden raz.</span><span class="sxs-lookup"><span data-stu-id="4ec63-356">Releases the <see cref="T:System.Threading.Mutex" /> once.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-357">Za każdym razem, gdy wątek uzyskuje obiekt mutex (na przykład przez <xref:System.Threading.WaitHandle.WaitOne%2A> wywołanie jego metody), musi on <xref:System.Threading.Mutex.ReleaseMutex%2A> następnie wywołać, aby wycofać własność obiektu mutex i odblokować inne wątki, które próbują uzyskać własność obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-357">Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</span></span> <span data-ttu-id="4ec63-358">Jeśli próba pobrania własności obiektu mutex nie powiedzie się (na przykład wtedy, gdy wywołanie <xref:System.Threading.WaitHandle.WaitOne%2A> metody `millisecondsTimeout` z `timeout` parametrem lub zwraca wartość `false` , ponieważ upłynął limit czasu żądania), wątek nie powinien wywoływać <xref:System.Threading.Mutex.ReleaseMutex%2A>, w tym przypadku wątek nie powinien również mieć uprawnień dostępu do zasobu chronionego przez mutex, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4ec63-358">If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 <span data-ttu-id="4ec63-359">Wątek, który jest właścicielem obiektu mutex, może określać ten sam obiekt mutex w powtórzonych wywołaniach funkcji oczekiwania bez blokowania jego wykonywania.</span><span class="sxs-lookup"><span data-stu-id="4ec63-359">A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</span></span> <span data-ttu-id="4ec63-360">Liczba wywołań jest utrzymywana przez środowisko uruchomieniowe języka wspólnego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-360">The number of calls is kept by the common language runtime.</span></span> <span data-ttu-id="4ec63-361">Wątek musi wywoływać <xref:System.Threading.Mutex.ReleaseMutex%2A> tę samą liczbę razy, aby zwolnić własność obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-361">The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="4ec63-362">Jeśli wątek kończy się, będąc właścicielem obiektu mutex, element mutex zostanie wskazany jako porzucony.</span><span class="sxs-lookup"><span data-stu-id="4ec63-362">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="4ec63-363">Stan obiektu mutex jest ustawiony na zasygnalizowanie i Następny wątek oczekujący pobiera własność.</span><span class="sxs-lookup"><span data-stu-id="4ec63-363">The state of the mutex is set to signaled and the next waiting thread gets ownership.</span></span> <span data-ttu-id="4ec63-364">Jeśli żaden z nich nie jest właścicielem obiektu mutex, stan obiektu mutex jest sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="4ec63-364">If no one owns the mutex, the state of the mutex is signaled.</span></span> <span data-ttu-id="4ec63-365">Począwszy od wersji 2,0 .NET Framework, <xref:System.Threading.AbandonedMutexException> zostanie zgłoszony w następnym wątku, który uzyskuje mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-365">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex.</span></span> <span data-ttu-id="4ec63-366">Przed wersjami 2,0 .NET Framework nie został zgłoszony żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4ec63-366">Prior to version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="4ec63-367">Porzucony obiekt mutex często wskazuje poważny błąd w kodzie.</span><span class="sxs-lookup"><span data-stu-id="4ec63-367">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="4ec63-368">Gdy wątek zostanie zakończony bez zwalniania obiektu mutex, struktury danych chronione przez element Mutex mogą nie być w stanie spójności.</span><span class="sxs-lookup"><span data-stu-id="4ec63-368">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="4ec63-369">Następny wątek do żądania własności obiektu mutex może obsłużyć ten wyjątek i postępować, jeśli można zweryfikować integralność struktur danych.</span><span class="sxs-lookup"><span data-stu-id="4ec63-369">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="4ec63-370">W przypadku obiektu mutex w całym systemie porzucony obiekt mutex może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).</span><span class="sxs-lookup"><span data-stu-id="4ec63-370">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ec63-371">Poniższy przykład pokazuje, jak obiekt lokalny <xref:System.Threading.Mutex> jest używany do synchronizowania dostępu do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-371">The following example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="4ec63-372">Wątek, który tworzy mutex, nie jest początkowo jego właścicielem.</span><span class="sxs-lookup"><span data-stu-id="4ec63-372">The thread that creates the mutex does not own it initially.</span></span> <span data-ttu-id="4ec63-373"><xref:System.Threading.Mutex.ReleaseMutex%2A> Metoda jest używana do zwolnienia obiektu mutex, gdy nie jest już potrzebne.</span><span class="sxs-lookup"><span data-stu-id="4ec63-373">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is used to release the mutex when it is no longer needed.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="4ec63-374">Wątek wywołujący nie jest właścicielem obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-374">The calling thread does not own the mutex.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4ec63-375">Bieżące wystąpienie zostało już usunięte.</span><span class="sxs-lookup"><span data-stu-id="4ec63-375">The current instance has already been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="4ec63-376">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="4ec63-376">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="4ec63-377">Muteksy</span><span class="sxs-lookup"><span data-stu-id="4ec63-377">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity"><span data-ttu-id="4ec63-378"><see cref="T:System.Security.AccessControl.MutexSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu, który ma zostać zastosowany do nazwanego obiektu mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-378">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="4ec63-379">Ustawia zabezpieczenia kontroli dostępu dla nazwanego muteksu systemowego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-379">Sets the access control security for a named system mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-380">Użytkownik musi mieć <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> uprawnienia do wywołania tej metody, a element mutex musi być otwarty za pomocą <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ec63-380">The user must have <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ec63-381">Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego obiektu mutex z zabezpieczeniami kontroli dostępu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-381">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="4ec63-382">W przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego muteksu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-382">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="4ec63-383">Jeśli mutex nie istnieje, jest tworzony z początkową własnością i zabezpieczeniami kontroli dostępu, która odmówi bieżącym użytkownikowi prawo do korzystania z elementu mutex, ale przyznaje prawo do odczytu i zmiany uprawnień do obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-383">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="4ec63-384">W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="4ec63-384">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="4ec63-385">Przechwycono wyjątek, a w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, aby otworzyć mutex z prawami wymaganymi do odczytu i zmiany uprawnień <xref:System.Threading.Mutex.GetAccessControl%2A> przy użyciu metod i <xref:System.Threading.Mutex.SetAccessControl%2A> .</span><span class="sxs-lookup"><span data-stu-id="4ec63-385">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="4ec63-386">Po zmianie uprawnień element mutex zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="4ec63-386">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="4ec63-387">W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="4ec63-387">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4ec63-388"><paramref name="mutexSecurity" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-388"><paramref name="mutexSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="4ec63-389">Użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-389">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span>  
  
<span data-ttu-id="4ec63-390">—lub—</span><span class="sxs-lookup"><span data-stu-id="4ec63-390">-or-</span></span> 
<span data-ttu-id="4ec63-391">Element mutex nie został otwarty przy <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />użyciu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-391">The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="4ec63-392">Bieżący <see cref="T:System.Threading.Mutex" /> obiekt nie reprezentuje nazwanego elementu mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-392">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4ec63-393">Otwiera określony nazwany obiekt mutex, jeśli już istnieje, i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="4ec63-393">Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="4ec63-394">Nazwa elementu mutex systemu do otwarcia.</span><span class="sxs-lookup"><span data-stu-id="4ec63-394">The name of the system mutex to open.</span></span></param>
        <param name="result"><span data-ttu-id="4ec63-395">Gdy ta metoda zwraca, zawiera <see cref="T:System.Threading.Mutex" /> obiekt, który reprezentuje nazwany mutex, jeśli wywołanie zakończyło się powodzeniem lub <see langword="null" /> wywołanie nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="4ec63-395">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="4ec63-396">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="4ec63-396">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="4ec63-397">Otwiera określony nazwany obiekt mutex, jeśli już istnieje, i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="4ec63-397">Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="4ec63-398"><see langword="true" />Jeśli nazwany mutex został pomyślnie otwarty; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="4ec63-398"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-399">Jeśli nazwany element mutex nie istnieje, ta metoda nie zostanie utworzona.</span><span class="sxs-lookup"><span data-stu-id="4ec63-399">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="4ec63-400">Aby utworzyć systemowy obiekt mutex, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które `name` mają parametr.</span><span class="sxs-lookup"><span data-stu-id="4ec63-400">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="4ec63-401">Jeśli nie masz pewności, czy nazwany element mutex istnieje, użyj tego przeciążenia metody zamiast <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenia metody, które zgłasza wyjątek, jeśli element mutex nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="4ec63-401">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="4ec63-402">Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.Mutex> obiekt, nawet jeśli zwracane obiekty reprezentują ten sam nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-402">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="4ec63-403">To Przeciążenie metody jest równoważne wywołaniem <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> przeciążenia metody i określaniem <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> prawami, połączonymi przy użyciu bitowej lub operacji.</span><span class="sxs-lookup"><span data-stu-id="4ec63-403">This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="4ec63-404">Określenie flagi pozwala wątku czekać na element mutex, a <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> określenie flagi umożliwia wątek wywołujący <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="4ec63-404">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="4ec63-405">Ta metoda nie żąda własności obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-405">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4ec63-406"><paramref name="name" />jest pustym ciągiem.</span><span class="sxs-lookup"><span data-stu-id="4ec63-406"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="4ec63-407">—lub—</span><span class="sxs-lookup"><span data-stu-id="4ec63-407">-or-</span></span> 
 <span data-ttu-id="4ec63-408"><paramref name="name" />jest dłuższa niż 260 znaków.</span><span class="sxs-lookup"><span data-stu-id="4ec63-408"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4ec63-409"><paramref name="name" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-409"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="4ec63-410">Wystąpił błąd Win32.</span><span class="sxs-lookup"><span data-stu-id="4ec63-410">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="4ec63-411">Nazwany mutex istnieje, ale użytkownik nie ma wymaganego dostępu zabezpieczeń, aby go użyć.</span><span class="sxs-lookup"><span data-stu-id="4ec63-411">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4ec63-412">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-412">requires full trust for the immediate caller.</span></span> <span data-ttu-id="4ec63-413">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="4ec63-413">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="4ec63-414">Nazwa elementu mutex systemu do otwarcia.</span><span class="sxs-lookup"><span data-stu-id="4ec63-414">The name of the system mutex to open.</span></span></param>
        <param name="rights"><span data-ttu-id="4ec63-415">Bitowa kombinacja wartości wyliczenia, które reprezentują żądany dostęp do zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="4ec63-415">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="4ec63-416">Gdy ta metoda zwraca, zawiera <see cref="T:System.Threading.Mutex" /> obiekt, który reprezentuje nazwany mutex, jeśli wywołanie zakończyło się powodzeniem lub <see langword="null" /> wywołanie nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="4ec63-416">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="4ec63-417">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="4ec63-417">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="4ec63-418">Otwiera określony nazwany obiekt mutex, jeśli już istnieje, z żądanym dostępem zabezpieczeń i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="4ec63-418">Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="4ec63-419"><see langword="true" />Jeśli nazwany mutex został pomyślnie otwarty; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="4ec63-419"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ec63-420">Jeśli nazwany element mutex nie istnieje, ta metoda nie zostanie utworzona.</span><span class="sxs-lookup"><span data-stu-id="4ec63-420">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="4ec63-421">Aby utworzyć systemowy obiekt mutex, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które `name` mają parametr.</span><span class="sxs-lookup"><span data-stu-id="4ec63-421">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="4ec63-422">Jeśli nie masz pewności, czy nazwany element mutex istnieje, użyj tego przeciążenia metody zamiast <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, które zgłasza wyjątek, jeśli element mutex nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="4ec63-422">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="4ec63-423">Parametr musi <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> zawierać flagę, aby umożliwić wątkom oczekiwanie na element mutex, oraz flagę, aby umożliwić wątkom <xref:System.Threading.Mutex.ReleaseMutex%2A> wywoływanie metody. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> `rights`</span><span class="sxs-lookup"><span data-stu-id="4ec63-423">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="4ec63-424">Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.Mutex> obiekt, nawet jeśli zwracane obiekty reprezentują ten sam nazwany element mutex systemu.</span><span class="sxs-lookup"><span data-stu-id="4ec63-424">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="4ec63-425">Ta metoda nie żąda własności obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="4ec63-425">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4ec63-426"><paramref name="name" />jest pustym ciągiem.</span><span class="sxs-lookup"><span data-stu-id="4ec63-426"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="4ec63-427">—lub—</span><span class="sxs-lookup"><span data-stu-id="4ec63-427">-or-</span></span> 
 <span data-ttu-id="4ec63-428"><paramref name="name" />jest dłuższa niż 260 znaków.</span><span class="sxs-lookup"><span data-stu-id="4ec63-428"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4ec63-429"><paramref name="name" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4ec63-429"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="4ec63-430">Wystąpił błąd Win32.</span><span class="sxs-lookup"><span data-stu-id="4ec63-430">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="4ec63-431">Nazwany mutex istnieje, ale użytkownik nie ma wymaganego dostępu zabezpieczeń, aby go użyć.</span><span class="sxs-lookup"><span data-stu-id="4ec63-431">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="4ec63-432">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4ec63-432">requires full trust for the immediate caller.</span></span> <span data-ttu-id="4ec63-433">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="4ec63-433">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>

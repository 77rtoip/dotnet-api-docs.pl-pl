<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d1155367ffed453c9616698e60c5a31d0ab90cef" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69144018" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Element podstawowy synchronizacji, który może być również używany na potrzeby synchronizacji międzyprocesowej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy co najmniej dwa wątki muszą uzyskać dostęp do udostępnionego zasobu w tym samym czasie, system wymaga mechanizmu synchronizacji, aby upewnić się, że tylko jeden wątek w danym momencie używa zasobu. <xref:System.Threading.Mutex>jest pierwotną synchronizacją, która przyznaje wyłączny dostęp do zasobu udostępnionego tylko jednemu wątkowi. Jeśli wątek uzyskuje mutex, drugi wątek, który chce uzyskać ten mutex, jest zawieszony do momentu, gdy pierwszy wątek zwolni element mutex.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejs. Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio. Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `catch` w bloku. Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.  
  
 Możesz użyć metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> aby zażądać własności obiektu mutex. Bloki wywołujące wątki do jednego z następujących wystąpień:  
  
-   Element mutex jest sygnalizowane sygnalizowaniem wskazującym, że nie jest własnością. W <xref:System.Threading.WaitHandle.WaitOne%2A> takim przypadku metoda zwraca `true`, a wątek wywołujący przyjmuje własność obiektu mutex i uzyskuje dostęp do zasobu chronionego przez mutex. Po zakończeniu uzyskiwania dostępu do zasobu wątek musi wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę, aby zwolnić własność obiektu mutex. Pierwszy przykład w sekcji Przykłady ilustruje ten wzorzec.  
  
-   Przekroczono limit czasu określony w wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> metody, która `millisecondsTimeout` ma parametr lub `timeout` . Gdy tak się <xref:System.Threading.WaitHandle.WaitOne%2A> stanie, metoda zwraca `false`, a wątek wywołujący nie podejmuje dalszej próby uzyskania własności obiektu mutex. W takim przypadku należy zapewnić strukturę kodu tak, aby dostęp do zasobu, który jest chroniony przez mutex, został odrzucony do wątku wywołującego. Ponieważ wątek nigdy nie uzyskał własności elementu mutex, nie może wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metody. Drugi przykład w sekcji Przykłady ilustruje ten wzorzec.  
  
 <xref:System.Threading.Mutex> Klasa wymusza tożsamość wątku, więc element mutex może być wydawany tylko przez wątek, który go pozyskuje. Z kolei <xref:System.Threading.Semaphore> Klasa nie wymusza tożsamości wątku. Element mutex może być również przekazywać między granicami domeny aplikacji.  
  
 Wątek, który jest właścicielem obiektu mutex, może zażądać tego samego obiektu mutex <xref:System.Threading.WaitHandle.WaitOne%2A> w powtórzonych wywołaniach do bez blokowania jego wykonywania. Jednak wątek musi wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę o tej samej liczbie razy, aby zwolnić własność obiektu mutex.  
  
 Ponieważ klasa dziedziczy z <xref:System.Threading.WaitHandle>, można również wywołać metody statyczne <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> i <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> , aby zsynchronizować dostęp do chronionego zasobu. <xref:System.Threading.Mutex>  
  
 Jeśli wątek kończy się, będąc właścicielem obiektu mutex, element mutex zostanie wskazany jako porzucony. Stan obiektu mutex jest ustawiony na sygnalizowanie, a następny oczekujący wątek pobiera własność. Począwszy od wersji 2,0 .NET Framework, <xref:System.Threading.AbandonedMutexException> zostanie zgłoszony w następnym wątku, który uzyskuje porzucony obiekt mutex. Przed wersją 2,0 .NET Framework nie został zgłoszony żaden wyjątek.  
  
> [!CAUTION]
>  Porzucony obiekt mutex często wskazuje poważny błąd w kodzie. Gdy wątek zostanie zakończony bez zwalniania obiektu mutex, struktury danych chronione przez element Mutex mogą nie być w stanie spójności. Następny wątek do żądania własności obiektu mutex może obsłużyć ten wyjątek i postępować, jeśli można zweryfikować integralność struktur danych.  
  
 W przypadku obiektu mutex w całym systemie porzucony obiekt mutex może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).  
  
 Muteksy są dwa typy: lokalne muteksy, które są nienazwane i nazwane muteksy systemowe. Lokalny element mutex istnieje tylko w ramach procesu. Może być używany przez dowolny wątek w procesie, który zawiera odwołanie do <xref:System.Threading.Mutex> obiektu, który reprezentuje element mutex. Każdy <xref:System.Threading.Mutex> obiekt bez nazwy reprezentuje oddzielny lokalny element mutex.  
  
 Nazwane muteksy systemu są widoczne w całym systemie operacyjnym i mogą być używane do synchronizowania działań procesów. Można utworzyć <xref:System.Threading.Mutex> obiekt reprezentujący nazwany element mutex systemu przy użyciu konstruktora, który akceptuje nazwę. Obiekt systemu operacyjnego można utworzyć w tym samym czasie lub może istnieć przed utworzeniem <xref:System.Threading.Mutex> obiektu. Można utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują ten sam nazwany obiekt mutex, i można <xref:System.Threading.Mutex.OpenExisting%2A> użyć metody, aby otworzyć istniejący nazwany element mutex systemu.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe, nazwany element mutex systemu może mieć dwa poziomy widoczności. Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex jest widoczny we wszystkich sesjach serwera terminali. Jeśli nazwa zaczyna się od prefiksu "Local\\", mutex jest widoczny tylko w sesji serwera terminali, w której został utworzony. W takim przypadku na serwerze może istnieć oddzielny obiekt mutex o tej samej nazwie. Jeśli nie określisz prefiksu podczas tworzenia nazwanego obiektu mutex, przyjmuje prefiks "Local\\". W sesji serwera terminali dwa muteksy, których nazwy różnią się tylko prefiksami, są oddzielnymi muteksami, a oba są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksów "\\globalne" i "\\lokalne" opisują zakres nazwy obiektu mutex względem sesji serwera terminali, a nie względem procesów.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 Ten przykład pokazuje, jak obiekt <xref:System.Threading.Mutex> lokalny jest używany do synchronizowania dostępu do chronionego zasobu. Ponieważ każdy wywoływany wątek jest blokowany do momentu uzyskania własności obiektu mutex, musi wywołać <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę, aby zwolnić własność wątku.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 W poniższym przykładzie każdy wątek wywołuje <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> metodę w celu uzyskania obiektu mutex. Jeśli upłynie limit czasu, metoda zwróci wartość `false`, a wątek nie uzyska obiektu mutex ani nie uzyska dostępu do zasobu, którego zabezpiecza. <xref:System.Threading.Mutex.ReleaseMutex%2A> Metoda jest wywoływana tylko przez wątek, który uzyskuje mutex.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Mutex" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Mutex" /> klasy z właściwościami domyślnymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tego przeciążenia konstruktora jest takie samo jak wywołanie <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> przeciążenia konstruktora i określanie `false` początkowego własności obiektu mutex. Oznacza to, że wątek wywołujący nie jest właścicielem obiektu mutex.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak obiekt lokalny <xref:System.Threading.Mutex> jest używany do synchronizowania dostępu do chronionego zasobu. Wątek, który tworzy mutex, nie jest początkowo jego właścicielem.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />Aby nadać wątek wywołujący początkową własność obiektu mutex; w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Mutex" /> klasy z wartością logiczną, która wskazuje, czy wątek wywołujący powinien mieć wstępną własność obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak obiekt lokalny <xref:System.Threading.Mutex> jest używany do synchronizowania dostępu do chronionego zasobu. Wątek, który najpierw tworzy <xref:System.Threading.Mutex> właściciela.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />Aby nadać wątkowi wywołującemu początkową własność o nazwie systemowego obiektu mutex w przypadku utworzenia nazwanego muteksu systemu w wyniku tego wywołania; w przeciwnym razie. <see langword="false" /></param>
        <param name="name">Nazwa <see cref="T:System.Threading.Mutex" />. Jeśli wartość to <see langword="null" /> <see cref="T:System.Threading.Mutex" /> , nazwa jest bez nazwy.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Mutex" /> klasy z wartością logiczną, która wskazuje, czy wątek wywołujący powinien mieć początkową własność obiektu mutex, oraz ciąg, który jest nazwą obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` nie `null` jest i `initiallyOwned` jest`true`, wątek wywołujący jest właścicielem obiektu mutex tylko wtedy, gdy obiekt mutex o nazwie system został utworzony w wyniku tego wywołania. Ponieważ nie istnieje mechanizm określania, czy nazwany element mutex systemu został utworzony, lepiej jest określić `false` dla `initiallyOwned` podczas wywoływania tego przeciążenia konstruktora. Można użyć konstruktora, <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> Jeśli trzeba określić wstępną własność.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt reprezentujący nazwany element mutex systemu. Można utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują ten sam nazwany mutex systemu.  
  
 Jeśli nazwany mutex został już utworzony z zabezpieczeniami kontroli dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, zgłaszany jest wyjątek. Aby otworzyć istniejący obiekt mutex o nazwie tylko te uprawnienia, które są konieczne do synchronizowania działań wątku <xref:System.Threading.Mutex.OpenExisting%2A> , zobacz metodę.  
  
 W przypadku określenia `null` lub pustego ciągu dla `name`, tworzony jest lokalny element mutex, tak jakby był wywoływany <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> Konstruktor. W tym przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ są one w całym systemie, nazwane muteksy mogą służyć do koordynowania użycia zasobów w granicach procesów.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe, nazwany element mutex systemu może mieć dwa poziomy widoczności. Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex jest widoczny we wszystkich sesjach serwera terminali. Jeśli nazwa zaczyna się od prefiksu "Local\\", mutex jest widoczny tylko w sesji serwera terminali, w której został utworzony. W takim przypadku na serwerze może istnieć oddzielny obiekt mutex o tej samej nazwie. Jeśli nie określisz prefiksu podczas tworzenia nazwanego obiektu mutex, przyjmuje prefiks "Local\\". W sesji serwera terminali dwa muteksy, których nazwy różnią się tylko prefiksami, są oddzielnymi muteksami, a oba są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksów "\\globalne" i "\\lokalne" opisują zakres nazwy obiektu mutex względem sesji serwera terminali, a nie względem procesów.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 Poniższy przykład pokazuje, jak nazwany mutex jest używany do sygnalizowania między wątkami uruchomionymi w dwóch oddzielnych procesach.  
  
 Uruchom ten program z dwóch lub więcej okien poleceń. Każdy proces tworzy <xref:System.Threading.Mutex> obiekt, który reprezentuje nazwany mutex `MyMutex`. Nazwany element mutex jest obiektem systemowym, którego okres istnienia jest ograniczony przez okresy <xref:System.Threading.Mutex> istnienia obiektów, które reprezentują tę wartość. Nazwany mutex jest tworzony, gdy pierwszy proces tworzy swój <xref:System.Threading.Mutex> obiekt; w tym przykładzie nazwany mutex jest własnością pierwszego procesu, który uruchamia program. Nazwany element mutex jest niszczony, gdy <xref:System.Threading.Mutex> wszystkie obiekty, które reprezentują tę wartość, zostały wydane.  
  
 Przeciążenie konstruktora użyte w tym przykładzie nie może określić wątku wywołującego, czy udzielono pierwotnej własności wywołanego obiektu mutex. Nie należy używać tego konstruktora do żądania początkowej własności, chyba że można się upewnić, że wątek utworzy nazwany mutex.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany mutex istnieje i ma zabezpieczenia kontroli dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nie można utworzyć nazwanego obiektu mutex, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />Aby nadać wątkowi wywołującemu początkową własność o nazwie systemowego obiektu mutex w przypadku utworzenia nazwanego muteksu systemu w wyniku tego wywołania; w przeciwnym razie. <see langword="false" /></param>
        <param name="name">Nazwa <see cref="T:System.Threading.Mutex" />. Jeśli wartość to <see langword="null" /> <see cref="T:System.Threading.Mutex" /> , nazwa jest bez nazwy.</param>
        <param name="createdNew">Gdy ta metoda zwraca, zawiera wartość logiczną, która <see langword="true" /> jest w przypadku utworzenia lokalnego obiektu mutex (czyli jeśli <paramref name="name" /> jest <see langword="null" /> lub pusty ciąg) lub jeśli został utworzony określony nazwany element mutex systemu; <see langword="false" /> Jeśli określony nazwany element mutex już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Mutex" /> klasy z wartością logiczną, która wskazuje, czy wątek wywołujący powinien mieć początkową własność obiektu mutex, ciąg, który jest nazwą obiektu mutex, i wartość logiczną, która po powrocie metody wskazuje czy wątek wywołujący otrzymał wstępną własność obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` nie `true` `createdNew` jest i `initiallyOwned` jest`true`, wątek wywołujący jest właścicielem nazwanego obiektu mutex tylko wtedy, gdy jest po wywołaniu. `null` W przeciwnym razie wątek może zażądać obiektu mutex przez <xref:System.Threading.WaitHandle.WaitOne%2A> wywołanie metody.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt reprezentujący nazwany element mutex systemu. Można utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują ten sam nazwany mutex systemu.  
  
 Jeśli nazwany mutex został już utworzony z zabezpieczeniami kontroli dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> uprawnień, zgłaszany jest wyjątek. Aby otworzyć istniejący obiekt mutex o nazwie tylko te uprawnienia, które są konieczne do synchronizowania działań wątku <xref:System.Threading.Mutex.OpenExisting%2A> , zobacz metodę.  
  
 W przypadku określenia `null` lub pustego ciągu dla `name`, tworzony jest lokalny element mutex, tak jakby był wywoływany <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> Konstruktor. W tym przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ są one w całym systemie, nazwane muteksy mogą służyć do koordynowania użycia zasobów w granicach procesów.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe, nazwany element mutex systemu może mieć dwa poziomy widoczności. Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex jest widoczny we wszystkich sesjach serwera terminali. Jeśli nazwa zaczyna się od prefiksu "Local\\", mutex jest widoczny tylko w sesji serwera terminali, w której został utworzony. W takim przypadku na serwerze może istnieć oddzielny obiekt mutex o tej samej nazwie. Jeśli nie określisz prefiksu podczas tworzenia nazwanego obiektu mutex, przyjmuje prefiks "Local\\". W sesji serwera terminali dwa muteksy, których nazwy różnią się tylko prefiksami, są oddzielnymi muteksami, a oba są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksów "\\globalne" i "\\lokalne" opisują zakres nazwy obiektu mutex względem sesji serwera terminali, a nie względem procesów.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak nazwany mutex jest używany do sygnalizowania między procesami lub wątkami. Uruchom ten program z dwóch lub więcej okien poleceń. Każdy proces tworzy <xref:System.Threading.Mutex> obiekt, który reprezentuje nazwany mutex "muteks". Nazwany element mutex jest obiektem systemowym. W tym przykładzie jego okres istnienia jest ograniczony przez okres istnienia <xref:System.Threading.Mutex> obiektów, które reprezentują tę wartość. Nazwany mutex jest tworzony, gdy pierwszy proces tworzy swój obiekt lokalny <xref:System.Threading.Mutex> i niszczony, gdy <xref:System.Threading.Mutex> wszystkie obiekty, które reprezentują ten element, zostały wydane. Nazwany mutex jest początkowo własnością pierwszego procesu. Drugi proces i wszystkie kolejne procesy czekają na wcześniejsze procesy w celu zwolnienia nazwanego obiektu mutex.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany mutex istnieje i ma zabezpieczenia kontroli dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nie można utworzyć nazwanego obiektu mutex, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" />Aby nadać wątkowi wywołującemu początkową własność o nazwie systemowego obiektu mutex w przypadku utworzenia nazwanego muteksu systemu w wyniku tego wywołania; w przeciwnym razie. <see langword="false" /></param>
        <param name="name">Nazwa obiektu mutex systemu. Jeśli wartość to <see langword="null" /> <see cref="T:System.Threading.Mutex" /> , nazwa jest bez nazwy.</param>
        <param name="createdNew">Gdy ta metoda zwraca, zawiera wartość logiczną, która <see langword="true" /> jest w przypadku utworzenia lokalnego obiektu mutex (czyli jeśli <paramref name="name" /> jest <see langword="null" /> lub pusty ciąg) lub jeśli został utworzony określony nazwany element mutex systemu; <see langword="false" /> Jeśli określony nazwany element mutex już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="mutexSecurity"><see cref="T:System.Security.AccessControl.MutexSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu, który ma zostać zastosowany do nazwanego obiektu mutex systemu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Mutex" /> klasy za pomocą wartości logicznej wskazującej, czy wątek wywołujący powinien mieć początkową własność obiektu mutex, ciąg, który jest nazwą obiektu mutex, zmienną logiczną, która po powrocie metody wskazuje czy wątek wywołujący otrzymał wstępną własność obiektu mutex, a zabezpieczenia kontroli dostępu mają być stosowane do nazwanego obiektu mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` nie `true` `createdNew` jest i `initiallyOwned` jest`true`, wątek wywołujący jest właścicielem nazwanego obiektu mutex tylko wtedy, gdy jest po wywołaniu. `null` W przeciwnym razie wątek może zażądać obiektu mutex przez <xref:System.Threading.WaitHandle.WaitOne%2A> wywołanie metody.  
  
 Użyj tego konstruktora, aby zastosować zabezpieczenia kontroli dostępu do nazwanego muteksowego obiektu mutex podczas tworzenia, uniemożliwiając innemu kodowi przejęcie kontroli nad muteksem.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Mutex> obiekt reprezentujący nazwany element mutex systemu. Można utworzyć wiele <xref:System.Threading.Mutex> obiektów, które reprezentują ten sam nazwany mutex systemu.  
  
 Jeśli element mutex o nazwie system nie istnieje, jest tworzony z określonym zabezpieczeniami kontroli dostępu. Jeśli istnieje nazwany mutex, określony zabezpieczenia kontroli dostępu jest ignorowany.  
  
> [!NOTE]
>  Obiekt wywołujący ma pełną kontrolę nad nowo utworzonym <xref:System.Threading.Mutex> obiektem, nawet w przypadku `mutexSecurity` odmowy lub niepowodzenia udzielenia pewnych praw dostępu bieżącemu użytkownikowi. Jeśli jednak bieżący użytkownik próbuje uzyskać inny <xref:System.Threading.Mutex> obiekt reprezentujący ten sam nazwany element mutex, używając konstruktora <xref:System.Threading.Mutex.OpenExisting%2A> lub metody zabezpieczenia kontroli dostępu do systemu Windows jest stosowane.  
  
 Jeśli nazwany mutex został już utworzony z zabezpieczeniami kontroli dostępu, a obiekt wywołujący nie ma <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, zgłaszany jest wyjątek. Aby otworzyć istniejący obiekt mutex o nazwie tylko te uprawnienia, które są konieczne do synchronizowania działań wątku <xref:System.Threading.Mutex.OpenExisting%2A> , zobacz metodę.  
  
 W przypadku określenia `null` lub pustego ciągu dla `name`, tworzony jest lokalny element mutex, tak jakby był wywoływany <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> Konstruktor. W tym przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ są one w całym systemie, nazwane muteksy mogą służyć do koordynowania użycia zasobów w granicach procesów.  
  
> [!NOTE]
>  Na serwerze, na którym są uruchomione usługi terminalowe, nazwany element mutex systemu może mieć dwa poziomy widoczności. Jeśli nazwa zaczyna się od prefiksu "Global\\", element mutex jest widoczny we wszystkich sesjach serwera terminali. Jeśli nazwa zaczyna się od prefiksu "Local\\", mutex jest widoczny tylko w sesji serwera terminali, w której został utworzony. W takim przypadku na serwerze może istnieć oddzielny obiekt mutex o tej samej nazwie. Jeśli nie określisz prefiksu podczas tworzenia nazwanego obiektu mutex, przyjmuje prefiks "Local\\". W sesji serwera terminali dwa muteksy, których nazwy różnią się tylko prefiksami, są oddzielnymi muteksami, a oba są widoczne dla wszystkich procesów w sesji serwera terminali. Oznacza to, że nazwy prefiksów "\\globalne" i "\\lokalne" opisują zakres nazwy obiektu mutex względem sesji serwera terminali, a nie względem procesów.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego obiektu mutex z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego muteksu.  
  
 Jeśli mutex nie istnieje, jest tworzony z początkową własnością i zabezpieczeniami kontroli dostępu, która odmówi bieżącym użytkownikowi prawo do korzystania z elementu mutex, ale przyznaje prawo do odczytu i zmiany uprawnień do obiektu mutex.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> Przeciążenie metody, aby otworzyć mutex z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień element mutex zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany mutex istnieje i ma zabezpieczenia kontroli dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nie można utworzyć nazwanego obiektu mutex, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Security.AccessControl.MutexSecurity" /> Pobiera obiekt reprezentujący zabezpieczenia kontroli dostępu dla nazwanego obiektu mutex.</summary>
        <returns><see cref="T:System.Security.AccessControl.MutexSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu dla nazwanego obiektu mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda używa następującej kombinacji flag (połączonych przy użyciu wartości bitowej lub operacji) do wyszukiwania uprawnień: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. <xref:System.Threading.Mutex.GetAccessControl%2A>  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> zawywoływanie tej metody, a element mutex musi być otwarty za pomocą <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego obiektu mutex z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego muteksu.  
  
 Jeśli mutex nie istnieje, jest tworzony z początkową własnością i zabezpieczeniami kontroli dostępu, która odmówi bieżącym użytkownikowi prawo do korzystania z elementu mutex, ale przyznaje prawo do odczytu i zmiany uprawnień do obiektu mutex.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Przechwycono wyjątek, a w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, aby otworzyć mutex z prawami wymaganymi do odczytu i zmiany uprawnień <xref:System.Threading.Mutex.GetAccessControl%2A> przy użyciu metod i <xref:System.Threading.Mutex.SetAccessControl%2A> .  
  
 Po zmianie uprawnień element mutex zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący <see cref="T:System.Threading.Mutex" /> obiekt reprezentuje nazwany element mutex systemu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
—lub— 
Bieżący <see cref="T:System.Threading.Mutex" /> obiekt reprezentuje nazwany element mutex systemu i nie został otwarty za pomocą <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Nieobsługiwane dla systemu Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określony nazwany obiekt mutex, jeśli już istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu mutex systemu do otwarcia.</param>
        <summary>Otwiera określony nazwany mutex, jeśli już istnieje.</summary>
        <returns>Obiekt reprezentujący nazwany element mutex systemu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> Metoda próbuje otworzyć określony nazwany element mutex systemu. Jeśli obiekt mutex systemu nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia obiektu systemowego. Aby utworzyć systemowy obiekt mutex, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.Mutex> obiekt, nawet jeśli zwracane obiekty reprezentują ten sam nazwany element mutex systemu.  
  
 To Przeciążenie metody jest równoważne wywołaniem <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody i określaniem <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> prawami, połączonymi przy użyciu bitowej lub operacji.  
  
 Określenie flagi pozwala wątku czekać na element mutex, a <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> określenie flagi umożliwia wątek wywołujący <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>  
  
 Ta metoda nie żąda własności obiektu mutex.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego obiektu mutex z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego muteksu.  
  
 Jeśli mutex nie istnieje, jest tworzony z początkową własnością i zabezpieczeniami kontroli dostępu, która odmówi bieżącym użytkownikowi prawo do korzystania z elementu mutex, ale przyznaje prawo do odczytu i zmiany uprawnień do obiektu mutex.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> Przeciążenie metody, aby otworzyć mutex z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień element mutex zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwany element mutex nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany mutex istnieje, ale użytkownik nie ma wymaganego dostępu zabezpieczeń, aby go użyć.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu mutex systemu do otwarcia.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują żądany dostęp do zabezpieczeń.</param>
        <summary>Otwiera określony nazwany mutex, jeśli już istnieje, z żądanym dostępem zabezpieczeń.</summary>
        <returns>Obiekt reprezentujący nazwany element mutex systemu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> zawierać flagę, aby umożliwić wątkom oczekiwanie na element mutex, oraz flagę, aby umożliwić wątkom <xref:System.Threading.Mutex.ReleaseMutex%2A> wywoływanie metody. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> `rights`  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> Metoda próbuje otworzyć istniejący nazwany mutex. Jeśli obiekt mutex systemu nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia obiektu systemowego. Aby utworzyć systemowy obiekt mutex, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.Mutex> obiekt, nawet jeśli zwracane obiekty reprezentują ten sam nazwany element mutex systemu.  
  
 Ta metoda nie żąda własności obiektu mutex.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego obiektu mutex z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego muteksu.  
  
 Jeśli mutex nie istnieje, jest tworzony z początkową własnością i zabezpieczeniami kontroli dostępu, która odmówi bieżącym użytkownikowi prawo do korzystania z elementu mutex, ale przyznaje prawo do odczytu i zmiany uprawnień do obiektu mutex.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> Przeciążenie metody, aby otworzyć mutex z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień element mutex zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwany element mutex nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany element mutex istnieje, ale użytkownik nie ma wymaganego dostępu do zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Mutex" /> Zwalnia jeden raz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za każdym razem, gdy wątek uzyskuje obiekt mutex (na przykład przez <xref:System.Threading.WaitHandle.WaitOne%2A> wywołanie jego metody), musi on <xref:System.Threading.Mutex.ReleaseMutex%2A> następnie wywołać, aby wycofać własność obiektu mutex i odblokować inne wątki, które próbują uzyskać własność obiektu mutex. Jeśli próba pobrania własności obiektu mutex nie powiedzie się (na przykład wtedy, gdy wywołanie <xref:System.Threading.WaitHandle.WaitOne%2A> metody `millisecondsTimeout` z `timeout` parametrem lub zwraca wartość `false` , ponieważ upłynął limit czasu żądania), wątek nie powinien wywoływać <xref:System.Threading.Mutex.ReleaseMutex%2A>, w tym przypadku wątek nie powinien również mieć uprawnień dostępu do zasobu chronionego przez mutex, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Wątek, który jest właścicielem obiektu mutex, może określać ten sam obiekt mutex w powtórzonych wywołaniach funkcji oczekiwania bez blokowania jego wykonywania. Liczba wywołań jest utrzymywana przez środowisko uruchomieniowe języka wspólnego. Wątek musi wywoływać <xref:System.Threading.Mutex.ReleaseMutex%2A> tę samą liczbę razy, aby zwolnić własność obiektu mutex.  
  
 Jeśli wątek kończy się, będąc właścicielem obiektu mutex, element mutex zostanie wskazany jako porzucony. Stan obiektu mutex jest ustawiony na zasygnalizowanie i Następny wątek oczekujący pobiera własność. Jeśli żaden z nich nie jest właścicielem obiektu mutex, stan obiektu mutex jest sygnalizowane. Począwszy od wersji 2,0 .NET Framework, <xref:System.Threading.AbandonedMutexException> zostanie zgłoszony w następnym wątku, który uzyskuje mutex. Przed wersjami 2,0 .NET Framework nie został zgłoszony żaden wyjątek.  
  
> [!CAUTION]
>  Porzucony obiekt mutex często wskazuje poważny błąd w kodzie. Gdy wątek zostanie zakończony bez zwalniania obiektu mutex, struktury danych chronione przez element Mutex mogą nie być w stanie spójności. Następny wątek do żądania własności obiektu mutex może obsłużyć ten wyjątek i postępować, jeśli można zweryfikować integralność struktur danych.  
  
 W przypadku obiektu mutex w całym systemie porzucony obiekt mutex może wskazywać, że aplikacja została zakończona nieoczekiwanie (na przykład za pomocą Menedżera zadań systemu Windows).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak obiekt lokalny <xref:System.Threading.Mutex> jest używany do synchronizowania dostępu do chronionego zasobu. Wątek, który tworzy mutex, nie jest początkowo jego właścicielem. <xref:System.Threading.Mutex.ReleaseMutex%2A> Metoda jest używana do zwolnienia obiektu mutex, gdy nie jest już potrzebne.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Wątek wywołujący nie jest właścicielem obiektu mutex.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Muteksy</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity"><see cref="T:System.Security.AccessControl.MutexSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu, który ma zostać zastosowany do nazwanego obiektu mutex systemu.</param>
        <summary>Ustawia zabezpieczenia kontroli dostępu dla nazwanego muteksu systemowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi mieć <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> uprawnienia do wywołania tej metody, a element mutex musi być otwarty za pomocą <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego obiektu mutex z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.Mutex.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego muteksu.  
  
 Jeśli mutex nie istnieje, jest tworzony z początkową własnością i zabezpieczeniami kontroli dostępu, która odmówi bieżącym użytkownikowi prawo do korzystania z elementu mutex, ale przyznaje prawo do odczytu i zmiany uprawnień do obiektu mutex.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Przechwycono wyjątek, a w przykładzie użyto <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, aby otworzyć mutex z prawami wymaganymi do odczytu i zmiany uprawnień <xref:System.Threading.Mutex.GetAccessControl%2A> przy użyciu metod i <xref:System.Threading.Mutex.SetAccessControl%2A> .  
  
 Po zmianie uprawnień element mutex zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mutexSecurity" />jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
—lub— 
Element mutex nie został otwarty przy <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />użyciu.</exception>
        <exception cref="T:System.SystemException">Bieżący <see cref="T:System.Threading.Mutex" /> obiekt nie reprezentuje nazwanego elementu mutex systemu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określony nazwany obiekt mutex, jeśli już istnieje, i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu mutex systemu do otwarcia.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera <see cref="T:System.Threading.Mutex" /> obiekt, który reprezentuje nazwany mutex, jeśli wywołanie zakończyło się powodzeniem lub <see langword="null" /> wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określony nazwany obiekt mutex, jeśli już istnieje, i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli nazwany mutex został pomyślnie otwarty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwany element mutex nie istnieje, ta metoda nie zostanie utworzona. Aby utworzyć systemowy obiekt mutex, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Jeśli nie masz pewności, czy nazwany element mutex istnieje, użyj tego przeciążenia metody zamiast <xref:System.Threading.Mutex.OpenExisting%28System.String%29> przeciążenia metody, które zgłasza wyjątek, jeśli element mutex nie istnieje.  
  
 Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.Mutex> obiekt, nawet jeśli zwracane obiekty reprezentują ten sam nazwany element mutex systemu.  
  
 To Przeciążenie metody jest równoważne wywołaniem <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> przeciążenia metody i określaniem <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> prawami, połączonymi przy użyciu bitowej lub operacji. Określenie flagi pozwala wątku czekać na element mutex, a <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> określenie flagi umożliwia wątek wywołujący <xref:System.Threading.Mutex.ReleaseMutex%2A> metodę. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>  
  
 Ta metoda nie żąda własności obiektu mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany mutex istnieje, ale użytkownik nie ma wymaganego dostępu zabezpieczeń, aby go użyć.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu mutex systemu do otwarcia.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują żądany dostęp do zabezpieczeń.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera <see cref="T:System.Threading.Mutex" /> obiekt, który reprezentuje nazwany mutex, jeśli wywołanie zakończyło się powodzeniem lub <see langword="null" /> wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określony nazwany obiekt mutex, jeśli już istnieje, z żądanym dostępem zabezpieczeń i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli nazwany mutex został pomyślnie otwarty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwany element mutex nie istnieje, ta metoda nie zostanie utworzona. Aby utworzyć systemowy obiekt mutex, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Mutex.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Jeśli nie masz pewności, czy nazwany element mutex istnieje, użyj tego przeciążenia metody zamiast <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> przeciążenia metody, które zgłasza wyjątek, jeśli element mutex nie istnieje.  
  
 Parametr musi <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> zawierać flagę, aby umożliwić wątkom oczekiwanie na element mutex, oraz flagę, aby umożliwić wątkom <xref:System.Threading.Mutex.ReleaseMutex%2A> wywoływanie metody. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> `rights`  
  
 Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.Mutex> obiekt, nawet jeśli zwracane obiekty reprezentują ten sam nazwany element mutex systemu.  
  
 Ta metoda nie żąda własności obiektu mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany mutex istnieje, ale użytkownik nie ma wymaganego dostępu zabezpieczeń, aby go użyć.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>

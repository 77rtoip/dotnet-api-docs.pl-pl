<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30579820" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ogranicza liczbę wątków, które mogą uzyskać dostęp do zasobu lub pulę zasobów jednocześnie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Threading.Semaphore> klasę, aby kontrolować dostęp do puli zasobów. Wątki wprowadź semafora przez wywołanie metody <xref:System.Threading.WaitHandle.WaitOne%2A> metodę, która jest odziedziczone <xref:System.Threading.WaitHandle> klasy, a następnie zwolnij semafora przez wywołanie metody <xref:System.Threading.Semaphore.Release%2A> — metoda.  
  
 Licznik na semafora zostanie zmniejszona zawsze wątku wprowadza semafor i zwiększany, gdy wątek zwalnia semafora. Jeśli licznik osiągnie wartość zero, kolejne żądania bloku, aż do semafora zwolnienia inne wątki. Gdy wszystkie wątki zostały wydane semafora, wartość licznika jest wartość maksymalna określone podczas tworzenia semafora.  
  
 Nie gwarantuje kolejność, takich jak FIFO lub LIFO, w którym zablokowanych wątków wprowadź semafora nie istnieje.  
  
 Wątek można wprowadzić semafora wielokrotnie, wywołując <xref:System.Threading.WaitHandle.WaitOne%2A> metody wielokrotnie. Aby zwolnić niektóre lub wszystkie te wpisy, można wywołać bez parametrów wątku <xref:System.Threading.Semaphore.Release> przeciążenie metody można wywołać wiele razy lub <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenie metody, która określa liczbę wpisów do zwolnienia.  
  
 <xref:System.Threading.Semaphore> Klasa nie obsługuje wymuszania tożsamość wątku na wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> lub <xref:System.Threading.Semaphore.Release%2A>. Odpowiada programisty upewnij się, że wątków nie zwalnia semafora zbyt wiele razy. Na przykład załóżmy, że maksymalna liczba dwóch i który wątku A i B wątku ma semafora zarówno wprowadź semafora. Jeśli to błąd programistyczny w wątku B powoduje go do wywołania <xref:System.Threading.Semaphore.Release%2A> dwa razy, zarówno wywołania powiodło się. Licznik na semafora jest pełny i gdy wątku A ostatecznie wywołuje <xref:System.Threading.Semaphore.Release%2A>, <xref:System.Threading.SemaphoreFullException> jest generowany.  
  
 Istnieją dwa typy semaforów: semaforów lokalnych i semaforów systemu o nazwie. W przypadku utworzenia <xref:System.Threading.Semaphore> przy użyciu konstruktora akceptującego nazwy, jest on skojarzony z systemu operacyjnego semafor o tej nazwie. O nazwie system semaforów są widoczne w systemie operacyjnym i może służyć do synchronizowania działania procesów. Możesz utworzyć wiele <xref:System.Threading.Semaphore> semafora systemu o nazwie obiekty reprezentujące takie same i można użyć <xref:System.Threading.Semaphore.OpenExisting%2A> otworzyć istniejącą metodę o nazwie semafora systemowego.  
  
 Semafor lokalny istnieje tylko w ramach procesu. Może służyć za którymkolwiek wątku w procesie, który zawiera odwołanie do lokalnej <xref:System.Threading.Semaphore> obiektu. Każdy <xref:System.Threading.Semaphore> obiekt jest oddzielny semafora lokalnego.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy semafora maksymalnej liczby trzy i liczba początkowa zero. W przykładzie uruchomiono pięć wątków, które blokują oczekiwania semaforów. Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenie metody, aby zwiększyć licznik semafora do jego maksymalnej, umożliwiając trzech wątków na wejście do semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Poczekaj chwilę, symulacji pracy i wywołania metody <xref:System.Threading.Semaphore.Release> przeciążenie metody, aby zwolnić semafora. Zawsze, gdy wydaniu semafora poprzedniej Licznik semafora jest wyświetlany. Użycie semafora śledzenie wiadomości konsoli. Interwał symulowane pracy zwiększają się nieznacznie dla każdego wątku, aby ułatwić dane wyjściowe.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semafora, które mogą być przyznane jednocześnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań semafora, które mogą być przyznane jednocześnie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> Klasa początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje semafora bez nazwy. Wszystkie wątki wystąpienia takich semafora musi mieć odwołania do wystąpienia.  
  
 Jeśli `initialCount` jest mniejsza niż `maximumCount`, efekt jest taki sam jak, jeśli bieżący wątek wywołał <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy. Jeśli nie chcesz zarezerwować żadnych wpisów dla wątku, który tworzy semafora, użyj tego samego numeru dla `maximumCount` i `initialCount`.  
  
   
  
## Examples  
 Poniższy przykład tworzy semafor o maksymalnej liczby trzech i liczba początkowa zero. W przykładzie uruchomiono pięć wątków, które blokują oczekiwania semaforów. Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenie metody, aby zwiększyć licznik semafora do jego maksymalnej, umożliwiając trzech wątków na wejście do semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Poczekaj chwilę, symulacji pracy i wywołania metody <xref:System.Threading.Semaphore.Release> przeciążenie metody, aby zwolnić semafora. Zawsze, gdy wydaniu semafora poprzedniej Licznik semafora jest wyświetlany. Użycie semafora śledzenie wiadomości konsoli. Interwał symulowane pracy zwiększają się nieznacznie dla każdego wątku, aby ułatwić dane wyjściowe.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> jest mniejsza niż 1.  
  
 —lub—  
  
 <paramref name="initialCount" /> jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semafora, które mogą być przyznane jednocześnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań semafora, które mogą być przyznane jednocześnie.</param>
        <param name="name">Nazwa obiektu semafora systemu o nazwie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy, określenie początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów i opcjonalnie określając nazwę obiektu semafora systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt, który reprezentuje semafora systemu o nazwie. Możesz utworzyć wiele <xref:System.Threading.Semaphore> semafora systemu o nazwie obiekty reprezentujące takie same.  
  
 Jeśli semafora systemu o nazwie nie istnieje, jest on tworzony przy użyciu liczba początkowa i maksymalna liczba określona przez `initialCount` i `maximumCount`. Jeśli semafora systemu o nazwie już istnieje, `initialCount` i `maximumCount` nie są używane, mimo że nieprawidłowe wartości nadal powodują wyjątków. Jeśli trzeba określić, czy semafor o nazwie system został utworzony, użyj <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> Konstruktor zamiast tego przeciążenia.  
  
> [!IMPORTANT]
>  Korzystając z tego przeciążenia konstruktora, zalecaną praktyką jest określenie tego samego numeru dla `initialCount` i `maximumCount`. Jeśli `initialCount` jest mniejsza niż `maximumCount`i utworzeniu semafora systemu o nazwie, efekt jest taki sam jak, jeśli bieżący wątek wywołał <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy. Z tego przeciążenia konstruktora istnieje jednak nie można określić, czy semafor o nazwie system został utworzony.  
  
 Jeśli określisz `null` lub pusty ciąg `name`, semafora lokalnym jest tworzony tak, jakby były nazywane <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeładowania konstruktora.  
  
 Ponieważ nazwanego semaforów są widoczne w systemie operacyjnym, ich może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
 Jeśli chcesz dowiedzieć się, czy istnieje semafor o nazwie system, należy użyć <xref:System.Threading.Semaphore.OpenExisting%2A> metody. <xref:System.Threading.Semaphore.OpenExisting%2A> Metoda próbuje otworzyć istniejące o nazwie semafor i zgłasza wyjątek, jeśli nie istnieje semafor systemu.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa semafora nazwanego. Semafor o nazwie jest tworzona z maksymalną liczbę pięciu i liczba początkowa pięć. Program udostępnia trzy wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> metody. W związku z tym jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia zablokuje na trzeci wywołanie <xref:System.Threading.WaitHandle.WaitOne%2A>. Zwolnij jeden lub więcej wpisów w pierwszej kopii programu odblokowania drugiego.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> jest mniejsza niż 1.  
  
 —lub—  
  
 <paramref name="initialCount" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor o nazwie istnieje i ma kontrolę dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Semafor o nazwie nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływania kodu niezarządzanego utworzyć semafora systemu o nazwie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semafora, które mogą być spełnione jednocześnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań semafora, które mogą być spełnione jednocześnie.</param>
        <param name="name">Nazwa obiektu semafora systemu o nazwie.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono semafora lokalnego (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> lub ciąg pusty) lub jeśli utworzono semafora określonego systemu o nazwie; <see langword="false" /> Jeśli określonego o nazwie semafora systemowego już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy, określając początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów, opcjonalnie określający nazwę obiektu semafora systemu i określanie zmienna, która odbiera wartość wskazującą Określa, czy nowe semafora systemu został utworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt, który reprezentuje semafora systemu o nazwie. Możesz utworzyć wiele <xref:System.Threading.Semaphore> semafora systemu o nazwie obiekty reprezentujące takie same.  
  
 Jeśli semafora systemu o nazwie nie istnieje, jest on tworzony przy użyciu liczba początkowa i maksymalna liczba określona przez `initialCount` i `maximumCount`. Jeśli semafora systemu o nazwie już istnieje, `initialCount` i `maximumCount` nie są używane, mimo że nieprawidłowe wartości nadal powodują wyjątków. Użyj `createdNew` ustalenie, czy utworzono semafora systemowego.  
  
 Jeśli `initialCount` jest mniejsza niż `maximumCount`, i `createdNew` jest `true`, efekt jest taki sam jak, jeśli bieżący wątek wywołał <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy.  
  
 Jeśli określisz `null` lub pusty ciąg `name`, semafora lokalnym jest tworzony tak, jakby były nazywane <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeładowania konstruktora. W takim przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ nazwanego semaforów są widoczne w systemie operacyjnym, ich może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano zachowanie międzyprocesowa semafora nazwanego. Semafor o nazwie jest tworzona z maksymalną liczbę pięciu i liczba początkowa dwóch. Oznacza to zastrzega sobie trzy wpisy dla wątku, który wywołuje konstruktor. Jeśli `createNew` jest `false`, program udostępnia trzy wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> metody. W związku z tym jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia zablokuje na trzeci wywołanie <xref:System.Threading.WaitHandle.WaitOne%2A>. Zwolnij jeden lub więcej wpisów w pierwszej kopii programu odblokowania drugiego.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> jest mniejsza niż 1.  
  
 —lub—  
  
 <paramref name="initialCount" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor o nazwie istnieje i ma kontrolę dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Semafor o nazwie nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływania kodu niezarządzanego utworzyć semafora systemu o nazwie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semafora, które mogą być spełnione jednocześnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań semafora, które mogą być spełnione jednocześnie.</param>
        <param name="name">Nazwa obiektu semafora systemu o nazwie.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono semafora lokalnego (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> lub ciąg pusty) lub jeśli utworzono semafora określonego systemu o nazwie; <see langword="false" /> Jeśli określonego o nazwie semafora systemowego już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> obiekt, który reprezentuje kontrolę dostępu ma zostać zastosowany do semafora systemu o nazwie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> Klasa początkowa liczba wpisów i maksymalną liczbę równoczesnych wpisów, opcjonalnie określając nazwę obiektu semafora systemu, określając zmienna, która odbiera wartość wskazującą Określa, czy utworzono nowe semafora systemu i określania kontroli dostępu zabezpieczeń semafora systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, aby zastosować kontrolę dostępu do semafora systemu o nazwie podczas jego tworzenia, uniemożliwia pobieranie formantu semafora innego kodu.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt, który reprezentuje semafora systemu o nazwie. Możesz utworzyć wiele <xref:System.Threading.Semaphore> semafora systemu o nazwie obiekty reprezentujące takie same.  
  
 Jeśli semafora systemu o nazwie nie istnieje, jest tworzony z określonym kontrolę dostępu. Jeśli istnieje semafor o nazwie, określony kontrolę dostępu jest ignorowane.  
  
> [!NOTE]
>  Obiekt wywołujący ma pełną kontrolę nad nowo utworzony <xref:System.Threading.Semaphore> nawet wtedy, gdy obiekt `semaphoreSecurity` nie zezwala lub nie powiedzie się pewne prawa dostępu do bieżącego użytkownika. Jednak jeśli bieżący użytkownik próbuje pobrać inny <xref:System.Threading.Semaphore> obiekt, do reprezentowania takie same o nazwie semafora przy użyciu konstruktora lub <xref:System.Threading.Semaphore.OpenExisting%2A> zastosowano kontrolę dostępu w systemie Windows metody.  
  
 Jeśli semafora systemu o nazwie nie istnieje, jest on tworzony przy użyciu liczba początkowa i maksymalna liczba określona przez `initialCount` i `maximumCount`. Jeśli semafora systemu o nazwie już istnieje, `initialCount` i `maximumCount` nie są używane, mimo że nieprawidłowe wartości nadal powodują wyjątków. Użyj `createdNew` parametr, aby określić, czy semafora systemu został utworzony przez tego konstruktora.  
  
 Jeśli `initialCount` jest mniejsza niż `maximumCount`, i `createdNew` jest `true`, efekt jest taki sam jak, jeśli bieżący wątek wywołał <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy.  
  
 Jeśli określisz `null` lub pusty ciąg `name`, semafora lokalnym jest tworzony tak, jakby były nazywane <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeładowania konstruktora. W takim przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ nazwanego semaforów są widoczne w systemie operacyjnym, ich może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie międzyprocesowa nazwanego semafora z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenie metody do testowania istnieje semafor o nazwie. Jeśli nie istnieje semafor, tworzona jest maksymalna liczba dwóch oraz kontrolę dostępu, który nie zezwala na bieżący użytkownik prawa do używania semafora, ale daje prawo do odczytu, a zmiana uprawnień do semafora. Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenie metody, aby otworzyć semafora z uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia, semafor został otwarty z uprawnień wymaganych do wprowadzania i wersji. Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> jest mniejsza niż 1.  
  
 —lub—  
  
 <paramref name="initialCount" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor o nazwie istnieje i ma kontrolę dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Semafor o nazwie nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływania kodu niezarządzanego utworzyć semafora systemu o nazwie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kontrolę dostępu dla semafora systemu o nazwie.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> obiekt, który reprezentuje kontrolę dostępu do semafora systemu o nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Semaphore.GetAccessControl%2A> Metoda używa następujących kombinacji flag (połączone, przy użyciu operacji bitowej OR) do wyszukania uprawnienia: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> praw, aby wywołać tę metodę i semaforów musi została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> praw.  
  
 W lokalnej semafora kontrolę dostępu nie ma znaczenia. Jeśli <xref:System.Threading.Semaphore> obiekt nie reprezentuje semafora systemu o nazwie, ta metoda zwraca <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt, który przyznaje wszystkie prawa do dowolnego użytkownika.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie międzyprocesowa nazwanego semafora z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenie metody do testowania istnieje semafor o nazwie.  
  
 Jeśli nie istnieje semafor, tworzona jest maksymalna liczba dwóch oraz kontrolę dostępu, który nie zezwala na bieżący użytkownik prawa do używania semafora, ale daje prawo do odczytu, a zmiana uprawnień do semafora.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenie metody, aby otworzyć semafora z uprawnień wymaganych do odczytywania i zmienić uprawnienia. Kontrolę dostępu do semafora systemu są uzyskiwane przy użyciu <xref:System.Threading.Semaphore.GetAccessControl%2A> metody.  
  
 Po zmianie uprawnienia, semafor został otwarty z uprawnień wymaganych do wprowadzania i wersji. Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący <see cref="T:System.Threading.Semaphore" /> obiekt reprezentuje semafora systemu o nazwie, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> praw.  
  
 —lub—  
  
 Bieżący <see cref="T:System.Threading.Semaphore" /> obiekt reprezentuje semafor o nazwie system i nie została otwarta z <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> praw.</exception>
        <exception cref="T:System.NotSupportedException">Nie jest obsługiwane dla systemu Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określony semafor o nazwie, jeśli już istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemu, aby otworzyć.</param>
        <summary>Otwiera określony semafor o nazwie, jeśli już istnieje.</summary>
        <returns>Obiekt, który reprezentuje semafora systemu o nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Semaphore.OpenExisting%2A> Metody spróbuje otworzyć określonego nazwanego semafora. Jeśli nie istnieje semafor systemu, ta metoda zgłasza wyjątek zamiast tworzenia semafora systemowego. Aby utworzyć semafora systemu, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Wiele wywołań do tej metody, używanego przez tę samą wartość `name` nie musi zwracać taki sam <xref:System.Threading.Semaphore> obiektu, nawet jeśli obiekty, które reprezentują zwracane są takie same o nazwie semafora systemowego.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.Semaphore.OpenExisting%2A> przeciążenie metody i określając <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw, połączone przy użyciu operacji lub.  
  
 Określanie <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku na wejście do semafora i określając <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątku w celu wywołania <xref:System.Threading.Semaphore.Release%2A> — metoda.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie międzyprocesowa nazwanego semafora z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenie metody do testowania istnieje semafor o nazwie.  
  
 Jeśli nie istnieje semafor, tworzona jest maksymalna liczba dwóch oraz kontrolę dostępu odmowy prawa do używania semafora bieżącego użytkownika, ale który przyznaje prawa do odczytu, a zmiana uprawnień do semafora.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenie metody. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenie metody, aby otworzyć semafora z uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia, semafor został otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Semafor o nazwie nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Istnieje semafor o nazwie, ale użytkownik nie ma dostępu zabezpieczeń, trzeba go używać.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływania kodu niezarządzanego, aby otworzyć semafora systemu o nazwie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemu, aby otworzyć.</param>
        <param name="rights">Bitowe połączenie wartości wyliczenia, które reprezentują dostęp wymaganymi.</param>
        <summary>Otwiera określonego nazwanego semafora, jeśli już istnieje, z wymaganymi dostępu.</summary>
        <returns>Obiekt, który reprezentuje semafora systemu o nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Parametr musi zawierać <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flagę wątków na wejście do semafora i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flagę wątków, aby wywołać <xref:System.Threading.Semaphore.Release%2A> metody.  
  
 <xref:System.Threading.Semaphore.OpenExisting%2A> Metody próbuje otworzyć istniejące o nazwie semafora. Jeśli nie istnieje semafor systemu, ta metoda zgłasza wyjątek zamiast tworzenia semafora systemowego. Aby utworzyć semafora systemu, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Wiele wywołań do tej metody, używanego przez tę samą wartość `name` nie musi zwracać taki sam <xref:System.Threading.Semaphore> obiektu, nawet jeśli obiekty, które reprezentują zwracane są takie same o nazwie semafora systemowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie międzyprocesowa nazwanego semafora z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenie metody do testowania istnieje semafor o nazwie.  
  
 Jeśli nie istnieje semafor, tworzona jest maksymalna liczba dwóch oraz kontrolę dostępu, który nie zezwala na bieżący użytkownik prawa do używania semafora, ale daje prawo do odczytu, a zmiana uprawnień do semafora.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenie metody, aby otworzyć semafora z uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia, semafor został otwarty z uprawnień wymaganych do wprowadzania i zwolnij go. Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Semafor o nazwie nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Istnieje semafor o nazwie, ale użytkownik nie ma żądanego praw dostępu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływania kodu niezarządzanego utworzyć semafora systemu o nazwie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamyka semafora.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka semafor i zwraca liczbę poprzednich.</summary>
        <returns>Licznik na semafora przed <see cref="Overload:System.Threading.Semaphore.Release" /> wywołano metodę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątków jest zwykle używany <xref:System.Threading.WaitHandle.WaitOne%2A> metodę, aby wprowadzić semafor i zwykle użyć przeciążenie tej metody, aby wyjść.  
  
 Jeśli <xref:System.Threading.SemaphoreFullException> jest generowany przez <xref:System.Threading.Semaphore.Release%2A> metody go nie musi oznaczać problem z wątek wywołujący. Tego wątku zakończyć semafora więcej razy niż wprowadzona mogła spowodować błąd programistyczny w innym wątku.  
  
 Jeśli bieżący <xref:System.Threading.Semaphore> obiekt reprezentuje semafora systemu o nazwie, użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> prawa i semaforów musi mieć została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy semafora maksymalnej liczby trzy i liczba początkowa zero. W przykładzie uruchomiono pięć wątków, które blokują oczekiwania semaforów. Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenie metody, aby zwiększyć licznik semafora do jego maksymalnej, umożliwiając trzech wątków na wejście do semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Poczekaj chwilę, symulacji pracy i wywołania metody <xref:System.Threading.Semaphore.Release> przeciążenie metody, aby zwolnić semafora.  
  
 Zawsze, gdy wydaniu semafora poprzedniej Licznik semafora jest wyświetlany. Użycie semafora śledzenie wiadomości konsoli. Interwał symulowane pracy zwiększają się nieznacznie dla każdego wątku, aby ułatwić dane wyjściowe.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">Licznik semafora jest już w wartości maksymalnej.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32 z nazwanym semafora.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor bieżącego reprezentuje semafora systemu o nazwie, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
 —lub—  
  
 Semafor bieżącego reprezentuje semafora systemu o nazwie, ale nie została otwarta z <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Liczba razy, aby zamknąć semafora.</param>
        <summary>Zamyka semafora określoną liczbę razy i zwraca liczbę poprzednich.</summary>
        <returns>Licznik na semafora przed <see cref="Overload:System.Threading.Semaphore.Release" /> wywołano metodę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątek wszedł semafora wiele razy, przeciążenie tej metody umożliwia Licznik semafora całego do przywrócenia przez jedno wywołanie.  
  
 Jeśli <xref:System.Threading.SemaphoreFullException> jest generowany przez <xref:System.Threading.Semaphore.Release%2A> metody go nie musi oznaczać problem z wątek wywołujący. Tego wątku zakończyć semafora więcej razy niż wprowadzona mogła spowodować błąd programistyczny w innym wątku.  
  
 Jeśli bieżący <xref:System.Threading.Semaphore> obiekt reprezentuje semafora systemu o nazwie, użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> prawa i semaforów musi mieć została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy semafora maksymalnej liczby trzy i liczba początkowa zero. W przykładzie uruchomiono pięć wątków, które blokują oczekiwania semaforów. Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenie metody, aby zwiększyć licznik semafora do jego maksymalnej, umożliwiając trzech wątków na wejście do semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Poczekaj chwilę, symulacji pracy i wywołania metody <xref:System.Threading.Semaphore.Release> przeciążenie metody, aby zwolnić semafora.  
  
 Zawsze, gdy wydaniu semafora poprzedniej Licznik semafora jest wyświetlany. Użycie semafora śledzenie wiadomości konsoli. Interwał symulowane pracy zwiększają się nieznacznie dla każdego wątku, aby ułatwić dane wyjściowe.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> jest mniejsza niż 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">Licznik semafora jest już w wartości maksymalnej.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32 z nazwanym semafora.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor bieżącego reprezentuje semafora systemu o nazwie, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> praw.  
  
 —lub—  
  
 Semafor bieżącego reprezentuje semafora systemu o nazwie, ale nie została otwarta z <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> praw.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> obiekt, który reprezentuje kontrolę dostępu ma zostać zastosowany do semafora systemu o nazwie.</param>
        <summary>Ustawia kontrolę dostępu do semafora systemu o nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolę dostępu można ustawić tylko na <xref:System.Threading.Semaphore> obiekty reprezentujące semaforów systemu o nazwie.  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> praw, aby wywołać tę metodę i semaforów musi została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> praw.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie międzyprocesowa nazwanego semafora z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenie metody do testowania istnieje semafor o nazwie.  
  
 Jeśli nie istnieje semafor, tworzona jest maksymalna liczba dwóch oraz kontrolę dostępu, który nie zezwala na bieżący użytkownik prawa do używania semafora, ale daje prawo do odczytu, a zmiana uprawnień do semafora.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenie metody, aby otworzyć semafora z uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia, przy użyciu <xref:System.Threading.Semaphore.SetAccessControl%2A> metody semafora jest otwierany z uprawnień wymaganych do wprowadzania i wersji. Trzeci okno polecenia uruchamiane przykład skompilowany, uruchamia, przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> praw.  
  
 —lub—  
  
 Semafor nie została otwarta z <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> praw.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący <see cref="T:System.Threading.Semaphore" /> obiekt nie reprezentuje semafora systemu o nazwie.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określony semafor o nazwie, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemu, aby otworzyć.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.Semaphore" /> obiekt, który reprezentuje semafor o nazwie, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie zakończyło się niepowodzeniem. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określony semafor o nazwie, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwany semafora została otwarta pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie istnieje semafor o nazwie, ta metoda nie tworzy go. Aby utworzyć semafora systemu, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Jeśli masz pewności, czy istnieje semafor o nazwie, użyj tego przeciążenia metody zamiast <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenie metody, która zgłasza wyjątek, jeśli nie istnieje semafor.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.Semaphore.TryOpenExisting%2A> przeciążenie metody i określając <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw, połączone przy użyciu operacji lub. Określanie <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku na wejście do semafora i określając <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątku w celu wywołania <xref:System.Threading.Semaphore.Release%2A> — metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Istnieje semafor o nazwie, ale użytkownik nie ma dostępu zabezpieczeń, trzeba go używać.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemu, aby otworzyć.</param>
        <param name="rights">Bitowe połączenie wartości wyliczenia, które reprezentują dostęp wymaganymi.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.Semaphore" /> obiekt, który reprezentuje semafor o nazwie, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie zakończyło się niepowodzeniem. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określony semafor o nazwie, jeśli już istnieje z wymaganymi dostęp i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwany semafora została otwarta pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie istnieje semafor o nazwie, ta metoda nie tworzy go. Aby utworzyć semafora systemu, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Jeśli masz pewności, czy istnieje semafor o nazwie, użyj tego przeciążenia metody zamiast <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenie metody, która zgłasza wyjątek, jeśli nie istnieje semafor.  
  
 `rights` Parametr musi zawierać <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flagę wątków na wejście do semafora i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flagę wątków, aby wywołać <xref:System.Threading.Semaphore.Release%2A> metody.  
  
 Wiele wywołań do tej metody, używanego przez tę samą wartość `name` nie musi zwracać taki sam <xref:System.Threading.Semaphore> obiektu, nawet jeśli obiekty, które reprezentują zwracane są takie same o nazwie semafora systemowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Istnieje semafor o nazwie, ale użytkownik nie ma dostępu zabezpieczeń, trzeba go używać.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
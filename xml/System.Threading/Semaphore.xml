<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="341a2bbc0c3988004ab57f93d5e715cb713edbe1" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48748926" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="e21e7-101">Ogranicza liczbę wątków, które mogą uzyskać dostęp do zasobu lub puli zasobów jednocześnie.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e21e7-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-102">Użyj <xref:System.Threading.Semaphore> klasy do kontrolowania dostępu do puli zasobów.</span><span class="sxs-lookup"><span data-stu-id="e21e7-102">Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources.</span></span> <span data-ttu-id="e21e7-103">Wątki wprowadź semafora przez wywołanie metody <xref:System.Threading.WaitHandle.WaitOne%2A> metody, która jest dziedziczona z <xref:System.Threading.WaitHandle> klasy, a następnie zwolnij semafora przez wywołanie metody <xref:System.Threading.Semaphore.Release%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-103">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="e21e7-104">Liczba klientów na semafor zostanie zmniejszona każdorazowo wątku przechodzi semafora i zwiększany, gdy wątek zwalnia semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-104">The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</span></span> <span data-ttu-id="e21e7-105">Jeśli licznik osiągnie wartość zero, kolejne żądania blokuje, aż do innych wątków zwolnienia semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-105">When the count is zero, subsequent requests block until other threads release the semaphore.</span></span> <span data-ttu-id="e21e7-106">Gdy wszystkie wątki zostały wydane semafora, liczba przy maksymalnej wartości określono podczas tworzenia semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-106">When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</span></span>  
  
 <span data-ttu-id="e21e7-107">Nie jest zagwarantowana kolejność, takich jak FIFO lub LIFO, w którym zablokowane wątki wprowadzić semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-107">There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-108">Wątek można wprowadzić semafora wielokrotnie, wywołując <xref:System.Threading.WaitHandle.WaitOne%2A> metoda wielokrotnie.</span><span class="sxs-lookup"><span data-stu-id="e21e7-108">A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly.</span></span> <span data-ttu-id="e21e7-109">Aby zwolnić niektórych lub wszystkich tych wpisów, można wywołać bez parametrów wątku <xref:System.Threading.Semaphore.Release> przeciążenia metody, które można wywołać wiele razy lub jest on <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody, która określa liczbę wpisów, które mogą być wprowadzane.</span><span class="sxs-lookup"><span data-stu-id="e21e7-109">To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.</span></span>  
  
 <span data-ttu-id="e21e7-110"><xref:System.Threading.Semaphore> Klasy nie wymusza tożsamość wątku na wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> lub <xref:System.Threading.Semaphore.Release%2A>.</span><span class="sxs-lookup"><span data-stu-id="e21e7-110">The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>.</span></span> <span data-ttu-id="e21e7-111">Odpowiada za programisty upewnij się, że wątki nie zwalnia semafora zbyt wiele razy.</span><span class="sxs-lookup"><span data-stu-id="e21e7-111">It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</span></span> <span data-ttu-id="e21e7-112">Na przykład załóżmy, że semafor ma maksymalną liczbę dwóch tego wątku, A i B wątku obydwa wprowadź semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-112">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="e21e7-113">Jeśli to błąd programistyczny w wątku B powoduje go do wywoływania <xref:System.Threading.Semaphore.Release%2A> dwa razy, oba wywołania powiodło się.</span><span class="sxs-lookup"><span data-stu-id="e21e7-113">If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed.</span></span> <span data-ttu-id="e21e7-114">Liczba klientów na semafora jest zapełniony i kiedy wątek, A ostatecznie wywołuje <xref:System.Threading.Semaphore.Release%2A>, <xref:System.Threading.SemaphoreFullException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="e21e7-114">The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
 <span data-ttu-id="e21e7-115">Istnieją dwa typy semaforów: lokalne semaforów i semaforów systemu o nazwie.</span><span class="sxs-lookup"><span data-stu-id="e21e7-115">Semaphores are of two types: local semaphores and named system semaphores.</span></span> <span data-ttu-id="e21e7-116">Jeśli tworzysz <xref:System.Threading.Semaphore> przy użyciu konstruktora, który przyjmuje nazwę, jest on skojarzony z semafora systemu operacyjnego o takiej nazwie.</span><span class="sxs-lookup"><span data-stu-id="e21e7-116">If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</span></span> <span data-ttu-id="e21e7-117">O nazwie system semaforów są widoczne w całym systemie operacyjnym i może służyć do synchronizowania działania procesów.</span><span class="sxs-lookup"><span data-stu-id="e21e7-117">Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="e21e7-118">Możesz tworzyć wiele <xref:System.Threading.Semaphore> obiekty reprezentujące takie same, o nazwie semafora systemowego i można użyć <xref:System.Threading.Semaphore.OpenExisting%2A> metodę, aby otworzyć istniejący o nazwie semafora systemowego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-118">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-119">Semafor lokalny istnieje tylko w ramach procesu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-119">A local semaphore exists only within your process.</span></span> <span data-ttu-id="e21e7-120">Mogą być używane w żadnym z wątków w procesie, który odwołuje się do lokalnej <xref:System.Threading.Semaphore> obiektu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-120">It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="e21e7-121">Każdy <xref:System.Threading.Semaphore> obiekt jest oddzielne semafora lokalnego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-121">Each <xref:System.Threading.Semaphore> object is a separate local semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-122">Poniższy przykład kodu tworzy semafor maksymalna liczba trzy i początkową liczbę zero.</span><span class="sxs-lookup"><span data-stu-id="e21e7-122">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="e21e7-123">W przykładzie uruchomiono pięć wątków, które blokować oczekiwanie na semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-123">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="e21e7-124">Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody, aby zwiększyć tę liczbę semafora do maksymalną, dzięki czemu trzech wątków do wprowadzania semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-124">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="e21e7-125">Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> poczekaj 1 sekundę, aby zasymulować pracy, a następnie wywołuje metodę <xref:System.Threading.Semaphore.Release> przeciążenia metody, aby zwolnić semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-125">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="e21e7-126">Każdorazowo, gdy wydaniu semafora wyświetlane liczba semafora w poprzednim.</span><span class="sxs-lookup"><span data-stu-id="e21e7-126">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="e21e7-127">Użycie konsoli komunikaty śledzenia semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-127">Console messages track semaphore use.</span></span> <span data-ttu-id="e21e7-128">Interwał symulowane pracy zwiększa się nieco dla każdego wątku, aby ułatwić dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="e21e7-128">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="e21e7-129">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e21e7-129">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="e21e7-130">Zarządzana wątkowość</span>
      <span class="sxs-lookup">
        <span data-stu-id="e21e7-130">Managed Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
      <span data-ttu-id="e21e7-131">Semaphore</span>
      <span class="sxs-lookup">
        <span data-stu-id="e21e7-131">Semaphore</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e21e7-132">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-132">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="e21e7-133">Początkowa liczba żądań semaforów, które mogą być przyznane jednocześnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-133">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="e21e7-134">Maksymalna liczba żądań dotyczących semafor, które mogą być przyznane jednocześnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-134">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e21e7-135">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy, określając początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-135">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-136">Ten konstruktor inicjuje semafora bez nazwy.</span><span class="sxs-lookup"><span data-stu-id="e21e7-136">This constructor initializes an unnamed semaphore.</span></span> <span data-ttu-id="e21e7-137">Wszystkie wątki używające wystąpienia takich semafora musi mieć odwołania do wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="e21e7-137">All threads that use an instance of such a semaphore must have references to the instance.</span></span>  
  
 <span data-ttu-id="e21e7-138">Jeśli `initialCount` jest mniejsza niż `maximumCount`, efekt jest taki sam, jakby były nazywane bieżącego wątku <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy.</span><span class="sxs-lookup"><span data-stu-id="e21e7-138">If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="e21e7-139">Nie można zarezerwować żadnych wpisów dla wątku, który tworzy semafora, użyć tego samego numeru dla `maximumCount` i `initialCount`.</span><span class="sxs-lookup"><span data-stu-id="e21e7-139">If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-140">Poniższy przykład tworzy semafor z maksymalną na równe 3 i początkową liczbę zero.</span><span class="sxs-lookup"><span data-stu-id="e21e7-140">The following example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="e21e7-141">W przykładzie uruchomiono pięć wątków, które blokować oczekiwanie na semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-141">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="e21e7-142">Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody, aby zwiększyć tę liczbę semafora do maksymalną, dzięki czemu trzech wątków do wprowadzania semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-142">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="e21e7-143">Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> poczekaj 1 sekundę, aby zasymulować pracy, a następnie wywołuje metodę <xref:System.Threading.Semaphore.Release> przeciążenia metody, aby zwolnić semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-143">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="e21e7-144">Każdorazowo, gdy wydaniu semafora wyświetlane liczba semafora w poprzednim.</span><span class="sxs-lookup"><span data-stu-id="e21e7-144">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="e21e7-145">Użycie konsoli komunikaty śledzenia semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-145">Console messages track semaphore use.</span></span> <span data-ttu-id="e21e7-146">Interwał symulowane pracy zwiększa się nieco dla każdego wątku, aby ułatwić dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="e21e7-146">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e21e7-147">
            <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-147">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e21e7-148">
            <paramref name="maximumCount" /> jest mniejsza niż 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-148">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="e21e7-149">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-149">-or-</span>
          </span>
          <span data-ttu-id="e21e7-150">
            <paramref name="initialCount" /> jest mniejsza niż 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-150">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="e21e7-151">Zarządzana wątkowość</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-151">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="e21e7-152">Semaphore</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-152">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="e21e7-153">Początkowa liczba żądań semaforów, które mogą być przyznane jednocześnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-153">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="e21e7-154">Maksymalna liczba żądań dotyczących semafor, które mogą być przyznane jednocześnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-154">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="e21e7-155">Nazwa obiektu semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-155">The name of a named system semaphore object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e21e7-156">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy, określając początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów i opcjonalnie określając nazwę obiektu semafora systemu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-156">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-157">Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt, który przedstawia semafor systemu o nazwie.</span><span class="sxs-lookup"><span data-stu-id="e21e7-157">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="e21e7-158">Możesz tworzyć wiele <xref:System.Threading.Semaphore> obiekty reprezentujące takie same, o nazwie semafora systemowego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-158">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-159">Jeśli semafora systemu o nazwie nie istnieje, zostanie utworzony przy użyciu liczba początkowej i maksymalna liczba określona przez `initialCount` i `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="e21e7-159">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="e21e7-160">Jeśli semafora systemu o nazwie już istnieje, `initialCount` i `maximumCount` nie są używane, mimo że nieprawidłowe wartości nadal powodują wyjątki.</span><span class="sxs-lookup"><span data-stu-id="e21e7-160">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="e21e7-161">Jeśli zachodzi potrzeba określenia czy semafora systemu o nazwie została utworzona, należy użyć <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> Konstruktor przeciążenia zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-161">If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e21e7-162">Gdy używasz tego przeciążenia konstruktora, zaleca się określić ten sam numer w `initialCount` i `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="e21e7-162">When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="e21e7-163">Jeśli `initialCount` jest mniejsza niż `maximumCount`i semafora systemu o nazwie zostanie utworzony, efekt jest taki sam, jakby były nazywane bieżącego wątku <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy.</span><span class="sxs-lookup"><span data-stu-id="e21e7-163">If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="e21e7-164">Z tego przeciążenia konstruktora istnieje jednak sposób określenia, czy semafora o nazwie system został utworzony.</span><span class="sxs-lookup"><span data-stu-id="e21e7-164">However, with this constructor overload there is no way to determine whether a named system semaphore was created.</span></span>  
  
 <span data-ttu-id="e21e7-165">Jeśli określisz `null` lub ciągu pustego `name`, utworzony lokalny semafora tak, jakby były nazywane <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeciążenia konstruktora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-165">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span>  
  
 <span data-ttu-id="e21e7-166">Ponieważ nazwany semaforów są widoczne w całym systemie operacyjnym, ich może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-166">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
 <span data-ttu-id="e21e7-167">Jeśli chcesz dowiedzieć się, czy istnieje semafora systemu o nazwie, użyj <xref:System.Threading.Semaphore.OpenExisting%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-167">If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method.</span></span> <span data-ttu-id="e21e7-168"><xref:System.Threading.Semaphore.OpenExisting%2A> Metoda próbuje otworzyć istniejący o nazwie semafor i zgłasza wyjątek, jeśli semafora systemu nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="e21e7-168">The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-169">Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-169">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="e21e7-170">Ten przykład tworzy nazwany semafora maksymalna liczba 5 i początkowa liczba 5.</span><span class="sxs-lookup"><span data-stu-id="e21e7-170">The example creates a named semaphore with a maximum count of five and an initial count of five.</span></span> <span data-ttu-id="e21e7-171">Program sprawia, że trzech wywołań <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-171">The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="e21e7-172">W związku z tym, po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zablokowanie w trzecim wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="e21e7-172">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="e21e7-173">Zwolnij jeden lub więcej wpisów w pierwszej kopii programu, aby odblokować drugiego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-173">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e21e7-174">
            <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-174">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="e21e7-175">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-175">-or-</span>
          </span>
          <span data-ttu-id="e21e7-176">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-176">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e21e7-177">
            <paramref name="maximumCount" /> jest mniejsza niż 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-177">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="e21e7-178">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-178">-or-</span>
          </span>
          <span data-ttu-id="e21e7-179">
            <paramref name="initialCount" /> jest mniejsza niż 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-179">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e21e7-180">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-180">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-181">Semafor o nazwie istnieje i ma kontrolę dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-181">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="e21e7-182">Semafor nazwanych nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-182">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e21e7-183">wywoływanie niezarządzanego kodu do tworzenia semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-183">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="e21e7-184">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-184">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="e21e7-185">Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-185">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="e21e7-186">Zarządzana wątkowość</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-186">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="e21e7-187">Semaphore</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-187">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="e21e7-188">Początkowa liczba żądań semaforów, które mogą zostać zrealizowane jednocześnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-188">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="e21e7-189">Maksymalna liczba żądań dotyczących semafor, które mogą zostać zrealizowane jednocześnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-189">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="e21e7-190">Nazwa obiektu semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-190">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="e21e7-191">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono semafora lokalnego (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> ani być pustym ciągiem) lub jeśli utworzono semafora określonego nazwanego systemu; <see langword="false" /> Jeśli określony o nazwie system semafora już istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-191">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="e21e7-192">Ten parametr jest przekazywany niezainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-192">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e21e7-193">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy, określając początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów, opcjonalnie określania nazwy obiektu semafora systemu i określanie zmienna, która odbiera wartość wskazującą czy został utworzony nowy semafora systemowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-193">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-194">Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt, który przedstawia semafor systemu o nazwie.</span><span class="sxs-lookup"><span data-stu-id="e21e7-194">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="e21e7-195">Możesz tworzyć wiele <xref:System.Threading.Semaphore> obiekty reprezentujące takie same, o nazwie semafora systemowego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-195">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-196">Jeśli semafora systemu o nazwie nie istnieje, zostanie utworzony przy użyciu liczba początkowej i maksymalna liczba określona przez `initialCount` i `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="e21e7-196">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="e21e7-197">Jeśli semafora systemu o nazwie już istnieje, `initialCount` i `maximumCount` nie są używane, mimo że nieprawidłowe wartości nadal powodują wyjątki.</span><span class="sxs-lookup"><span data-stu-id="e21e7-197">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="e21e7-198">Użyj `createdNew` do określenia, czy semafora systemu został utworzony.</span><span class="sxs-lookup"><span data-stu-id="e21e7-198">Use `createdNew` to determine whether the system semaphore was created.</span></span>  
  
 <span data-ttu-id="e21e7-199">Jeśli `initialCount` jest mniejsza niż `maximumCount`, i `createdNew` jest `true`, efekt jest taki sam, jakby były nazywane bieżącego wątku <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy.</span><span class="sxs-lookup"><span data-stu-id="e21e7-199">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="e21e7-200">Jeśli określisz `null` lub ciągu pustego `name`, utworzony lokalny semafora tak, jakby były nazywane <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeciążenia konstruktora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-200">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="e21e7-201">W tym przypadku `createdNew` jest zawsze `true`.</span><span class="sxs-lookup"><span data-stu-id="e21e7-201">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="e21e7-202">Ponieważ nazwany semaforów są widoczne w całym systemie operacyjnym, ich może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-202">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-203">Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-203">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="e21e7-204">Ten przykład tworzy nazwany semafora maksymalna liczba 5 i początkowa liczba dwa.</span><span class="sxs-lookup"><span data-stu-id="e21e7-204">The example creates a named semaphore with a maximum count of five and an initial count of two.</span></span> <span data-ttu-id="e21e7-205">Oznacza to rezerwuje trzy wpisy w wątku, który wywołuje konstruktora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-205">That is, it reserves three entries for the thread that calls the constructor.</span></span> <span data-ttu-id="e21e7-206">Jeśli `createNew` jest `false`, program wykonuje trzy wywołań do <xref:System.Threading.WaitHandle.WaitOne%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-206">If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="e21e7-207">W związku z tym, po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zablokowanie w trzecim wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="e21e7-207">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="e21e7-208">Zwolnij jeden lub więcej wpisów w pierwszej kopii programu, aby odblokować drugiego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-208">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e21e7-209">
            <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-209">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="e21e7-210">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-210">-or-</span>
          </span>
          <span data-ttu-id="e21e7-211">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-211">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e21e7-212">
            <paramref name="maximumCount" /> jest mniejsza niż 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-212">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="e21e7-213">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-213">-or-</span>
          </span>
          <span data-ttu-id="e21e7-214">
            <paramref name="initialCount" /> jest mniejsza niż 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-214">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e21e7-215">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-215">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-216">Semafor o nazwie istnieje i ma kontrolę dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-216">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="e21e7-217">Semafor nazwanych nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-217">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e21e7-218">wywoływanie niezarządzanego kodu do tworzenia semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-218">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="e21e7-219">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-219">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="e21e7-220">Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-220">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="e21e7-221">Zarządzana wątkowość</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-221">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="e21e7-222">Semaphore</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-222">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="e21e7-223">Początkowa liczba żądań semaforów, które mogą zostać zrealizowane jednocześnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-223">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="e21e7-224">Maksymalna liczba żądań dotyczących semafor, które mogą zostać zrealizowane jednocześnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-224">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="e21e7-225">Nazwa obiektu semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-225">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="e21e7-226">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono semafora lokalnego (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> ani być pustym ciągiem) lub jeśli utworzono semafora określonego nazwanego systemu; <see langword="false" /> Jeśli określony o nazwie system semafora już istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-226">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="e21e7-227">Ten parametr jest przekazywany niezainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-227">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="semaphoreSecurity">
          <span data-ttu-id="e21e7-228">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> obiekt, który reprezentuje kontrolę dostępu mają być stosowane do systemu o nazwie semafora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-228">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e21e7-229">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy, określając początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów, opcjonalnie Określ nazwę obiektu semafora systemu, określając zmienna, która odbiera wartość wskazującą czy został utworzony nowy semafora systemu i określanie kontroli dostępu zabezpieczeń dla semafora systemowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-229">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-230">Dotyczą kontrolę dostępu semafora nazwane systemu podczas jego tworzenia, uniemożliwiając przejmowaniu semafora przez inny kod, należy użyć tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-230">Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-231">Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt, który przedstawia semafor systemu o nazwie.</span><span class="sxs-lookup"><span data-stu-id="e21e7-231">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="e21e7-232">Możesz tworzyć wiele <xref:System.Threading.Semaphore> obiekty reprezentujące takie same, o nazwie semafora systemowego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-232">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-233">Semafor systemu o nazwie nie istnieje, zostanie utworzony przy użyciu określonego kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-233">If the named system semaphore does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="e21e7-234">Semafor o nazwie istnieje, jest ignorowana określonego kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-234">If the named semaphore exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e21e7-235">Obiekt wywołujący ma pełną kontrolę nad nowo utworzony <xref:System.Threading.Semaphore> nawet wtedy, gdy obiekt `semaphoreSecurity` nie zezwala lub nie powiedzie się pewne prawa dostępu do bieżącego użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e21e7-235">The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="e21e7-236">Jednak jeśli bieżący użytkownik próbuje pobrać inny <xref:System.Threading.Semaphore> obiektu, do reprezentowania takie same o nazwie semafor, za pomocą konstruktora lub <xref:System.Threading.Semaphore.OpenExisting%2A> metody Windows zastosowano kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-236">However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="e21e7-237">Jeśli semafora systemu o nazwie nie istnieje, zostanie utworzony przy użyciu liczba początkowej i maksymalna liczba określona przez `initialCount` i `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="e21e7-237">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="e21e7-238">Jeśli semafora systemu o nazwie już istnieje, `initialCount` i `maximumCount` nie są używane, mimo że nieprawidłowe wartości nadal powodują wyjątki.</span><span class="sxs-lookup"><span data-stu-id="e21e7-238">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="e21e7-239">Użyj `createdNew` parametru do określenia, czy semafora systemu zostało utworzone przez tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-239">Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.</span></span>  
  
 <span data-ttu-id="e21e7-240">Jeśli `initialCount` jest mniejsza niż `maximumCount`, i `createdNew` jest `true`, efekt jest taki sam, jakby były nazywane bieżącego wątku <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy.</span><span class="sxs-lookup"><span data-stu-id="e21e7-240">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="e21e7-241">Jeśli określisz `null` lub ciągu pustego `name`, utworzony lokalny semafora tak, jakby były nazywane <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeciążenia konstruktora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-241">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="e21e7-242">W tym przypadku `createdNew` jest zawsze `true`.</span><span class="sxs-lookup"><span data-stu-id="e21e7-242">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="e21e7-243">Ponieważ nazwany semaforów są widoczne w całym systemie operacyjnym, ich może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-243">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-244">Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora o kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-244">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="e21e7-245">W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia o nazwie semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-245">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span> <span data-ttu-id="e21e7-246">Semafor nie istnieje, zostanie utworzony z maksymalną liczbą dwa i kontrolę dostępu, odrzuca prawa do używania semafora bieżącego użytkownika, która przyznaje uprawnienia do odczytu i zmienić uprawnienia semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-246">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span> <span data-ttu-id="e21e7-247">Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-247">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="e21e7-248">Wyjątek, a w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, aby otworzyć semafora za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="e21e7-248">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e21e7-249">Po zmianie uprawnienia semafora jest otwierany przy użyciu praw wymaganych do wprowadzania i wersji.</span><span class="sxs-lookup"><span data-stu-id="e21e7-249">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="e21e7-250">Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="e21e7-250">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e21e7-251">
            <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-251">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="e21e7-252">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-252">-or-</span>
          </span>
          <span data-ttu-id="e21e7-253">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-253">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e21e7-254">
            <paramref name="maximumCount" /> jest mniejsza niż 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-254">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="e21e7-255">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-255">-or-</span>
          </span>
          <span data-ttu-id="e21e7-256">
            <paramref name="initialCount" /> jest mniejsza niż 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-256">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-257">Semafor o nazwie istnieje i ma kontrolę dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-257">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e21e7-258">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-258">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="e21e7-259">Semafor nazwanych nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-259">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e21e7-260">wywoływanie niezarządzanego kodu do tworzenia semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-260">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="e21e7-261">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-261">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="e21e7-262">Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-262">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="e21e7-263">Zarządzana wątkowość</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-263">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="e21e7-264">Semaphore</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-264">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e21e7-265">Pobiera kontrolę dostępu dla semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-265">Gets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e21e7-266">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> obiekt, który reprezentuje kontrolę dostępu, semaforów systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-266">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-267"><xref:System.Threading.Semaphore.GetAccessControl%2A> Metoda używa następujących kombinacji flag (połączone za pomocą bitowej operacji OR) do wyszukania uprawnienia: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e21e7-267">The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e21e7-268">Użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> praw, aby wywołać tę metodę i semafora musi została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> praw.</span><span class="sxs-lookup"><span data-stu-id="e21e7-268">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights.</span></span>  
  
 <span data-ttu-id="e21e7-269">W lokalnym semafor kontrolę dostępu nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="e21e7-269">On a local semaphore, access control security is irrelevant.</span></span> <span data-ttu-id="e21e7-270">Jeśli <xref:System.Threading.Semaphore> obiekt nie reprezentuje semafora systemu o nazwie, ta metoda zwraca <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt, który przyznaje wszystkie prawa do każdego użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e21e7-270">If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-271">Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora o kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-271">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="e21e7-272">W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia o nazwie semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-272">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-273">Semafor nie istnieje, zostanie utworzony z maksymalną liczbą dwa i kontrolę dostępu, odrzuca prawa do używania semafora bieżącego użytkownika, ale daje prawo do odczytu, a zmiana uprawnień semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-273">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-274">Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-274">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="e21e7-275">Wyjątek, a w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, aby otworzyć semafora za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="e21e7-275">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span> <span data-ttu-id="e21e7-276">Kontrolę dostępu, semaforów systemu uzyskuje się za pomocą <xref:System.Threading.Semaphore.GetAccessControl%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-276">The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.</span></span>  
  
 <span data-ttu-id="e21e7-277">Po zmianie uprawnienia semafora jest otwierany przy użyciu praw wymaganych do wprowadzania i wersji.</span><span class="sxs-lookup"><span data-stu-id="e21e7-277">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="e21e7-278">Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="e21e7-278">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-279">Bieżący <see cref="T:System.Threading.Semaphore" /> obiektu przedstawia semafor systemu o nazwie, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> praw.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-279">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
          <span data-ttu-id="e21e7-280">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-280">-or-</span>
          </span>
          <span data-ttu-id="e21e7-281">Bieżący <see cref="T:System.Threading.Semaphore" /> obiektu przedstawia semafor o nazwie system i nie została otwarta z <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> praw.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-281">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="e21e7-282">Nie jest obsługiwane dla Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-282">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="e21e7-283">Zarządzana wątkowość</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-283">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="e21e7-284">Semaphore</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-284">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e21e7-285">Otwiera określony semafor o nazwie, jeśli już istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-285">Opens a specified named semaphore, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="e21e7-286">Nazwa semafora systemu, aby otworzyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-286">The name of the system semaphore to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e21e7-287">Otwiera określony semafor o nazwie, jeśli już istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-287">Opens the specified named semaphore, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e21e7-288">Obiekt, który reprezentuje semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-288">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-289"><xref:System.Threading.Semaphore.OpenExisting%2A> Metoda podejmuje próbę otwarcia określonego nazwanego semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-289">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore.</span></span> <span data-ttu-id="e21e7-290">Jeśli semafora systemu nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia semafora systemowego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-290">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="e21e7-291">Aby utworzyć semafora systemu, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które ma `name` parametru.</span><span class="sxs-lookup"><span data-stu-id="e21e7-291">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e21e7-292">Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.Semaphore> obiektu, mimo że obiekty, które reprezentują zwracane są takie same o nazwie semafora systemowego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-292">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-293">Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.Semaphore.OpenExisting%2A> przeciążenie metody i określając <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw, połączone za pomocą bitowej operacji OR.</span><span class="sxs-lookup"><span data-stu-id="e21e7-293">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="e21e7-294">Określanie <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku wprowadzić semafor i określając <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątków do wywoływania <xref:System.Threading.Semaphore.Release%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-294">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-295">Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora o kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-295">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="e21e7-296">W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia o nazwie semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-296">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-297">Semafor nie istnieje, zostanie utworzony z maksymalną liczbą dwa i zabezpieczenia kontroli dostępu, który nie zezwala na bieżącemu użytkownikowi prawa do używania semafora, ale która przyznaje uprawnienia do odczytu i zmienić uprawnienia semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-297">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-298">Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-298">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload.</span></span> <span data-ttu-id="e21e7-299">Wyjątek, a w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, aby otworzyć semafora za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="e21e7-299">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e21e7-300">Po zmianie uprawnienia semafora jest otwierany przy użyciu praw wymaganych do wprowadzania i zwolnij go.</span><span class="sxs-lookup"><span data-stu-id="e21e7-300">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="e21e7-301">Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="e21e7-301">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e21e7-302">
            <paramref name="name" /> jest ciągiem pustym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-302">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="e21e7-303">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-303">-or-</span>
          </span>
          <span data-ttu-id="e21e7-304">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-304">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e21e7-305">
            <paramref name="name" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-305">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="e21e7-306">Semafor o nazwie nie istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-306">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e21e7-307">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-307">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-308">Semafor o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-308">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e21e7-309">wywoływanie niezarządzanego kodu, aby otworzyć semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-309">for calling unmanaged code to open a named system semaphore.</span>
          </span>
          <span data-ttu-id="e21e7-310">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-310">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="e21e7-311">Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-311">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="e21e7-312">Zarządzana wątkowość</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-312">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="e21e7-313">Semaphore</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-313">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="e21e7-314">Nazwa semafora systemu, aby otworzyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-314">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="e21e7-315">Bitowa kombinacja wartości wyliczenia, które reprezentują dostęp pożądanych zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-315">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e21e7-316">Zostanie otwarty określonego nazwanego semafor, jeśli już istnieje, z dostępem do pożądanych zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-316">Opens the specified named semaphore, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e21e7-317">Obiekt, który reprezentuje semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-317">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-318">`rights` Parametr musi zawierać <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flagi, aby zezwolić wątków, aby wprowadzić semafor i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flagi, aby zezwolić wątków do wywoływania <xref:System.Threading.Semaphore.Release%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-318">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="e21e7-319"><xref:System.Threading.Semaphore.OpenExisting%2A> Metoda próbuje otworzyć istniejący o nazwie semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-319">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore.</span></span> <span data-ttu-id="e21e7-320">Jeśli semafora systemu nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia semafora systemowego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-320">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="e21e7-321">Aby utworzyć semafora systemu, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które ma `name` parametru.</span><span class="sxs-lookup"><span data-stu-id="e21e7-321">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e21e7-322">Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.Semaphore> obiektu, mimo że obiekty, które reprezentują zwracane są takie same o nazwie semafora systemowego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-322">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-323">Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora o kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-323">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="e21e7-324">W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia o nazwie semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-324">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-325">Semafor nie istnieje, zostanie utworzony z maksymalną liczbą dwa i kontrolę dostępu, odrzuca prawa do używania semafora bieżącego użytkownika, ale daje prawo do odczytu, a zmiana uprawnień semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-325">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-326">Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-326">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="e21e7-327">Wyjątek, a w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, aby otworzyć semafora za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="e21e7-327">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e21e7-328">Po zmianie uprawnienia semafora jest otwierany przy użyciu praw wymaganych do wprowadzania i zwolnij go.</span><span class="sxs-lookup"><span data-stu-id="e21e7-328">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="e21e7-329">Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="e21e7-329">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e21e7-330">
            <paramref name="name" /> jest ciągiem pustym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-330">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="e21e7-331">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-331">-or-</span>
          </span>
          <span data-ttu-id="e21e7-332">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-332">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e21e7-333">
            <paramref name="name" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-333">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="e21e7-334">Semafor o nazwie nie istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-334">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e21e7-335">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-335">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-336">Semafor o nazwie istnieje, ale użytkownik nie ma praw dostępu pożądanych zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-336">The named semaphore exists, but the user does not have the desired security access rights.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e21e7-337">wywoływanie niezarządzanego kodu do tworzenia semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-337">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="e21e7-338">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-338">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="e21e7-339">Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-339">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="e21e7-340">Zarządzana wątkowość</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-340">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="e21e7-341">Semaphore</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-341">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e21e7-342">Zamyka semafora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-342">Exits the semaphore.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e21e7-343">Zamyka semafora i zwraca liczbę poprzednich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-343">Exits the semaphore and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e21e7-344">Liczba klientów na semafora przed <see cref="Overload:System.Threading.Semaphore.Release" /> metoda została wywołana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-344">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-345">Zazwyczaj używa się wątków <xref:System.Threading.WaitHandle.WaitOne%2A> metodę, aby wprowadzić semafora, dlatego zwykle używać tego przeciążenia metody, aby zakończyć pracę.</span><span class="sxs-lookup"><span data-stu-id="e21e7-345">Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.</span></span>  
  
 <span data-ttu-id="e21e7-346">Jeśli <xref:System.Threading.SemaphoreFullException> jest generowany przez <xref:System.Threading.Semaphore.Release%2A> metody, nie musi oznaczać problem z wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-346">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="e21e7-347">Błąd programowania w innym wątku może spowodować zakończenie semafora razy więcej niż wprowadzone dla tego wątku.</span><span class="sxs-lookup"><span data-stu-id="e21e7-347">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="e21e7-348">Jeśli bieżący <xref:System.Threading.Semaphore> obiektu przedstawia semafor systemu o nazwie, użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw i semafora musi mieć została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw.</span><span class="sxs-lookup"><span data-stu-id="e21e7-348">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-349">Poniższy przykład kodu tworzy semafor maksymalna liczba trzy i początkową liczbę zero.</span><span class="sxs-lookup"><span data-stu-id="e21e7-349">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="e21e7-350">W przykładzie uruchomiono pięć wątków, które blokować oczekiwanie na semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-350">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="e21e7-351">Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody, aby zwiększyć tę liczbę semafora do maksymalną, dzięki czemu trzech wątków do wprowadzania semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-351">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="e21e7-352">Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> poczekaj 1 sekundę, aby zasymulować pracy, a następnie wywołuje metodę <xref:System.Threading.Semaphore.Release> przeciążenia metody, aby zwolnić semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-352">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-353">Każdorazowo, gdy wydaniu semafora wyświetlane liczba semafora w poprzednim.</span><span class="sxs-lookup"><span data-stu-id="e21e7-353">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="e21e7-354">Użycie konsoli komunikaty śledzenia semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-354">Console messages track semaphore use.</span></span> <span data-ttu-id="e21e7-355">Interwał symulowane pracy zwiększa się nieco dla każdego wątku, aby ułatwić dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="e21e7-355">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="e21e7-356">Liczba semafora jest już w wartości maksymalnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-356">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e21e7-357">Wystąpił błąd Win32 nazwane semafora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-357">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-358">Semafor bieżącego przedstawia semafor systemu o nazwie, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-358">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
          <span data-ttu-id="e21e7-359">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-359">-or-</span>
          </span>
          <span data-ttu-id="e21e7-360">Semafor bieżącego przedstawia semafor systemu o nazwie, ale nie została otwarta z <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-360">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="e21e7-361">Zarządzana wątkowość</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-361">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="e21e7-362">Semaphore</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-362">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">
          <span data-ttu-id="e21e7-363">Liczba razy, aby zamknąć semafora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-363">The number of times to exit the semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e21e7-364">Zamyka semafora określoną liczbę razy i zwraca liczbę poprzednich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-364">Exits the semaphore a specified number of times and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e21e7-365">Liczba klientów na semafora przed <see cref="Overload:System.Threading.Semaphore.Release" /> metoda została wywołana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-365">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-366">Jeśli wątek został wprowadzony semafora wiele razy, tego przeciążenia metody umożliwia liczba całego semafora można przywrócić za pomocą jednego wywołania.</span><span class="sxs-lookup"><span data-stu-id="e21e7-366">If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</span></span>  
  
 <span data-ttu-id="e21e7-367">Jeśli <xref:System.Threading.SemaphoreFullException> jest generowany przez <xref:System.Threading.Semaphore.Release%2A> metody, nie musi oznaczać problem z wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-367">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="e21e7-368">Błąd programowania w innym wątku może spowodować zakończenie semafora razy więcej niż wprowadzone dla tego wątku.</span><span class="sxs-lookup"><span data-stu-id="e21e7-368">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="e21e7-369">Jeśli bieżący <xref:System.Threading.Semaphore> obiektu przedstawia semafor systemu o nazwie, użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw i semafora musi mieć została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw.</span><span class="sxs-lookup"><span data-stu-id="e21e7-369">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-370">Poniższy przykład kodu tworzy semafor maksymalna liczba trzy i początkową liczbę zero.</span><span class="sxs-lookup"><span data-stu-id="e21e7-370">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="e21e7-371">W przykładzie uruchomiono pięć wątków, które blokować oczekiwanie na semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-371">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="e21e7-372">Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody, aby zwiększyć tę liczbę semafora do maksymalną, dzięki czemu trzech wątków do wprowadzania semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-372">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="e21e7-373">Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> poczekaj 1 sekundę, aby zasymulować pracy, a następnie wywołuje metodę <xref:System.Threading.Semaphore.Release> przeciążenia metody, aby zwolnić semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-373">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-374">Każdorazowo, gdy wydaniu semafora wyświetlane liczba semafora w poprzednim.</span><span class="sxs-lookup"><span data-stu-id="e21e7-374">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="e21e7-375">Użycie konsoli komunikaty śledzenia semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-375">Console messages track semaphore use.</span></span> <span data-ttu-id="e21e7-376">Interwał symulowane pracy zwiększa się nieco dla każdego wątku, aby ułatwić dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="e21e7-376">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e21e7-377">
            <paramref name="releaseCount" /> jest mniejsza niż 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-377">
              <paramref name="releaseCount" /> is less than 1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="e21e7-378">Liczba semafora jest już w wartości maksymalnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-378">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e21e7-379">Wystąpił błąd Win32 nazwane semafora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-379">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-380">Semafor bieżącego przedstawia semafor systemu o nazwie, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> praw.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-380">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
          <span data-ttu-id="e21e7-381">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-381">-or-</span>
          </span>
          <span data-ttu-id="e21e7-382">Semafor bieżącego przedstawia semafor systemu o nazwie, ale nie została otwarta z <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> praw.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-382">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="e21e7-383">Zarządzana wątkowość</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-383">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="e21e7-384">Semaphore</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-384">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">
          <span data-ttu-id="e21e7-385">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> obiekt, który reprezentuje kontrolę dostępu mają być stosowane do systemu o nazwie semafora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-385">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e21e7-386">Ustawia kontrolę dostępu dla semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-386">Sets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-387">Zabezpieczenia kontroli dostępu można ustawić tylko na <xref:System.Threading.Semaphore> obiekty reprezentujące semaforów systemu o nazwie.</span><span class="sxs-lookup"><span data-stu-id="e21e7-387">You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.</span></span>  
  
 <span data-ttu-id="e21e7-388">Użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> praw, aby wywołać tę metodę i semafora musi została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> praw.</span><span class="sxs-lookup"><span data-stu-id="e21e7-388">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e21e7-389">Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora o kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="e21e7-389">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="e21e7-390">W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia o nazwie semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-390">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-391">Semafor nie istnieje, zostanie utworzony z maksymalną liczbą dwa i kontrolę dostępu, odrzuca prawa do używania semafora bieżącego użytkownika, która przyznaje uprawnienia do odczytu i zmienić uprawnienia semafora.</span><span class="sxs-lookup"><span data-stu-id="e21e7-391">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="e21e7-392">Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-392">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="e21e7-393">Wyjątek, a w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, aby otworzyć semafora za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="e21e7-393">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e21e7-394">Po zmianie uprawnienia, za pomocą <xref:System.Threading.Semaphore.SetAccessControl%2A> metody semafora jest otwierany przy użyciu praw wymaganych do wprowadzania i wersji.</span><span class="sxs-lookup"><span data-stu-id="e21e7-394">After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="e21e7-395">Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="e21e7-395">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e21e7-396">
            <paramref name="semaphoreSecurity" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-396">
              <paramref name="semaphoreSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-397">Użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> praw.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-397">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
          <span data-ttu-id="e21e7-398">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-398">-or-</span>
          </span>
          <span data-ttu-id="e21e7-399">Semafor nie zostało otwarte z <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> praw.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-399">The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="e21e7-400">Bieżący <see cref="T:System.Threading.Semaphore" /> obiekt nie reprezentuje semafora systemu o nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-400">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="e21e7-401">Zarządzana wątkowość</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-401">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="e21e7-402">Semaphore</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-402">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e21e7-403">Otwiera określony semafor nazwanych, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-403">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="e21e7-404">Nazwa semafora systemu, aby otworzyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-404">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="e21e7-405">Po powrocie z tej metody zawiera <see cref="T:System.Threading.Semaphore" /> obiekt, który reprezentuje nazwane semafor, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie nie powiodło się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-405">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="e21e7-406">Ten parametr jest traktowany jako niezainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-406">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e21e7-407">Otwiera określony nazwany semafor, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-407">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e21e7-408">
            <see langword="true" /> Jeśli nazwany semafora został otwarty pomyślnie; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-408">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-409">Jeśli nazwany semafora nie istnieje, ta metoda nie powoduje utworzenia go.</span><span class="sxs-lookup"><span data-stu-id="e21e7-409">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="e21e7-410">Aby utworzyć semafora systemu, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które ma `name` parametru.</span><span class="sxs-lookup"><span data-stu-id="e21e7-410">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e21e7-411">Jeśli masz pewności, czy istnieje semafora nazwane, należy używać tego przeciążenia metody, zamiast <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody, która zgłasza wyjątek, jeśli semafora nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="e21e7-411">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="e21e7-412">Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.Semaphore.TryOpenExisting%2A> przeciążenie metody i określając <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw, połączone za pomocą bitowej operacji OR.</span><span class="sxs-lookup"><span data-stu-id="e21e7-412">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="e21e7-413">Określanie <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku wprowadzić semafor i określając <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątków do wywoływania <xref:System.Threading.Semaphore.Release%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-413">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e21e7-414">
            <paramref name="name" /> jest ciągiem pustym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-414">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="e21e7-415">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-415">-or-</span>
          </span>
          <span data-ttu-id="e21e7-416">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-416">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e21e7-417">
            <paramref name="name" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-417">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e21e7-418">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-418">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-419">Semafor o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-419">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="e21e7-420">Nazwa semafora systemu, aby otworzyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-420">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="e21e7-421">Bitowa kombinacja wartości wyliczenia, które reprezentują dostęp pożądanych zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-421">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="e21e7-422">Po powrocie z tej metody zawiera <see cref="T:System.Threading.Semaphore" /> obiekt, który reprezentuje nazwane semafor, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie nie powiodło się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-422">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="e21e7-423">Ten parametr jest traktowany jako niezainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-423">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e21e7-424">Otwiera określony nazwany semafor, jeśli już istnieje z dostępem do pożądanych zabezpieczeń i zwraca wartość wskazującą, czy operacja się powiedzie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-424">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e21e7-425">
            <see langword="true" /> Jeśli nazwany semafora został otwarty pomyślnie; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-425">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e21e7-426">Jeśli nazwany semafora nie istnieje, ta metoda nie powoduje utworzenia go.</span><span class="sxs-lookup"><span data-stu-id="e21e7-426">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="e21e7-427">Aby utworzyć semafora systemu, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które ma `name` parametru.</span><span class="sxs-lookup"><span data-stu-id="e21e7-427">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e21e7-428">Jeśli masz pewności, czy istnieje semafora nazwane, należy używać tego przeciążenia metody, zamiast <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, która zgłasza wyjątek, jeśli semafora nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="e21e7-428">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="e21e7-429">`rights` Parametr musi zawierać <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flagi, aby zezwolić wątków, aby wprowadzić semafor i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flagi, aby zezwolić wątków do wywoływania <xref:System.Threading.Semaphore.Release%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e21e7-429">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="e21e7-430">Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.Semaphore> obiektu, mimo że obiekty, które reprezentują zwracane są takie same o nazwie semafora systemowego.</span><span class="sxs-lookup"><span data-stu-id="e21e7-430">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e21e7-431">
            <paramref name="name" /> jest ciągiem pustym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-431">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="e21e7-432">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-432">-or-</span>
          </span>
          <span data-ttu-id="e21e7-433">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-433">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e21e7-434">
            <paramref name="name" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-434">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e21e7-435">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-435">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e21e7-436">Semafor o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e21e7-436">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e87fa180884985d655430f6614104ea2d1020256" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39804430" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ogranicza liczbę wątków, które mogą uzyskać dostęp do zasobu lub puli zasobów jednocześnie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Threading.Semaphore> klasy do kontrolowania dostępu do puli zasobów. Wątki wprowadź semafora przez wywołanie metody <xref:System.Threading.WaitHandle.WaitOne%2A> metody, która jest dziedziczona z <xref:System.Threading.WaitHandle> klasy, a następnie zwolnij semafora przez wywołanie metody <xref:System.Threading.Semaphore.Release%2A> metody.  
  
 Liczba klientów na semafor zostanie zmniejszona każdorazowo wątku przechodzi semafora i zwiększany, gdy wątek zwalnia semafora. Jeśli licznik osiągnie wartość zero, kolejne żądania blokuje, aż do innych wątków zwolnienia semafora. Gdy wszystkie wątki zostały wydane semafora, liczba przy maksymalnej wartości określono podczas tworzenia semafora.  
  
 Nie jest zagwarantowana kolejność, takich jak FIFO lub LIFO, w którym zablokowane wątki wprowadzić semafora.  
  
 Wątek można wprowadzić semafora wielokrotnie, wywołując <xref:System.Threading.WaitHandle.WaitOne%2A> metoda wielokrotnie. Aby zwolnić niektórych lub wszystkich tych wpisów, można wywołać bez parametrów wątku <xref:System.Threading.Semaphore.Release> przeciążenia metody, które można wywołać wiele razy lub jest on <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody, która określa liczbę wpisów, które mogą być wprowadzane.  
  
 <xref:System.Threading.Semaphore> Klasy nie wymusza tożsamość wątku na wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> lub <xref:System.Threading.Semaphore.Release%2A>. Odpowiada za programisty upewnij się, że wątki nie zwalnia semafora zbyt wiele razy. Na przykład załóżmy, że semafor ma maksymalną liczbę dwóch tego wątku, A i B wątku obydwa wprowadź semafora. Jeśli to błąd programistyczny w wątku B powoduje go do wywoływania <xref:System.Threading.Semaphore.Release%2A> dwa razy, oba wywołania powiodło się. Liczba klientów na semafora jest zapełniony i kiedy wątek, A ostatecznie wywołuje <xref:System.Threading.Semaphore.Release%2A>, <xref:System.Threading.SemaphoreFullException> zgłaszany.  
  
 Istnieją dwa typy semaforów: lokalne semaforów i semaforów systemu o nazwie. Jeśli tworzysz <xref:System.Threading.Semaphore> przy użyciu konstruktora, który przyjmuje nazwę, jest on skojarzony z semafora systemu operacyjnego o takiej nazwie. O nazwie system semaforów są widoczne w całym systemie operacyjnym i może służyć do synchronizowania działania procesów. Możesz tworzyć wiele <xref:System.Threading.Semaphore> obiekty reprezentujące takie same, o nazwie semafora systemowego i można użyć <xref:System.Threading.Semaphore.OpenExisting%2A> metodę, aby otworzyć istniejący o nazwie semafora systemowego.  
  
 Semafor lokalny istnieje tylko w ramach procesu. Mogą być używane w żadnym z wątków w procesie, który odwołuje się do lokalnej <xref:System.Threading.Semaphore> obiektu. Każdy <xref:System.Threading.Semaphore> obiekt jest oddzielne semafora lokalnego.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy semafor maksymalna liczba trzy i początkową liczbę zero. W przykładzie uruchomiono pięć wątków, które blokować oczekiwanie na semafora. Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody, aby zwiększyć tę liczbę semafora do maksymalną, dzięki czemu trzech wątków do wprowadzania semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> poczekaj 1 sekundę, aby zasymulować pracy, a następnie wywołuje metodę <xref:System.Threading.Semaphore.Release> przeciążenia metody, aby zwolnić semafora. Każdorazowo, gdy wydaniu semafora wyświetlane liczba semafora w poprzednim. Użycie konsoli komunikaty śledzenia semafora. Interwał symulowane pracy zwiększa się nieco dla każdego wątku, aby ułatwić dane wyjściowe.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semaforów, które mogą być przyznane jednocześnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań dotyczących semafor, które mogą być przyznane jednocześnie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy, określając początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje semafora bez nazwy. Wszystkie wątki używające wystąpienia takich semafora musi mieć odwołania do wystąpienia.  
  
 Jeśli `initialCount` jest mniejsza niż `maximumCount`, efekt jest taki sam, jakby były nazywane bieżącego wątku <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy. Nie można zarezerwować żadnych wpisów dla wątku, który tworzy semafora, użyć tego samego numeru dla `maximumCount` i `initialCount`.  
  
   
  
## Examples  
 Poniższy przykład tworzy semafor z maksymalną na równe 3 i początkową liczbę zero. W przykładzie uruchomiono pięć wątków, które blokować oczekiwanie na semafora. Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody, aby zwiększyć tę liczbę semafora do maksymalną, dzięki czemu trzech wątków do wprowadzania semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> poczekaj 1 sekundę, aby zasymulować pracy, a następnie wywołuje metodę <xref:System.Threading.Semaphore.Release> przeciążenia metody, aby zwolnić semafora. Każdorazowo, gdy wydaniu semafora wyświetlane liczba semafora w poprzednim. Użycie konsoli komunikaty śledzenia semafora. Interwał symulowane pracy zwiększa się nieco dla każdego wątku, aby ułatwić dane wyjściowe.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> jest mniejsza niż 1.  - lub - <paramref name="initialCount" /> jest mniejszy niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semaforów, które mogą być przyznane jednocześnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań dotyczących semafor, które mogą być przyznane jednocześnie.</param>
        <param name="name">Nazwa obiektu semafora systemu o nazwie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy, określając początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów i opcjonalnie określając nazwę obiektu semafora systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt, który przedstawia semafor systemu o nazwie. Możesz tworzyć wiele <xref:System.Threading.Semaphore> obiekty reprezentujące takie same, o nazwie semafora systemowego.  
  
 Jeśli semafora systemu o nazwie nie istnieje, zostanie utworzony przy użyciu liczba początkowej i maksymalna liczba określona przez `initialCount` i `maximumCount`. Jeśli semafora systemu o nazwie już istnieje, `initialCount` i `maximumCount` nie są używane, mimo że nieprawidłowe wartości nadal powodują wyjątki. Jeśli zachodzi potrzeba określenia czy semafora systemu o nazwie została utworzona, należy użyć <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> Konstruktor przeciążenia zamiast tego.  
  
> [!IMPORTANT]
>  Gdy używasz tego przeciążenia konstruktora, zaleca się określić ten sam numer w `initialCount` i `maximumCount`. Jeśli `initialCount` jest mniejsza niż `maximumCount`i semafora systemu o nazwie zostanie utworzony, efekt jest taki sam, jakby były nazywane bieżącego wątku <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy. Z tego przeciążenia konstruktora istnieje jednak sposób określenia, czy semafora o nazwie system został utworzony.  
  
 Jeśli określisz `null` lub ciągu pustego `name`, utworzony lokalny semafora tak, jakby były nazywane <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeciążenia konstruktora.  
  
 Ponieważ nazwany semaforów są widoczne w całym systemie operacyjnym, ich może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
 Jeśli chcesz dowiedzieć się, czy istnieje semafora systemu o nazwie, użyj <xref:System.Threading.Semaphore.OpenExisting%2A> metody. <xref:System.Threading.Semaphore.OpenExisting%2A> Metoda próbuje otworzyć istniejący o nazwie semafor i zgłasza wyjątek, jeśli semafora systemu nie istnieje.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora. Ten przykład tworzy nazwany semafora maksymalna liczba 5 i początkowa liczba 5. Program sprawia, że trzech wywołań <xref:System.Threading.WaitHandle.WaitOne%2A> metody. W związku z tym, po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zablokowanie w trzecim wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A>. Zwolnij jeden lub więcej wpisów w pierwszej kopii programu, aby odblokować drugiego.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> jest mniejsza niż 1.  - lub - <paramref name="initialCount" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor o nazwie istnieje i ma kontrolę dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Semafor nazwanych nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływanie niezarządzanego kodu do tworzenia semafora systemu o nazwie. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semaforów, które mogą zostać zrealizowane jednocześnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań dotyczących semafor, które mogą zostać zrealizowane jednocześnie.</param>
        <param name="name">Nazwa obiektu semafora systemu o nazwie.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono semafora lokalnego (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> ani być pustym ciągiem) lub jeśli utworzono semafora określonego nazwanego systemu; <see langword="false" /> Jeśli określony o nazwie system semafora już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy, określając początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów, opcjonalnie określania nazwy obiektu semafora systemu i określanie zmienna, która odbiera wartość wskazującą czy został utworzony nowy semafora systemowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt, który przedstawia semafor systemu o nazwie. Możesz tworzyć wiele <xref:System.Threading.Semaphore> obiekty reprezentujące takie same, o nazwie semafora systemowego.  
  
 Jeśli semafora systemu o nazwie nie istnieje, zostanie utworzony przy użyciu liczba początkowej i maksymalna liczba określona przez `initialCount` i `maximumCount`. Jeśli semafora systemu o nazwie już istnieje, `initialCount` i `maximumCount` nie są używane, mimo że nieprawidłowe wartości nadal powodują wyjątki. Użyj `createdNew` do określenia, czy semafora systemu został utworzony.  
  
 Jeśli `initialCount` jest mniejsza niż `maximumCount`, i `createdNew` jest `true`, efekt jest taki sam, jakby były nazywane bieżącego wątku <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy.  
  
 Jeśli określisz `null` lub ciągu pustego `name`, utworzony lokalny semafora tak, jakby były nazywane <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeciążenia konstruktora. W tym przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ nazwany semaforów są widoczne w całym systemie operacyjnym, ich może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora. Ten przykład tworzy nazwany semafora maksymalna liczba 5 i początkowa liczba dwa. Oznacza to rezerwuje trzy wpisy w wątku, który wywołuje konstruktora. Jeśli `createNew` jest `false`, program wykonuje trzy wywołań do <xref:System.Threading.WaitHandle.WaitOne%2A> metody. W związku z tym, po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zablokowanie w trzecim wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A>. Zwolnij jeden lub więcej wpisów w pierwszej kopii programu, aby odblokować drugiego.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> jest mniejsza niż 1.  - lub - <paramref name="initialCount" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor o nazwie istnieje i ma kontrolę dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Semafor nazwanych nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływanie niezarządzanego kodu do tworzenia semafora systemu o nazwie. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semaforów, które mogą zostać zrealizowane jednocześnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań dotyczących semafor, które mogą zostać zrealizowane jednocześnie.</param>
        <param name="name">Nazwa obiektu semafora systemu o nazwie.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono semafora lokalnego (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> ani być pustym ciągiem) lub jeśli utworzono semafora określonego nazwanego systemu; <see langword="false" /> Jeśli określony o nazwie system semafora już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> obiekt, który reprezentuje kontrolę dostępu mają być stosowane do systemu o nazwie semafora.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy, określając początkowa liczba wpisów i maksymalną liczbę równoczesnych zapisów, opcjonalnie Określ nazwę obiektu semafora systemu, określając zmienna, która odbiera wartość wskazującą czy został utworzony nowy semafora systemu i określanie kontroli dostępu zabezpieczeń dla semafora systemowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dotyczą kontrolę dostępu semafora nazwane systemu podczas jego tworzenia, uniemożliwiając przejmowaniu semafora przez inny kod, należy użyć tego konstruktora.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt, który przedstawia semafor systemu o nazwie. Możesz tworzyć wiele <xref:System.Threading.Semaphore> obiekty reprezentujące takie same, o nazwie semafora systemowego.  
  
 Semafor systemu o nazwie nie istnieje, zostanie utworzony przy użyciu określonego kontrolę dostępu. Semafor o nazwie istnieje, jest ignorowana określonego kontrolę dostępu.  
  
> [!NOTE]
>  Obiekt wywołujący ma pełną kontrolę nad nowo utworzony <xref:System.Threading.Semaphore> nawet wtedy, gdy obiekt `semaphoreSecurity` nie zezwala lub nie powiedzie się pewne prawa dostępu do bieżącego użytkownika. Jednak jeśli bieżący użytkownik próbuje pobrać inny <xref:System.Threading.Semaphore> obiektu, do reprezentowania takie same o nazwie semafor, za pomocą konstruktora lub <xref:System.Threading.Semaphore.OpenExisting%2A> metody Windows zastosowano kontrolę dostępu.  
  
 Jeśli semafora systemu o nazwie nie istnieje, zostanie utworzony przy użyciu liczba początkowej i maksymalna liczba określona przez `initialCount` i `maximumCount`. Jeśli semafora systemu o nazwie już istnieje, `initialCount` i `maximumCount` nie są używane, mimo że nieprawidłowe wartości nadal powodują wyjątki. Użyj `createdNew` parametru do określenia, czy semafora systemu zostało utworzone przez tego konstruktora.  
  
 Jeśli `initialCount` jest mniejsza niż `maximumCount`, i `createdNew` jest `true`, efekt jest taki sam, jakby były nazywane bieżącego wątku <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) razy.  
  
 Jeśli określisz `null` lub ciągu pustego `name`, utworzony lokalny semafora tak, jakby były nazywane <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeciążenia konstruktora. W tym przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ nazwany semaforów są widoczne w całym systemie operacyjnym, ich może służyć do zapewnienia koordynacji wykorzystania zasobów przez granice procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora o kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia o nazwie semafora. Semafor nie istnieje, zostanie utworzony z maksymalną liczbą dwa i kontrolę dostępu, odrzuca prawa do używania semafora bieżącego użytkownika, która przyznaje uprawnienia do odczytu i zmienić uprawnienia semafora. Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Wyjątek, a w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, aby otworzyć semafora za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia semafora jest otwierany przy użyciu praw wymaganych do wprowadzania i wersji. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> jest większa niż <paramref name="maximumCount" />.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> jest mniejsza niż 1.  - lub - <paramref name="initialCount" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor o nazwie istnieje i ma kontrolę dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Semafor nazwanych nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływanie niezarządzanego kodu do tworzenia semafora systemu o nazwie. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kontrolę dostępu dla semafora systemu o nazwie.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> obiekt, który reprezentuje kontrolę dostępu, semaforów systemu o nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Semaphore.GetAccessControl%2A> Metoda używa następujących kombinacji flag (połączone za pomocą bitowej operacji OR) do wyszukania uprawnienia: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> praw, aby wywołać tę metodę i semafora musi została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> praw.  
  
 W lokalnym semafor kontrolę dostępu nie ma znaczenia. Jeśli <xref:System.Threading.Semaphore> obiekt nie reprezentuje semafora systemu o nazwie, ta metoda zwraca <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt, który przyznaje wszystkie prawa do każdego użytkownika.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora o kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia o nazwie semafora.  
  
 Semafor nie istnieje, zostanie utworzony z maksymalną liczbą dwa i kontrolę dostępu, odrzuca prawa do używania semafora bieżącego użytkownika, ale daje prawo do odczytu, a zmiana uprawnień semafora.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Wyjątek, a w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, aby otworzyć semafora za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia. Kontrolę dostępu, semaforów systemu uzyskuje się za pomocą <xref:System.Threading.Semaphore.GetAccessControl%2A> metody.  
  
 Po zmianie uprawnienia semafora jest otwierany przy użyciu praw wymaganych do wprowadzania i wersji. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący <see cref="T:System.Threading.Semaphore" /> obiektu przedstawia semafor systemu o nazwie, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> praw.  - lub - bieżący <see cref="T:System.Threading.Semaphore" /> obiektu przedstawia semafor o nazwie system i nie została otwarta z <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> praw.</exception>
        <exception cref="T:System.NotSupportedException">Nie jest obsługiwane dla Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określony semafor o nazwie, jeśli już istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemu, aby otworzyć.</param>
        <summary>Otwiera określony semafor o nazwie, jeśli już istnieje.</summary>
        <returns>Obiekt, który reprezentuje semafora systemu o nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Semaphore.OpenExisting%2A> Metoda podejmuje próbę otwarcia określonego nazwanego semafora. Jeśli semafora systemu nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia semafora systemowego. Aby utworzyć semafora systemu, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.Semaphore> obiektu, mimo że obiekty, które reprezentują zwracane są takie same o nazwie semafora systemowego.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.Semaphore.OpenExisting%2A> przeciążenie metody i określając <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw, połączone za pomocą bitowej operacji OR.  
  
 Określanie <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku wprowadzić semafor i określając <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątków do wywoływania <xref:System.Threading.Semaphore.Release%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora o kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia o nazwie semafora.  
  
 Semafor nie istnieje, zostanie utworzony z maksymalną liczbą dwa i zabezpieczenia kontroli dostępu, który nie zezwala na bieżącemu użytkownikowi prawa do używania semafora, ale która przyznaje uprawnienia do odczytu i zmienić uprawnienia semafora.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenie metody. Wyjątek, a w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, aby otworzyć semafora za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia semafora jest otwierany przy użyciu praw wymaganych do wprowadzania i zwolnij go. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Semafor o nazwie nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływanie niezarządzanego kodu, aby otworzyć semafora systemu o nazwie. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemu, aby otworzyć.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują dostęp pożądanych zabezpieczeń.</param>
        <summary>Zostanie otwarty określonego nazwanego semafor, jeśli już istnieje, z dostępem do pożądanych zabezpieczeń.</summary>
        <returns>Obiekt, który reprezentuje semafora systemu o nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Parametr musi zawierać <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flagi, aby zezwolić wątków, aby wprowadzić semafor i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flagi, aby zezwolić wątków do wywoływania <xref:System.Threading.Semaphore.Release%2A> metody.  
  
 <xref:System.Threading.Semaphore.OpenExisting%2A> Metoda próbuje otworzyć istniejący o nazwie semafora. Jeśli semafora systemu nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia semafora systemowego. Aby utworzyć semafora systemu, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.Semaphore> obiektu, mimo że obiekty, które reprezentują zwracane są takie same o nazwie semafora systemowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora o kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia o nazwie semafora.  
  
 Semafor nie istnieje, zostanie utworzony z maksymalną liczbą dwa i kontrolę dostępu, odrzuca prawa do używania semafora bieżącego użytkownika, ale daje prawo do odczytu, a zmiana uprawnień semafora.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Wyjątek, a w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, aby otworzyć semafora za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia semafora jest otwierany przy użyciu praw wymaganych do wprowadzania i zwolnij go. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Semafor o nazwie nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor o nazwie istnieje, ale użytkownik nie ma praw dostępu pożądanych zabezpieczeń.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływanie niezarządzanego kodu do tworzenia semafora systemu o nazwie. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamyka semafora.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka semafora i zwraca liczbę poprzednich.</summary>
        <returns>Liczba klientów na semafora przed <see cref="Overload:System.Threading.Semaphore.Release" /> metoda została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj używa się wątków <xref:System.Threading.WaitHandle.WaitOne%2A> metodę, aby wprowadzić semafora, dlatego zwykle używać tego przeciążenia metody, aby zakończyć pracę.  
  
 Jeśli <xref:System.Threading.SemaphoreFullException> jest generowany przez <xref:System.Threading.Semaphore.Release%2A> metody, nie musi oznaczać problem z wątku wywołującego. Błąd programowania w innym wątku może spowodować zakończenie semafora razy więcej niż wprowadzone dla tego wątku.  
  
 Jeśli bieżący <xref:System.Threading.Semaphore> obiektu przedstawia semafor systemu o nazwie, użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw i semafora musi mieć została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy semafor maksymalna liczba trzy i początkową liczbę zero. W przykładzie uruchomiono pięć wątków, które blokować oczekiwanie na semafora. Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody, aby zwiększyć tę liczbę semafora do maksymalną, dzięki czemu trzech wątków do wprowadzania semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> poczekaj 1 sekundę, aby zasymulować pracy, a następnie wywołuje metodę <xref:System.Threading.Semaphore.Release> przeciążenia metody, aby zwolnić semafora.  
  
 Każdorazowo, gdy wydaniu semafora wyświetlane liczba semafora w poprzednim. Użycie konsoli komunikaty śledzenia semafora. Interwał symulowane pracy zwiększa się nieco dla każdego wątku, aby ułatwić dane wyjściowe.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">Liczba semafora jest już w wartości maksymalnej.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32 nazwane semafora.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor bieżącego przedstawia semafor systemu o nazwie, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  - lub - bieżący semafora przedstawia semafor systemu o nazwie, ale nie została otwarta z <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Liczba razy, aby zamknąć semafora.</param>
        <summary>Zamyka semafora określoną liczbę razy i zwraca liczbę poprzednich.</summary>
        <returns>Liczba klientów na semafora przed <see cref="Overload:System.Threading.Semaphore.Release" /> metoda została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątek został wprowadzony semafora wiele razy, tego przeciążenia metody umożliwia liczba całego semafora można przywrócić za pomocą jednego wywołania.  
  
 Jeśli <xref:System.Threading.SemaphoreFullException> jest generowany przez <xref:System.Threading.Semaphore.Release%2A> metody, nie musi oznaczać problem z wątku wywołującego. Błąd programowania w innym wątku może spowodować zakończenie semafora razy więcej niż wprowadzone dla tego wątku.  
  
 Jeśli bieżący <xref:System.Threading.Semaphore> obiektu przedstawia semafor systemu o nazwie, użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw i semafora musi mieć została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy semafor maksymalna liczba trzy i początkową liczbę zero. W przykładzie uruchomiono pięć wątków, które blokować oczekiwanie na semafora. Korzysta z wątku głównego <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody, aby zwiększyć tę liczbę semafora do maksymalną, dzięki czemu trzech wątków do wprowadzania semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> poczekaj 1 sekundę, aby zasymulować pracy, a następnie wywołuje metodę <xref:System.Threading.Semaphore.Release> przeciążenia metody, aby zwolnić semafora.  
  
 Każdorazowo, gdy wydaniu semafora wyświetlane liczba semafora w poprzednim. Użycie konsoli komunikaty śledzenia semafora. Interwał symulowane pracy zwiększa się nieco dla każdego wątku, aby ułatwić dane wyjściowe.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> jest mniejsza niż 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">Liczba semafora jest już w wartości maksymalnej.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32 nazwane semafora.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor bieżącego przedstawia semafor systemu o nazwie, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> praw.  - lub - bieżący semafora przedstawia semafor systemu o nazwie, ale nie została otwarta z <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> praw.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> obiekt, który reprezentuje kontrolę dostępu mają być stosowane do systemu o nazwie semafora.</param>
        <summary>Ustawia kontrolę dostępu dla semafora systemu o nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zabezpieczenia kontroli dostępu można ustawić tylko na <xref:System.Threading.Semaphore> obiekty reprezentujące semaforów systemu o nazwie.  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> praw, aby wywołać tę metodę i semafora musi została otwarta z <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> praw.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami nazwane semafora o kontrolę dostępu. W przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia o nazwie semafora.  
  
 Semafor nie istnieje, zostanie utworzony z maksymalną liczbą dwa i kontrolę dostępu, odrzuca prawa do używania semafora bieżącego użytkownika, która przyznaje uprawnienia do odczytu i zmienić uprawnienia semafora.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Wyjątek, a w przykładzie użyto <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, aby otworzyć semafora za pomocą uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia, za pomocą <xref:System.Threading.Semaphore.SetAccessControl%2A> metody semafora jest otwierany przy użyciu praw wymaganych do wprowadzania i wersji. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> praw.  - lub - semafora nie zostało otwarte z <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> praw.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący <see cref="T:System.Threading.Semaphore" /> obiekt nie reprezentuje semafora systemu o nazwie.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określony semafor nazwanych, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemu, aby otworzyć.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.Semaphore" /> obiekt, który reprezentuje nazwane semafor, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określony nazwany semafor, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwany semafora został otwarty pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwany semafora nie istnieje, ta metoda nie powoduje utworzenia go. Aby utworzyć semafora systemu, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Jeśli masz pewności, czy istnieje semafora nazwane, należy używać tego przeciążenia metody, zamiast <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody, która zgłasza wyjątek, jeśli semafora nie istnieje.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.Semaphore.TryOpenExisting%2A> przeciążenie metody i określając <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> praw, połączone za pomocą bitowej operacji OR. Określanie <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku wprowadzić semafor i określając <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątków do wywoływania <xref:System.Threading.Semaphore.Release%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemu, aby otworzyć.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują dostęp pożądanych zabezpieczeń.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.Semaphore" /> obiekt, który reprezentuje nazwane semafor, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określony nazwany semafor, jeśli już istnieje z dostępem do pożądanych zabezpieczeń i zwraca wartość wskazującą, czy operacja się powiedzie.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwany semafora został otwarty pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwany semafora nie istnieje, ta metoda nie powoduje utworzenia go. Aby utworzyć semafora systemu, jeśli jeszcze nie istnieje, użyj jednej z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Jeśli masz pewności, czy istnieje semafora nazwane, należy używać tego przeciążenia metody, zamiast <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, która zgłasza wyjątek, jeśli semafora nie istnieje.  
  
 `rights` Parametr musi zawierać <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flagi, aby zezwolić wątków, aby wprowadzić semafor i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flagi, aby zezwolić wątków do wywoływania <xref:System.Threading.Semaphore.Release%2A> metody.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.Semaphore> obiektu, mimo że obiekty, które reprezentują zwracane są takie same o nazwie semafora systemowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  - lub - <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Semafor o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4d612444124f1e9e0d4b84aef281ef295eb335ce" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69098836" /></Metadata><TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ogranicza liczbę wątków, które mogą jednocześnie uzyskiwać dostęp do zasobu lub puli zasobów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj klasy <xref:System.Threading.Semaphore> , aby kontrolować dostęp do puli zasobów. Wątki wprowadzają semafor, wywołując <xref:System.Threading.WaitHandle.WaitOne%2A> metodę, która jest dziedziczona <xref:System.Threading.WaitHandle> z klasy i zwalnia semafor przez wywołanie <xref:System.Threading.Semaphore.Release%2A> metody.  
  
 Licznik semafora jest zmniejszany za każdym razem, gdy wątek przechodzi do semafora, i zwiększany, gdy wątek zwalnia semafor. Gdy liczba jest równa zero, kolejne żądania blokują do momentu zwolnienia semafora przez inne wątki. Gdy wszystkie wątki wywydały semafor, licznik jest przy maksymalnej wartości określonej podczas tworzenia semafora.  
  
 Nie ma kolejności gwarantowanej, takiej jak FIFO lub LIFO, w której zablokowane wątki wprowadzają semafor.  
  
 Wątek może wielokrotnie wprowadzać semafor, wywołując <xref:System.Threading.WaitHandle.WaitOne%2A> metodę wielokrotnie. Aby zwolnić niektóre lub wszystkie z tych wpisów, wątek może wywoływać przeciążenie <xref:System.Threading.Semaphore.Release> metody bez parametrów wielokrotnie lub <xref:System.Threading.Semaphore.Release%28System.Int32%29> wywołać Przeciążenie metody, które określa liczbę wpisów do zwolnienia.  
  
 Klasa nie wymusza tożsamości wątku dla wywołań do <xref:System.Threading.WaitHandle.WaitOne%2A> lub <xref:System.Threading.Semaphore.Release%2A>. <xref:System.Threading.Semaphore> Programista może zapewnić, że wątki nie zwalniają zbyt wiele razy semaforów. Załóżmy na przykład, że semafor ma maksymalną liczbę dwóch, a wątek a i wątek B jednocześnie wprowadźe semafor. Jeśli błąd programowania w wątku B powoduje wywołanie <xref:System.Threading.Semaphore.Release%2A> dwa razy, oba wywołania powiodą się. Licznik semafora jest zapełniony, a kiedy wątek a ostatecznie wywołuje <xref:System.Threading.Semaphore.Release%2A> <xref:System.Threading.SemaphoreFullException> , jest zgłaszany.  
  
 Semafory są dwa typy: semafory lokalne i nazwane semafory systemowe. Jeśli utworzysz <xref:System.Threading.Semaphore> Obiekt przy użyciu konstruktora, który akceptuje nazwę, jest on skojarzony z semaforem systemu operacyjnego o tej nazwie. Nazwane semafory systemowe są widoczne w całym systemie operacyjnym i mogą służyć do synchronizowania działań procesów. Można utworzyć wiele <xref:System.Threading.Semaphore> obiektów, które reprezentują ten sam, nazwany semafor systemowy i można <xref:System.Threading.Semaphore.OpenExisting%2A> użyć metody, aby otworzyć istniejący, nazwany semafor systemowy.  
  
 Lokalny semafor istnieje tylko w ramach procesu. Może być używany przez dowolny wątek w procesie, który ma odwołanie do obiektu lokalnego <xref:System.Threading.Semaphore> . Każdy <xref:System.Threading.Semaphore> obiekt jest osobnym semaforem lokalnym.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy semafor z maksymalną liczbą trzech i początkową liczbą równą zero. Przykład uruchamia pięć wątków, które blokują oczekiwanie na semafor. Główny wątek używa <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody w celu zwiększenia liczby semaforów do maksymalnej, co pozwala trzy wątki na wprowadzanie semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody do oczekiwania na sekundę, w celu symulowania pracy, a następnie <xref:System.Threading.Semaphore.Release> wywołuje Przeciążenie metody w celu zwolnienia semafora. Za każdym razem, gdy semafor zostanie wystawiony, zostanie wyświetlona Poprzednia liczba semaforów. Komunikaty konsoli śledzą użycie semafora. Symulowany interwał pracy został nieco zwiększony dla każdego wątku, aby ułatwić odczytywanie danych wyjściowych.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Semaphore" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań dla semafora, które mogą być przyznawane współbieżnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań dla semafora, które mogą być przyznawane współbieżnie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Semaphore" /> klasy, określając początkową liczbę wpisów i maksymalną liczbę równoczesnych wpisów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje semafor nienazwany. Wszystkie wątki używające wystąpienia takiego semafora muszą mieć odwołania do wystąpienia.  
  
 Jeśli `initialCount` jest mniejsza niż `maximumCount`, efekt jest taki sam jak w przypadku wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> bieżącego wątku (`maximumCount` minus `initialCount`). Jeśli nie chcesz zarezerwować żadnych wpisów dla wątku, który tworzy semafor, Użyj tej samej liczby dla `maximumCount` i. `initialCount`  
  
   
  
## Examples  
 Poniższy przykład tworzy semafor z maksymalną liczbą trzech i początkową liczbą równą zero. Przykład uruchamia pięć wątków, które blokują oczekiwanie na semafor. Główny wątek używa <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody w celu zwiększenia liczby semaforów do maksymalnej, co pozwala trzy wątki na wprowadzanie semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody do oczekiwania na sekundę, w celu symulowania pracy, a następnie <xref:System.Threading.Semaphore.Release> wywołuje Przeciążenie metody w celu zwolnienia semafora. Za każdym razem, gdy semafor zostanie wystawiony, zostanie wyświetlona Poprzednia liczba semaforów. Komunikaty konsoli śledzą użycie semafora. Symulowany interwał pracy został nieco zwiększony dla każdego wątku, aby ułatwić odczytywanie danych wyjściowych.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" />jest większa niż <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" />jest mniejsza niż 1.  
  
—lub— 
 <paramref name="initialCount" />jest mniejsza niż 0.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań dla semafora, które mogą być przyznawane współbieżnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań dla semafora, które mogą być przyznawane współbieżnie.</param>
        <param name="name">Nazwa nazwany obiekt semafora systemowego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Semaphore" /> klasy, określając początkową liczbę wpisów i maksymalną liczbę równoczesnych wpisów oraz opcjonalnie określając nazwę obiektu semafora systemowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt reprezentujący nazwany semafor systemowy. Można utworzyć wiele <xref:System.Threading.Semaphore> obiektów, które reprezentują ten sam semafor o nazwie System.  
  
 Jeśli wskazany semafor systemowy nie istnieje, jest tworzony z początkową liczbą i maksymalną liczbą określoną przez `initialCount` i. `maximumCount` Jeśli wskazany semafor systemowy już istnieje `initialCount` i `maximumCount` nie jest używany, chociaż nieprawidłowe wartości nadal powodują wyjątki. Jeśli musisz określić, czy nazwany semafor systemowy został utworzony, użyj <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> przeciążenia konstruktora zamiast tego.  
  
> [!IMPORTANT]
>  W przypadku korzystania z tego przeciążenia konstruktora zalecaną metodą jest określenie tego samego numeru dla `initialCount` i. `maximumCount` Jeśli `initialCount` jest mniejsza niż `maximumCount`i zostanie utworzony nazwany semafor systemowy, efekt jest taki sam jak w przypadku wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> bieżącego wątku (`maximumCount` minus `initialCount`). Jednak w przypadku tego przeciążenia konstruktora nie ma możliwości określenia, czy nazwanego semafora systemowego została utworzona.  
  
 Jeśli określisz `null` lub pusty ciąg dla `name`, zostanie utworzony semafor lokalny, tak jakby został wywołany <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeciążenie konstruktora.  
  
 Ponieważ nazwane semafory są widoczne w całym systemie operacyjnym, mogą służyć do koordynowania użycia zasobów między granicami procesów.  
  
 Jeśli chcesz dowiedzieć się, czy nazwanego semafora systemowego istnieje, <xref:System.Threading.Semaphore.OpenExisting%2A> Użyj metody. <xref:System.Threading.Semaphore.OpenExisting%2A> Metoda próbuje otworzyć istniejący, nazwany semafor, i zgłasza wyjątek, jeśli semafor systemowy nie istnieje.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe nazwanego semafora. W przykładzie tworzony jest nazwany semafor z maksymalną liczbą pięciu i początkową liczbą pięciu. Program wykonuje trzy wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> metody. W takim przypadku w przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia zostanie Zablokowani po trzecim wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A>. Zwolnij co najmniej jeden wpis w pierwszej kopii programu, aby odblokować drugi.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" />jest większa niż <paramref name="maximumCount" />.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" />jest mniejsza niż 1.  
  
—lub— 
 <paramref name="initialCount" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany semafor istnieje i ma zabezpieczenia kontroli dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nie można utworzyć nazwanego semafora, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wywoływania kodu niezarządzanego w celu utworzenia nazwanego semafora systemowego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań dla semafora, które mogą być spełnione współbieżnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań dla semafora, które mogą być jednocześnie spełnione.</param>
        <param name="name">Nazwa nazwany obiekt semafora systemowego.</param>
        <param name="createdNew">Gdy ta metoda zwraca, zawiera <see langword="true" /> , czy został utworzony semafor lokalny (czyli jeśli <paramref name="name" /> jest <see langword="null" /> lub pusty ciąg) lub jeśli został utworzony określony, nazwany semafor systemowy; <see langword="false" /> Jeśli określona nazwanego semafora systemowego już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Semaphore" /> klasy, określając początkową liczbę wpisów i maksymalną liczbę równoczesnych wpisów, opcjonalnie określając nazwę obiektu semafora systemowego i określając zmienną, która otrzymuje wartość wskazującą czy został utworzony nowy semafor systemowy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt reprezentujący nazwany semafor systemowy. Można utworzyć wiele <xref:System.Threading.Semaphore> obiektów, które reprezentują ten sam semafor o nazwie System.  
  
 Jeśli wskazany semafor systemowy nie istnieje, jest tworzony z początkową liczbą i maksymalną liczbą określoną przez `initialCount` i. `maximumCount` Jeśli wskazany semafor systemowy już istnieje `initialCount` i `maximumCount` nie jest używany, chociaż nieprawidłowe wartości nadal powodują wyjątki. Użyj `createdNew` , aby określić, czy semafor systemowy został utworzony.  
  
 Jeśli `initialCount` jest mniejsza niż `maximumCount`, i `createdNew` jest `true`, efekt jest taki sam jak w przypadku wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> bieżącego wątku (`maximumCount` minus `initialCount`).  
  
 Jeśli określisz `null` lub pusty ciąg dla `name`, zostanie utworzony semafor lokalny, tak jakby został wywołany <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeciążenie konstruktora. W tym przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ nazwane semafory są widoczne w całym systemie operacyjnym, mogą służyć do koordynowania użycia zasobów między granicami procesów.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe nazwanego semafora. W przykładzie tworzony jest nazwany semafor z maksymalną liczbą pięciu i początkową liczbą dwóch. Oznacza to, że rezerwuje trzy wpisy dla wątku, który wywołuje konstruktora. Jeśli `createNew` tak `false`, program<xref:System.Threading.WaitHandle.WaitOne%2A> wykonuje trzy wywołania metody. W takim przypadku w przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia zostanie Zablokowani po trzecim wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A>. Zwolnij co najmniej jeden wpis w pierwszej kopii programu, aby odblokować drugi.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" />jest większa niż <paramref name="maximumCount" />.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" />jest mniejsza niż 1.  
  
—lub— 
 <paramref name="initialCount" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany semafor istnieje i ma zabezpieczenia kontroli dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nie można utworzyć nazwanego semafora, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wywoływania kodu niezarządzanego w celu utworzenia nazwanego semafora systemowego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maximumCount" Type="System.Int32" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań dla semafora, które mogą być spełnione współbieżnie.</param>
        <param name="maximumCount">Maksymalna liczba żądań dla semafora, które mogą być jednocześnie spełnione.</param>
        <param name="name">Nazwa nazwany obiekt semafora systemowego.</param>
        <param name="createdNew">Gdy ta metoda zwraca, zawiera <see langword="true" /> , czy został utworzony semafor lokalny (czyli jeśli <paramref name="name" /> jest <see langword="null" /> lub pusty ciąg) lub jeśli został utworzony określony, nazwany semafor systemowy; <see langword="false" /> Jeśli określona nazwanego semafora systemowego już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="semaphoreSecurity"><see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu, który ma zostać zastosowany do nazwanego semafora systemowego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Semaphore" /> klasy, określając początkową liczbę wpisów i maksymalną liczbę równoczesnych wpisów, opcjonalnie określając nazwę obiektu semafora systemowego, określając zmienną, która otrzymuje wartość wskazującą czy został utworzony nowy semafor systemowy i określono kontrolę dostępu zabezpieczeń dla semafora systemowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, aby zastosować zabezpieczenia kontroli dostępu do nazwanego semafora systemu podczas jego tworzenia, uniemożliwiając innemu kodowi przejęcie kontroli nad semaforem.  
  
 Ten konstruktor inicjuje <xref:System.Threading.Semaphore> obiekt reprezentujący nazwany semafor systemowy. Można utworzyć wiele <xref:System.Threading.Semaphore> obiektów, które reprezentują ten sam semafor o nazwie System.  
  
 Jeśli wskazany semafor systemowy nie istnieje, jest tworzony z określonym zabezpieczeniami kontroli dostępu. Jeśli istnieje nazwany semafor, określone zabezpieczenia kontroli dostępu zostaną zignorowane.  
  
> [!NOTE]
>  Obiekt wywołujący ma pełną kontrolę nad nowo utworzonym <xref:System.Threading.Semaphore> obiektem, nawet w przypadku `semaphoreSecurity` odmowy lub niepowodzenia udzielenia pewnych praw dostępu bieżącemu użytkownikowi. Jeśli jednak bieżący użytkownik próbuje uzyskać inny <xref:System.Threading.Semaphore> obiekt do reprezentowania tego samego, nazwanego semafora, przy użyciu konstruktora <xref:System.Threading.Semaphore.OpenExisting%2A> lub metody, stosowane są zabezpieczenia kontroli dostępu systemu Windows.  
  
 Jeśli wskazany semafor systemowy nie istnieje, jest tworzony z początkową liczbą i maksymalną liczbą określoną przez `initialCount` i. `maximumCount` Jeśli wskazany semafor systemowy już istnieje `initialCount` i `maximumCount` nie jest używany, chociaż nieprawidłowe wartości nadal powodują wyjątki. Użyj parametru `createdNew` , aby określić, czy semafor systemowy został utworzony przez tego konstruktora.  
  
 Jeśli `initialCount` jest mniejsza niż `maximumCount`, i `createdNew` jest `true`, efekt jest taki sam jak w przypadku wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> bieżącego wątku (`maximumCount` minus `initialCount`).  
  
 Jeśli określisz `null` lub pusty ciąg dla `name`, zostanie utworzony semafor lokalny, tak jakby został wywołany <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> przeciążenie konstruktora. W tym przypadku `createdNew` jest zawsze `true`.  
  
 Ponieważ nazwane semafory są widoczne w całym systemie operacyjnym, mogą służyć do koordynowania użycia zasobów między granicami procesów.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego semafora z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Przeciążenie metody do testowania obecności nazwanego semafora. Jeśli semafor nie istnieje, jest tworzony z maksymalną liczbą dwóch i z zabezpieczeniami kontroli dostępu, który odmówi bieżącego użytkownika prawo do użycia semafora, ale przyznaje prawo do odczytu i zmiany uprawnień do semafora. W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> Przeciążenie metody, aby otworzyć semafor z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień semafor zostanie otwarty z prawami wymaganymi do wejścia i zwolnienia. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" />jest większa niż <paramref name="maximumCount" />.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" />jest mniejsza niż 1.  
  
—lub— 
 <paramref name="initialCount" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany semafor istnieje i ma zabezpieczenia kontroli dostępu, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nie można utworzyć nazwanego semafora, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wywoływania kodu niezarządzanego w celu utworzenia nazwanego semafora systemowego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera zabezpieczenia kontroli dostępu dla nazwanego semafora systemowego.</summary>
        <returns><see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu dla nazwanego semafora systemowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda używa następującej kombinacji flag (połączonych przy użyciu wartości bitowej lub operacji) do wyszukiwania uprawnień: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. <xref:System.Threading.Semaphore.GetAccessControl%2A>  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> uprawnienia do wywołania tej metody, a semafor musi być otwarty z <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> prawami.  
  
 W przypadku semafora lokalnego zabezpieczenia kontroli dostępu są nieistotne. Jeśli obiekt nie reprezentuje nazwanego semafora systemu, Metoda <xref:System.Security.AccessControl.SemaphoreSecurity> zwraca obiekt, który przyznaje wszystkie prawa każdemu użytkownikowi. <xref:System.Threading.Semaphore>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego semafora z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Przeciążenie metody do testowania obecności nazwanego semafora.  
  
 Jeśli semafor nie istnieje, jest tworzony z maksymalną liczbą dwóch i z zabezpieczeniami kontroli dostępu, które odmówi bieżącego użytkownika prawo do użycia semafora, ale przyznaje prawo do odczytu i zmiany uprawnień do semafora.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> Przeciążenie metody, aby otworzyć semafor z prawami wymaganymi do odczytu i zmiany uprawnień. Zabezpieczenia kontroli dostępu dla semafora systemowego są uzyskiwane przy <xref:System.Threading.Semaphore.GetAccessControl%2A> użyciu metody.  
  
 Po zmianie uprawnień semafor zostanie otwarty z prawami wymaganymi do wejścia i zwolnienia. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący <see cref="T:System.Threading.Semaphore" /> obiekt reprezentuje nazwanego semafora systemowego, a użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> uprawnień.  
  
—lub— 
Bieżący <see cref="T:System.Threading.Semaphore" /> obiekt reprezentuje nazwanego semafora systemowego i nie został otwarty <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> z prawami.</exception>
        <exception cref="T:System.NotSupportedException">Nieobsługiwane dla systemu Windows 98 lub Windows Millennium Edition.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określony, nazwany semafor, jeśli już istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemowego do otwarcia.</param>
        <summary>Otwiera określony semafor nazwany, jeśli już istnieje.</summary>
        <returns>Obiekt reprezentujący nazwany semafor systemowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Semaphore.OpenExisting%2A> Metoda próbuje otworzyć określony nazwany semafor. Jeśli semafor systemowy nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia semafora systemowego. Aby utworzyć semafor systemowy, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Wielokrotne wywołania tej metody, które używają tej samej wartości `name` dla niekoniecznie zwracają ten <xref:System.Threading.Semaphore> sam obiekt, nawet jeśli zwracane obiekty reprezentują ten sam, nazwany semafor systemowy.  
  
 To Przeciążenie metody jest równoważne wywołaniem <xref:System.Threading.Semaphore.OpenExisting%2A> przeciążenia metody i określaniem <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> prawami, połączonymi przy użyciu bitowej lub operacji.  
  
 Określenie flagi pozwala wątek wprowadzić semafor, a <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> określenie flagi umożliwia wątkowi wywołanie <xref:System.Threading.Semaphore.Release%2A> metody. <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego semafora z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Przeciążenie metody do testowania obecności nazwanego semafora.  
  
 Jeśli semafor nie istnieje, jest tworzony z maksymalną liczbą dwóch i z zabezpieczeniami kontroli dostępu, który odmówi bieżącego użytkownika prawo do użycia semafora, ale przyznaje prawo do odczytu i zmiany uprawnień do semafora.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> Przeciążenie metody, aby otworzyć semafor z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień semafor zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwany semafor nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany semafor istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymaganego do jego użycia.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wywoływania kodu niezarządzanego w celu otworzenia nazwanego semafora systemowego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemowego do otwarcia.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują żądany dostęp do zabezpieczeń.</param>
        <summary>Otwiera określony semafor nazwany, jeśli już istnieje, z żądanym dostępem zabezpieczeń.</summary>
        <returns>Obiekt reprezentujący nazwany semafor systemowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> zawierać flagę, aby umożliwić wątkom wprowadzanie semafora, oraz flagę, aby umożliwić wątkom wywoływanie <xref:System.Threading.Semaphore.Release%2A> metody. <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> `rights`  
  
 <xref:System.Threading.Semaphore.OpenExisting%2A> Metoda próbuje otworzyć istniejący semafor o nazwie. Jeśli semafor systemowy nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia semafora systemowego. Aby utworzyć semafor systemowy, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Wielokrotne wywołania tej metody, które używają tej samej wartości `name` dla niekoniecznie zwracają ten <xref:System.Threading.Semaphore> sam obiekt, nawet jeśli zwracane obiekty reprezentują ten sam, nazwany semafor systemowy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego semafora z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Przeciążenie metody do testowania obecności nazwanego semafora.  
  
 Jeśli semafor nie istnieje, jest tworzony z maksymalną liczbą dwóch i z zabezpieczeniami kontroli dostępu, które odmówi bieżącego użytkownika prawo do użycia semafora, ale przyznaje prawo do odczytu i zmiany uprawnień do semafora.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> Przeciążenie metody, aby otworzyć semafor z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień semafor zostanie otwarty z prawami wymaganymi do wprowadzenia i zwolnienia. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwany semafor nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany semafor istnieje, ale użytkownik nie ma odpowiednich praw dostępu zabezpieczeń.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wywoływania kodu niezarządzanego w celu utworzenia nazwanego semafora systemowego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy działanie semafora.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka Semafor i zwraca poprzednią liczbę.</summary>
        <returns>Licznik semafora przed <see cref="Overload:System.Threading.Semaphore.Release" /> wywołaniem metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątki zwykle używają <xref:System.Threading.WaitHandle.WaitOne%2A> metody do wprowadzania semafora i zwykle używają tego przeciążenia metody do zakończenia.  
  
 Jeśli jest zgłaszany przez metodę, niekoniecznie wskazuje problem z wątkem wywołującym. <xref:System.Threading.Semaphore.Release%2A> <xref:System.Threading.SemaphoreFullException> Błąd programowania w innym wątku spowodował, że wątek wymusił więcej czasu niż wprowadzona.  
  
 Jeśli bieżący <xref:System.Threading.Semaphore> obiekt reprezentuje nazwę semafora systemowego, użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> prawa i semafor musiał zostać otwarty z <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> prawami.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy semafor z maksymalną liczbą trzech i początkową liczbą równą zero. Przykład uruchamia pięć wątków, które blokują oczekiwanie na semafor. Główny wątek używa <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody w celu zwiększenia liczby semaforów do maksymalnej, co pozwala trzy wątki na wprowadzanie semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody do oczekiwania na sekundę, w celu symulowania pracy, a następnie <xref:System.Threading.Semaphore.Release> wywołuje Przeciążenie metody w celu zwolnienia semafora.  
  
 Za każdym razem, gdy semafor zostanie wystawiony, zostanie wyświetlona Poprzednia liczba semaforów. Komunikaty konsoli śledzą użycie semafora. Symulowany interwał pracy został nieco zwiększony dla każdego wątku, aby ułatwić odczytywanie danych wyjściowych.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">Liczba semaforów ma już wartość maksymalną.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32 z nazwanym semaforem.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący semafor reprezentuje nazwanego semafora systemowego, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
—lub— 
Bieżący semafor reprezentuje nazwanego semafora systemowego, ale nie został otwarty za <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />pomocą.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Liczba godzin zamykania semafora.</param>
        <summary>Zamyka semafora określoną liczbę razy i zwraca poprzednią liczbę.</summary>
        <returns>Licznik semafora przed <see cref="Overload:System.Threading.Semaphore.Release" /> wywołaniem metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątek przeszedł wielokrotnie, to Przeciążenie metody umożliwia przywrócenie całej liczby semaforów z jednym wywołaniem.  
  
 Jeśli jest zgłaszany przez metodę, niekoniecznie wskazuje problem z wątkem wywołującym. <xref:System.Threading.Semaphore.Release%2A> <xref:System.Threading.SemaphoreFullException> Błąd programowania w innym wątku spowodował, że wątek wymusił więcej czasu niż wprowadzona.  
  
 Jeśli bieżący <xref:System.Threading.Semaphore> obiekt reprezentuje nazwę semafora systemowego, użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> prawa i semafor musiał zostać otwarty z <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> prawami.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy semafor z maksymalną liczbą trzech i początkową liczbą równą zero. Przykład uruchamia pięć wątków, które blokują oczekiwanie na semafor. Główny wątek używa <xref:System.Threading.Semaphore.Release%28System.Int32%29> przeciążenia metody w celu zwiększenia liczby semaforów do maksymalnej, co pozwala trzy wątki na wprowadzanie semafora. Każdy wątek używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody do oczekiwania na sekundę, w celu symulowania pracy, a następnie <xref:System.Threading.Semaphore.Release> wywołuje Przeciążenie metody w celu zwolnienia semafora.  
  
 Za każdym razem, gdy semafor zostanie wystawiony, zostanie wyświetlona Poprzednia liczba semaforów. Komunikaty konsoli śledzą użycie semafora. Symulowany interwał pracy został nieco zwiększony dla każdego wątku, aby ułatwić odczytywanie danych wyjściowych.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="releaseCount" />jest mniejsza niż 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">Liczba semaforów ma już wartość maksymalną.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32 z nazwanym semaforem.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący semafor reprezentuje nazwanego semafora systemowego, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> uprawnień.  
  
—lub— 
Bieżący semafor reprezentuje nazwanego semafora systemowego, ale nie został otwarty z <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> prawami.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity"><see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu, który ma zostać zastosowany do nazwanego semafora systemowego.</param>
        <summary>Ustawia zabezpieczenia kontroli dostępu dla nazwanego semafora systemowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zabezpieczenia kontroli dostępu można ustawić tylko dla <xref:System.Threading.Semaphore> obiektów, które reprezentują nazwane semafory systemowe.  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> uprawnienia do wywołania tej metody, a semafor musi być otwarty z <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> prawami.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe dla nazwanego semafora z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Przeciążenie metody do testowania obecności nazwanego semafora.  
  
 Jeśli semafor nie istnieje, jest tworzony z maksymalną liczbą dwóch i z zabezpieczeniami kontroli dostępu, który odmówi bieżącego użytkownika prawo do użycia semafora, ale przyznaje prawo do odczytu i zmiany uprawnień do semafora.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metody. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> Przeciążenie metody, aby otworzyć semafor z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień przy użyciu <xref:System.Threading.Semaphore.SetAccessControl%2A> metody, semafor zostanie otwarty z prawami wymaganymi do wejścia i zwolnienia. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń zostanie ono uruchomione przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="semaphoreSecurity" />jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> uprawnień.  
  
—lub— 
Semafor nie został otwarty z <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> prawami.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący <see cref="T:System.Threading.Semaphore" /> obiekt nie reprezentuje nazwanego semafora systemowego.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określony, nazwany semafor, jeśli już istnieje, i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemowego do otwarcia.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera <see cref="T:System.Threading.Semaphore" /> obiekt, który reprezentuje nazwane semafor, jeśli wywołanie zakończyło się powodzeniem lub <see langword="null" /> wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określony, nazwany semafor, jeśli już istnieje, i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli nazwany semafor został pomyślnie otwarty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwany semafor nie istnieje, ta metoda nie zostanie utworzona. Aby utworzyć semafor systemowy, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Jeśli nie masz pewności, czy nazwany semafor istnieje, użyj tego przeciążenia metody zamiast <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> przeciążenia metody, które zgłasza wyjątek, jeśli semafor nie istnieje.  
  
 To Przeciążenie metody jest równoważne wywołaniem <xref:System.Threading.Semaphore.TryOpenExisting%2A> przeciążenia metody i określaniem <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> prawami, połączonymi przy użyciu bitowej lub operacji. Określenie flagi pozwala wątek wprowadzić semafor, a <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> określenie flagi umożliwia wątkowi wywołanie <xref:System.Threading.Semaphore.Release%2A> metody. <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany semafor istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymaganego do jego użycia.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemowego do otwarcia.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują żądany dostęp do zabezpieczeń.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera <see cref="T:System.Threading.Semaphore" /> obiekt, który reprezentuje nazwane semafor, jeśli wywołanie zakończyło się powodzeniem lub <see langword="null" /> wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określony, nazwany semafor, jeśli już istnieje, z żądanym dostępem zabezpieczeń i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli nazwany semafor został pomyślnie otwarty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwany semafor nie istnieje, ta metoda nie zostanie utworzona. Aby utworzyć semafor systemowy, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.Semaphore.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Jeśli nie masz pewności, czy nazwany semafor istnieje, użyj tego przeciążenia metody zamiast <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> przeciążenia metody, które zgłasza wyjątek, jeśli semafor nie istnieje.  
  
 Parametr musi <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> zawierać flagę, aby umożliwić wątkom wprowadzanie semafora, oraz flagę, aby umożliwić wątkom wywoływanie <xref:System.Threading.Semaphore.Release%2A> metody. <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> `rights`  
  
 Wielokrotne wywołania tej metody, które używają tej samej wartości `name` dla niekoniecznie zwracają ten <xref:System.Threading.Semaphore> sam obiekt, nawet jeśli zwracane obiekty reprezentują ten sam, nazwany semafor systemowy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwany semafor istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymaganego do jego użycia.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

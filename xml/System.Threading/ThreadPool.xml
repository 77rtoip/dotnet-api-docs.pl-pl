<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4c7b332b62aaa5c8a15d140203a179ae61742d2f" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58707170" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera pulę wątków, które może służyć do wykonywania zadań, Publikuj elementy robocze, Przetwarzanie asynchroniczne We/Wy, Oczekiwanie w imieniu innych wątków i przetworzyć czasomierzy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele aplikacji Utwórz wątki, które możesz wydać dużym stopniem czas w stanie uśpiony, oczekiwanie na zdarzenia. Inne wątki mogą przejść w stan uśpiony tylko do wznowione, okresowo sondować zmiany lub zaktualizować informacje o stanie. Pula wątków umożliwia wątków bardziej wydajnie, zapewniając aplikację z pulą wątków roboczych, które są zarządzane przez system. Następujące operacje, które używają wątków z puli wątków:  
  
-   Po utworzeniu <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> obiektu w celu wykonania niektórych zadań asynchronicznie, domyślnie zadanie jest zaplanowane do uruchomienia na wątku z puli wątków.  
  
-   Czasomierze asynchronicznego użyć puli wątków. Wątków z puli wątków wykonania wywołania zwrotne z <xref:System.Threading.Timer?displayProperty=nameWithType> klasy i wywoływanie zdarzeń od <xref:System.Timers.Timer?displayProperty=nameWithType> klasy.  
  
-   Korzystając z uchwytami oczekiwania zarejestrowanych wątku systemu monitoruje stan dojść oczekiwania. Po ukończeniu operacji oczekiwania wątku roboczego z puli wątków wykonuje odpowiedniej funkcji wywołania zwrotnego.  
  
-   Gdy wywołujesz <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metoda to metoda wykonanie na wątku z puli wątków w kolejce. Można to zrobić, przekazując metody <xref:System.Threading.WaitCallback> delegować.   Pełnomocnik ma podpis  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     gdzie `state` jest obiektem, który zawiera dane używane przez delegata. Rzeczywiste dane mogą być przekazywane do obiektu delegowanego, wywołując <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> metody.  
  
> [!NOTE]
>  Wątki w puli wątków zarządzanych są wątków w tle. Oznacza to, że ich <xref:System.Threading.Thread.IsBackground%2A> właściwości są `true`. Oznacza to, że <xref:System.Threading.ThreadPool> wątku nie zachowa aplikację działającą po zamknięciu wszystkie wątki pierwszego planu.  
  
> [!IMPORTANT]
>  Gdy w puli wątków ponownie używa wątku, czyści dane w pamięci lokalnej wątku lub pola, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutu. W związku z tym, gdy metoda sprawdza, czy lokalny magazyn wątków lub pola, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutu wartości znajdzie może pozostać za pośrednictwem z wcześniejszego użycia wątek puli wątków.  
  
 Możesz również dodawać do kolejki elementów roboczych, które nie są związane z operacji oczekiwania, do puli wątków. Aby zażądać obsługiwania przez wątek w puli wątków o element roboczy, należy wywołać <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody. Ta metoda przyjmuje jako parametr to odwołanie do metody lub delegata, która zostanie wywołana przez wątek wybrane z puli wątków. Nie ma możliwości anulowania elementu roboczego po zostało umieszczone w kolejce.  
  
 Czasomierze kolejki czasomierza i oczekiwania zarejestrowanych operacji należy również użyć puli wątków. Ich funkcji wywołania zwrotnego są umieszczane w kolejce puli wątków.  
  
 Istnieje jedna pula wątków na proces. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], domyślny rozmiar puli wątków dla procesu zależy od wielu czynników, takich jak rozmiar wirtualnej przestrzeni adresowej. Proces może wywołać <xref:System.Threading.ThreadPool.GetMaxThreads%2A> metodę pozwala ustalić liczbę wątków. Liczba wątków w puli wątków można zmienić za pomocą <xref:System.Threading.ThreadPool.SetMaxThreads%2A> metody. Każdy wątek korzysta z domyślnego rozmiaru stosu i uruchamia wyzwalacz w priorytet domyślny.  
  
> [!NOTE]
>  Kod niezarządzany, który jest hostem środowiska .NET Framework można zmienić rozmiar puli wątków za pomocą `CorSetMaxThreads` funkcji, zdefiniowane w pliku mscoree.h.  
  
 Puli wątków zapewnia nowych wątków roboczych lub wątków do ukończenia operacji We/Wy na żądanie, dopóki nie zostanie osiągnięty co najmniej dla każdej kategorii. Po osiągnięciu co najmniej puli wątków można utworzyć dodatkowe wątki w danej kategorii lub poczekaj na ukończenie niektóre zadania. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], puli wątków tworzy i niszczy wątków roboczych w celu zoptymalizowania przepływności, która jest zdefiniowana jako liczbę zadań, kończące się na jednostkę czasu. Zbyt mało wątków może nie mieć optymalnego wykorzystania dostępnych zasobów, natomiast zbyt wiele wątków może zwiększyć rywalizacji o zasoby.  
  
> [!NOTE]
>  Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków z puli wątków może spadną poniżej wartości minimalnej.  
  
 Możesz użyć <xref:System.Threading.ThreadPool.GetMinThreads%2A> metody uzyskiwania tych wartości minimalnej.  
  
> [!CAUTION]
>  Możesz użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodę, aby zwiększyć minimalną liczbę wątków. Jednak niepotrzebnie zwiększenie tych wartości może spowodować problemy z wydajnością. Jeśli zbyt wiele zadań jest uruchomiona w tym samym czasie, wszystkie z nich może pojawić się wolno. W większości przypadków puli wątków będą działać lepiej z własną algorytm wątki alokacji.  
  
   
  
## Examples  
 W poniższym przykładzie wątku głównego aplikacji kolejki metodę o nazwie `ThreadProc` można wykonać na wątku z puli wątków, sen dla jednej sekundy, a następnie zamyka. `ThreadProc` Metoda po prostu wyświetla komunikat.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 Jeśli komentarz wystąpi poza wywołanie <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody główny wątek kończy działanie zanim metoda zostanie uruchomiona w wątku z puli wątków.  Korzysta z puli wątków wątków w tle, które nie jest przechowywana aplikacja była uruchomiona, jeśli wszystkie wątki pierwszoplanowe zostać zakończony.  (Jest to prosty przykład sytuacja wyścigu).  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pula wątków zarządzanych</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wiąże dojście systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="osHandle"><see cref="T:System.IntPtr" /> Przechowuje dojście. Dojście musi otwarte dla nakładające się operacji We/Wy w niezarządzanym.</param>
        <summary>Wiąże dojście systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns><see langword="true" /> Jeśli uchwyt jest powiązana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania niezarządzanego kodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> przechowuje dojście systemu operacyjnego. Dojście musi otwarte dla nakładające się operacji We/Wy w niezarządzanym.</param>
        <summary>Wiąże dojście systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns><see langword="true" /> Jeśli uchwyt jest powiązana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `osHandle` Parametr powinien być <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, która jest pochodną abstrakcyjnej <xref:System.Runtime.InteropServices.SafeHandle> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="osHandle" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania niezarządzanego kodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Liczba wątków roboczych dostępne.</param>
        <param name="completionPortThreads">Liczba dostępnych asynchronicznego wątków We/Wy.</param>
        <summary>Pobiera różnicę między maksymalną liczbę wątków z puli wątków zwrócony przez <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> metoda i liczba aktualnie aktywne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> zwraca zmiennej określonej przez `workerThreads` zawiera liczbę wątków roboczych dodatkowe, które mogą być uruchamiane, a zmienna określona przez `completionPortThreads` zawiera liczbę dodatkowych asynchronicznego wątków We/Wy, które mogą być pracę.  
  
 W przypadku nie ma dostępnych wątków żądania puli wątków dodatkowe pozostają w kolejce do momentu wątków z puli wątków stają się dostępne.  
  
   
  
## Examples  
 Poniższy przykład wyświetla liczbę wątków roboczych i dostępne wątki We/Wy po uruchomieniu prostą aplikację.  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Maksymalna liczba wątków w puli wątków.</param>
        <param name="completionPortThreads">Maksymalna liczba asynchronicznego wątków We/Wy w puli wątków.</param>
        <summary>Pobiera liczbę żądań w puli wątków, które mogą być wykonywane jednocześnie. Wszystkie żądania powyżej tego numeru pozostaną w kolejce, dopóki wątków z puli wątków stają się dostępne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Threading.ThreadPool.GetMaxThreads%2A> zwraca zmiennej określonej przez `workerThreads` zawiera maksymalną liczbę wątków roboczych dozwolonych w puli wątków i zmiennej określonej przez `completionPortThreads` zawiera maksymalną liczbę asynchronicznego wątków We/Wy w Pula wątków.  
  
 Możesz użyć <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> metodę pozwala ustalić rzeczywista liczba wątków w puli wątków w danym momencie.  
  
 Możesz użyć <xref:System.Threading.ThreadPool.SetMaxThreads%2A> można ustawić maksymalną liczbę wątków roboczych i asynchronicznych operacji We/Wy wątków w puli wątków.  
  
 Możesz dodawać do kolejki, jak wiele wątków, żądań w puli pamięci systemowej zezwala na to. W przypadku żądań więcej niż wątków z puli wątków dodatkowych żądań pozostają w kolejce do momentu wątków z puli wątków stają się dostępne.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak pobrać liczbę maksymalną i dostępna liczba wątków w puli wątków. Element roboczy znajduje się w kolejce używającej `FileStream` do asynchronicznego zapisu do dwóch plików. Metody wywołania zwrotnego jest mierzony nakładania się. Wątek roboczy obsługuje element roboczy i, w zależności od szybkości i liczby procesorów w komputerze, co najmniej dwóch wątków portu zakończenia obsługi operacji zapisu.  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Po powrocie z tej metody zawiera minimalną liczbę wątków roboczych, tworzonych w puli wątków na żądanie.</param>
        <param name="completionPortThreads">Po powrocie z tej metody zawiera minimalna liczba asynchronicznego wątków We/Wy, tworzonych w puli wątków na żądanie.</param>
        <summary>Pobiera minimalną liczbę wątków, tworzonych w puli wątków na żądanie, gdy zostaną wprowadzone nowe żądania, przed przełączeniem na algorytm do zarządzania tworzeniem wątku i niszczeniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puli wątków zapewnia nowych wątków roboczych lub wątków do ukończenia operacji We/Wy na żądanie, dopóki nie zostanie osiągnięty co najmniej dla każdej kategorii. Minimalna liczba wątków domyślnie do liczby procesorów w systemie. Gdy zostanie osiągnięta minimalny, puli wątków można utworzyć dodatkowe wątki w danej kategorii lub poczekaj na ukończenie niektóre zadania. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], puli wątków tworzy i niszczy wątki w celu zoptymalizowania przepływności, która jest zdefiniowana jako liczbę zadań, kończące się na jednostkę czasu. Zbyt mało wątków może nie mieć optymalnego wykorzystania dostępnych zasobów, natomiast zbyt wiele wątków może zwiększyć rywalizacji o zasoby.  
  
> [!NOTE]
>  Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków z puli wątków może spadną poniżej wartości minimalnej.  
  
   
  
## Examples  
 Poniższy przykład Ustawia minimalną liczbę wątków roboczych na cztery i zachowuje oryginalnej wartości minimalna liczba wątków uzupełniania w usłudze asynchronicznych operacji We/Wy.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umieszcza w kolejce metody do wykonania. Metoda jest wykonywana po udostępnieniu wątku z puli wątków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący metodę do wykonania.</param>
        <summary>Umieszcza w kolejce metody do wykonania. Metoda jest wykonywana po udostępnieniu wątku z puli wątków.</summary>
        <returns><see langword="true" /> Jeśli metoda pomyślnie znajduje się w kolejce; <see cref="T:System.NotSupportedException" /> jest generowany, jeśli element roboczy nie można umieścić w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz umieścić dane wymagane przez umieszczonych w kolejce metody pól wystąpienia klasy, w którym metoda jest zdefiniowany, lub możesz użyć <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> przeciążenie, które akceptuje obiekt zawierający niezbędnych danych.  
  
> [!NOTE]
>  Użytkowników programu Visual Basic można pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu użyj `AddressOf` operator przy przekazywaniu Metoda wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic automatycznie wywołuje konstruktor poprawnym delegacie.  
  
## <a name="version-information"></a>Informacje o wersji  
 W .NET Framework w wersji 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody. We wcześniejszych wersjach nie są propagowane informacji o jednostce.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> przeciążenia metody do kolejki zadań, która jest reprezentowana przez `ThreadProc` metod w celu wykonania, gdy wątek stanie się dostępny. Nie informacji o zadaniu jest dostarczany za pomocą tego przeciążenia. W związku z tym, informacje, które są dostępne dla `ThreadProc` metoda jest ograniczona do obiektu, którego należy metoda.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Znajduje się środowisko uruchomieniowe języka wspólnego (CLR) i host nie obsługuje tej akcji.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący metodę do wykonania.</param>
        <param name="state">Obiekt zawierający dane do użycia przez metodę.</param>
        <summary>Kolejki metodę wykonywania i określa obiekt zawierający dane do użycia przez metodę. Metoda jest wykonywana po udostępnieniu wątku z puli wątków.</summary>
        <returns><see langword="true" /> Jeśli metoda pomyślnie znajduje się w kolejce; <see cref="T:System.NotSupportedException" /> jest generowany, jeśli element roboczy nie można umieścić w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda wywołania zwrotnego wymaga złożonych danych, można zdefiniować klasę zawierającą dane.  
  
> [!NOTE]
>  Użytkowników programu Visual Basic można pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu użyj `AddressOf` operator przy przekazywaniu Metoda wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic automatycznie wywołuje konstruktor poprawnym delegacie.  
  
## <a name="version-information"></a>Informacje o wersji  
 W .NET Framework w wersji 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody. We wcześniejszych wersjach nie są propagowane informacji o jednostce.  
  
   
  
## Examples  
 W poniższym przykładzie użyto puli wątków .NET do obliczania `Fibonacci` wyniku dla pięciu liczby z zakresu od 20 do 40. Każdy `Fibonacci` wynik jest reprezentowany przez `Fibonacci` klasy, która udostępnia metodę o nazwie `ThreadPoolCallback` , która wykonuje obliczenie. Obiekt, który reprezentuje każdy `Fibonacci` wartość zostanie utworzony i `ThreadPoolCallback` metoda jest przekazywana do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, co powoduje przypisanie dostępnych wątków w puli, aby wykonać metodę.  
  
 Ponieważ każdy `Fibonacci` obiekt otrzymuje częściową losową wartość do obliczenia, a ponieważ każdy wątek będzie konkurującymi czasu procesora, nie wiadomo z wyprzedzeniem, jak długo potrwa dla wszystkich pięciu wyniki mają być obliczane. Dlatego każdego `Fibonacci` obiekt jest przekazywany wystąpienie <xref:System.Threading.ManualResetEvent> klasy podczas konstruowania. Każdy obiekt sygnalizuje obiektu podanego zdarzenia po obliczeniu zakończeniu, pozwalający głównemu wątkowi bloku wykonywania za pomocą <xref:System.Threading.WaitHandle.WaitAll%2A> aż do wszystkich pięciu `Fibonacci` obiekty zostały obliczone wynik. `Main` Metoda następnie wyświetla każdy `Fibonacci` wynik.
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Znajduje się środowisko uruchomieniowe języka wspólnego (CLR) i host nie obsługuje tej akcji.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Typ elementów <paramref name="state" />.</typeparam>
        <param name="callBack"><see cref="T:System.Action`1" /> Reprezentujący metodę do wykonania.</param>
        <param name="state">Obiekt zawierający dane do użycia przez metodę.</param>
        <param name="preferLocal">W przeciwieństwie do innych metod QueueUserWorkItem — najpierw exeucting w puli wątków lokalnych i nie puli wątków globalnego.</param>
        <summary>Kolejki metodę określone przez <see cref="T:System.Action`1" /> delegować do wykonania, a następnie dostarcza dane do użycia przez metodę. Metoda jest wykonywana po udostępnieniu wątku z puli wątków.</summary>
        <returns><see langword="true" /> Jeśli metoda pomyślnie znajduje się w kolejce; <see cref="T:System.NotSupportedException" /> jest generowany, jeśli element roboczy nie można umieścić w kolejce.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje delegata, która oczekuje na <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack"><see cref="T:System.Threading.WaitOrTimerCallback" /> Pełnomocnika do wywołania, gdy <paramref name="waitObject" /> zasygnalizowania parametru.</param>
        <param name="state">Obiekt, który jest przekazywany do obiektu delegowanego.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <paramref name="millisecondsTimeOutInterval" /> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <paramref name="millisecondsTimeOutInterval" /> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</param>
        <param name="executeOnlyOnce"><see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <paramref name="waitObject" /> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając całkowita 32-bitowych limitu czasu w milisekundach.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków. Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących czynności:  
  
-   Określony obiekt jest w sygnalizowanego stanu.  
  
-   Upłynie limit czasu.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>. Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacji oczekiwania jest wykonywane przez wątków z puli wątków. Delegat jest wykonywana przez wątek roboczy, gdy stan obiektu jest sygnalizowane lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.  
  
> [!IMPORTANT]
>  Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków. Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> z maksymalną liczbą 1.  
  
 Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.  
  
 Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcję, aby monitorowanie operacji oczekiwania zarejestrowane. W związku z tym, jeśli musisz użyć tego samego uchwytu macierzystego systemu operacyjnego w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt przy użyciu Win32 `DuplicateHandle` funkcji. Należy zwrócić uwagę, czy nie powinien impulsów przekazany obiekt zdarzenia <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania nie może wykryć, czy zdarzenie jest sygnalizowane, zanim zostanie zresetowane.  
  
 Przed zwróceniem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko w przypadku obiektu, którego sygnalizowanego stanu spowodowane warunek oczekiwania, które należy spełnić. Na przykład za pomocą jednej zmniejsza się liczba semafora.  
  
## <a name="version-information"></a>Informacje o wersji  
 Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody. We wcześniejszych wersjach nie są propagowane informacji o jednostce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack"><see cref="T:System.Threading.WaitOrTimerCallback" /> Pełnomocnika do wywołania, gdy <paramref name="waitObject" /> zasygnalizowania parametru.</param>
        <param name="state">Obiekt przekazany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <paramref name="millisecondsTimeOutInterval" /> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <paramref name="millisecondsTimeOutInterval" /> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</param>
        <param name="executeOnlyOnce"><see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <paramref name="waitObject" /> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając całkowita 64-bitowych limitu czasu w milisekundach.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków. Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących czynności:  
  
-   Określony obiekt jest w sygnalizowanego stanu.  
  
-   Upłynie limit czasu.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>. Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacji oczekiwania jest wykonywane przez wątków z puli wątków. Delegat jest wykonywana przez wątek roboczy, gdy stan obiektu jest sygnalizowane lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.  
  
> [!IMPORTANT]
>  Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków. Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> z maksymalną liczbą 1.  
  
 Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.  
  
 Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcję, aby monitorowanie operacji oczekiwania zarejestrowane. W związku z tym, jeśli musisz użyć tego samego uchwytu macierzystego systemu operacyjnego w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt przy użyciu Win32 `DuplicateHandle` funkcji. Należy zwrócić uwagę, czy nie powinien impulsów przekazany obiekt zdarzenia <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania nie może wykryć, czy zdarzenie jest sygnalizowane, zanim zostanie zresetowane.  
  
 Przed zwróceniem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko w przypadku obiektu, którego sygnalizowanego stanu spowodowane warunek oczekiwania, które należy spełnić. Na przykład za pomocą jednej zmniejsza się liczba semafora.  
  
## <a name="version-information"></a>Informacje o wersji  
 Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody. We wcześniejszych wersjach nie są propagowane informacji o jednostce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack"><see cref="T:System.Threading.WaitOrTimerCallback" /> Pełnomocnika do wywołania, gdy <paramref name="waitObject" /> zasygnalizowania parametru.</param>
        <param name="state">Obiekt przekazany do delegata.</param>
        <param name="timeout">Limit czasu, reprezentowane przez <see cref="T:System.TimeSpan" />. Jeśli <paramref name="timeout" /> jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <paramref name="timeout" /> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</param>
        <param name="executeOnlyOnce"><see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <paramref name="waitObject" /> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określanie <see cref="T:System.TimeSpan" /> wartość limitu czasu.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków. Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących czynności:  
  
-   Określony obiekt jest w sygnalizowanego stanu.  
  
-   Upłynie limit czasu.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>. Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacji oczekiwania jest wykonywane przez wątków z puli wątków. Delegat jest wykonywana przez wątek roboczy, gdy stan obiektu jest sygnalizowane lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.  
  
> [!IMPORTANT]
>  Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków. Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> z maksymalną liczbą 1.  
  
 Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.  
  
 Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcję, aby monitorowanie operacji oczekiwania zarejestrowane. W związku z tym, jeśli musisz użyć tego samego uchwytu macierzystego systemu operacyjnego w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt przy użyciu Win32 `DuplicateHandle` funkcji. Należy zwrócić uwagę, czy nie powinien impulsów przekazany obiekt zdarzenia <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania nie może wykryć, czy zdarzenie jest sygnalizowane, zanim zostanie zresetowane.  
  
 Przed zwróceniem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko w przypadku obiektu, którego sygnalizowanego stanu spowodowane warunek oczekiwania, które należy spełnić. Na przykład za pomocą jednej zmniejsza się liczba semafora.  
  
## <a name="version-information"></a>Informacje o wersji  
 Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody. We wcześniejszych wersjach nie są propagowane informacji o jednostce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> Parametr jest mniejsza niż -1.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="timeout" /> Parametru jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack"><see cref="T:System.Threading.WaitOrTimerCallback" /> Pełnomocnika do wywołania, gdy <paramref name="waitObject" /> zasygnalizowania parametru.</param>
        <param name="state">Obiekt przekazany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <paramref name="millisecondsTimeOutInterval" /> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <paramref name="millisecondsTimeOutInterval" /> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</param>
        <param name="executeOnlyOnce"><see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <paramref name="waitObject" /> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 32-bitowej nieoznaczonej liczby całkowitej limitu czasu w milisekundach.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Można anulować operacji oczekiwania zarejestrowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków. Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących czynności:  
  
-   Określony obiekt jest w sygnalizowanego stanu.  
  
-   Upłynie limit czasu.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>. Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacji oczekiwania jest wykonywane przez wątków z puli wątków. Delegat jest wykonywana przez wątek roboczy, gdy stan obiektu jest sygnalizowane lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.  
  
> [!IMPORTANT]
>  Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków. Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> z maksymalną liczbą 1.  
  
 Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.  
  
 Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcję, aby monitorowanie operacji oczekiwania zarejestrowane. W związku z tym, jeśli musisz użyć tego samego uchwytu macierzystego systemu operacyjnego w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt przy użyciu Win32 `DuplicateHandle` funkcji. Należy zwrócić uwagę, czy nie powinien impulsów przekazany obiekt zdarzenia <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania nie może wykryć, czy zdarzenie jest sygnalizowane, zanim zostanie zresetowane.  
  
 Przed zwróceniem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko w przypadku obiektu, którego sygnalizowanego stanu spowodowane warunek oczekiwania, które należy spełnić. Na przykład za pomocą jednej zmniejsza się liczba semafora.  
  
## <a name="version-information"></a>Informacje o wersji  
 Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody. We wcześniejszych wersjach nie są propagowane informacji o jednostce.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody do wykonania metodą określonego wywołania zwrotnego, gdy jest sygnalizowane dojście oczekiwania określony. W tym przykładzie, metody wywołania zwrotnego jest `WaitProc`, a to dojście oczekiwania <xref:System.Threading.AutoResetEvent>.  
  
 W przykładzie zdefiniowano `TaskInfo` klasy do przechowywania informacji, który jest przekazywany do wywołania zwrotnego, podczas wykonywania. W przykładzie jest tworzony `TaskInfo` obiektu, a następnie przypisuje go niektóre dane ciągu. <xref:System.Threading.RegisteredWaitHandle> Zwracanym przez <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody jest przypisany do `Handle` pole `TaskInfo` obiekt metody wywołania zwrotnego ma dostęp do <xref:System.Threading.RegisteredWaitHandle>.  
  
 Oprócz określenia `TaskInfo` jako obiekt do przekazania do metody wywołania zwrotnego, wywołanie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> określa metodę <xref:System.Threading.AutoResetEvent> , zadanie będzie oczekiwać, <xref:System.Threading.WaitOrTimerCallback> delegata, który reprezentuje `WaitProc` metody wywołania zwrotnego co drugi interwał limitu czasu, a wiele wywołań zwrotnych.  
  
 Gdy sygnały w głównym wątku <xref:System.Threading.AutoResetEvent> przez wywołanie jego <xref:System.Threading.EventWaitHandle.Set%2A> metody <xref:System.Threading.WaitOrTimerCallback> obiekt delegowany jest wywoływany. `WaitProc` Testy metoda <xref:System.Threading.RegisteredWaitHandle> do określenia, czy upłynął limit czasu. Jeśli wywołano wywołanie zwrotne, ponieważ zostało zasygnalizowane dojście oczekiwania, `WaitProc` wyrejestrowuje metoda <xref:System.Threading.RegisteredWaitHandle>, zatrzymanie dodatkowe wywołania zwrotne. W przypadku przekroczenia limitu czasu zadanie będzie nadal czekać. `WaitProc` Metoda kończy się wydrukować komunikat do konsoli.  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Maksymalna liczba wątków w puli wątków.</param>
        <param name="completionPortThreads">Maksymalna liczba asynchronicznego wątków We/Wy w puli wątków.</param>
        <summary>Ustawia liczbę żądań w puli wątków, które mogą być wykonywane jednocześnie. Wszystkie żądania powyżej tego numeru pozostaną w kolejce, dopóki wątków z puli wątków stają się dostępne.</summary>
        <returns><see langword="true" /> Jeśli ta zmiana jest kończy się pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można ustawić maksymalną liczbę wątków roboczych lub wątków zakończenia operacji We/Wy na liczbę mniejszą niż liczba procesorów w komputerze. Aby określić liczbę procesorów są obecne, pobrać wartość <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> właściwości. Ponadto nie można ustawić maksymalną liczbę wątków roboczych lub wątków ukończenia operacji We/Wy na liczbę mniejsze niż minimalne odpowiednią liczbę wątków roboczych lub wątki zakończenia operacji We/Wy. Aby określić rozmiar puli wątków minimalne, należy wywołać <xref:System.Threading.ThreadPool.GetMinThreads%2A> metody.  
  
 Jeśli znajduje się środowisko uruchomieniowe języka wspólnego, np. przez Internet Information Services (IIS) lub SQL Server host może ograniczyć lub uniemożliwić zmiany rozmiaru puli wątków.  
  
 Zmiana maksymalnej liczby wątków w puli wątków, należy zachować ostrożność. Podczas organizowanych kodu, zmiany mogą się niekorzystny wpływ na bibliotek kodu, których używasz.  
  
 Ustawienie zbyt duży rozmiar puli wątków może spowodować problemy z wydajnością. Jeśli zbyt wiele wątków, są wykonywane w tym samym czasie, przełączanie zadań obciążenie staje się ważnym czynnikiem.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość kontrolować wątki. Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Minimalna liczba wątków roboczych, tworzonych w puli wątków na żądanie.</param>
        <param name="completionPortThreads">Minimalna liczba asynchronicznych operacji We/Wy wątków, tworzonych w puli wątków na żądanie.</param>
        <summary>Ustawia minimalną liczbę wątków, tworzonych w puli wątków na żądanie, nowych żądań, przed przełączeniem na algorytm zarządzania wątku tworzenia i niszczenia.</summary>
        <returns><see langword="true" /> Jeśli ta zmiana jest kończy się pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puli wątków zapewnia nowych wątków roboczych lub wątków do ukończenia operacji We/Wy na żądanie, dopóki nie zostanie osiągnięty co najmniej dla każdej kategorii. Gdy zostanie osiągnięta minimalny, puli wątków można utworzyć dodatkowe wątki w danej kategorii lub poczekaj na ukończenie niektóre zadania. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], puli wątków tworzy i niszczy wątki w celu zoptymalizowania przepływności, która jest zdefiniowana jako liczbę zadań, kończące się na jednostkę czasu. Zbyt mało wątków może nie mieć optymalnego wykorzystania dostępnych zasobów, natomiast zbyt wiele wątków może zwiększyć rywalizacji o zasoby.  
  
 Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków z puli wątków może spadną poniżej wartości minimalnej.  
  
 Jeśli określisz liczbę ujemną lub podana liczba większa niż maksymalna liczba aktywnych wątków z puli wątków (uzyskanych przy użyciu <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> zwraca `false` i nie jest zmieniany minimalnej wartości.  
  
> [!CAUTION]
>  Minimalna liczba wątków domyślnie do liczby procesorów w systemie. Możesz użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodę, aby zwiększyć minimalną ofthreads liczb. Jednak niepotrzebnie zwiększenie tych wartości może spowodować problemy z wydajnością. Jeśli zbyt wiele zadań jest uruchomiona w tym samym czasie, wszystkie z nich może pojawić się wolno. W większości przypadków puli wątków będą działać lepiej z własną algorytm wątki alokacji. Zmniejszenie minimum, aby była ona mniejsza niż liczba procesorów również może obniżyć wydajność.  
  
   
  
## Examples  
 Poniższy przykład Ustawia minimalną liczbę wątków roboczych na cztery i zachowuje oryginalnej wartości minimalna liczba wątków uzupełniania w usłudze asynchronicznych operacji We/Wy.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość kontrolować wątki. Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="overlapped"><see cref="T:System.Threading.NativeOverlapped" /> Struktury do kolejki.</param>
        <summary>Umieszcza w kolejce nakładające się operacji We/Wy do wykonania.</summary>
        <returns><see langword="true" /> Jeśli operacja pomyślnie zostało umieszczone w kolejce do portu ukończenia operacji We/Wy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacji o używaniu natywny Win32 pokrywający się operacji We/Wy, zobacz <xref:System.Threading.Overlapped> klasy, <xref:System.Threading.NativeOverlapped> struktury i `OVERLAPPED` struktury w zestawie SDK platformy Win32.  
  
> [!CAUTION]
>  Za pomocą <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> metoda może przypadkowo otwierają lukę w zabezpieczeniach. Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, stosu wątku z puli wątków nie ma kontekście rzeczywistych obiektów wywołujących. Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callBack">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący pełnomocnika do wywołania, gdy wątków w puli wątków przejmuje elementu roboczego.</param>
        <param name="state">Obiekt, który jest przekazywany do obiektu delegowanego, gdy obsługiwany z puli wątków.</param>
        <summary>Kolejki określonego delegata do puli wątków, ale nie propaguje stosu wywołującego do wątku roboczego.</summary>
        <returns><see langword="true" /> Jeśli metoda się powiedzie; <see cref="T:System.OutOfMemoryException" /> jest generowany, jeśli element roboczy nie można umieścić w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> nie propaguje stosu wywołującego do wątku roboczego. Dzięki temu kod utratę wywołania stosu, a tym samym do podniesienia swoich uprawnień zabezpieczeń.  
  
> [!CAUTION]
>  Za pomocą <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> może przypadkowo otwierają lukę w zabezpieczeniach. Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, stosu wątku z puli wątków nie będzie miał kontekście rzeczywistych obiektów wywołujących. Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ApplicationException">Wystąpił stan braku pamięci.</exception>
        <exception cref="T:System.OutOfMemoryException">Element roboczy nie można umieścić w kolejce.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Typ elementów <paramref name="state" />.</typeparam>
        <param name="callBack">Delegat metody reprezentująca do wykonania.</param>
        <param name="state">Obiekt zawierający dane do użycia przez metodę.</param>
        <param name="preferLocal">`true` do wykonania w puli wątków lokalnych; `false` do wykonania w puli wątków globalnego.</param>
        <summary>Kolejki metodę określone przez <see cref="T:System.Action`1" /> delegować do wykonania, a następnie określa obiekt zawierający dane do użycia przez metodę. Metoda jest wykonywana po udostępnieniu wątku z puli wątków.</summary>
        <returns><see langword="true" /> Jeśli metoda pomyślnie znajduje się w kolejce; <see cref="T:System.NotSupportedException" /> jest generowany, jeśli element roboczy nie można umieścić w kolejce.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, ale nie propaguje stosu wywołującego do wątku roboczego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Pełnomocnika do wywołania, gdy <paramref name="waitObject" /> zasygnalizowania parametru.</param>
        <param name="state">Obiekt, który jest przekazywany do obiektu delegowanego.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <paramref name="millisecondsTimeOutInterval" /> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <paramref name="millisecondsTimeOutInterval" /> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</param>
        <param name="executeOnlyOnce"><see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <paramref name="waitObject" /> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, za pomocą całkowita 32-bitowych dla limitu czasu w milisekundach. Ta metoda nie propaguje stosu wywołującego do wątku roboczego.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji oczekiwania zarejestrowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołującego do wątku roboczego. Dzięki temu kod utratę wywołania stosu, a tym samym do podniesienia swoich uprawnień zabezpieczeń.  
  
> [!CAUTION]
>  Za pomocą <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może przypadkowo otwierają lukę w zabezpieczeniach. Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku z puli wątków nie będzie miał kontekście rzeczywistych obiektów wywołujących. Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.  
  
 Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.  
  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Pełnomocnika do wywołania, gdy <paramref name="waitObject" /> zasygnalizowania parametru.</param>
        <param name="state">Obiekt, który jest przekazywany do obiektu delegowanego.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <paramref name="millisecondsTimeOutInterval" /> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <paramref name="millisecondsTimeOutInterval" /> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</param>
        <param name="executeOnlyOnce"><see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <paramref name="waitObject" /> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając całkowita 64-bitowych limitu czasu w milisekundach. Ta metoda nie propaguje stosu wywołującego do wątku roboczego.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji oczekiwania zarejestrowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołującego do wątku roboczego. Dzięki temu kod utratę wywołania stosu, a tym samym do podniesienia swoich uprawnień zabezpieczeń.  
  
> [!CAUTION]
>  Za pomocą <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może przypadkowo otwierają lukę w zabezpieczeniach. Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku z puli wątków nie będzie miał kontekście rzeczywistych obiektów wywołujących. Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.  
  
 Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.  
  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Pełnomocnika do wywołania, gdy <paramref name="waitObject" /> zasygnalizowania parametru.</param>
        <param name="state">Obiekt, który jest przekazywany do obiektu delegowanego.</param>
        <param name="timeout">Limit czasu, reprezentowane przez <see cref="T:System.TimeSpan" />. Jeśli <paramref name="timeout" /> jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <paramref name="timeout" /> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</param>
        <param name="executeOnlyOnce"><see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <paramref name="waitObject" /> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określanie <see cref="T:System.TimeSpan" /> wartość limitu czasu. Ta metoda nie propaguje stosu wywołującego do wątku roboczego.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji oczekiwania zarejestrowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołującego do wątku roboczego. Dzięki temu kod utratę wywołania stosu, a tym samym do podniesienia swoich uprawnień zabezpieczeń.  
  
> [!CAUTION]
>  Za pomocą <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może przypadkowo otwierają lukę w zabezpieczeniach. Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku z puli wątków nie będzie miał kontekście rzeczywistych obiektów wywołujących. Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.  
  
 Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.  
  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> Parametr jest mniejsza niż -1.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="timeout" /> Parametru jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Pełnomocnika do wywołania, gdy <paramref name="waitObject" /> zasygnalizowania parametru.</param>
        <param name="state">Obiekt, który jest przekazywany do obiektu delegowanego.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <paramref name="millisecondsTimeOutInterval" /> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <paramref name="millisecondsTimeOutInterval" /> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</param>
        <param name="executeOnlyOnce"><see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <paramref name="waitObject" /> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 32-bitowej nieoznaczonej liczby całkowitej limitu czasu w milisekundach. Ta metoda nie propaguje stosu wywołującego do wątku roboczego.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji oczekiwania zarejestrowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołującego do wątku roboczego. Dzięki temu kod utratę wywołania stosu, a tym samym do podniesienia swoich uprawnień zabezpieczeń.  
  
> [!CAUTION]
>  Za pomocą <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może przypadkowo otwierają lukę w zabezpieczeniach. Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku z puli wątków nie będzie miał kontekście rzeczywistych obiektów wywołujących. Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.  
  
 Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.  
  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
  </Members>
</Type>
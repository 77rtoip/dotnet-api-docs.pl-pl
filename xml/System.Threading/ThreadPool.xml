<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7542193821586bc0241b3b3025f0ccf05510af2f" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609238" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="60f8b-101">Zawiera pulę wątków, które może służyć do wykonywania zadań, Publikuj elementy robocze, Przetwarzanie asynchroniczne We/Wy, Oczekiwanie w imieniu innych wątków i przetworzyć czasomierzy.</span>
      <span class="sxs-lookup">
        <span data-stu-id="60f8b-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-102">Wiele aplikacji Utwórz wątki, które możesz wydać dużym stopniem czas w stanie uśpiony, oczekiwanie na zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="60f8b-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="60f8b-103">Inne wątki mogą przejść w stan uśpiony tylko do wznowione, okresowo sondować zmiany lub zaktualizować informacje o stanie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="60f8b-104">Pula wątków umożliwia wątków bardziej wydajnie, zapewniając aplikację z pulą wątków roboczych, które są zarządzane przez system.</span><span class="sxs-lookup"><span data-stu-id="60f8b-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="60f8b-105">Następujące operacje, które używają wątków z puli wątków:</span><span class="sxs-lookup"><span data-stu-id="60f8b-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="60f8b-106">Po utworzeniu <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> obiektu w celu wykonania niektórych zadań asynchronicznie, domyślnie zadanie jest zaplanowane do uruchomienia na wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="60f8b-107">Czasomierze asynchronicznego użyć puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="60f8b-108">Wątków z puli wątków wykonania wywołania zwrotne z <xref:System.Threading.Timer?displayProperty=nameWithType> klasy i wywoływanie zdarzeń od <xref:System.Timers.Timer?displayProperty=nameWithType> klasy.</span><span class="sxs-lookup"><span data-stu-id="60f8b-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="60f8b-109">Korzystając z uchwytami oczekiwania zarejestrowanych wątku systemu monitoruje stan dojść oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="60f8b-110">Po ukończeniu operacji oczekiwania wątku roboczego z puli wątków wykonuje odpowiedniej funkcji wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="60f8b-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="60f8b-111">Gdy wywołujesz <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metoda to metoda wykonanie na wątku z puli wątków w kolejce.</span><span class="sxs-lookup"><span data-stu-id="60f8b-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="60f8b-112">Można to zrobić, przekazując metody <xref:System.Threading.WaitCallback> delegować.</span><span class="sxs-lookup"><span data-stu-id="60f8b-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="60f8b-113">Pełnomocnik ma podpis</span><span class="sxs-lookup"><span data-stu-id="60f8b-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="60f8b-114">gdzie `state` jest obiektem, który zawiera dane używane przez delegata.</span><span class="sxs-lookup"><span data-stu-id="60f8b-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="60f8b-115">Rzeczywiste dane mogą być przekazywane do obiektu delegowanego, wywołując <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60f8b-116">Wątki w puli wątków zarządzanych są wątków w tle.</span><span class="sxs-lookup"><span data-stu-id="60f8b-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="60f8b-117">Oznacza to, że ich <xref:System.Threading.Thread.IsBackground%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="60f8b-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="60f8b-118">Oznacza to, że <xref:System.Threading.ThreadPool> wątku nie zachowa aplikację działającą po zamknięciu wszystkie wątki pierwszego planu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="60f8b-119">Gdy w puli wątków ponownie używa wątku, czyści dane w pamięci lokalnej wątku lub pola, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="60f8b-120">W związku z tym, gdy metoda sprawdza, czy lokalny magazyn wątków lub pola, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutu wartości znajdzie może pozostać za pośrednictwem z wcześniejszego użycia wątek puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="60f8b-121">Możesz również dodawać do kolejki elementów roboczych, które nie są związane z operacji oczekiwania, do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="60f8b-122">Aby zażądać obsługiwania przez wątek w puli wątków o element roboczy, należy wywołać <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="60f8b-123">Ta metoda przyjmuje jako parametr to odwołanie do metody lub delegata, która zostanie wywołana przez wątek wybrane z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="60f8b-124">Nie ma możliwości anulowania elementu roboczego po zostało umieszczone w kolejce.</span><span class="sxs-lookup"><span data-stu-id="60f8b-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="60f8b-125">Czasomierze kolejki czasomierza i oczekiwania zarejestrowanych operacji należy również użyć puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="60f8b-126">Ich funkcji wywołania zwrotnego są umieszczane w kolejce puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="60f8b-127">Istnieje jedna pula wątków na proces.</span><span class="sxs-lookup"><span data-stu-id="60f8b-127">There is one thread pool per process.</span></span> <span data-ttu-id="60f8b-128">Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], domyślny rozmiar puli wątków dla procesu zależy od wielu czynników, takich jak rozmiar wirtualnej przestrzeni adresowej.</span><span class="sxs-lookup"><span data-stu-id="60f8b-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="60f8b-129">Proces może wywołać <xref:System.Threading.ThreadPool.GetMaxThreads%2A> metodę pozwala ustalić liczbę wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="60f8b-130">Liczba wątków w puli wątków można zmienić za pomocą <xref:System.Threading.ThreadPool.SetMaxThreads%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="60f8b-131">Każdy wątek korzysta z domyślnego rozmiaru stosu i uruchamia wyzwalacz w priorytet domyślny.</span><span class="sxs-lookup"><span data-stu-id="60f8b-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60f8b-132">Kod niezarządzany, który jest hostem środowiska .NET Framework można zmienić rozmiar puli wątków za pomocą `CorSetMaxThreads` funkcji, zdefiniowane w pliku mscoree.h.</span><span class="sxs-lookup"><span data-stu-id="60f8b-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="60f8b-133">Puli wątków zapewnia nowych wątków roboczych lub wątków do ukończenia operacji We/Wy na żądanie, dopóki nie zostanie osiągnięty co najmniej dla każdej kategorii.</span><span class="sxs-lookup"><span data-stu-id="60f8b-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="60f8b-134">Po osiągnięciu co najmniej puli wątków można utworzyć dodatkowe wątki w danej kategorii lub poczekaj na ukończenie niektóre zadania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="60f8b-135">Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], puli wątków tworzy i niszczy wątków roboczych w celu zoptymalizowania przepływności, która jest zdefiniowana jako liczbę zadań, kończące się na jednostkę czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="60f8b-136">Zbyt mało wątków może nie mieć optymalnego wykorzystania dostępnych zasobów, natomiast zbyt wiele wątków może zwiększyć rywalizacji o zasoby.</span><span class="sxs-lookup"><span data-stu-id="60f8b-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60f8b-137">Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków z puli wątków może spadną poniżej wartości minimalnej.</span><span class="sxs-lookup"><span data-stu-id="60f8b-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="60f8b-138">Możesz użyć <xref:System.Threading.ThreadPool.GetMinThreads%2A> metody uzyskiwania tych wartości minimalnej.</span><span class="sxs-lookup"><span data-stu-id="60f8b-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="60f8b-139">Możesz użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodę, aby zwiększyć minimalną liczbę wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="60f8b-140">Jednak niepotrzebnie zwiększenie tych wartości może spowodować problemy z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="60f8b-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="60f8b-141">Jeśli zbyt wiele zadań jest uruchomiona w tym samym czasie, wszystkie z nich może pojawić się wolno.</span><span class="sxs-lookup"><span data-stu-id="60f8b-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="60f8b-142">W większości przypadków puli wątków będą działać lepiej z własną algorytm wątki alokacji.</span><span class="sxs-lookup"><span data-stu-id="60f8b-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60f8b-143">W poniższym przykładzie wątku głównego aplikacji kolejki metodę o nazwie `ThreadProc` można wykonać na wątku z puli wątków, sen dla jednej sekundy, a następnie zamyka.</span><span class="sxs-lookup"><span data-stu-id="60f8b-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="60f8b-144">`ThreadProc` Metoda po prostu wyświetla komunikat.</span><span class="sxs-lookup"><span data-stu-id="60f8b-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="60f8b-145">Jeśli komentarz wystąpi poza wywołanie <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody główny wątek kończy działanie zanim metoda zostanie uruchomiona w wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="60f8b-146">Korzysta z puli wątków wątków w tle, które nie jest przechowywana aplikacja była uruchomiona, jeśli wszystkie wątki pierwszoplanowe zostać zakończony.</span><span class="sxs-lookup"><span data-stu-id="60f8b-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="60f8b-147">(Jest to prosty przykład sytuacja wyścigu).</span><span class="sxs-lookup"><span data-stu-id="60f8b-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="60f8b-148">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="60f8b-148">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="60f8b-149">Wiąże dojście systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-149">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="60f8b-150">
            <see cref="T:System.IntPtr" /> Przechowuje dojście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-150">An <see cref="T:System.IntPtr" /> that holds the handle.</span>
          </span>
          <span data-ttu-id="60f8b-151">Dojście musi otwarte dla nakładające się operacji We/Wy w niezarządzanym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-151">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-152">Wiąże dojście systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-152">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-153">
            <see langword="true" /> Jeśli uchwyt jest powiązana; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-153">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="60f8b-154">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-154">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="60f8b-155">Aby uzyskać możliwość wywoływania niezarządzanego kodu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-155">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="60f8b-156">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-156">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="60f8b-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> przechowuje dojście systemu operacyjnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span>
          </span>
          <span data-ttu-id="60f8b-158">Dojście musi otwarte dla nakładające się operacji We/Wy w niezarządzanym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-158">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-159">Wiąże dojście systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-159">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-160">
            <see langword="true" /> Jeśli uchwyt jest powiązana; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-160">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-161">`osHandle` Parametr powinien być <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, która jest pochodną abstrakcyjnej <xref:System.Runtime.InteropServices.SafeHandle> klasy.</span><span class="sxs-lookup"><span data-stu-id="60f8b-161">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60f8b-162">
            <paramref name="osHandle" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-162">
              <paramref name="osHandle" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="60f8b-163">Aby uzyskać możliwość wywoływania niezarządzanego kodu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-163">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="60f8b-164">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-164">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="60f8b-165">Liczba wątków roboczych dostępne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-165">The number of available worker threads.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="60f8b-166">Liczba dostępnych asynchronicznego wątków We/Wy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-166">The number of available asynchronous I/O threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-167">Pobiera różnicę między maksymalną liczbę wątków z puli wątków zwrócony przez <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> metoda i liczba aktualnie aktywne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-167">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-168">Gdy <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> zwraca zmiennej określonej przez `workerThreads` zawiera liczbę wątków roboczych dodatkowe, które mogą być uruchamiane, a zmienna określona przez `completionPortThreads` zawiera liczbę dodatkowych asynchronicznego wątków We/Wy, które mogą być pracę.</span><span class="sxs-lookup"><span data-stu-id="60f8b-168">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="60f8b-169">W przypadku nie ma dostępnych wątków żądania puli wątków dodatkowe pozostają w kolejce do momentu wątków z puli wątków stają się dostępne.</span><span class="sxs-lookup"><span data-stu-id="60f8b-169">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60f8b-170">Poniższy przykład wyświetla liczbę wątków roboczych i dostępne wątki We/Wy po uruchomieniu prostą aplikację.</span><span class="sxs-lookup"><span data-stu-id="60f8b-170">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="60f8b-171">Maksymalna liczba wątków w puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-171">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="60f8b-172">Maksymalna liczba asynchronicznego wątków We/Wy w puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-172">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-173">Pobiera liczbę żądań w puli wątków, które mogą być wykonywane jednocześnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-173">Retrieves the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="60f8b-174">Wszystkie żądania powyżej tego numeru pozostaną w kolejce, dopóki wątków z puli wątków stają się dostępne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-174">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-175">Gdy <xref:System.Threading.ThreadPool.GetMaxThreads%2A> zwraca zmiennej określonej przez `workerThreads` zawiera maksymalną liczbę wątków roboczych dozwolonych w puli wątków i zmiennej określonej przez `completionPortThreads` zawiera maksymalną liczbę asynchronicznego wątków We/Wy w Pula wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-175">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="60f8b-176">Możesz użyć <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> metodę pozwala ustalić rzeczywista liczba wątków w puli wątków w danym momencie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-176">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="60f8b-177">Możesz użyć <xref:System.Threading.ThreadPool.SetMaxThreads%2A> można ustawić maksymalną liczbę wątków roboczych i asynchronicznych operacji We/Wy wątków w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-177">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="60f8b-178">Możesz dodawać do kolejki, jak wiele wątków, żądań w puli pamięci systemowej zezwala na to.</span><span class="sxs-lookup"><span data-stu-id="60f8b-178">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="60f8b-179">W przypadku żądań więcej niż wątków z puli wątków dodatkowych żądań pozostają w kolejce do momentu wątków z puli wątków stają się dostępne.</span><span class="sxs-lookup"><span data-stu-id="60f8b-179">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60f8b-180">Poniższy przykład kodu pokazuje, jak pobrać liczbę maksymalną i dostępna liczba wątków w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-180">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="60f8b-181">Element roboczy znajduje się w kolejce używającej `FileStream` do asynchronicznego zapisu do dwóch plików.</span><span class="sxs-lookup"><span data-stu-id="60f8b-181">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="60f8b-182">Metody wywołania zwrotnego jest mierzony nakładania się.</span><span class="sxs-lookup"><span data-stu-id="60f8b-182">The callback methods are timed to overlap.</span></span> <span data-ttu-id="60f8b-183">Wątek roboczy obsługuje element roboczy i, w zależności od szybkości i liczby procesorów w komputerze, co najmniej dwóch wątków portu zakończenia obsługi operacji zapisu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-183">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="60f8b-184">Po powrocie z tej metody zawiera minimalną liczbę wątków roboczych, tworzonych w puli wątków na żądanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-184">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="60f8b-185">Po powrocie z tej metody zawiera minimalna liczba asynchronicznego wątków We/Wy, tworzonych w puli wątków na żądanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-185">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-186">Pobiera minimalną liczbę wątków, tworzonych w puli wątków na żądanie, gdy zostaną wprowadzone nowe żądania, przed przełączeniem na algorytm do zarządzania tworzeniem wątku i niszczeniem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-186">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-187">Puli wątków zapewnia nowych wątków roboczych lub wątków do ukończenia operacji We/Wy na żądanie, dopóki nie zostanie osiągnięty co najmniej dla każdej kategorii.</span><span class="sxs-lookup"><span data-stu-id="60f8b-187">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="60f8b-188">Minimalna liczba wątków domyślnie do liczby procesorów w systemie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-188">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="60f8b-189">Gdy zostanie osiągnięta minimalny, puli wątków można utworzyć dodatkowe wątki w danej kategorii lub poczekaj na ukończenie niektóre zadania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-189">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="60f8b-190">Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], puli wątków tworzy i niszczy wątki w celu zoptymalizowania przepływności, która jest zdefiniowana jako liczbę zadań, kończące się na jednostkę czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-190">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="60f8b-191">Zbyt mało wątków może nie mieć optymalnego wykorzystania dostępnych zasobów, natomiast zbyt wiele wątków może zwiększyć rywalizacji o zasoby.</span><span class="sxs-lookup"><span data-stu-id="60f8b-191">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60f8b-192">Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków z puli wątków może spadną poniżej wartości minimalnej.</span><span class="sxs-lookup"><span data-stu-id="60f8b-192">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60f8b-193">Poniższy przykład Ustawia minimalną liczbę wątków roboczych na cztery i zachowuje oryginalnej wartości minimalna liczba wątków uzupełniania w usłudze asynchronicznych operacji We/Wy.</span><span class="sxs-lookup"><span data-stu-id="60f8b-193">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="60f8b-194">Umieszcza w kolejce metody do wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-194">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="60f8b-195">Metoda jest wykonywana po udostępnieniu wątku z puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-195">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="60f8b-196">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący metodę do wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-196">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-197">Umieszcza w kolejce metody do wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-197">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="60f8b-198">Metoda jest wykonywana po udostępnieniu wątku z puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-198">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-199">
            <see langword="true" /> Jeśli metoda pomyślnie znajduje się w kolejce; <see cref="T:System.NotSupportedException" /> jest generowany, jeśli element roboczy nie można umieścić w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-199">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-200">Możesz umieścić dane wymagane przez umieszczonych w kolejce metody pól wystąpienia klasy, w którym metoda jest zdefiniowany, lub możesz użyć <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> przeciążenie, które akceptuje obiekt zawierający niezbędnych danych.</span><span class="sxs-lookup"><span data-stu-id="60f8b-200">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60f8b-201">Użytkowników programu Visual Basic można pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu użyj `AddressOf` operator przy przekazywaniu Metoda wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="60f8b-201">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="60f8b-202">Visual Basic automatycznie wywołuje konstruktor poprawnym delegacie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-202">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="60f8b-203">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="60f8b-203">Version Information</span></span>  
 <span data-ttu-id="60f8b-204">W .NET Framework w wersji 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-204">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="60f8b-205">We wcześniejszych wersjach nie są propagowane informacji o jednostce.</span><span class="sxs-lookup"><span data-stu-id="60f8b-205">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60f8b-206">W poniższym przykładzie użyto <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> przeciążenia metody do kolejki zadań, która jest reprezentowana przez `ThreadProc` metod w celu wykonania, gdy wątek stanie się dostępny.</span><span class="sxs-lookup"><span data-stu-id="60f8b-206">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="60f8b-207">Nie informacji o zadaniu jest dostarczany za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="60f8b-207">No task information is supplied with this overload.</span></span> <span data-ttu-id="60f8b-208">W związku z tym, informacje, które są dostępne dla `ThreadProc` metoda jest ograniczona do obiektu, którego należy metoda.</span><span class="sxs-lookup"><span data-stu-id="60f8b-208">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60f8b-209">
            <paramref name="callBack" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-209">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="60f8b-210">Znajduje się środowisko uruchomieniowe języka wspólnego (CLR) i host nie obsługuje tej akcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-210">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="60f8b-211">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący metodę do wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-211">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60f8b-212">Obiekt zawierający dane do użycia przez metodę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-212">An object containing data to be used by the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-213">Kolejki metodę wykonywania i określa obiekt zawierający dane do użycia przez metodę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-213">Queues a method for execution, and specifies an object containing data to be used by the method.</span>
          </span>
          <span data-ttu-id="60f8b-214">Metoda jest wykonywana po udostępnieniu wątku z puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-214">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-215">
            <see langword="true" /> Jeśli metoda pomyślnie znajduje się w kolejce; <see cref="T:System.NotSupportedException" /> jest generowany, jeśli element roboczy nie można umieścić w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-215">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-216">Jeśli metoda wywołania zwrotnego wymaga złożonych danych, można zdefiniować klasę zawierającą dane.</span><span class="sxs-lookup"><span data-stu-id="60f8b-216">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60f8b-217">Użytkowników programu Visual Basic można pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu użyj `AddressOf` operator przy przekazywaniu Metoda wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="60f8b-217">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="60f8b-218">Visual Basic automatycznie wywołuje konstruktor poprawnym delegacie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-218">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="60f8b-219">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="60f8b-219">Version Information</span></span>  
 <span data-ttu-id="60f8b-220">W .NET Framework w wersji 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-220">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="60f8b-221">We wcześniejszych wersjach nie są propagowane informacji o jednostce.</span><span class="sxs-lookup"><span data-stu-id="60f8b-221">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60f8b-222">Poniższy przykład pokazuje, jak utworzyć obiekt, który zawiera informacje o zadaniu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-222">The following example shows how to create an object that contains task information.</span></span> <span data-ttu-id="60f8b-223">Ilustruje też sposób przekazywania obiektu do zadania, które znajduje się w kolejce do wykonania w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-223">It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="60f8b-224">Znajduje się środowisko uruchomieniowe języka wspólnego (CLR) i host nie obsługuje tej akcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-224">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60f8b-225">
            <paramref name="callBack" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-225">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="60f8b-226">Rejestruje delegata, która oczekuje na <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-226">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="60f8b-227">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-227">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="60f8b-228">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-228">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="60f8b-229">
            <see cref="T:System.Threading.WaitOrTimerCallback" /> Pełnomocnika do wywołania, gdy <c>waitObject</c> zasygnalizowania parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-229">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60f8b-230">Obiekt, który jest przekazywany do obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-230">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="60f8b-231">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-231">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="60f8b-232">Jeśli <c>millisecondsTimeOutInterval</c> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-232">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="60f8b-233">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-233">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="60f8b-234">
            <see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-234">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-235">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając całkowita 32-bitowych limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-235">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-236">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-236">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-237">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-237">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="60f8b-238">Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="60f8b-238">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="60f8b-239">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-239">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="60f8b-240"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-240">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="60f8b-241">Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="60f8b-241">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="60f8b-242">Określony obiekt jest w sygnalizowanego stanu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-242">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="60f8b-243">Upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-243">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="60f8b-244"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="60f8b-244">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="60f8b-245">Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-245">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="60f8b-246">Operacji oczekiwania jest wykonywane przez wątków z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-246">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="60f8b-247">Delegat jest wykonywana przez wątek roboczy, gdy stan obiektu jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-247">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="60f8b-248">Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-248">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="60f8b-249">Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-249">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="60f8b-250">Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> z maksymalną liczbą 1.</span><span class="sxs-lookup"><span data-stu-id="60f8b-250">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="60f8b-251">Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-251">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="60f8b-252">Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcję, aby monitorowanie operacji oczekiwania zarejestrowane.</span><span class="sxs-lookup"><span data-stu-id="60f8b-252">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="60f8b-253">W związku z tym, jeśli musisz użyć tego samego uchwytu macierzystego systemu operacyjnego w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt przy użyciu Win32 `DuplicateHandle` funkcji.</span><span class="sxs-lookup"><span data-stu-id="60f8b-253">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="60f8b-254">Należy zwrócić uwagę, czy nie powinien impulsów przekazany obiekt zdarzenia <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania nie może wykryć, czy zdarzenie jest sygnalizowane, zanim zostanie zresetowane.</span><span class="sxs-lookup"><span data-stu-id="60f8b-254">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="60f8b-255">Przed zwróceniem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="60f8b-255">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="60f8b-256">Modyfikacja występuje tylko w przypadku obiektu, którego sygnalizowanego stanu spowodowane warunek oczekiwania, które należy spełnić.</span><span class="sxs-lookup"><span data-stu-id="60f8b-256">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="60f8b-257">Na przykład za pomocą jednej zmniejsza się liczba semafora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-257">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="60f8b-258">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="60f8b-258">Version Information</span></span>  
 <span data-ttu-id="60f8b-259">Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-259">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="60f8b-260">We wcześniejszych wersjach nie są propagowane informacji o jednostce.</span><span class="sxs-lookup"><span data-stu-id="60f8b-260">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="60f8b-261">
            <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-261">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="60f8b-262">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-262">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="60f8b-263">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-263">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="60f8b-264">
            <see cref="T:System.Threading.WaitOrTimerCallback" /> Pełnomocnika do wywołania, gdy <c>waitObject</c> zasygnalizowania parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-264">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60f8b-265">Obiekt przekazany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-265">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="60f8b-266">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-266">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="60f8b-267">Jeśli <c>millisecondsTimeOutInterval</c> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-267">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="60f8b-268">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-268">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="60f8b-269">
            <see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-269">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-270">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając całkowita 64-bitowych limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-270">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-271">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-271">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-272">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-272">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="60f8b-273">Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="60f8b-273">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="60f8b-274">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-274">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="60f8b-275"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-275">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="60f8b-276">Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="60f8b-276">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="60f8b-277">Określony obiekt jest w sygnalizowanego stanu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-277">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="60f8b-278">Upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-278">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="60f8b-279"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="60f8b-279">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="60f8b-280">Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-280">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="60f8b-281">Operacji oczekiwania jest wykonywane przez wątków z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-281">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="60f8b-282">Delegat jest wykonywana przez wątek roboczy, gdy stan obiektu jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-282">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="60f8b-283">Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-283">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="60f8b-284">Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-284">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="60f8b-285">Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> z maksymalną liczbą 1.</span><span class="sxs-lookup"><span data-stu-id="60f8b-285">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="60f8b-286">Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-286">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="60f8b-287">Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcję, aby monitorowanie operacji oczekiwania zarejestrowane.</span><span class="sxs-lookup"><span data-stu-id="60f8b-287">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="60f8b-288">W związku z tym, jeśli musisz użyć tego samego uchwytu macierzystego systemu operacyjnego w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt przy użyciu Win32 `DuplicateHandle` funkcji.</span><span class="sxs-lookup"><span data-stu-id="60f8b-288">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="60f8b-289">Należy zwrócić uwagę, czy nie powinien impulsów przekazany obiekt zdarzenia <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania nie może wykryć, czy zdarzenie jest sygnalizowane, zanim zostanie zresetowane.</span><span class="sxs-lookup"><span data-stu-id="60f8b-289">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="60f8b-290">Przed zwróceniem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="60f8b-290">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="60f8b-291">Modyfikacja występuje tylko w przypadku obiektu, którego sygnalizowanego stanu spowodowane warunek oczekiwania, które należy spełnić.</span><span class="sxs-lookup"><span data-stu-id="60f8b-291">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="60f8b-292">Na przykład za pomocą jednej zmniejsza się liczba semafora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-292">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="60f8b-293">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="60f8b-293">Version Information</span></span>  
 <span data-ttu-id="60f8b-294">Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-294">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="60f8b-295">We wcześniejszych wersjach nie są propagowane informacji o jednostce.</span><span class="sxs-lookup"><span data-stu-id="60f8b-295">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="60f8b-296">
            <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-296">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="60f8b-297">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-297">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="60f8b-298">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-298">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="60f8b-299">
            <see cref="T:System.Threading.WaitOrTimerCallback" /> Pełnomocnika do wywołania, gdy <c>waitObject</c> zasygnalizowania parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-299">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60f8b-300">Obiekt przekazany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-300">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="60f8b-301">Limit czasu, reprezentowane przez <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-301">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="60f8b-302">Jeśli <c>limitu czasu</c> jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-302">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="60f8b-303">Jeśli <c>limitu czasu</c> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-303">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="60f8b-304">
            <see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-304">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-305">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określanie <see cref="T:System.TimeSpan" /> wartość limitu czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-305">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-306">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-306">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-307">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-307">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="60f8b-308">Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="60f8b-308">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="60f8b-309">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-309">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="60f8b-310"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-310">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="60f8b-311">Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="60f8b-311">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="60f8b-312">Określony obiekt jest w sygnalizowanego stanu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-312">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="60f8b-313">Upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-313">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="60f8b-314"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="60f8b-314">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="60f8b-315">Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-315">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="60f8b-316">Operacji oczekiwania jest wykonywane przez wątków z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-316">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="60f8b-317">Delegat jest wykonywana przez wątek roboczy, gdy stan obiektu jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-317">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="60f8b-318">Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-318">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="60f8b-319">Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-319">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="60f8b-320">Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> z maksymalną liczbą 1.</span><span class="sxs-lookup"><span data-stu-id="60f8b-320">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="60f8b-321">Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-321">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="60f8b-322">Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcję, aby monitorowanie operacji oczekiwania zarejestrowane.</span><span class="sxs-lookup"><span data-stu-id="60f8b-322">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="60f8b-323">W związku z tym, jeśli musisz użyć tego samego uchwytu macierzystego systemu operacyjnego w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt przy użyciu Win32 `DuplicateHandle` funkcji.</span><span class="sxs-lookup"><span data-stu-id="60f8b-323">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="60f8b-324">Należy zwrócić uwagę, czy nie powinien impulsów przekazany obiekt zdarzenia <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania nie może wykryć, czy zdarzenie jest sygnalizowane, zanim zostanie zresetowane.</span><span class="sxs-lookup"><span data-stu-id="60f8b-324">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="60f8b-325">Przed zwróceniem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="60f8b-325">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="60f8b-326">Modyfikacja występuje tylko w przypadku obiektu, którego sygnalizowanego stanu spowodowane warunek oczekiwania, które należy spełnić.</span><span class="sxs-lookup"><span data-stu-id="60f8b-326">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="60f8b-327">Na przykład za pomocą jednej zmniejsza się liczba semafora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-327">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="60f8b-328">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="60f8b-328">Version Information</span></span>  
 <span data-ttu-id="60f8b-329">Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-329">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="60f8b-330">We wcześniejszych wersjach nie są propagowane informacji o jednostce.</span><span class="sxs-lookup"><span data-stu-id="60f8b-330">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="60f8b-331">
            <paramref name="timeout" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-331">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="60f8b-332">
            <paramref name="timeout" /> Parametru jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-332">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="60f8b-333">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-333">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="60f8b-334">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-334">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="60f8b-335">
            <see cref="T:System.Threading.WaitOrTimerCallback" /> Pełnomocnika do wywołania, gdy <c>waitObject</c> zasygnalizowania parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-335">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60f8b-336">Obiekt przekazany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-336">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="60f8b-337">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-337">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="60f8b-338">Jeśli <c>millisecondsTimeOutInterval</c> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-338">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="60f8b-339">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-339">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="60f8b-340">
            <see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-340">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-341">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 32-bitowej nieoznaczonej liczby całkowitej limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-341">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-342">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Można anulować operacji oczekiwania zarejestrowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-342">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-343">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-343">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="60f8b-344">Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="60f8b-344">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="60f8b-345">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-345">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="60f8b-346"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-346">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="60f8b-347">Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="60f8b-347">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="60f8b-348">Określony obiekt jest w sygnalizowanego stanu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-348">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="60f8b-349">Upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-349">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="60f8b-350"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="60f8b-350">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="60f8b-351">Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-351">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="60f8b-352">Operacji oczekiwania jest wykonywane przez wątków z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-352">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="60f8b-353">Delegat jest wykonywana przez wątek roboczy, gdy stan obiektu jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-353">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="60f8b-354">Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-354">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="60f8b-355">Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-355">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="60f8b-356">Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> z maksymalną liczbą 1.</span><span class="sxs-lookup"><span data-stu-id="60f8b-356">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="60f8b-357">Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-357">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="60f8b-358">Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcję, aby monitorowanie operacji oczekiwania zarejestrowane.</span><span class="sxs-lookup"><span data-stu-id="60f8b-358">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="60f8b-359">W związku z tym, jeśli musisz użyć tego samego uchwytu macierzystego systemu operacyjnego w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt przy użyciu Win32 `DuplicateHandle` funkcji.</span><span class="sxs-lookup"><span data-stu-id="60f8b-359">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="60f8b-360">Należy zwrócić uwagę, czy nie powinien impulsów przekazany obiekt zdarzenia <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania nie może wykryć, czy zdarzenie jest sygnalizowane, zanim zostanie zresetowane.</span><span class="sxs-lookup"><span data-stu-id="60f8b-360">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="60f8b-361">Przed zwróceniem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="60f8b-361">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="60f8b-362">Modyfikacja występuje tylko w przypadku obiektu, którego sygnalizowanego stanu spowodowane warunek oczekiwania, które należy spełnić.</span><span class="sxs-lookup"><span data-stu-id="60f8b-362">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="60f8b-363">Na przykład za pomocą jednej zmniejsza się liczba semafora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-363">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="60f8b-364">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="60f8b-364">Version Information</span></span>  
 <span data-ttu-id="60f8b-365">Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątki robocze w kolejce przy użyciu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-365">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="60f8b-366">We wcześniejszych wersjach nie są propagowane informacji o jednostce.</span><span class="sxs-lookup"><span data-stu-id="60f8b-366">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60f8b-367">Poniższy przykład pokazuje, jak używać <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody do wykonania metodą określonego wywołania zwrotnego, gdy jest sygnalizowane dojście oczekiwania określony.</span><span class="sxs-lookup"><span data-stu-id="60f8b-367">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="60f8b-368">W tym przykładzie, metody wywołania zwrotnego jest `WaitProc`, a to dojście oczekiwania <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="60f8b-368">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="60f8b-369">W przykładzie zdefiniowano `TaskInfo` klasy do przechowywania informacji, który jest przekazywany do wywołania zwrotnego, podczas wykonywania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-369">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="60f8b-370">W przykładzie jest tworzony `TaskInfo` obiektu, a następnie przypisuje go niektóre dane ciągu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-370">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="60f8b-371"><xref:System.Threading.RegisteredWaitHandle> Zwracanym przez <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody jest przypisany do `Handle` pole `TaskInfo` obiekt metody wywołania zwrotnego ma dostęp do <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="60f8b-371">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="60f8b-372">Oprócz określenia `TaskInfo` jako obiekt do przekazania do metody wywołania zwrotnego, wywołanie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> określa metodę <xref:System.Threading.AutoResetEvent> , zadanie będzie oczekiwać, <xref:System.Threading.WaitOrTimerCallback> delegata, który reprezentuje `WaitProc` metody wywołania zwrotnego co drugi interwał limitu czasu, a wiele wywołań zwrotnych.</span><span class="sxs-lookup"><span data-stu-id="60f8b-372">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="60f8b-373">Gdy sygnały w głównym wątku <xref:System.Threading.AutoResetEvent> przez wywołanie jego <xref:System.Threading.EventWaitHandle.Set%2A> metody <xref:System.Threading.WaitOrTimerCallback> obiekt delegowany jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="60f8b-373">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="60f8b-374">`WaitProc` Testy metoda <xref:System.Threading.RegisteredWaitHandle> do określenia, czy upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-374">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="60f8b-375">Jeśli wywołano wywołanie zwrotne, ponieważ zostało zasygnalizowane dojście oczekiwania, `WaitProc` wyrejestrowuje metoda <xref:System.Threading.RegisteredWaitHandle>, zatrzymanie dodatkowe wywołania zwrotne.</span><span class="sxs-lookup"><span data-stu-id="60f8b-375">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="60f8b-376">W przypadku przekroczenia limitu czasu zadanie będzie nadal czekać.</span><span class="sxs-lookup"><span data-stu-id="60f8b-376">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="60f8b-377">`WaitProc` Metoda kończy się wydrukować komunikat do konsoli.</span><span class="sxs-lookup"><span data-stu-id="60f8b-377">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="60f8b-378">
            <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-378">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="60f8b-379">Maksymalna liczba wątków w puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-379">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="60f8b-380">Maksymalna liczba asynchronicznego wątków We/Wy w puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-380">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-381">Ustawia liczbę żądań w puli wątków, które mogą być wykonywane jednocześnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-381">Sets the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="60f8b-382">Wszystkie żądania powyżej tego numeru pozostaną w kolejce, dopóki wątków z puli wątków stają się dostępne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-382">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-383">
            <see langword="true" /> Jeśli ta zmiana jest kończy się pomyślnie; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-383">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-384">Nie można ustawić maksymalną liczbę wątków roboczych lub wątków zakończenia operacji We/Wy na liczbę mniejszą niż liczba procesorów w komputerze.</span><span class="sxs-lookup"><span data-stu-id="60f8b-384">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="60f8b-385">Aby określić liczbę procesorów są obecne, pobrać wartość <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="60f8b-385">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="60f8b-386">Ponadto nie można ustawić maksymalną liczbę wątków roboczych lub wątków ukończenia operacji We/Wy na liczbę mniejsze niż minimalne odpowiednią liczbę wątków roboczych lub wątki zakończenia operacji We/Wy.</span><span class="sxs-lookup"><span data-stu-id="60f8b-386">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="60f8b-387">Aby określić rozmiar puli wątków minimalne, należy wywołać <xref:System.Threading.ThreadPool.GetMinThreads%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="60f8b-387">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="60f8b-388">Jeśli znajduje się środowisko uruchomieniowe języka wspólnego, np. przez Internet Information Services (IIS) lub SQL Server host może ograniczyć lub uniemożliwić zmiany rozmiaru puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-388">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="60f8b-389">Zmiana maksymalnej liczby wątków w puli wątków, należy zachować ostrożność.</span><span class="sxs-lookup"><span data-stu-id="60f8b-389">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="60f8b-390">Podczas organizowanych kodu, zmiany mogą się niekorzystny wpływ na bibliotek kodu, których używasz.</span><span class="sxs-lookup"><span data-stu-id="60f8b-390">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="60f8b-391">Ustawienie zbyt duży rozmiar puli wątków może spowodować problemy z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="60f8b-391">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="60f8b-392">Jeśli zbyt wiele wątków, są wykonywane w tym samym czasie, przełączanie zadań obciążenie staje się ważnym czynnikiem.</span><span class="sxs-lookup"><span data-stu-id="60f8b-392">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="60f8b-393">Aby uzyskać możliwość kontrolować wątki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-393">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="60f8b-394">Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-394">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="60f8b-395">Minimalna liczba wątków roboczych, tworzonych w puli wątków na żądanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-395">The minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="60f8b-396">Minimalna liczba asynchronicznych operacji We/Wy wątków, tworzonych w puli wątków na żądanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-396">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-397">Ustawia minimalną liczbę wątków, tworzonych w puli wątków na żądanie, nowych żądań, przed przełączeniem na algorytm zarządzania wątku tworzenia i niszczenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-397">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-398">
            <see langword="true" /> Jeśli ta zmiana jest kończy się pomyślnie; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-398">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-399">Puli wątków zapewnia nowych wątków roboczych lub wątków do ukończenia operacji We/Wy na żądanie, dopóki nie zostanie osiągnięty co najmniej dla każdej kategorii.</span><span class="sxs-lookup"><span data-stu-id="60f8b-399">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="60f8b-400">Gdy zostanie osiągnięta minimalny, puli wątków można utworzyć dodatkowe wątki w danej kategorii lub poczekaj na ukończenie niektóre zadania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-400">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="60f8b-401">Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], puli wątków tworzy i niszczy wątki w celu zoptymalizowania przepływności, która jest zdefiniowana jako liczbę zadań, kończące się na jednostkę czasu.</span><span class="sxs-lookup"><span data-stu-id="60f8b-401">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="60f8b-402">Zbyt mało wątków może nie mieć optymalnego wykorzystania dostępnych zasobów, natomiast zbyt wiele wątków może zwiększyć rywalizacji o zasoby.</span><span class="sxs-lookup"><span data-stu-id="60f8b-402">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="60f8b-403">Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków z puli wątków może spadną poniżej wartości minimalnej.</span><span class="sxs-lookup"><span data-stu-id="60f8b-403">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="60f8b-404">Jeśli określisz liczbę ujemną lub podana liczba większa niż maksymalna liczba aktywnych wątków z puli wątków (uzyskanych przy użyciu <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> zwraca `false` i nie jest zmieniany minimalnej wartości.</span><span class="sxs-lookup"><span data-stu-id="60f8b-404">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="60f8b-405">Minimalna liczba wątków domyślnie do liczby procesorów w systemie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-405">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="60f8b-406">Możesz użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodę, aby zwiększyć minimalną ofthreads liczb.</span><span class="sxs-lookup"><span data-stu-id="60f8b-406">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="60f8b-407">Jednak niepotrzebnie zwiększenie tych wartości może spowodować problemy z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="60f8b-407">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="60f8b-408">Jeśli zbyt wiele zadań jest uruchomiona w tym samym czasie, wszystkie z nich może pojawić się wolno.</span><span class="sxs-lookup"><span data-stu-id="60f8b-408">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="60f8b-409">W większości przypadków puli wątków będą działać lepiej z własną algorytm wątki alokacji.</span><span class="sxs-lookup"><span data-stu-id="60f8b-409">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="60f8b-410">Zmniejszenie minimum, aby była ona mniejsza niż liczba procesorów również może obniżyć wydajność.</span><span class="sxs-lookup"><span data-stu-id="60f8b-410">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60f8b-411">Poniższy przykład Ustawia minimalną liczbę wątków roboczych na cztery i zachowuje oryginalnej wartości minimalna liczba wątków uzupełniania w usłudze asynchronicznych operacji We/Wy.</span><span class="sxs-lookup"><span data-stu-id="60f8b-411">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="60f8b-412">Aby uzyskać możliwość kontrolować wątki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-412">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="60f8b-413">Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-413">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <span data-ttu-id="60f8b-414">
            <see cref="T:System.Threading.NativeOverlapped" /> Struktury do kolejki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-414">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-415">Umieszcza w kolejce nakładające się operacji We/Wy do wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-415">Queues an overlapped I/O operation for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-416">
            <see langword="true" /> Jeśli operacja pomyślnie zostało umieszczone w kolejce do portu ukończenia operacji We/Wy; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-416">
              <see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-417">Aby uzyskać informacji o używaniu natywny Win32 pokrywający się operacji We/Wy, zobacz <xref:System.Threading.Overlapped> klasy, <xref:System.Threading.NativeOverlapped> struktury i `OVERLAPPED` struktury w zestawie SDK platformy Win32.</span><span class="sxs-lookup"><span data-stu-id="60f8b-417">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="60f8b-418">Za pomocą <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> metoda może przypadkowo otwierają lukę w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="60f8b-418">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="60f8b-419">Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-419">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="60f8b-420">Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, stosu wątku z puli wątków nie ma kontekście rzeczywistych obiektów wywołujących.</span><span class="sxs-lookup"><span data-stu-id="60f8b-420">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="60f8b-421">Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="60f8b-421">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="60f8b-422">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-422">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="60f8b-423">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-423">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="60f8b-424">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący pełnomocnika do wywołania, gdy wątków w puli wątków przejmuje elementu roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-424">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60f8b-425">Obiekt, który jest przekazywany do obiektu delegowanego, gdy obsługiwany z puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-425">The object that is passed to the delegate when serviced from the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-426">Kolejki określonego delegata do puli wątków, ale nie propaguje stosu wywołującego do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-426">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-427">
            <see langword="true" /> Jeśli metoda się powiedzie; <see cref="T:System.OutOfMemoryException" /> jest generowany, jeśli element roboczy nie można umieścić w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-427">
              <see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-428">W odróżnieniu od <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> nie propaguje stosu wywołującego do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="60f8b-428">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="60f8b-429">Dzięki temu kod utratę wywołania stosu, a tym samym do podniesienia swoich uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="60f8b-429">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="60f8b-430">Za pomocą <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> może przypadkowo otwierają lukę w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="60f8b-430">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="60f8b-431">Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-431">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="60f8b-432">Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, stosu wątku z puli wątków nie będzie miał kontekście rzeczywistych obiektów wywołujących.</span><span class="sxs-lookup"><span data-stu-id="60f8b-432">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="60f8b-433">Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="60f8b-433">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="60f8b-434">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-434">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="60f8b-435">Wystąpił stan braku pamięci.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-435">An out-of-memory condition was encountered.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="60f8b-436">Element roboczy nie można umieścić w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-436">The work item could not be queued.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60f8b-437">
            <paramref name="callBack" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-437">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="60f8b-438">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-438">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="60f8b-439">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-439">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="60f8b-440">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, ale nie propaguje stosu wywołującego do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-440">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="60f8b-441">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-441">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="60f8b-442">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-442">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="60f8b-443">Pełnomocnika do wywołania, gdy <c>waitObject</c> zasygnalizowania parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-443">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60f8b-444">Obiekt, który jest przekazywany do obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-444">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="60f8b-445">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-445">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="60f8b-446">Jeśli <c>millisecondsTimeOutInterval</c> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-446">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="60f8b-447">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-447">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="60f8b-448">
            <see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-448">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-449">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, za pomocą całkowita 32-bitowych dla limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-449">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="60f8b-450">Ta metoda nie propaguje stosu wywołującego do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-450">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-451">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji oczekiwania zarejestrowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-451">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-452">W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołującego do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="60f8b-452">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="60f8b-453">Dzięki temu kod utratę wywołania stosu, a tym samym do podniesienia swoich uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="60f8b-453">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="60f8b-454">Za pomocą <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może przypadkowo otwierają lukę w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="60f8b-454">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="60f8b-455">Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-455">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="60f8b-456">Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku z puli wątków nie będzie miał kontekście rzeczywistych obiektów wywołujących.</span><span class="sxs-lookup"><span data-stu-id="60f8b-456">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="60f8b-457">Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="60f8b-457">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="60f8b-458">Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-458">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="60f8b-459">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-459">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="60f8b-460">Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="60f8b-460">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="60f8b-461">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-461">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="60f8b-462">
            <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-462">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="60f8b-463">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-463">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="60f8b-464">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-464">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="60f8b-465">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-465">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="60f8b-466">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-466">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="60f8b-467">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-467">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="60f8b-468">Pełnomocnika do wywołania, gdy <c>waitObject</c> zasygnalizowania parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-468">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60f8b-469">Obiekt, który jest przekazywany do obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-469">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="60f8b-470">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-470">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="60f8b-471">Jeśli <c>millisecondsTimeOutInterval</c> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-471">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="60f8b-472">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-472">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="60f8b-473">
            <see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-473">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-474">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając całkowita 64-bitowych limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-474">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="60f8b-475">Ta metoda nie propaguje stosu wywołującego do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-475">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-476">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji oczekiwania zarejestrowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-476">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-477">W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołującego do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="60f8b-477">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="60f8b-478">Dzięki temu kod utratę wywołania stosu, a tym samym do podniesienia swoich uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="60f8b-478">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="60f8b-479">Za pomocą <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może przypadkowo otwierają lukę w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="60f8b-479">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="60f8b-480">Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-480">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="60f8b-481">Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku z puli wątków nie będzie miał kontekście rzeczywistych obiektów wywołujących.</span><span class="sxs-lookup"><span data-stu-id="60f8b-481">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="60f8b-482">Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="60f8b-482">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="60f8b-483">Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-483">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="60f8b-484">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-484">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="60f8b-485">Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="60f8b-485">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="60f8b-486">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-486">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="60f8b-487">
            <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-487">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="60f8b-488">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-488">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="60f8b-489">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-489">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="60f8b-490">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-490">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="60f8b-491">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-491">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="60f8b-492">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-492">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="60f8b-493">Pełnomocnika do wywołania, gdy <c>waitObject</c> zasygnalizowania parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-493">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60f8b-494">Obiekt, który jest przekazywany do obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-494">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="60f8b-495">Limit czasu, reprezentowane przez <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-495">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="60f8b-496">Jeśli <c>limitu czasu</c> jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-496">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="60f8b-497">Jeśli <c>limitu czasu</c> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-497">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="60f8b-498">
            <see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-498">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-499">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określanie <see cref="T:System.TimeSpan" /> wartość limitu czasu. Ta metoda nie propaguje stosu wywołującego do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-499">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-500">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji oczekiwania zarejestrowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-500">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-501">W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołującego do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="60f8b-501">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="60f8b-502">Dzięki temu kod utratę wywołania stosu, a tym samym do podniesienia swoich uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="60f8b-502">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="60f8b-503">Za pomocą <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może przypadkowo otwierają lukę w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="60f8b-503">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="60f8b-504">Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-504">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="60f8b-505">Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku z puli wątków nie będzie miał kontekście rzeczywistych obiektów wywołujących.</span><span class="sxs-lookup"><span data-stu-id="60f8b-505">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="60f8b-506">Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="60f8b-506">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="60f8b-507">Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-507">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="60f8b-508">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-508">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="60f8b-509">Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="60f8b-509">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="60f8b-510">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-510">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="60f8b-511">
            <paramref name="timeout" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-511">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="60f8b-512">
            <paramref name="timeout" /> Parametru jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-512">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="60f8b-513">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-513">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="60f8b-514">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-514">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="60f8b-515">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-515">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="60f8b-516">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-516">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="60f8b-517">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-517">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="60f8b-518">Pełnomocnika do wywołania, gdy <c>waitObject</c> zasygnalizowania parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-518">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60f8b-519">Obiekt, który jest przekazywany do obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-519">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="60f8b-520">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-520">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="60f8b-521">Jeśli <c>millisecondsTimeOutInterval</c> parametr ma wartość 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-521">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="60f8b-522">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upływa interwał limitu czasu funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-522">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="60f8b-523">
            <see langword="true" /> Aby wskazać, że wątek nie jest już będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz za każdym razem, gdy kończy operacji oczekiwania, dopóki nie zostanie wyrejestrowany czas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-523">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60f8b-524">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 32-bitowej nieoznaczonej liczby całkowitej limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-524">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="60f8b-525">Ta metoda nie propaguje stosu wywołującego do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-525">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60f8b-526">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji oczekiwania zarejestrowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-526">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60f8b-527">W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołującego do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="60f8b-527">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="60f8b-528">Dzięki temu kod utratę wywołania stosu, a tym samym do podniesienia swoich uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="60f8b-528">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="60f8b-529">Za pomocą <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może przypadkowo otwierają lukę w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="60f8b-529">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="60f8b-530">Zabezpieczenia dostępu kodu określa jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="60f8b-530">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="60f8b-531">Podczas pracy znajduje się w kolejce przy użyciu wątek puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku z puli wątków nie będzie miał kontekście rzeczywistych obiektów wywołujących.</span><span class="sxs-lookup"><span data-stu-id="60f8b-531">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="60f8b-532">Złośliwy kod może być w stanie wykorzystać ten element, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="60f8b-532">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="60f8b-533">Za pomocą <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołania zwrotne, ponieważ podstawowego interfejsu API Win32 używa domyślnego `WT_EXECUTEDEFAULT` Flaga, dzięki czemu każdy wywołania zwrotnego jest wysyłane w oddzielnym wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="60f8b-533">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="60f8b-534">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , jest zwracana przez tę metodę, należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="60f8b-534">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="60f8b-535">Firma Microsoft zaleca, aby zawsze wywołujesz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="60f8b-535">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="60f8b-536">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie Jeśli wywołasz <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizatora.</span><span class="sxs-lookup"><span data-stu-id="60f8b-536">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="60f8b-537">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-537">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="60f8b-538">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-538">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="60f8b-539">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60f8b-539">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>
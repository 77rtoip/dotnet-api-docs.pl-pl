<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="68b7762e25c13529637c3ed6d542d63fee277f04" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911353" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia puli wątków, które mogą służyć do wykonywania zadań, publikowania elementów roboczych, Przetwarzanie asynchroniczne We/Wy, Oczekiwanie w imieniu innych wątków i przetworzyć czasomierze.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele aplikacji Tworzenie wątków, które spędzają na dużą ilość czasu w stanie uśpiony, oczekuje na wystąpienie zdarzenia. Inne wątki może przejść w stan uśpiony tylko do wznowione okresowo sondować zmiany lub zaktualizować informacje o stanie. Pula wątków umożliwia korzystanie wątków wydajniej, udostępniając aplikację z pulą wątków roboczych, które są zarządzane przez system. Oto operacje, które używają wątków z puli wątków:  
  
-   Po utworzeniu <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> obiektu w celu wykonania niektórych zadań asynchronicznie, domyślnie zadanie jest zaplanowane do uruchomienia w wątku puli wątków.  
  
-   Czasomierze asynchroniczne Użyj puli wątków. Wątków z puli wątków wykonywania wywołań zwrotnych z <xref:System.Threading.Timer?displayProperty=nameWithType> klasy i wywoływanie zdarzeń od <xref:System.Timers.Timer?displayProperty=nameWithType> klasy.  
  
-   Gdy używasz uchwyty oczekiwania zarejestrowanych wątku systemu monitoruje stan uchwyty oczekiwania. Po ukończeniu operacji oczekiwania wątku roboczego z puli wątków wykonuje odpowiednie funkcja wywołania zwrotnego.  
  
-   Podczas wywoływania <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody do kolejki metody do wykonania w wątku puli wątków. Można to zrobić przez przekazanie metody <xref:System.Threading.WaitCallback> delegowanie.   Delegat ma sygnaturę  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     gdzie `state` jest obiekt, który zawiera dane, które mają być używane przez delegata. Rzeczywiste dane mogą zostać przekazane do delegata, wywołując <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> metody.  
  
> [!NOTE]
>  Wątki w puli wątków zarządzanych są wątki w tle. Oznacza to, że ich <xref:System.Threading.Thread.IsBackground%2A> właściwości są `true`. Oznacza to, że <xref:System.Threading.ThreadPool> wątku nie zachowa aplikacji uruchomionej po zamknięciu wszystkie wątki pierwszego planu.  
  
> [!IMPORTANT]
>  Gdy puli wątków ponownie używa wątku, nie czyści danych lokalny magazyn wątków lub pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybutu. W związku z tym, gdy metoda sprawdza, czy lokalny magazyn wątków lub pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut wartości znajdzie może pozostać za pośrednictwem z wcześniejszego użycia wątku puli wątków.  
  
 Można również kolejki elementów pracy, które nie są powiązane z operacją oczekiwania do puli wątków. Aby zażądać, że element pracy ma być obsługiwany przez wątek w puli wątków, należy wywołać <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody. Ta metoda przyjmuje jako parametr odwołania do metody lub delegata, która zostanie wywołana przez wątek z puli wątków. Nie istnieje sposób anulowania elementu roboczego po jego zostało umieszczone w kolejce.  
  
 Czasomierze kolejki czasomierza i zarejestrowanych oczekiwania operacji również używają puli wątków. Funkcje wywołania zwrotnego, ich są umieszczane w kolejce do puli wątków.  
  
 Brak jednej puli wątków na proces. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], domyślny rozmiar puli wątków procesu zależy od wielu czynników, takich jak rozmiar wirtualnej przestrzeni adresowej. Proces może wywołać <xref:System.Threading.ThreadPool.GetMaxThreads%2A> metodę, aby określić liczbę wątków. Liczba wątków w puli wątków można zmieniać za pomocą <xref:System.Threading.ThreadPool.SetMaxThreads%2A> metody. Każdy wątek używa domyślny rozmiar stosu i uruchamia priorytetem domyślne.  
  
> [!NOTE]
>  Niezarządzany kod, który jest hostem środowiska .NET Framework, można zmienić rozmiar puli wątków za pomocą `CorSetMaxThreads` funkcja zdefiniowana w pliku mscoree.h.  
  
 Puli wątków zawiera nowe wątków roboczych lub wątków zakończenia We/Wy na żądanie, dopóki nie osiągnie minimum dla każdej kategorii. Po osiągnięciu minimum puli wątków można utworzyć dodatkowe wątki w tej kategorii lub zaczekaj na zakończenie niektórych zadań. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], pulą wątków tworzy i niszczy wątków roboczych w celu zoptymalizowania przepustowości, która jest zdefiniowana jako liczba zadań, kończące się na jednostkę czasu. Zbyt mało wątków może nie mieć optymalne wykorzystanie dostępnych zasobów, natomiast zbyt wiele wątków można zwiększyć rywalizacji.  
  
> [!NOTE]
>  Jeśli żądanie jest niska, rzeczywista liczba wątków z puli wątków można spadnie poniżej wartości minimalnej.  
  
 Można użyć <xref:System.Threading.ThreadPool.GetMinThreads%2A> metodę, aby uzyskać te wartości minimalnej.  
  
> [!CAUTION]
>  Można użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodę, aby zwiększyć minimalną liczbę wątków roboczych. Jednak niepotrzebnie zwiększenie tych wartości może spowodować problemy z wydajnością. Jeśli zbyt wiele zadań jest uruchomiona w tym samym czasie, wszystkie z nich wydaje się powoli. W większości przypadków puli wątków będą działać lepiej z własną algorytmu alokacji wątków.  
  
   
  
## Examples  
 W poniższym przykładzie wątku głównego aplikacji kolejki metodę o nazwie `ThreadProc` do wykonywania w wątku puli wątków, sen dla jednej sekundy, a następnie zamyka. `ThreadProc` Metoda po prostu zostanie wyświetlony komunikat.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 Jeśli komentarz wywołanie <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody wątku głównego jest kończona przed uruchomieniem metody w wątku puli wątków.  Pula wątków używa wątki w tle, które nie jest przechowywana aplikacja była uruchomiona, jeśli wszystkie wątki pierwszoplanowe zostały zakończone.  (Jest to prosty przykład sytuacja wyścigu).  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wiąże dojścia systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <see cref="T:System.IntPtr" /> Przechowuje dojście. Dojście musi otwarte dla pokrywającej się z inną operacji We/Wy na stronie niezarządzane.</param>
        <summary>Wiąże dojścia systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>
          <see langword="true" /> Jeśli dojście jest powiązana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> przechowuje dojście systemu operacyjnego. Dojście musi otwarte dla pokrywającej się z inną operacji We/Wy na stronie niezarządzane.</param>
        <summary>Wiąże dojścia systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>
          <see langword="true" /> Jeśli dojście jest powiązana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `osHandle` Parametr powinien być <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, która pochodzi z klasy abstrakcyjnej <xref:System.Runtime.InteropServices.SafeHandle> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="osHandle" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Liczba wątków roboczych dostępne.</param>
        <param name="completionPortThreads">Liczba dostępnych asynchronicznych wątków We/Wy.</param>
        <summary>Pobiera różnicę między maksymalną liczbę wątków z puli wątków zwrócony przez <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> — metoda i numer obecnie aktywne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> zwraca określonej przez zmienną `workerThreads` zawiera liczbę wątków roboczych dodatkowe, które można uruchomić, a zmienna określony przez `completionPortThreads` zawiera liczbę dodatkowych asynchronicznych wątków We/Wy, które mogą być Rozpoczęto.  
  
 Jeśli nie ma żadnych dostępnych wątków, żądania puli wątków dodatkowe pozostają w kolejce do momentu udostępnienie wątków z puli wątków.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono liczbę wątków roboczych i wątków We/Wy dostępne po uruchomieniu prostej aplikacji.  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Maksymalna liczba wątków roboczych w puli wątków.</param>
        <param name="completionPortThreads">Maksymalna liczba asynchronicznych wątków We/Wy w puli wątków.</param>
        <summary>Pobiera liczbę żądań w puli wątków, które mogą być jednocześnie aktywne. Wszystkie żądania powyżej tego numeru pozostają w kolejce do momentu udostępnienie wątków z puli wątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Threading.ThreadPool.GetMaxThreads%2A> zwraca określonej przez zmienną `workerThreads` zawiera maksymalną liczbę dozwolonych w puli wątków wątków roboczych, a zmienna określony przez `completionPortThreads` zawiera maksymalną liczbę asynchronicznych wątków We/Wy w Pula wątków.  
  
 Można użyć <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> metodę, aby określić rzeczywistą liczbę wątków w puli wątków w danym momencie.  
  
 Można użyć <xref:System.Threading.ThreadPool.SetMaxThreads%2A> Aby ustawić maksymalną liczbę wątków roboczych i asynchronicznych wątków We/Wy w puli wątków.  
  
 Można dodać do kolejki jako wiele żądań w puli wątków zezwala pamięci systemowej. W przypadku żądań więcej niż wątków z puli wątków dodatkowe żądania pozostają w kolejce do momentu udostępnienie wątków z puli wątków.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak pobrać liczba maksymalna i dostępna liczba wątków w puli wątków. Element roboczy znajduje się w kolejce używającej `FileStream` do asynchronicznego zapisu do dwóch plików. Metody wywołania zwrotnego jest mierzony nakładanie się. Wątek roboczy obsługuje elementu roboczego i, w zależności od szybkości oraz liczby procesorów w komputerze, co najmniej dwóch wątków portu zakończenia obsługiwać operacje zapisu.  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Gdy metoda zwróci wartość, zawiera minimalną liczbę wątków roboczych, utworzonych puli wątków na żądanie.</param>
        <param name="completionPortThreads">Gdy metoda zwróci wartość, zawiera minimalną liczbę asynchronicznych wątków We/Wy, które tworzy puli wątków na żądanie.</param>
        <summary>Pobiera minimalną liczbę wątków, jakiej puli wątków tworzy na żądanie, jak zostały wprowadzone nowe żądania, przed przełączeniem do zarządzania wątku tworzenie i likwidacja algorytm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puli wątków zawiera nowe wątków roboczych lub wątków zakończenia We/Wy na żądanie, dopóki nie osiągnie minimum dla każdej kategorii. Minimalna liczba wątków domyślnie do liczby procesorów w systemie. Po osiągnięciu wartości minimalnej puli wątków można utworzyć dodatkowe wątki w tej kategorii lub zaczekaj na zakończenie niektórych zadań. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], pulą wątków tworzy i niszczy wątki w celu zoptymalizowania przepustowości, która jest zdefiniowana jako liczba zadań, kończące się na jednostkę czasu. Zbyt mało wątków może nie mieć optymalne wykorzystanie dostępnych zasobów, natomiast zbyt wiele wątków można zwiększyć rywalizacji.  
  
> [!NOTE]
>  Jeśli żądanie jest niska, rzeczywista liczba wątków z puli wątków można spadnie poniżej wartości minimalnej.  
  
   
  
## Examples  
 Poniższy przykład Ustawia minimalną liczbę wątków roboczych cztery i zachowa oryginalnej wartości minimalną liczbę asynchronicznych wątków zakończenia We/Wy.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia metodę do wykonania. Metoda jest wykonywana po udostępnieniu wątku puli wątków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący metodę do wykonania.</param>
        <summary>Ustawia metodę do wykonania. Metoda jest wykonywana po udostępnieniu wątku puli wątków.</summary>
        <returns>
          <see langword="true" /> Jeśli metoda pomyślnie znajduje się w kolejce; <see cref="T:System.NotSupportedException" /> jest generowany, jeśli nie można umieścić w kolejce elementu roboczego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można umieścić dane wymagane przez metodę umieszczonych w kolejce w pól wystąpień klasy, w którym zdefiniowano metody, lub można użyć <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> przeciążenia, które akceptuje obiekt zawierający potrzebne dane.  
  
> [!NOTE]
>  Użytkownicy programu Visual Basic można pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu użyj `AddressOf` operator podczas przekazywania metody wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic automatycznie wywołuje konstruktor delegata poprawne.  
  
## <a name="version-information"></a>Informacje o wersji  
 W programie .NET Framework w wersji 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody. We wcześniejszych wersjach głównych informacje nie są propagowane.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> przeciążenie metody można umieścić w kolejce zadań, która jest reprezentowana przez `ThreadProc` metody do wykonania, gdy wątek staje się dostępny. Informacje o zadaniu są dostarczane z tego przeciążenia. W związku z tym informacje, które są dostępne dla `ThreadProc` metody jest ograniczona do metody należy do obiektu.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Środowisko uruchomieniowe języka wspólnego (CLR) jest obsługiwana, i host nie obsługuje tej akcji.</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący metodę do wykonania.</param>
        <param name="state">Obiekt zawierający dane, które mają być używane przez metodę.</param>
        <summary>Metody wykonywania kolejek i określa obiekt zawierający dane, które mają być używane przez metodę. Metoda jest wykonywana po udostępnieniu wątku puli wątków.</summary>
        <returns>
          <see langword="true" /> Jeśli metoda pomyślnie znajduje się w kolejce; <see cref="T:System.NotSupportedException" /> jest generowany, jeśli nie można umieścić w kolejce elementu roboczego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda wywołania zwrotnego wymaga złożone dane, można zdefiniować klasy zawierają dane.  
  
> [!NOTE]
>  Użytkownicy programu Visual Basic można pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu użyj `AddressOf` operator podczas przekazywania metody wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic automatycznie wywołuje konstruktor delegata poprawne.  
  
## <a name="version-information"></a>Informacje o wersji  
 W programie .NET Framework w wersji 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody. We wcześniejszych wersjach głównych informacje nie są propagowane.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia obiektu, który zawiera informacje o zadaniu. Ilustruje też sposób przekazywania tego obiektu do umieszczonych w kolejce do wykonania zadania w puli wątków.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Środowisko uruchomieniowe języka wspólnego (CLR) jest obsługiwana, i host nie obsługuje tej akcji.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje delegata, który oczekuje na <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <see cref="T:System.Threading.WaitOrTimerCallback" /> Delegata do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</param>
        <param name="state">Obiekt, który jest przekazywany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 32-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków. Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:  
  
-   Określony obiekt jest w stanie sygnałowego.  
  
-   Upłynie limit czasu.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>. Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacja oczekiwania została wykonana przez wątek z puli wątków. Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.  
  
> [!IMPORTANT]
>  Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku. Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> maksymalna liczba 1.  
  
 Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.  
  
 Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji. W związku z tym należy używać tej samej uchwyt macierzysty system operacyjny w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji. Należy pamiętać, że nie należy impulsów zdarzeń obiektu przekazanych do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.  
  
 Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić. Na przykład Licznik semafora zostaje zmniejszona o jeden.  
  
## <a name="version-information"></a>Informacje o wersji  
 W programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody. We wcześniejszych wersjach głównych informacje nie są propagowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <see cref="T:System.Threading.WaitOrTimerCallback" /> Delegata do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</param>
        <param name="state">Obiekt przekazywany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 64-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków. Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:  
  
-   Określony obiekt jest w stanie sygnałowego.  
  
-   Upłynie limit czasu.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>. Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacja oczekiwania została wykonana przez wątek z puli wątków. Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.  
  
> [!IMPORTANT]
>  Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku. Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> maksymalna liczba 1.  
  
 Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.  
  
 Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji. W związku z tym należy używać tej samej uchwyt macierzysty system operacyjny w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji. Należy pamiętać, że nie należy impulsów zdarzeń obiektu przekazanych do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.  
  
 Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić. Na przykład Licznik semafora zostaje zmniejszona o jeden.  
  
## <a name="version-information"></a>Informacje o wersji  
 W programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody. We wcześniejszych wersjach głównych informacje nie są propagowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <see cref="T:System.Threading.WaitOrTimerCallback" /> Delegata do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</param>
        <param name="state">Obiekt przekazywany do delegata.</param>
        <param name="timeout">Limit czasu reprezentowany przez <see cref="T:System.TimeSpan" />. Jeśli <c>limitu czasu</c> jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <c>limitu czasu</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określania <see cref="T:System.TimeSpan" /> wartość limitu czasu.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków. Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:  
  
-   Określony obiekt jest w stanie sygnałowego.  
  
-   Upłynie limit czasu.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>. Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacja oczekiwania została wykonana przez wątek z puli wątków. Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.  
  
> [!IMPORTANT]
>  Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku. Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> maksymalna liczba 1.  
  
 Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.  
  
 Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji. W związku z tym należy używać tej samej uchwyt macierzysty system operacyjny w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji. Należy pamiętać, że nie należy impulsów zdarzeń obiektu przekazanych do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.  
  
 Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić. Na przykład Licznik semafora zostaje zmniejszona o jeden.  
  
## <a name="version-information"></a>Informacje o wersji  
 W programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody. We wcześniejszych wersjach głównych informacje nie są propagowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> Parametr jest mniejsza niż -1.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="timeout" /> Parametru jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <see cref="T:System.Threading.WaitOrTimerCallback" /> Delegata do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</param>
        <param name="state">Obiekt przekazywany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 32-bitową nieznakowaną liczbą całkowitą wartość limitu czasu w milisekundach.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> Można anulować operacji zarejestrowanych oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków. Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:  
  
-   Określony obiekt jest w stanie sygnałowego.  
  
-   Upłynie limit czasu.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>. Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacja oczekiwania została wykonana przez wątek z puli wątków. Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.  
  
> [!IMPORTANT]
>  Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku. Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> maksymalna liczba 1.  
  
 Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.  
  
 Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji. W związku z tym należy używać tej samej uchwyt macierzysty system operacyjny w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji. Należy pamiętać, że nie należy impulsów zdarzeń obiektu przekazanych do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.  
  
 Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić. Na przykład Licznik semafora zostaje zmniejszona o jeden.  
  
## <a name="version-information"></a>Informacje o wersji  
 W programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody. We wcześniejszych wersjach głównych informacje nie są propagowane.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody próbę wykonania metody wywołania zwrotnego określony podczas oczekiwania określonego dojścia jest sygnalizowane. W tym przykładzie metoda wywołania zwrotnego jest `WaitProc`, i jest dojście oczekiwania <xref:System.Threading.AutoResetEvent>.  
  
 W przykładzie zdefiniowano `TaskInfo` klasy do przechowywania informacji, który jest przekazywany do wywołania zwrotnego, podczas wykonywania. W przykładzie jest tworzony `TaskInfo` obiektów i przypisuje go niektórych danych ciągu. <xref:System.Threading.RegisteredWaitHandle> Zwróconego przez <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody jest przypisany do `Handle` pole `TaskInfo` obiekt, tak aby metody wywołania zwrotnego ma dostęp do <xref:System.Threading.RegisteredWaitHandle>.  
  
 Oprócz określenia `TaskInfo` jako obiekt, aby przekazać do metody wywołania zwrotnego, wywołanie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> określa metodę <xref:System.Threading.AutoResetEvent> zadanie czeka, <xref:System.Threading.WaitOrTimerCallback> delegata, który reprezentuje `WaitProc` metody wywołania zwrotnego co drugi interwał limitu czasu i wielu wywołań zwrotnych.  
  
 Jeśli sygnały wątku głównego <xref:System.Threading.AutoResetEvent> przez wywołanie jego <xref:System.Threading.EventWaitHandle.Set%2A> metody <xref:System.Threading.WaitOrTimerCallback> jest wywoływany delegat. `WaitProc` Testy metody <xref:System.Threading.RegisteredWaitHandle> ustalenie, czy upłynął limit czasu. Jeśli wywołania zwrotnego został wywołany, ponieważ został sygnalizowane dojście oczekiwania, `WaitProc` wyrejestrowuje metody <xref:System.Threading.RegisteredWaitHandle>, zatrzymywanie dodatkowe wywołań zwrotnych. W przypadku przekroczenia limitu czasu zadanie nadal oczekuje. `WaitProc` Metoda kończy się wydrukowanie komunikat do konsoli.  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Maksymalna liczba wątków roboczych w puli wątków.</param>
        <param name="completionPortThreads">Maksymalna liczba asynchronicznych wątków We/Wy w puli wątków.</param>
        <summary>Ustawia liczbę żądań w puli wątków, które mogą być jednocześnie aktywne. Wszystkie żądania powyżej tego numeru pozostają w kolejce do momentu udostępnienie wątków z puli wątków.</summary>
        <returns>
          <see langword="true" /> Jeśli zmiana zakończy się pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można ustawić maksymalną liczbę wątków roboczych lub wątków zakończenia We/Wy na liczbę mniejszą niż liczba procesorów na komputerze. Aby ustalić liczbę procesorów są obecne, pobrać wartość <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> właściwości. Ponadto nie można ustawić maksymalną liczbę wątków roboczych lub zakończenia We/Wy wątków liczbą mniejszą niż odpowiedni minimalna liczba wątków roboczych lub wątków zakończenia We/Wy. Aby określić rozmiar puli wątków minimalne, należy wywołać <xref:System.Threading.ThreadPool.GetMinThreads%2A> metody.  
  
 Jeśli środowisko uruchomieniowe języka wspólnego jest obsługiwana, na przykład przez Internet Information Services (IIS) lub SQL Server hosta można ograniczyć lub uniemożliwić zmiany rozmiaru puli wątków.  
  
 Należy zachować ostrożność podczas zmiany maksymalną liczbę wątków w puli wątków. Gdy kod może korzystać, zmiany mogą mieć niekorzystny wpływ na bibliotekach kod, którego używasz.  
  
 Ustawienie zbyt duży rozmiar puli wątków może spowodować problemy z wydajnością. Zbyt wiele wątków wykonywania jednocześnie przełączanie zadań nakładów pracy, staje się ważnym czynnikiem.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwości, aby kontrolować wątki. Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Minimalna liczba wątków roboczych, utworzonych puli wątków na żądanie.</param>
        <param name="completionPortThreads">Minimalna liczba asynchronicznych wątków We/Wy, które tworzy puli wątków na żądanie.</param>
        <summary>Ustawia minimalną liczbę wątków, jakiej puli wątków tworzy na żądanie, wprowadzono nowe żądania, przed przełączeniem algorytm zarządzania wątku tworzenie i likwidacja.</summary>
        <returns>
          <see langword="true" /> Jeśli zmiana zakończy się pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puli wątków zawiera nowe wątków roboczych lub wątków zakończenia We/Wy na żądanie, dopóki nie osiągnie minimum dla każdej kategorii. Po osiągnięciu wartości minimalnej puli wątków można utworzyć dodatkowe wątki w tej kategorii lub zaczekaj na zakończenie niektórych zadań. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], pulą wątków tworzy i niszczy wątki w celu zoptymalizowania przepustowości, która jest zdefiniowana jako liczba zadań, kończące się na jednostkę czasu. Zbyt mało wątków może nie mieć optymalne wykorzystanie dostępnych zasobów, natomiast zbyt wiele wątków można zwiększyć rywalizacji.  
  
 Jeśli żądanie jest niska, rzeczywista liczba wątków z puli wątków można spadnie poniżej wartości minimalnej.  
  
 Jeśli określono wartość ujemną lub większą niż maksymalna liczba aktywnych wątków z puli wątków liczbą (uzyskanych przy użyciu <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> zwraca `false` i nie zmienia się minimalnej wartości.  
  
> [!CAUTION]
>  Minimalna liczba wątków domyślnie do liczby procesorów w systemie. Można użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodę, aby zwiększyć minimalna liczba ofthreads. Jednak niepotrzebnie zwiększenie tych wartości może spowodować problemy z wydajnością. Jeśli zbyt wiele zadań jest uruchomiona w tym samym czasie, wszystkie z nich wydaje się powoli. W większości przypadków puli wątków będą działać lepiej z własną algorytmu alokacji wątków. Zmniejszanie minimalnej na wartość mniejszą niż liczba procesorów również może pogarszać wydajność.  
  
   
  
## Examples  
 Poniższy przykład Ustawia minimalną liczbę wątków roboczych cztery i zachowa oryginalnej wartości minimalną liczbę asynchronicznych wątków zakończenia We/Wy.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwości, aby kontrolować wątki. Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <see cref="T:System.Threading.NativeOverlapped" /> Struktury do kolejki.</param>
        <summary>Kolejkuje pokrywającej się z inną operacji We/Wy do wykonania.</summary>
        <returns>
          <see langword="true" /> Operacja została pomyślnie umieszczane w kolejce do portu zakończenia We/Wy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacji o korzystaniu z natywnego Win32 pokrywający się we/wy, zobacz <xref:System.Threading.Overlapped> klasy, <xref:System.Threading.NativeOverlapped> struktury i `OVERLAPPED` struktury w zestawie SDK platformy Win32.  
  
> [!CAUTION]
>  Przy użyciu <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> metody przypadkowo może otworzyć się luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, stosu wątku puli wątków nie ma kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący delegata do wywołania, gdy wątek w puli wątków przejmuje elementu roboczego.</param>
        <param name="state">Obiekt, który jest przekazywany do delegata, gdy obsługiwany z puli wątków.</param>
        <summary>Kolejkuje określonego delegata do puli wątków, ale nie propaguje stosu wywołania do wątku roboczego.</summary>
        <returns>
          <see langword="true" /> Jeśli metoda zakończy się pomyślnie; <see cref="T:System.OutOfMemoryException" /> jest generowany, jeśli nie można umieścić w kolejce elementu roboczego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> nie propaguje stosu wywołania do wątku roboczego. Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.  
  
> [!CAUTION]
>  Przy użyciu <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> może spowodować niezamierzoną otwarcia luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, stosu wątku puli wątków nie będą miały kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ApplicationException">Wystąpił stan braku pamięci.</exception>
        <exception cref="T:System.OutOfMemoryException">Element roboczy nie można umieścić w kolejce.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, ale nie propaguje stosu wywołania do wątku roboczego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegat do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</param>
        <param name="state">Obiekt, który jest przekazywany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, przy użyciu 32-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach. Ta metoda nie są propagowane stosu wywołania do wątku roboczego.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołania do wątku roboczego. Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.  
  
> [!CAUTION]
>  Przy użyciu <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może spowodować niezamierzoną otwarcia luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku puli wątków nie będą miały kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.  
  
 Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.  
  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegat do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</param>
        <param name="state">Obiekt, który jest przekazywany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 64-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach. Ta metoda nie są propagowane stosu wywołania do wątku roboczego.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołania do wątku roboczego. Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.  
  
> [!CAUTION]
>  Przy użyciu <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może spowodować niezamierzoną otwarcia luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku puli wątków nie będą miały kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.  
  
 Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.  
  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegat do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</param>
        <param name="state">Obiekt, który jest przekazywany do delegata.</param>
        <param name="timeout">Limit czasu reprezentowany przez <see cref="T:System.TimeSpan" />. Jeśli <c>limitu czasu</c> jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <c>limitu czasu</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określania <see cref="T:System.TimeSpan" /> wartość limitu czasu. Ta metoda nie są propagowane stosu wywołania do wątku roboczego.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołania do wątku roboczego. Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.  
  
> [!CAUTION]
>  Przy użyciu <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może spowodować niezamierzoną otwarcia luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku puli wątków nie będą miały kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.  
  
 Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.  
  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> Parametr jest mniejsza niż -1.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="timeout" /> Parametru jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania. Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegat do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</param>
        <param name="state">Obiekt, który jest przekazywany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</param>
        <summary>Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 32-bitową nieznakowaną liczbą całkowitą wartość limitu czasu w milisekundach. Ta metoda nie są propagowane stosu wywołania do wątku roboczego.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołania do wątku roboczego. Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.  
  
> [!CAUTION]
>  Przy użyciu <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może spowodować niezamierzoną otwarcia luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku puli wątków nie będą miały kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.  
  
 Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.  
  
 Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania. Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
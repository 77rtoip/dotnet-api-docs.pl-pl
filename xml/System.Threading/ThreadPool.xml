<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8063b9e725920384ee53d2c274685bfa60015f9f" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68541856" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Program udostępnia pulę wątków, które mogą służyć do wykonywania zadań, publikowania elementów roboczych, asynchronicznego wejścia/wyjścia procesu, oczekiwania w imieniu innych wątków i przetwarzania czasomierzy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele aplikacji tworzy wątki, które spędzają dużo czasu w stanie uśpienia, czekając na wystąpienie zdarzenia. Inne wątki mogą wejść w stan uśpienia tylko wtedy, gdy będą okresowo sondowane w celu przeszukania zmiany lub aktualizacji informacji o stanie. Pula wątków pozwala wydajniej używać wątków, dostarczając aplikację z pulą wątków roboczych, które są zarządzane przez system. Przykłady operacji korzystających z wątków puli wątków obejmują następujące elementy:  
  
-   Podczas tworzenia <xref:System.Threading.Tasks.Task> obiektu lub <xref:System.Threading.Tasks.Task%601> do wykonywania pewnego zadania asynchronicznie Domyślnie zadanie jest zaplanowane do uruchomienia w wątku puli wątków.  
  
-   Czasomierze asynchroniczne używają puli wątków. Wątki puli wątków wykonują wywołania zwrotne <xref:System.Threading.Timer?displayProperty=nameWithType> z klasy i zgłaszają zdarzenia <xref:System.Timers.Timer?displayProperty=nameWithType> z klasy.  
  
-   W przypadku użycia zarejestrowanych dojść oczekiwania wątek systemowy monitoruje stan dojść oczekiwania. Po zakończeniu operacji oczekiwania wątek roboczy z puli wątków wykonuje odpowiednią funkcję wywołania zwrotnego.  
  
-   Wywołanie <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody w celu zakolejkowania metody do wykonania w wątku puli wątków. W tym celu należy przekazać metodę <xref:System.Threading.WaitCallback> delegata.   Delegat ma sygnaturę  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     gdzie `state` to obiekt, który zawiera dane, które mają być używane przez delegata. Rzeczywiste dane można przekazać do delegata, wywołując <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> metodę.  
  
> [!NOTE]
>  Wątki w puli wątków zarządzanych są wątkiem w tle. Oznacza to, że <xref:System.Threading.Thread.IsBackground%2A> ich właściwości `true`są. Oznacza to, że <xref:System.Threading.ThreadPool> wątek nie będzie utrzymywać aplikacji uruchomionej po zakończeniu wszystkich wątków pierwszego planu.  
  
> [!IMPORTANT]
>  Gdy pula wątków ponownie używa wątku, nie czyści danych w lokalnym magazynie wątków ani w polach, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutem. W związku z tym, gdy Metoda analizuje lokalny magazyn wątków lub pola, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutem, znalezione wartości mogą pozostać poza wcześniejszym użyciem wątku puli wątków.  
  
 Można również kolejkować elementy robocze, które nie są powiązane z operacją oczekiwania do puli wątków. Aby zażądać obsługi elementu pracy przez wątek w puli wątków, wywołaj <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metodę. Ta metoda przyjmuje jako parametr odwołanie do metody lub delegata, który zostanie wywołany przez wątek wybrany z puli wątków. Nie ma możliwości anulowania elementu pracy po jego przejściu do kolejki.  
  
 Czasomierze kolejki i zarejestrowane operacje oczekiwania również używają puli wątków. Funkcje wywołania zwrotnego są umieszczane w kolejce do puli wątków.  
  
 Dla każdego procesu istnieje jedna pula wątków. Począwszy od, domyślny rozmiar puli wątków dla procesu zależy od kilku czynników, takich jak rozmiar wirtualnej przestrzeni adresowej. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Proces może wywołać <xref:System.Threading.ThreadPool.GetMaxThreads%2A> metodę w celu określenia liczby wątków. Liczbę wątków w puli wątków można zmienić za pomocą <xref:System.Threading.ThreadPool.SetMaxThreads%2A> metody. Każdy wątek używa domyślnego rozmiaru stosu i jest uruchamiany przy domyślnym priorytecie.  
  
> [!NOTE]
>  Kod niezarządzany, który hostuje .NET Framework można zmienić rozmiar puli wątków przy użyciu `CorSetMaxThreads` funkcji zdefiniowanej w pliku mscoree. h.  
  
 Pula wątków udostępnia nowe wątki procesów roboczych lub wątki zakończenia operacji we/wy na żądanie do momentu osiągnięcia minimum dla każdej kategorii. Po osiągnięciu minimalnej puli wątków można utworzyć dodatkowe wątki w tej kategorii lub poczekać na zakończenie niektórych zadań. Począwszy od programu [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], Pula wątków tworzy i niszczy wątki robocze w celu zoptymalizowania przepływności, która jest definiowana jako liczba zadań ukończonych na jednostkę czasu. Zbyt mało wątków może nie optymalnie korzystać z dostępnych zasobów, a zbyt wiele wątków może zwiększyć rywalizację o zasoby.  
  
> [!NOTE]
>  Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków puli wątków może spaść poniżej wartości minimalnych.  
  
 Aby uzyskać te wartości <xref:System.Threading.ThreadPool.GetMinThreads%2A> minimalne, można użyć metody.  
  
> [!CAUTION]
>  Możesz użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metody, aby zwiększyć minimalną liczbę wątków. Jednak niekonieczne zwiększenie tych wartości może spowodować problemy z wydajnością. Jeśli zbyt wiele zadań rozpocznie się w tym samym czasie, wszystkie z nich mogą wydawać się wolne. W większości przypadków Pula wątków będzie działać lepiej wraz z własnym algorytmem do alokowania wątków.  
  
   
  
## Examples  
 W poniższym przykładzie główny wątek aplikacji kolejkuje metodę o nazwie `ThreadProc` do wykonania na wątku puli wątków, uśpienia dla jednej sekundy, a następnie kończy. `ThreadProc` Metoda po prostu wyświetla komunikat.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 Jeśli dodajesz komentarz do <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> wywołania metody, główny wątek zostanie zakończony przed uruchomieniem metody w wątku puli wątków.  Pula wątków używa wątków w tle, które nie zachowują działania aplikacji, jeśli wszystkie wątki pierwszego planu zostały zakończone.  (Jest to prosty przykład warunku wyścigu).  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pule zarządzanych wątków</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy powiązanie z uchwytem <see cref="T:System.Threading.ThreadPool" />systemu operacyjnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="osHandle"><see cref="T:System.IntPtr" /> , Który przechowuje uchwyt. Dojście musi być otwarte dla nakładających się operacji we/wy na stronie niezarządzanej.</param>
        <summary>Tworzy powiązanie z uchwytem <see cref="T:System.Threading.ThreadPool" />systemu operacyjnego.</summary>
        <returns><see langword="true" />Jeśli dojście jest powiązane; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania niezarządzanego kodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> który zawiera dojście systemu operacyjnego. Dojście musi być otwarte dla nakładających się operacji we/wy na stronie niezarządzanej.</param>
        <summary>Tworzy powiązanie z uchwytem <see cref="T:System.Threading.ThreadPool" />systemu operacyjnego.</summary>
        <returns><see langword="true" />Jeśli dojście jest powiązane; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr powinien być, który pochodzi z klasy abstrakcyjnej <xref:System.Runtime.InteropServices.SafeHandle>. <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> `osHandle`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="osHandle" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania niezarządzanego kodu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CompletedWorkItemCount">
      <MemberSignature Language="C#" Value="public static long CompletedWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 CompletedWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long CompletedWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedWorkItemCount : int64" Usage="System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów roboczych, które zostały przetworzone do tej pory.</summary>
        <value>Liczba elementów roboczych, które zostały przetworzone do tej pory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

Jeśli implementacja puli wątków może mieć różne typy elementów roboczych, liczba obejmuje wszystkie typy.

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Liczba dostępnych wątków roboczych.</param>
        <param name="completionPortThreads">Liczba dostępnych asynchronicznych wątków we/wy.</param>
        <summary>Pobiera różnicę między maksymalną liczbą wątków puli wątków zwracanych przez <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> metodę i aktualnie aktywną liczbą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> zwraca, zmienna określona przez `workerThreads` zawiera liczbę dodatkowych wątków roboczych, które można uruchomić, a zmienna określona przez `completionPortThreads` zawiera liczbę dodatkowych asynchronicznych wątków we/wy, które mogą być uruchomieniu.  
  
 Jeśli nie ma dostępnych wątków, dodatkowe żądania puli wątków pozostają w kolejce, dopóki nie staną się dostępne wątki puli wątków.  
  
   
  
## Examples  
 Poniższy przykład wyświetla liczbę wątków roboczych i wątków we/wy dostępnych podczas uruchamiania prostej aplikacji.  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Maksymalna liczba wątków roboczych w puli wątków.</param>
        <param name="completionPortThreads">Maksymalna liczba asynchronicznych wątków we/wy w puli wątków.</param>
        <summary>Pobiera liczbę żądań do puli wątków, które mogą być aktywne współbieżnie. Wszystkie żądania powyżej tej liczby pozostają w kolejce, dopóki wątki puli wątków staną się dostępne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Threading.ThreadPool.GetMaxThreads%2A> zwraca, zmienna określona przez `workerThreads` zawiera maksymalną liczbę wątków roboczych dozwoloną w puli wątków, a zmienna określona przez `completionPortThreads` zawiera maksymalną liczbę asynchronicznych wątków we/wy dozwolonych w Pula wątków.  
  
 Można użyć <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> metody do określenia rzeczywistej liczby wątków w puli wątków w danym momencie.  
  
 Można użyć, <xref:System.Threading.ThreadPool.SetMaxThreads%2A> aby ustawić maksymalną liczbę wątków roboczych i asynchronicznych wątków we/wy w puli wątków.  
  
 Można kolejkować dowolną liczbę żądań puli wątków, jak zezwala na ilość pamięci systemowej. Jeśli występuje więcej żądań niż wątki puli wątków, dodatkowe żądania pozostają w kolejce, dopóki wątki puli wątków staną się dostępne.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak pobrać liczbę maksymalną i dostępną liczbę wątków w puli wątków. Element roboczy jest umieszczany w kolejce `FileStream` , który używa do asynchronicznego zapisu do dwóch plików. Metody wywołania zwrotnego czasu są nakładane na siebie. Wątek roboczy obsługuje element roboczy i, w zależności od szybkości i liczby procesorów komputera, jeden lub dwa wątki portów ukończenia obsługują operacje zapisu.  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Gdy ta metoda zwraca, zawiera minimalną liczbę wątków roboczych, które tworzy Pula wątków na żądanie.</param>
        <param name="completionPortThreads">Gdy ta metoda zwraca, zawiera minimalną liczbę asynchronicznych wątków we/wy, które tworzy Pula wątków na żądanie.</param>
        <summary>Pobiera minimalną liczbę wątków, które tworzy Pula wątków na żądanie, jako nowe żądania, przed przełączeniem do algorytmu zarządzania tworzeniem i zniszczeniem wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pula wątków udostępnia nowe wątki procesów roboczych lub wątki zakończenia operacji we/wy na żądanie do momentu osiągnięcia minimum dla każdej kategorii. Domyślnie minimalna liczba wątków jest ustawiona na liczbę procesorów w systemie. Po osiągnięciu wartości minimalnej Pula wątków może utworzyć dodatkowe wątki w tej kategorii lub poczekać na zakończenie niektórych zadań. Począwszy od, Pula wątków tworzy i niszczy wątki w celu zoptymalizowania przepływności, która jest definiowana jako liczba zadań ukończonych na jednostkę czasu. [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] Zbyt mało wątków może nie optymalnie korzystać z dostępnych zasobów, a zbyt wiele wątków może zwiększyć rywalizację o zasoby.  
  
> [!NOTE]
>  Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków puli wątków może spaść poniżej wartości minimalnych.  
  
   
  
## Examples  
 W poniższym przykładzie ustawiono minimalną liczbę wątków roboczych na cztery i zachowuje oryginalną wartość dla minimalnej liczby asynchronicznych wątków ukończenia operacji we/wy.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="PendingWorkItemCount">
      <MemberSignature Language="C#" Value="public static long PendingWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 PendingWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PendingWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long PendingWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PendingWorkItemCount : int64" Usage="System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów roboczych, które są obecnie umieszczane w kolejce do przetworzenia.</summary>
        <value>Liczba elementów roboczych, które są obecnie umieszczane w kolejce do przetworzenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

Jeśli implementacja puli wątków może mieć różne typy elementów roboczych, liczba obejmuje wszystkie typy, które mogą być śledzone, które mogą być tylko elementami roboczymi użytkownika, w tym zadaniami. Niektóre implementacje mogą również obejmować czasomierz w kolejce i oczekiwać wywołania zwrotnego w liczniku. W systemie Windows licznik jest mało prawdopodobne, aby uwzględnić liczbę oczekujących operacji we/wy, ponieważ są one wysyłane bezpośrednio do portu ukończenia we/wy.

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kolejkuje metodę do wykonania. Metoda jest wykonywana po udostępnieniu wątku puli wątków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">Reprezentuje <see cref="T:System.Threading.WaitCallback" /> metodę, która ma zostać wykonana.</param>
        <summary>Kolejkuje metodę do wykonania. Metoda jest wykonywana po udostępnieniu wątku puli wątków.</summary>
        <returns><see langword="true" />Jeśli metoda została pomyślnie umieszczona w kolejce; <see cref="T:System.NotSupportedException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane wymagane przez metodę znajdującą się w kolejce można umieścić w polach wystąpienia klasy, w której jest zdefiniowana Metoda, lub użyć <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> przeciążenia, które akceptuje obiekt zawierający niezbędne dane.  
  
> [!NOTE]
>  Visual Basic użytkownicy mogą pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu `AddressOf` użyć operatora podczas przekazywania metody wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic automatycznie wywołuje poprawnego konstruktora delegatów.  
  
## <a name="version-information"></a>Informacje o wersji  
 W .NET Framework w wersji 2,0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> przy użyciu metody. We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> Przeciążenie metody do kolejki zadania, które jest reprezentowane `ThreadProc` przez metodę, do wykonania, gdy wątek będzie dostępny. Z tym przeciążeniem nie dostarczono informacji o zadaniu. W związku z tym informacje dostępne dla `ThreadProc` metody są ograniczone do obiektu, do którego należy Metoda.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Środowisko uruchomieniowe języka wspólnego (CLR) jest hostowane i host nie obsługuje tej akcji.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><see cref="T:System.Threading.WaitCallback" /> Reprezentująca metodę do wykonania.</param>
        <param name="state">Obiekt zawierający dane, które mają być używane przez metodę.</param>
        <summary>Kolejkuje metodę do wykonania i określa obiekt zawierający dane, które mają być używane przez metodę. Metoda jest wykonywana po udostępnieniu wątku puli wątków.</summary>
        <returns><see langword="true" />Jeśli metoda została pomyślnie umieszczona w kolejce; <see cref="T:System.NotSupportedException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda wywołania zwrotnego wymaga złożonych danych, można zdefiniować klasę zawierającą dane.  
  
> [!NOTE]
>  Visual Basic użytkownicy mogą pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu `AddressOf` użyć operatora podczas przekazywania metody wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic automatycznie wywołuje poprawnego konstruktora delegatów.  
  
## <a name="version-information"></a>Informacje o wersji  
 W .NET Framework w wersji 2,0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> przy użyciu metody. We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.  
  
   
  
## Examples  
 Poniższy przykład używa puli wątków .NET, aby obliczyć `Fibonacci` wynik pięciu liczb z zakresu od 20 do 40. Każdy `Fibonacci` wynik jest reprezentowany `Fibonacci` przez klasę, która dostarcza metodę o nazwie `ThreadPoolCallback` , która wykonuje obliczenia. Obiekt, który reprezentuje każdą `Fibonacci` wartość, jest tworzony, `ThreadPoolCallback` a metoda jest przenoszona <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>do, która przypisuje dostępny wątek w puli, aby wykonać metodę.  
  
 Ponieważ każdy `Fibonacci` obiekt otrzymuje średnią wartość do obliczenia, a ponieważ każdy wątek będzie konkurencyjny dla czasu procesora, nie można dowiedzieć się z wyprzedzeniem, jak długo będzie trwać dla wszystkich pięciu wyników. To dlatego, że `Fibonacci` każdy obiekt jest przekazywać wystąpienie <xref:System.Threading.ManualResetEvent> klasy podczas konstruowania. Każdy obiekt sygnalizuje podanemu obiektowi zdarzenia po zakończeniu obliczeń, co umożliwia wątkom głównym blokowanie wykonywania <xref:System.Threading.WaitHandle.WaitAll%2A> , dopóki wszystkie pięć `Fibonacci` obiektów nie wyliczy wynik. Następnie Metoda wyświetla każdy `Fibonacci`wynik. `Main`
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Środowisko uruchomieniowe języka wspólnego (CLR) jest hostowane i host nie obsługuje tej akcji.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" />jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Typ elementów <paramref name="state" />.</typeparam>
        <param name="callBack"><see cref="T:System.Action`1" /> Reprezentująca metodę do wykonania.</param>
        <param name="state">Obiekt zawierający dane, które mają być używane przez metodę.</param>
        <param name="preferLocal"><see langword="true" />Aby preferować kolejkowanie elementu pracy w kolejce blisko bieżącego wątku; <see langword="false" /> aby preferować kolejkowanie elementu pracy do kolejki udostępnionej puli wątków.</param>
        <summary>Kolejkuje metodę określoną przez <see cref="T:System.Action`1" /> delegata do wykonania i dostarcza dane, które mają być używane przez metodę. Metoda jest wykonywana po udostępnieniu wątku puli wątków.</summary>
        <returns><see langword="true" />Jeśli metoda została pomyślnie umieszczona w kolejce; <see cref="T:System.NotSupportedException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje delegata, który oczekuje na <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji. Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></param>
        <param name="callBack">Delegat do wywołania <paramref name="waitObject" /> po zasygnalizowaniu parametru. <see cref="T:System.Threading.WaitOrTimerCallback" /></param>
        <param name="state">Obiekt, który jest przesyłany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. <paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość. Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</param>
        <param name="executeOnlyOnce"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</param>
        <summary>Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na, określając 32-bitową liczbę całkowitą ze znakiem dla limitu czasu w milisekundach.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> To hermetyzuje uchwyt macierzysty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania. Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda kolejkuje określony delegat do puli wątków. Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących wystąpień:  
  
-   Określony obiekt jest w stanie zasygnalizowane.  
  
-   Upłynął limit czasu.  
  
 Metoda sprawdza bieżący stan określonego <xref:System.Threading.WaitHandle>obiektu. <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Jeśli stan obiektu jest Niesygnalizowane, Metoda rejestruje operację oczekiwania. Operacja oczekiwania jest wykonywana przez wątek z puli wątków. Delegat jest wykonywany przez wątek roboczy, gdy stan obiektu zostanie zasygnalizowania lub upłynie interwał limitu czasu. Jeśli parametr nie ma wartości 0 (zero), `executeOnlyOnce` a parametr ma `false`wartość, czasomierz jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane, lub upłynął limit czasu. `timeOutInterval`  
  
> [!IMPORTANT]
>  Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków. Zamiast elementu <xref:System.Threading.Mutex>należy <xref:System.Threading.Semaphore> używać z maksymalną liczbą 1.  
  
 Aby anulować operację oczekiwania, wywołaj <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę.  
  
 Wątek oczekiwania używa funkcji Win32 `WaitForMultipleObjects` do monitorowania zarejestrowanych operacji oczekiwania. W związku z tym, jeśli konieczne jest użycie tego samego natywnego uchwytu systemu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>operacyjnego w wielu wywołaniach do, należy zduplikować `DuplicateHandle` uchwyt przy użyciu funkcji Win32. Należy zauważyć, że nie należy przekazywać obiektu zdarzenia do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania może nie wykryć, że zdarzenie jest sygnalizowane przed zresetowaniem.  
  
 Przed zwróceniem funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja odbywa się tylko dla obiektu, którego stan sygnału spowodował spełnienie warunku oczekiwania. Na przykład liczba semaforów jest mniejsza o jeden.  
  
## <a name="version-information"></a>Informacje o wersji  
 Począwszy od .NET Framework w wersji 2,0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> przy użyciu metody. We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejszy niż-1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji. Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></param>
        <param name="callBack">Delegat do wywołania <paramref name="waitObject" /> po zasygnalizowaniu parametru. <see cref="T:System.Threading.WaitOrTimerCallback" /></param>
        <param name="state">Obiekt przeszedł do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. <paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość. Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</param>
        <param name="executeOnlyOnce"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</param>
        <summary>Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na, określając 64-bitową liczbę całkowitą ze znakiem dla limitu czasu w milisekundach.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> To hermetyzuje uchwyt macierzysty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania. Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda kolejkuje określony delegat do puli wątków. Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących wystąpień:  
  
-   Określony obiekt jest w stanie zasygnalizowane.  
  
-   Upłynął limit czasu.  
  
 Metoda sprawdza bieżący stan określonego <xref:System.Threading.WaitHandle>obiektu. <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Jeśli stan obiektu jest Niesygnalizowane, Metoda rejestruje operację oczekiwania. Operacja oczekiwania jest wykonywana przez wątek z puli wątków. Delegat jest wykonywany przez wątek roboczy, gdy stan obiektu zostanie zasygnalizowania lub upłynie interwał limitu czasu. Jeśli parametr nie ma wartości 0 (zero), `executeOnlyOnce` a parametr ma `false`wartość, czasomierz jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane, lub upłynął limit czasu. `timeOutInterval`  
  
> [!IMPORTANT]
>  Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków. Zamiast elementu <xref:System.Threading.Mutex>należy <xref:System.Threading.Semaphore> używać z maksymalną liczbą 1.  
  
 Aby anulować operację oczekiwania, wywołaj <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę.  
  
 Wątek oczekiwania używa funkcji Win32 `WaitForMultipleObjects` do monitorowania zarejestrowanych operacji oczekiwania. W związku z tym, jeśli konieczne jest użycie tego samego natywnego uchwytu systemu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>operacyjnego w wielu wywołaniach do, należy zduplikować `DuplicateHandle` uchwyt przy użyciu funkcji Win32. Należy zauważyć, że nie należy przekazywać obiektu zdarzenia do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania może nie wykryć, że zdarzenie jest sygnalizowane przed zresetowaniem.  
  
 Przed zwróceniem funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja odbywa się tylko dla obiektu, którego stan sygnału spowodował spełnienie warunku oczekiwania. Na przykład liczba semaforów jest mniejsza o jeden.  
  
## <a name="version-information"></a>Informacje o wersji  
 Począwszy od .NET Framework w wersji 2,0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> przy użyciu metody. We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejszy niż-1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji. Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></param>
        <param name="callBack">Delegat do wywołania <paramref name="waitObject" /> po zasygnalizowaniu parametru. <see cref="T:System.Threading.WaitOrTimerCallback" /></param>
        <param name="state">Obiekt przeszedł do delegata.</param>
        <param name="timeout">Limit czasu reprezentowany przez <see cref="T:System.TimeSpan" />. Jeśli <paramref name="timeout" /> jest równa 0 (zero), funkcja testuje stan obiektu i natychmiast wraca. Jeśli <paramref name="timeout" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</param>
        <param name="executeOnlyOnce"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</param>
        <summary>Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na <see cref="T:System.TimeSpan" /> określenie wartości limitu czasu.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> To hermetyzuje uchwyt macierzysty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania. Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda kolejkuje określony delegat do puli wątków. Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących wystąpień:  
  
-   Określony obiekt jest w stanie zasygnalizowane.  
  
-   Upłynął limit czasu.  
  
 Metoda sprawdza bieżący stan określonego <xref:System.Threading.WaitHandle>obiektu. <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Jeśli stan obiektu jest Niesygnalizowane, Metoda rejestruje operację oczekiwania. Operacja oczekiwania jest wykonywana przez wątek z puli wątków. Delegat jest wykonywany przez wątek roboczy, gdy stan obiektu zostanie zasygnalizowania lub upłynie interwał limitu czasu. Jeśli parametr nie ma wartości 0 (zero), `executeOnlyOnce` a parametr ma `false`wartość, czasomierz jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane, lub upłynął limit czasu. `timeOutInterval`  
  
> [!IMPORTANT]
>  Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków. Zamiast elementu <xref:System.Threading.Mutex>należy <xref:System.Threading.Semaphore> używać z maksymalną liczbą 1.  
  
 Aby anulować operację oczekiwania, wywołaj <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę.  
  
 Wątek oczekiwania używa funkcji Win32 `WaitForMultipleObjects` do monitorowania zarejestrowanych operacji oczekiwania. W związku z tym, jeśli konieczne jest użycie tego samego natywnego uchwytu systemu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>operacyjnego w wielu wywołaniach do, należy zduplikować `DuplicateHandle` uchwyt przy użyciu funkcji Win32. Należy zauważyć, że nie należy przekazywać obiektu zdarzenia do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania może nie wykryć, że zdarzenie jest sygnalizowane przed zresetowaniem.  
  
 Przed zwróceniem funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja odbywa się tylko dla obiektu, którego stan sygnału spowodował spełnienie warunku oczekiwania. Na przykład liczba semaforów jest mniejsza o jeden.  
  
## <a name="version-information"></a>Informacje o wersji  
 Począwszy od .NET Framework w wersji 2,0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> przy użyciu metody. We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> Parametr jest mniejszy niż-1.</exception>
        <exception cref="T:System.NotSupportedException">Parametr jest większy niż <see cref="F:System.Int32.MaxValue" />. <paramref name="timeout" /></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji. Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></param>
        <param name="callBack">Delegat do wywołania <paramref name="waitObject" /> po zasygnalizowaniu parametru. <see cref="T:System.Threading.WaitOrTimerCallback" /></param>
        <param name="state">Obiekt przeszedł do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. <paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość. Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</param>
        <param name="executeOnlyOnce"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</param>
        <summary>Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na, określając 32-bitową liczbę całkowitą bez znaku dla limitu czasu w milisekundach.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Służy do anulowania zarejestrowanej operacji oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania. Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda kolejkuje określony delegat do puli wątków. Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących wystąpień:  
  
-   Określony obiekt jest w stanie zasygnalizowane.  
  
-   Upłynął limit czasu.  
  
 Metoda sprawdza bieżący stan określonego <xref:System.Threading.WaitHandle>obiektu. <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Jeśli stan obiektu jest Niesygnalizowane, Metoda rejestruje operację oczekiwania. Operacja oczekiwania jest wykonywana przez wątek z puli wątków. Delegat jest wykonywany przez wątek roboczy, gdy stan obiektu zostanie zasygnalizowania lub upłynie interwał limitu czasu. Jeśli parametr nie ma wartości 0 (zero), `executeOnlyOnce` a parametr ma `false`wartość, czasomierz jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane, lub upłynął limit czasu. `timeOutInterval`  
  
> [!IMPORTANT]
>  Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków. Zamiast elementu <xref:System.Threading.Mutex>należy <xref:System.Threading.Semaphore> używać z maksymalną liczbą 1.  
  
 Aby anulować operację oczekiwania, wywołaj <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę.  
  
 Wątek oczekiwania używa funkcji Win32 `WaitForMultipleObjects` do monitorowania zarejestrowanych operacji oczekiwania. W związku z tym, jeśli konieczne jest użycie tego samego natywnego uchwytu systemu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>operacyjnego w wielu wywołaniach do, należy zduplikować `DuplicateHandle` uchwyt przy użyciu funkcji Win32. Należy zauważyć, że nie należy przekazywać obiektu zdarzenia do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania może nie wykryć, że zdarzenie jest sygnalizowane przed zresetowaniem.  
  
 Przed zwróceniem funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja odbywa się tylko dla obiektu, którego stan sygnału spowodował spełnienie warunku oczekiwania. Na przykład liczba semaforów jest mniejsza o jeden.  
  
## <a name="version-information"></a>Informacje o wersji  
 Począwszy od .NET Framework w wersji 2,0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> przy użyciu metody. We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> jak używać metody do wykonywania określonej metody wywołania zwrotnego, gdy zostanie zasygnalizowani określone dojście oczekiwania. W tym przykładzie metoda wywołania zwrotnego ma `WaitProc`wartość, a uchwyt oczekiwania <xref:System.Threading.AutoResetEvent>to.  
  
 W przykładzie zdefiniowano `TaskInfo` klasę zawierającą informacje, które są przesyłane do wywołania zwrotnego, gdy jest ono wykonywane. Przykład tworzy `TaskInfo` obiekt i przypisuje mu niektóre dane ciągu. Wartość <xref:System.Threading.RegisteredWaitHandle> zwracana `TaskInfo` <xref:System.Threading.RegisteredWaitHandle>przez <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodęjestprzypisywanadopolaobiektu,takabyMetoda`Handle` wywołania zwrotnego miała dostęp do.  
  
 Oprócz `TaskInfo` określania jako obiektu, który ma zostać przekazany do metody wywołania zwrotnego, wywołanie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody Określa <xref:System.Threading.AutoResetEvent> <xref:System.Threading.WaitOrTimerCallback> , że zadanie będzie `WaitProc` oczekiwać dla, delegata, który reprezentuje metodę wywołania zwrotnego, a Drugi interwał limitu czasu i wiele wywołań zwrotnych.  
  
 Gdy główny wątek sygnalizuje <xref:System.Threading.AutoResetEvent> <xref:System.Threading.EventWaitHandle.Set%2A> wywołanie metody, <xref:System.Threading.WaitOrTimerCallback> obiekt delegowany jest wywoływany. Metoda `WaitProc` sprawdza<xref:System.Threading.RegisteredWaitHandle> , czy wystąpiło przekroczenie limitu czasu. Jeśli wywołanie zwrotne zostało wywołane ze względu na to, że `WaitProc` dojście oczekiwania zostało zasygnalizowane, Metoda wyrejestruje <xref:System.Threading.RegisteredWaitHandle>, zatrzymując dodatkowe wywołania zwrotne. W przypadku przekroczenia limitu czasu zadanie kontynuuje oczekiwanie. `WaitProc` Metoda zostaje zakończona, drukując komunikat do konsoli.  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejszy niż-1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Maksymalna liczba wątków roboczych w puli wątków.</param>
        <param name="completionPortThreads">Maksymalna liczba asynchronicznych wątków we/wy w puli wątków.</param>
        <summary>Ustawia liczbę żądań do puli wątków, które mogą być aktywne współbieżnie. Wszystkie żądania powyżej tej liczby pozostają w kolejce, dopóki wątki puli wątków staną się dostępne.</summary>
        <returns><see langword="true" />Jeśli zmiana zakończyła się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można ustawić maksymalnej liczby wątków roboczych lub wątków zakończenia operacji we/wy na liczbę mniejszą niż liczba procesorów na komputerze. Aby określić liczbę procesorów, należy pobrać wartość <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> właściwości. Ponadto nie można ustawić maksymalnej liczby wątków roboczych lub wątków uzupełniania we/wy na liczbę mniejszą niż odpowiadająca im minimalna liczba wątków roboczych lub wątki zakończenia operacji we/wy. Aby określić minimalny rozmiar puli wątków, wywołaj <xref:System.Threading.ThreadPool.GetMinThreads%2A> metodę.  
  
 Jeśli środowisko uruchomieniowe języka wspólnego jest hostowane, na przykład przez Internet Information Services (IIS) lub SQL Server, host może ograniczyć lub uniemożliwić zmiany rozmiaru puli wątków.  
  
 Należy zachować ostrożność w przypadku zmiany maksymalnej liczby wątków w puli wątków. Chociaż kod może korzystać z programu, zmiany mogą mieć niekorzystny wpływ na biblioteki kodu, których używasz.  
  
 Ustawienie zbyt dużego rozmiaru puli wątków może spowodować problemy z wydajnością. W przypadku wykonywania zbyt wielu wątków w tym samym czasie narzuty przełączenia zadań staną się istotnym czynnikiem.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla zdolności kontroli wątków. Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Minimalna liczba wątków roboczych, które tworzy Pula wątków na żądanie.</param>
        <param name="completionPortThreads">Minimalna liczba asynchronicznych wątków we/wy, które tworzy Pula wątków na żądanie.</param>
        <summary>Ustawia minimalną liczbę wątków tworzonych przez pulę wątków na żądanie, w miarę tworzenia nowych żądań przed przełączeniem do algorytmu zarządzania tworzeniem i zniszczeniem wątku.</summary>
        <returns><see langword="true" />Jeśli zmiana zakończyła się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pula wątków udostępnia nowe wątki procesów roboczych lub wątki zakończenia operacji we/wy na żądanie do momentu osiągnięcia minimum dla każdej kategorii. Po osiągnięciu wartości minimalnej Pula wątków może utworzyć dodatkowe wątki w tej kategorii lub poczekać na zakończenie niektórych zadań. Począwszy od, Pula wątków tworzy i niszczy wątki w celu zoptymalizowania przepływności, która jest definiowana jako liczba zadań ukończonych na jednostkę czasu. [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] Zbyt mało wątków może nie optymalnie korzystać z dostępnych zasobów, a zbyt wiele wątków może zwiększyć rywalizację o zasoby.  
  
 Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków puli wątków może spaść poniżej wartości minimalnych.  
  
 Jeśli zostanie określona liczba ujemna lub liczba większa niż maksymalna liczba aktywnych wątków puli wątków (uzyskanych za pomocą <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), program <xref:System.Threading.ThreadPool.SetMinThreads%2A> zwraca `false` i nie zmienia żadnej wartości minimalnej.  
  
> [!CAUTION]
>  Domyślnie minimalna liczba wątków jest ustawiona na liczbę procesorów w systemie. Możesz użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metody, aby zwiększyć minimalną liczbę wątków. Jednak niekonieczne zwiększenie tych wartości może spowodować problemy z wydajnością. Jeśli zbyt wiele zadań rozpocznie się w tym samym czasie, wszystkie z nich mogą wydawać się wolne. W większości przypadków Pula wątków będzie działać lepiej wraz z własnym algorytmem do alokowania wątków. Zmniejszenie wartości minimalnej do mniejszej niż liczba procesorów może również obniżyć wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie ustawiono minimalną liczbę wątków roboczych na cztery i zachowuje oryginalną wartość dla minimalnej liczby asynchronicznych wątków ukończenia operacji we/wy.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla zdolności kontroli wątków. Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="ThreadCount">
      <MemberSignature Language="C#" Value="public static int ThreadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ThreadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.ThreadCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ThreadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ThreadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadCount : int" Usage="System.Threading.ThreadPool.ThreadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę wątków puli wątków, które obecnie istnieją.</summary>
        <value>Liczba wątków puli wątków, które obecnie istnieją.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

Jeśli implementacja puli wątków może mieć różne typy wątków, liczba obejmuje wszystkie typy.

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="overlapped"><see cref="T:System.Threading.NativeOverlapped" /> Struktura do kolejki.</param>
        <summary>Kolejkuje przychodzącą operację we/wy do wykonania.</summary>
        <returns><see langword="true" />Jeśli operacja została pomyślnie umieszczona w kolejce do portu zakończenia we/wy; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje na temat korzystania z natywnego środowiska Win32 z nakładaniem <xref:System.Threading.Overlapped> operacji we/ <xref:System.Threading.NativeOverlapped> wy, zobacz Klasa `OVERLAPPED` , struktura i struktura w zestawie SDK platformy Win32.  
  
> [!CAUTION]
>  <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> Użycie metody może przypadkowo otworzyć otwór w zabezpieczeniach. Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie. Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>użyciu, stos wątku puli wątków nie ma kontekstu rzeczywistych wywołujących. Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack">Element roboczy do wywołania, gdy wątek w puli wątków Pobiera element roboczy.</param>
        <param name="preferLocal"><see langword="true" />Aby preferować kolejkowanie elementu pracy w kolejce blisko bieżącego wątku; <see langword="false" /> aby preferować kolejkowanie elementu pracy do kolejki udostępnionej puli wątków.</param>
        <summary>Kolejkuje określony obiekt elementu pracy w puli wątków.</summary>
        <returns><see langword="true" />Jeśli metoda się powiedzie; <see cref="T:System.OutOfMemoryException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Pula wątków wywoła <xref:System.Threading.IThreadPoolWorkItem.Execute> metodę elementu pracy. Jest odpowiedzialny za ten element roboczy do propagowania <xref:System.Threading.ExecutionContext> , jeśli jest to konieczne; Pula wątków nie zostanie tak przełączona.

         ]]></format>
       </remarks>
         <exception cref="T:System.ArgumentNullException"><paramref name="callback" />jest <see langword="null" />.</exception>
         <exception cref="T:System.ArgumentOutOfRangeException">Element roboczy jest <see cref="T:System.Threading.Tasks.Task" />.</exception>
         <exception cref="T:System.OutOfMemoryException">Nie można umieścić w kolejce elementu pracy.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callBack"><see cref="T:System.Threading.WaitCallback" /> Reprezentujący delegata do wywołania, gdy wątek w puli wątków Pobiera element roboczy.</param>
        <param name="state">Obiekt, który jest przesyłany do delegata, gdy jest obsługiwany z puli wątków.</param>
        <summary>Kolejkuje określonego delegata do puli wątków, ale nie propaguje stosu wywołań do wątku roboczego.</summary>
        <returns><see langword="true" />Jeśli metoda się powiedzie; <see cref="T:System.OutOfMemoryException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> do metody <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> , nie propaguje stosu wywołań do wątku roboczego. Dzięki temu kod może utracić stos wywołań i w związku z tym podwyższyć poziom uprawnień zabezpieczeń.  
  
> [!CAUTION]
>  Korzystanie <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> z programu może przypadkowo otworzyć otwór w zabezpieczeniach. Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie. Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>użyciu, stos wątku puli wątków nie będzie miał kontekstu rzeczywistych wywołujących. Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ApplicationException">Napotkano warunek braku pamięci.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie można umieścić w kolejce elementu pracy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Typ elementów <paramref name="state" />.</typeparam>
        <param name="callBack">Delegat reprezentujący metodę do wykonania.</param>
        <param name="state">Obiekt zawierający dane, które mają być używane przez metodę.</param>
        <param name="preferLocal"><see langword="true" />Aby preferować kolejkowanie elementu pracy w kolejce blisko bieżącego wątku; <see langword="false" /> aby preferować kolejkowanie elementu pracy do kolejki udostępnionej puli wątków.</param>
        <summary>Kolejkuje metodę określoną przez <see cref="T:System.Action`1" /> delegata do wykonania i określa obiekt zawierający dane, które mają być używane przez metodę. Metoda jest wykonywana po udostępnieniu wątku puli wątków.</summary>
        <returns><see langword="true" />Jeśli metoda została pomyślnie umieszczona w kolejce; <see cref="T:System.NotSupportedException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Nie można umieścić w kolejce elementu pracy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje delegata w celu oczekiwania na <see cref="T:System.Threading.WaitHandle" />, ale nie propaguje stosu wywołań do wątku roboczego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji. Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></param>
        <param name="callBack">Delegat do wywołania po <paramref name="waitObject" /> zasygnalizowaniu parametru.</param>
        <param name="state">Obiekt, który jest przesyłany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. <paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość. Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</param>
        <param name="executeOnlyOnce"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</param>
        <summary>Rejestruje delegata <see cref="T:System.Threading.WaitHandle" />, aby czekał na, przy użyciu 32-bitowej ze znakiem liczby całkowitej, aby przekroczyć limit czasu w milisekundach. Ta metoda nie propaguje stosu wywołań do wątku roboczego.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiekt, którego można użyć do anulowania zarejestrowanej operacji oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> do metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> , nie propaguje stosu wywołań do wątku roboczego. Dzięki temu kod może utracić stos wywołań i w związku z tym podwyższyć poziom uprawnień zabezpieczeń.  
  
> [!CAUTION]
>  Korzystanie <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> z programu może przypadkowo otworzyć otwór w zabezpieczeniach. Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie. Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>użyciu, stos wątku puli wątków nie będzie miał kontekstu rzeczywistych wywołujących. Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.  
  
 Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.  
  
 Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania. Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejszy niż-1.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji. Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></param>
        <param name="callBack">Delegat do wywołania po <paramref name="waitObject" /> zasygnalizowaniu parametru.</param>
        <param name="state">Obiekt, który jest przesyłany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. <paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość. Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</param>
        <param name="executeOnlyOnce"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</param>
        <summary>Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na, określając 64-bitową liczbę całkowitą ze znakiem dla limitu czasu w milisekundach. Ta metoda nie propaguje stosu wywołań do wątku roboczego.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiekt, którego można użyć do anulowania zarejestrowanej operacji oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> do metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> , nie propaguje stosu wywołań do wątku roboczego. Dzięki temu kod może utracić stos wywołań i w związku z tym podwyższyć poziom uprawnień zabezpieczeń.  
  
> [!CAUTION]
>  Korzystanie <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> z programu może przypadkowo otworzyć otwór w zabezpieczeniach. Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie. Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>użyciu, stos wątku puli wątków nie będzie miał kontekstu rzeczywistych wywołujących. Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.  
  
 Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.  
  
 Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania. Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejszy niż-1.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji. Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></param>
        <param name="callBack">Delegat do wywołania po <paramref name="waitObject" /> zasygnalizowaniu parametru.</param>
        <param name="state">Obiekt, który jest przesyłany do delegata.</param>
        <param name="timeout">Limit czasu reprezentowany przez <see cref="T:System.TimeSpan" />. Jeśli <paramref name="timeout" /> jest równa 0 (zero), funkcja testuje stan obiektu i natychmiast wraca. Jeśli <paramref name="timeout" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</param>
        <param name="executeOnlyOnce"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</param>
        <summary>Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na <see cref="T:System.TimeSpan" /> określenie wartości limitu czasu. Ta metoda nie propaguje stosu wywołań do wątku roboczego.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiekt, którego można użyć do anulowania zarejestrowanej operacji oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> do metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> , nie propaguje stosu wywołań do wątku roboczego. Dzięki temu kod może utracić stos wywołań i w związku z tym podwyższyć poziom uprawnień zabezpieczeń.  
  
> [!CAUTION]
>  Korzystanie <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> z programu może przypadkowo otworzyć otwór w zabezpieczeniach. Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie. Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>użyciu, stos wątku puli wątków nie będzie miał kontekstu rzeczywistych wywołujących. Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.  
  
 Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.  
  
 Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania. Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> Parametr jest mniejszy niż-1.</exception>
        <exception cref="T:System.NotSupportedException">Parametr jest większy niż <see cref="F:System.Int32.MaxValue" />. <paramref name="timeout" /></exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji. Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></param>
        <param name="callBack">Delegat do wywołania po <paramref name="waitObject" /> zasygnalizowaniu parametru.</param>
        <param name="state">Obiekt, który jest przesyłany do delegata.</param>
        <param name="millisecondsTimeOutInterval">Limit czasu w milisekundach. <paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość. Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</param>
        <param name="executeOnlyOnce"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</param>
        <summary>Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na, określając 32-bitową liczbę całkowitą bez znaku dla limitu czasu w milisekundach. Ta metoda nie propaguje stosu wywołań do wątku roboczego.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiekt, którego można użyć do anulowania zarejestrowanej operacji oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> do metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> , nie propaguje stosu wywołań do wątku roboczego. Dzięki temu kod może utracić stos wywołań i w związku z tym podwyższyć poziom uprawnień zabezpieczeń.  
  
> [!CAUTION]
>  Korzystanie <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> z programu może przypadkowo otworzyć otwór w zabezpieczeniach. Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie. Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>użyciu, stos wątku puli wątków nie będzie miał kontekstu rzeczywistych wywołujących. Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.  
  
 Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.  
  
 Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania. Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`. Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
  </Members>
</Type>
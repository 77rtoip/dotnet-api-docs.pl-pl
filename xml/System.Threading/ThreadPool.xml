<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8063b9e725920384ee53d2c274685bfa60015f9f" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68541856" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="fd181-101">Program udostępnia pulę wątków, które mogą służyć do wykonywania zadań, publikowania elementów roboczych, asynchronicznego wejścia/wyjścia procesu, oczekiwania w imieniu innych wątków i przetwarzania czasomierzy.</span><span class="sxs-lookup"><span data-stu-id="fd181-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-102">Wiele aplikacji tworzy wątki, które spędzają dużo czasu w stanie uśpienia, czekając na wystąpienie zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="fd181-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="fd181-103">Inne wątki mogą wejść w stan uśpienia tylko wtedy, gdy będą okresowo sondowane w celu przeszukania zmiany lub aktualizacji informacji o stanie.</span><span class="sxs-lookup"><span data-stu-id="fd181-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="fd181-104">Pula wątków pozwala wydajniej używać wątków, dostarczając aplikację z pulą wątków roboczych, które są zarządzane przez system.</span><span class="sxs-lookup"><span data-stu-id="fd181-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="fd181-105">Przykłady operacji korzystających z wątków puli wątków obejmują następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="fd181-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="fd181-106">Podczas tworzenia <xref:System.Threading.Tasks.Task> obiektu lub <xref:System.Threading.Tasks.Task%601> do wykonywania pewnego zadania asynchronicznie Domyślnie zadanie jest zaplanowane do uruchomienia w wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="fd181-107">Czasomierze asynchroniczne używają puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="fd181-108">Wątki puli wątków wykonują wywołania zwrotne <xref:System.Threading.Timer?displayProperty=nameWithType> z klasy i zgłaszają zdarzenia <xref:System.Timers.Timer?displayProperty=nameWithType> z klasy.</span><span class="sxs-lookup"><span data-stu-id="fd181-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="fd181-109">W przypadku użycia zarejestrowanych dojść oczekiwania wątek systemowy monitoruje stan dojść oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="fd181-110">Po zakończeniu operacji oczekiwania wątek roboczy z puli wątków wykonuje odpowiednią funkcję wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="fd181-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="fd181-111">Wywołanie <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody w celu zakolejkowania metody do wykonania w wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="fd181-112">W tym celu należy przekazać metodę <xref:System.Threading.WaitCallback> delegata.</span><span class="sxs-lookup"><span data-stu-id="fd181-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="fd181-113">Delegat ma sygnaturę</span><span class="sxs-lookup"><span data-stu-id="fd181-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="fd181-114">gdzie `state` to obiekt, który zawiera dane, które mają być używane przez delegata.</span><span class="sxs-lookup"><span data-stu-id="fd181-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="fd181-115">Rzeczywiste dane można przekazać do delegata, wywołując <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd181-116">Wątki w puli wątków zarządzanych są wątkiem w tle.</span><span class="sxs-lookup"><span data-stu-id="fd181-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="fd181-117">Oznacza to, że <xref:System.Threading.Thread.IsBackground%2A> ich właściwości `true`są.</span><span class="sxs-lookup"><span data-stu-id="fd181-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="fd181-118">Oznacza to, że <xref:System.Threading.ThreadPool> wątek nie będzie utrzymywać aplikacji uruchomionej po zakończeniu wszystkich wątków pierwszego planu.</span><span class="sxs-lookup"><span data-stu-id="fd181-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="fd181-119">Gdy pula wątków ponownie używa wątku, nie czyści danych w lokalnym magazynie wątków ani w polach, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutem.</span><span class="sxs-lookup"><span data-stu-id="fd181-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="fd181-120">W związku z tym, gdy Metoda analizuje lokalny magazyn wątków lub pola, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutem, znalezione wartości mogą pozostać poza wcześniejszym użyciem wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="fd181-121">Można również kolejkować elementy robocze, które nie są powiązane z operacją oczekiwania do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="fd181-122">Aby zażądać obsługi elementu pracy przez wątek w puli wątków, wywołaj <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="fd181-123">Ta metoda przyjmuje jako parametr odwołanie do metody lub delegata, który zostanie wywołany przez wątek wybrany z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="fd181-124">Nie ma możliwości anulowania elementu pracy po jego przejściu do kolejki.</span><span class="sxs-lookup"><span data-stu-id="fd181-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="fd181-125">Czasomierze kolejki i zarejestrowane operacje oczekiwania również używają puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="fd181-126">Funkcje wywołania zwrotnego są umieszczane w kolejce do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="fd181-127">Dla każdego procesu istnieje jedna pula wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-127">There is one thread pool per process.</span></span> <span data-ttu-id="fd181-128">Począwszy od, domyślny rozmiar puli wątków dla procesu zależy od kilku czynników, takich jak rozmiar wirtualnej przestrzeni adresowej. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="fd181-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="fd181-129">Proces może wywołać <xref:System.Threading.ThreadPool.GetMaxThreads%2A> metodę w celu określenia liczby wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="fd181-130">Liczbę wątków w puli wątków można zmienić za pomocą <xref:System.Threading.ThreadPool.SetMaxThreads%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="fd181-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="fd181-131">Każdy wątek używa domyślnego rozmiaru stosu i jest uruchamiany przy domyślnym priorytecie.</span><span class="sxs-lookup"><span data-stu-id="fd181-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd181-132">Kod niezarządzany, który hostuje .NET Framework można zmienić rozmiar puli wątków przy użyciu `CorSetMaxThreads` funkcji zdefiniowanej w pliku mscoree. h.</span><span class="sxs-lookup"><span data-stu-id="fd181-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="fd181-133">Pula wątków udostępnia nowe wątki procesów roboczych lub wątki zakończenia operacji we/wy na żądanie do momentu osiągnięcia minimum dla każdej kategorii.</span><span class="sxs-lookup"><span data-stu-id="fd181-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="fd181-134">Po osiągnięciu minimalnej puli wątków można utworzyć dodatkowe wątki w tej kategorii lub poczekać na zakończenie niektórych zadań.</span><span class="sxs-lookup"><span data-stu-id="fd181-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="fd181-135">Począwszy od programu [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], Pula wątków tworzy i niszczy wątki robocze w celu zoptymalizowania przepływności, która jest definiowana jako liczba zadań ukończonych na jednostkę czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="fd181-136">Zbyt mało wątków może nie optymalnie korzystać z dostępnych zasobów, a zbyt wiele wątków może zwiększyć rywalizację o zasoby.</span><span class="sxs-lookup"><span data-stu-id="fd181-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd181-137">Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków puli wątków może spaść poniżej wartości minimalnych.</span><span class="sxs-lookup"><span data-stu-id="fd181-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="fd181-138">Aby uzyskać te wartości <xref:System.Threading.ThreadPool.GetMinThreads%2A> minimalne, można użyć metody.</span><span class="sxs-lookup"><span data-stu-id="fd181-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="fd181-139">Możesz użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metody, aby zwiększyć minimalną liczbę wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="fd181-140">Jednak niekonieczne zwiększenie tych wartości może spowodować problemy z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="fd181-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="fd181-141">Jeśli zbyt wiele zadań rozpocznie się w tym samym czasie, wszystkie z nich mogą wydawać się wolne.</span><span class="sxs-lookup"><span data-stu-id="fd181-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="fd181-142">W większości przypadków Pula wątków będzie działać lepiej wraz z własnym algorytmem do alokowania wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fd181-143">W poniższym przykładzie główny wątek aplikacji kolejkuje metodę o nazwie `ThreadProc` do wykonania na wątku puli wątków, uśpienia dla jednej sekundy, a następnie kończy.</span><span class="sxs-lookup"><span data-stu-id="fd181-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="fd181-144">`ThreadProc` Metoda po prostu wyświetla komunikat.</span><span class="sxs-lookup"><span data-stu-id="fd181-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="fd181-145">Jeśli dodajesz komentarz do <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> wywołania metody, główny wątek zostanie zakończony przed uruchomieniem metody w wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="fd181-146">Pula wątków używa wątków w tle, które nie zachowują działania aplikacji, jeśli wszystkie wątki pierwszego planu zostały zakończone.</span><span class="sxs-lookup"><span data-stu-id="fd181-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="fd181-147">(Jest to prosty przykład warunku wyścigu).</span><span class="sxs-lookup"><span data-stu-id="fd181-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="fd181-148">Ten typ jest bezpieczny wątkowo.</span><span class="sxs-lookup"><span data-stu-id="fd181-148">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="fd181-149">Wątki i wątkowość</span><span class="sxs-lookup"><span data-stu-id="fd181-149">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-150">Pule zarządzanych wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-150">The Managed Thread Pooling</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="fd181-151">Tworzy powiązanie z uchwytem <see cref="T:System.Threading.ThreadPool" />systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="fd181-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="fd181-152"><see cref="T:System.IntPtr" /> , Który przechowuje uchwyt.</span><span class="sxs-lookup"><span data-stu-id="fd181-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span></span> <span data-ttu-id="fd181-153">Dojście musi być otwarte dla nakładających się operacji we/wy na stronie niezarządzanej.</span><span class="sxs-lookup"><span data-stu-id="fd181-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="fd181-154">Tworzy powiązanie z uchwytem <see cref="T:System.Threading.ThreadPool" />systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="fd181-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="fd181-155"><see langword="true" />Jeśli dojście jest powiązane; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="fd181-155"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fd181-156">Obiekt wywołujący nie posiada wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-156">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="fd181-157">Aby uzyskać możliwość wywoływania niezarządzanego kodu.</span><span class="sxs-lookup"><span data-stu-id="fd181-157">for the ability to call unmanaged code.</span></span> <span data-ttu-id="fd181-158">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-158">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="fd181-159">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> który zawiera dojście systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="fd181-159">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span></span> <span data-ttu-id="fd181-160">Dojście musi być otwarte dla nakładających się operacji we/wy na stronie niezarządzanej.</span><span class="sxs-lookup"><span data-stu-id="fd181-160">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="fd181-161">Tworzy powiązanie z uchwytem <see cref="T:System.Threading.ThreadPool" />systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="fd181-161">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="fd181-162"><see langword="true" />Jeśli dojście jest powiązane; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="fd181-162"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-163">Parametr powinien być, który pochodzi z klasy abstrakcyjnej <xref:System.Runtime.InteropServices.SafeHandle>. <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> `osHandle`</span><span class="sxs-lookup"><span data-stu-id="fd181-163">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fd181-164"><paramref name="osHandle" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-164"><paramref name="osHandle" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="fd181-165">Aby uzyskać możliwość wywoływania niezarządzanego kodu.</span><span class="sxs-lookup"><span data-stu-id="fd181-165">for the ability to call unmanaged code.</span></span> <span data-ttu-id="fd181-166">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-166">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CompletedWorkItemCount">
      <MemberSignature Language="C#" Value="public static long CompletedWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 CompletedWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long CompletedWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedWorkItemCount : int64" Usage="System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fd181-167">Pobiera liczbę elementów roboczych, które zostały przetworzone do tej pory.</span><span class="sxs-lookup"><span data-stu-id="fd181-167">Gets the number of work items that have been processed so far.</span></span></summary>
        <value><span data-ttu-id="fd181-168">Liczba elementów roboczych, które zostały przetworzone do tej pory.</span><span class="sxs-lookup"><span data-stu-id="fd181-168">The number of work items that have been processed so far.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="fd181-169">Jeśli implementacja puli wątków może mieć różne typy elementów roboczych, liczba obejmuje wszystkie typy.</span><span class="sxs-lookup"><span data-stu-id="fd181-169">If a thread pool implementation may have different types of work items, the count includes all types.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="fd181-170">Liczba dostępnych wątków roboczych.</span><span class="sxs-lookup"><span data-stu-id="fd181-170">The number of available worker threads.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="fd181-171">Liczba dostępnych asynchronicznych wątków we/wy.</span><span class="sxs-lookup"><span data-stu-id="fd181-171">The number of available asynchronous I/O threads.</span></span></param>
        <summary><span data-ttu-id="fd181-172">Pobiera różnicę między maksymalną liczbą wątków puli wątków zwracanych przez <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> metodę i aktualnie aktywną liczbą.</span><span class="sxs-lookup"><span data-stu-id="fd181-172">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-173">Gdy <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> zwraca, zmienna określona przez `workerThreads` zawiera liczbę dodatkowych wątków roboczych, które można uruchomić, a zmienna określona przez `completionPortThreads` zawiera liczbę dodatkowych asynchronicznych wątków we/wy, które mogą być uruchomieniu.</span><span class="sxs-lookup"><span data-stu-id="fd181-173">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="fd181-174">Jeśli nie ma dostępnych wątków, dodatkowe żądania puli wątków pozostają w kolejce, dopóki nie staną się dostępne wątki puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-174">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fd181-175">Poniższy przykład wyświetla liczbę wątków roboczych i wątków we/wy dostępnych podczas uruchamiania prostej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="fd181-175">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="fd181-176">Maksymalna liczba wątków roboczych w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-176">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="fd181-177">Maksymalna liczba asynchronicznych wątków we/wy w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-177">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="fd181-178">Pobiera liczbę żądań do puli wątków, które mogą być aktywne współbieżnie.</span><span class="sxs-lookup"><span data-stu-id="fd181-178">Retrieves the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="fd181-179">Wszystkie żądania powyżej tej liczby pozostają w kolejce, dopóki wątki puli wątków staną się dostępne.</span><span class="sxs-lookup"><span data-stu-id="fd181-179">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-180">Gdy <xref:System.Threading.ThreadPool.GetMaxThreads%2A> zwraca, zmienna określona przez `workerThreads` zawiera maksymalną liczbę wątków roboczych dozwoloną w puli wątków, a zmienna określona przez `completionPortThreads` zawiera maksymalną liczbę asynchronicznych wątków we/wy dozwolonych w Pula wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-180">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="fd181-181">Można użyć <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> metody do określenia rzeczywistej liczby wątków w puli wątków w danym momencie.</span><span class="sxs-lookup"><span data-stu-id="fd181-181">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="fd181-182">Można użyć, <xref:System.Threading.ThreadPool.SetMaxThreads%2A> aby ustawić maksymalną liczbę wątków roboczych i asynchronicznych wątków we/wy w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-182">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="fd181-183">Można kolejkować dowolną liczbę żądań puli wątków, jak zezwala na ilość pamięci systemowej.</span><span class="sxs-lookup"><span data-stu-id="fd181-183">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="fd181-184">Jeśli występuje więcej żądań niż wątki puli wątków, dodatkowe żądania pozostają w kolejce, dopóki wątki puli wątków staną się dostępne.</span><span class="sxs-lookup"><span data-stu-id="fd181-184">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fd181-185">Poniższy przykład kodu pokazuje, jak pobrać liczbę maksymalną i dostępną liczbę wątków w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-185">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="fd181-186">Element roboczy jest umieszczany w kolejce `FileStream` , który używa do asynchronicznego zapisu do dwóch plików.</span><span class="sxs-lookup"><span data-stu-id="fd181-186">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="fd181-187">Metody wywołania zwrotnego czasu są nakładane na siebie.</span><span class="sxs-lookup"><span data-stu-id="fd181-187">The callback methods are timed to overlap.</span></span> <span data-ttu-id="fd181-188">Wątek roboczy obsługuje element roboczy i, w zależności od szybkości i liczby procesorów komputera, jeden lub dwa wątki portów ukończenia obsługują operacje zapisu.</span><span class="sxs-lookup"><span data-stu-id="fd181-188">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="fd181-189">Gdy ta metoda zwraca, zawiera minimalną liczbę wątków roboczych, które tworzy Pula wątków na żądanie.</span><span class="sxs-lookup"><span data-stu-id="fd181-189">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="fd181-190">Gdy ta metoda zwraca, zawiera minimalną liczbę asynchronicznych wątków we/wy, które tworzy Pula wątków na żądanie.</span><span class="sxs-lookup"><span data-stu-id="fd181-190">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="fd181-191">Pobiera minimalną liczbę wątków, które tworzy Pula wątków na żądanie, jako nowe żądania, przed przełączeniem do algorytmu zarządzania tworzeniem i zniszczeniem wątku.</span><span class="sxs-lookup"><span data-stu-id="fd181-191">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-192">Pula wątków udostępnia nowe wątki procesów roboczych lub wątki zakończenia operacji we/wy na żądanie do momentu osiągnięcia minimum dla każdej kategorii.</span><span class="sxs-lookup"><span data-stu-id="fd181-192">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="fd181-193">Domyślnie minimalna liczba wątków jest ustawiona na liczbę procesorów w systemie.</span><span class="sxs-lookup"><span data-stu-id="fd181-193">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="fd181-194">Po osiągnięciu wartości minimalnej Pula wątków może utworzyć dodatkowe wątki w tej kategorii lub poczekać na zakończenie niektórych zadań.</span><span class="sxs-lookup"><span data-stu-id="fd181-194">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="fd181-195">Począwszy od, Pula wątków tworzy i niszczy wątki w celu zoptymalizowania przepływności, która jest definiowana jako liczba zadań ukończonych na jednostkę czasu. [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</span><span class="sxs-lookup"><span data-stu-id="fd181-195">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="fd181-196">Zbyt mało wątków może nie optymalnie korzystać z dostępnych zasobów, a zbyt wiele wątków może zwiększyć rywalizację o zasoby.</span><span class="sxs-lookup"><span data-stu-id="fd181-196">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd181-197">Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków puli wątków może spaść poniżej wartości minimalnych.</span><span class="sxs-lookup"><span data-stu-id="fd181-197">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fd181-198">W poniższym przykładzie ustawiono minimalną liczbę wątków roboczych na cztery i zachowuje oryginalną wartość dla minimalnej liczby asynchronicznych wątków ukończenia operacji we/wy.</span><span class="sxs-lookup"><span data-stu-id="fd181-198">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="PendingWorkItemCount">
      <MemberSignature Language="C#" Value="public static long PendingWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 PendingWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PendingWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long PendingWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PendingWorkItemCount : int64" Usage="System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fd181-199">Pobiera liczbę elementów roboczych, które są obecnie umieszczane w kolejce do przetworzenia.</span><span class="sxs-lookup"><span data-stu-id="fd181-199">Gets the number of work items that are currently queued to be processed.</span></span></summary>
        <value><span data-ttu-id="fd181-200">Liczba elementów roboczych, które są obecnie umieszczane w kolejce do przetworzenia.</span><span class="sxs-lookup"><span data-stu-id="fd181-200">The number of work items that are currently queued to be processed.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="fd181-201">Jeśli implementacja puli wątków może mieć różne typy elementów roboczych, liczba obejmuje wszystkie typy, które mogą być śledzone, które mogą być tylko elementami roboczymi użytkownika, w tym zadaniami.</span><span class="sxs-lookup"><span data-stu-id="fd181-201">If a thread pool implementation may have different types of work items, the count includes all types that can be tracked, which may only be the user work items, including tasks.</span></span> <span data-ttu-id="fd181-202">Niektóre implementacje mogą również obejmować czasomierz w kolejce i oczekiwać wywołania zwrotnego w liczniku.</span><span class="sxs-lookup"><span data-stu-id="fd181-202">Some implementations may also include queued timer and wait callbacks in the count.</span></span> <span data-ttu-id="fd181-203">W systemie Windows licznik jest mało prawdopodobne, aby uwzględnić liczbę oczekujących operacji we/wy, ponieważ są one wysyłane bezpośrednio do portu ukończenia we/wy.</span><span class="sxs-lookup"><span data-stu-id="fd181-203">On Windows, the count is unlikely to include the number of pending IO completions, because they are posted directly to an IO completion port.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="fd181-204">Kolejkuje metodę do wykonania.</span><span class="sxs-lookup"><span data-stu-id="fd181-204">Queues a method for execution.</span></span> <span data-ttu-id="fd181-205">Metoda jest wykonywana po udostępnieniu wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-205">The method executes when a thread pool thread becomes available.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="fd181-206">Reprezentuje <see cref="T:System.Threading.WaitCallback" /> metodę, która ma zostać wykonana.</span><span class="sxs-lookup"><span data-stu-id="fd181-206">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span></span></param>
        <summary><span data-ttu-id="fd181-207">Kolejkuje metodę do wykonania.</span><span class="sxs-lookup"><span data-stu-id="fd181-207">Queues a method for execution.</span></span> <span data-ttu-id="fd181-208">Metoda jest wykonywana po udostępnieniu wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-208">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="fd181-209"><see langword="true" />Jeśli metoda została pomyślnie umieszczona w kolejce; <see cref="T:System.NotSupportedException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="fd181-209"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-210">Dane wymagane przez metodę znajdującą się w kolejce można umieścić w polach wystąpienia klasy, w której jest zdefiniowana Metoda, lub użyć <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> przeciążenia, które akceptuje obiekt zawierający niezbędne dane.</span><span class="sxs-lookup"><span data-stu-id="fd181-210">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd181-211">Visual Basic użytkownicy mogą pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu `AddressOf` użyć operatora podczas przekazywania metody wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="fd181-211">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="fd181-212">Visual Basic automatycznie wywołuje poprawnego konstruktora delegatów.</span><span class="sxs-lookup"><span data-stu-id="fd181-212">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="fd181-213">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="fd181-213">Version Information</span></span>  
 <span data-ttu-id="fd181-214">W .NET Framework w wersji 2,0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="fd181-214">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="fd181-215">We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-215">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fd181-216">W poniższym przykładzie zastosowano <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> Przeciążenie metody do kolejki zadania, które jest reprezentowane `ThreadProc` przez metodę, do wykonania, gdy wątek będzie dostępny.</span><span class="sxs-lookup"><span data-stu-id="fd181-216">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="fd181-217">Z tym przeciążeniem nie dostarczono informacji o zadaniu.</span><span class="sxs-lookup"><span data-stu-id="fd181-217">No task information is supplied with this overload.</span></span> <span data-ttu-id="fd181-218">W związku z tym informacje dostępne dla `ThreadProc` metody są ograniczone do obiektu, do którego należy Metoda.</span><span class="sxs-lookup"><span data-stu-id="fd181-218">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fd181-219"><paramref name="callBack" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-219"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fd181-220">Środowisko uruchomieniowe języka wspólnego (CLR) jest hostowane i host nie obsługuje tej akcji.</span><span class="sxs-lookup"><span data-stu-id="fd181-220">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-221">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-221">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="fd181-222"><see cref="T:System.Threading.WaitCallback" /> Reprezentująca metodę do wykonania.</span><span class="sxs-lookup"><span data-stu-id="fd181-222">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-223">Obiekt zawierający dane, które mają być używane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-223">An object containing data to be used by the method.</span></span></param>
        <summary><span data-ttu-id="fd181-224">Kolejkuje metodę do wykonania i określa obiekt zawierający dane, które mają być używane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-224">Queues a method for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="fd181-225">Metoda jest wykonywana po udostępnieniu wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-225">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="fd181-226"><see langword="true" />Jeśli metoda została pomyślnie umieszczona w kolejce; <see cref="T:System.NotSupportedException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="fd181-226"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-227">Jeśli metoda wywołania zwrotnego wymaga złożonych danych, można zdefiniować klasę zawierającą dane.</span><span class="sxs-lookup"><span data-stu-id="fd181-227">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd181-228">Visual Basic użytkownicy mogą pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu `AddressOf` użyć operatora podczas przekazywania metody wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="fd181-228">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="fd181-229">Visual Basic automatycznie wywołuje poprawnego konstruktora delegatów.</span><span class="sxs-lookup"><span data-stu-id="fd181-229">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="fd181-230">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="fd181-230">Version Information</span></span>  
 <span data-ttu-id="fd181-231">W .NET Framework w wersji 2,0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="fd181-231">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="fd181-232">We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-232">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fd181-233">Poniższy przykład używa puli wątków .NET, aby obliczyć `Fibonacci` wynik pięciu liczb z zakresu od 20 do 40.</span><span class="sxs-lookup"><span data-stu-id="fd181-233">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="fd181-234">Każdy `Fibonacci` wynik jest reprezentowany `Fibonacci` przez klasę, która dostarcza metodę o nazwie `ThreadPoolCallback` , która wykonuje obliczenia.</span><span class="sxs-lookup"><span data-stu-id="fd181-234">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="fd181-235">Obiekt, który reprezentuje każdą `Fibonacci` wartość, jest tworzony, `ThreadPoolCallback` a metoda jest przenoszona <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>do, która przypisuje dostępny wątek w puli, aby wykonać metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-235">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="fd181-236">Ponieważ każdy `Fibonacci` obiekt otrzymuje średnią wartość do obliczenia, a ponieważ każdy wątek będzie konkurencyjny dla czasu procesora, nie można dowiedzieć się z wyprzedzeniem, jak długo będzie trwać dla wszystkich pięciu wyników.</span><span class="sxs-lookup"><span data-stu-id="fd181-236">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="fd181-237">To dlatego, że `Fibonacci` każdy obiekt jest przekazywać wystąpienie <xref:System.Threading.ManualResetEvent> klasy podczas konstruowania.</span><span class="sxs-lookup"><span data-stu-id="fd181-237">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="fd181-238">Każdy obiekt sygnalizuje podanemu obiektowi zdarzenia po zakończeniu obliczeń, co umożliwia wątkom głównym blokowanie wykonywania <xref:System.Threading.WaitHandle.WaitAll%2A> , dopóki wszystkie pięć `Fibonacci` obiektów nie wyliczy wynik.</span><span class="sxs-lookup"><span data-stu-id="fd181-238">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="fd181-239">Następnie Metoda wyświetla każdy `Fibonacci`wynik. `Main`</span><span class="sxs-lookup"><span data-stu-id="fd181-239">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fd181-240">Środowisko uruchomieniowe języka wspólnego (CLR) jest hostowane i host nie obsługuje tej akcji.</span><span class="sxs-lookup"><span data-stu-id="fd181-240">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fd181-241"><paramref name="callBack" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-241"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-242">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-242">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="fd181-243">Typ elementów <paramref name="state" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-243">The type of elements of <paramref name="state" />.</span></span></typeparam>
        <param name="callBack"><span data-ttu-id="fd181-244"><see cref="T:System.Action`1" /> Reprezentująca metodę do wykonania.</span><span class="sxs-lookup"><span data-stu-id="fd181-244">An <see cref="T:System.Action`1" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-245">Obiekt zawierający dane, które mają być używane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-245">An object containing data to be used by the method.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="fd181-246"><see langword="true" />Aby preferować kolejkowanie elementu pracy w kolejce blisko bieżącego wątku; <see langword="false" /> aby preferować kolejkowanie elementu pracy do kolejki udostępnionej puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-246"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="fd181-247">Kolejkuje metodę określoną przez <see cref="T:System.Action`1" /> delegata do wykonania i dostarcza dane, które mają być używane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-247">Queues a method specified by an <see cref="T:System.Action`1" /> delegate for execution, and provides data to be used by the method.</span></span> <span data-ttu-id="fd181-248">Metoda jest wykonywana po udostępnieniu wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-248">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="fd181-249"><see langword="true" />Jeśli metoda została pomyślnie umieszczona w kolejce; <see cref="T:System.NotSupportedException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="fd181-249"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="fd181-250">Rejestruje delegata, który oczekuje na <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-250">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="fd181-251"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji.</span><span class="sxs-lookup"><span data-stu-id="fd181-251">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="fd181-252">Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></span><span class="sxs-lookup"><span data-stu-id="fd181-252">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="fd181-253">Delegat do wywołania <paramref name="waitObject" /> po zasygnalizowaniu parametru. <see cref="T:System.Threading.WaitOrTimerCallback" /></span><span class="sxs-lookup"><span data-stu-id="fd181-253">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-254">Obiekt, który jest przesyłany do delegata.</span><span class="sxs-lookup"><span data-stu-id="fd181-254">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="fd181-255">Limit czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-255">The time-out in milliseconds.</span></span> <span data-ttu-id="fd181-256"><paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="fd181-256">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="fd181-257">Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</span><span class="sxs-lookup"><span data-stu-id="fd181-257">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="fd181-258"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-258"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="fd181-259">Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na, określając 32-bitową liczbę całkowitą ze znakiem dla limitu czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-259">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="fd181-260"><see cref="T:System.Threading.RegisteredWaitHandle" /> To hermetyzuje uchwyt macierzysty.</span><span class="sxs-lookup"><span data-stu-id="fd181-260">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-261">Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-261">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="fd181-262">Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="fd181-262">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="fd181-263">Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-263">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="fd181-264"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda kolejkuje określony delegat do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-264">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="fd181-265">Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących wystąpień:</span><span class="sxs-lookup"><span data-stu-id="fd181-265">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="fd181-266">Określony obiekt jest w stanie zasygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="fd181-266">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="fd181-267">Upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-267">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="fd181-268">Metoda sprawdza bieżący stan określonego <xref:System.Threading.WaitHandle>obiektu. <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A></span><span class="sxs-lookup"><span data-stu-id="fd181-268">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="fd181-269">Jeśli stan obiektu jest Niesygnalizowane, Metoda rejestruje operację oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-269">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="fd181-270">Operacja oczekiwania jest wykonywana przez wątek z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-270">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="fd181-271">Delegat jest wykonywany przez wątek roboczy, gdy stan obiektu zostanie zasygnalizowania lub upłynie interwał limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-271">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="fd181-272">Jeśli parametr nie ma wartości 0 (zero), `executeOnlyOnce` a parametr ma `false`wartość, czasomierz jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane, lub upłynął limit czasu. `timeOutInterval`</span><span class="sxs-lookup"><span data-stu-id="fd181-272">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="fd181-273">Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-273">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="fd181-274">Zamiast elementu <xref:System.Threading.Mutex>należy <xref:System.Threading.Semaphore> używać z maksymalną liczbą 1.</span><span class="sxs-lookup"><span data-stu-id="fd181-274">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="fd181-275">Aby anulować operację oczekiwania, wywołaj <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-275">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="fd181-276">Wątek oczekiwania używa funkcji Win32 `WaitForMultipleObjects` do monitorowania zarejestrowanych operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-276">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="fd181-277">W związku z tym, jeśli konieczne jest użycie tego samego natywnego uchwytu systemu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>operacyjnego w wielu wywołaniach do, należy zduplikować `DuplicateHandle` uchwyt przy użyciu funkcji Win32.</span><span class="sxs-lookup"><span data-stu-id="fd181-277">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="fd181-278">Należy zauważyć, że nie należy przekazywać obiektu zdarzenia do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania może nie wykryć, że zdarzenie jest sygnalizowane przed zresetowaniem.</span><span class="sxs-lookup"><span data-stu-id="fd181-278">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="fd181-279">Przed zwróceniem funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="fd181-279">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="fd181-280">Modyfikacja odbywa się tylko dla obiektu, którego stan sygnału spowodował spełnienie warunku oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-280">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="fd181-281">Na przykład liczba semaforów jest mniejsza o jeden.</span><span class="sxs-lookup"><span data-stu-id="fd181-281">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="fd181-282">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="fd181-282">Version Information</span></span>  
 <span data-ttu-id="fd181-283">Począwszy od .NET Framework w wersji 2,0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="fd181-283">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="fd181-284">We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-284">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fd181-285"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejszy niż-1.</span><span class="sxs-lookup"><span data-stu-id="fd181-285">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-286">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-286">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="fd181-287"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji.</span><span class="sxs-lookup"><span data-stu-id="fd181-287">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="fd181-288">Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></span><span class="sxs-lookup"><span data-stu-id="fd181-288">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="fd181-289">Delegat do wywołania <paramref name="waitObject" /> po zasygnalizowaniu parametru. <see cref="T:System.Threading.WaitOrTimerCallback" /></span><span class="sxs-lookup"><span data-stu-id="fd181-289">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-290">Obiekt przeszedł do delegata.</span><span class="sxs-lookup"><span data-stu-id="fd181-290">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="fd181-291">Limit czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-291">The time-out in milliseconds.</span></span> <span data-ttu-id="fd181-292"><paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="fd181-292">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="fd181-293">Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</span><span class="sxs-lookup"><span data-stu-id="fd181-293">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="fd181-294"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-294"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="fd181-295">Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na, określając 64-bitową liczbę całkowitą ze znakiem dla limitu czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-295">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="fd181-296"><see cref="T:System.Threading.RegisteredWaitHandle" /> To hermetyzuje uchwyt macierzysty.</span><span class="sxs-lookup"><span data-stu-id="fd181-296">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-297">Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-297">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="fd181-298">Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="fd181-298">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="fd181-299">Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-299">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="fd181-300"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda kolejkuje określony delegat do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-300">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="fd181-301">Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących wystąpień:</span><span class="sxs-lookup"><span data-stu-id="fd181-301">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="fd181-302">Określony obiekt jest w stanie zasygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="fd181-302">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="fd181-303">Upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-303">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="fd181-304">Metoda sprawdza bieżący stan określonego <xref:System.Threading.WaitHandle>obiektu. <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A></span><span class="sxs-lookup"><span data-stu-id="fd181-304">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="fd181-305">Jeśli stan obiektu jest Niesygnalizowane, Metoda rejestruje operację oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-305">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="fd181-306">Operacja oczekiwania jest wykonywana przez wątek z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-306">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="fd181-307">Delegat jest wykonywany przez wątek roboczy, gdy stan obiektu zostanie zasygnalizowania lub upłynie interwał limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-307">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="fd181-308">Jeśli parametr nie ma wartości 0 (zero), `executeOnlyOnce` a parametr ma `false`wartość, czasomierz jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane, lub upłynął limit czasu. `timeOutInterval`</span><span class="sxs-lookup"><span data-stu-id="fd181-308">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="fd181-309">Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-309">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="fd181-310">Zamiast elementu <xref:System.Threading.Mutex>należy <xref:System.Threading.Semaphore> używać z maksymalną liczbą 1.</span><span class="sxs-lookup"><span data-stu-id="fd181-310">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="fd181-311">Aby anulować operację oczekiwania, wywołaj <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-311">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="fd181-312">Wątek oczekiwania używa funkcji Win32 `WaitForMultipleObjects` do monitorowania zarejestrowanych operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-312">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="fd181-313">W związku z tym, jeśli konieczne jest użycie tego samego natywnego uchwytu systemu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>operacyjnego w wielu wywołaniach do, należy zduplikować `DuplicateHandle` uchwyt przy użyciu funkcji Win32.</span><span class="sxs-lookup"><span data-stu-id="fd181-313">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="fd181-314">Należy zauważyć, że nie należy przekazywać obiektu zdarzenia do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania może nie wykryć, że zdarzenie jest sygnalizowane przed zresetowaniem.</span><span class="sxs-lookup"><span data-stu-id="fd181-314">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="fd181-315">Przed zwróceniem funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="fd181-315">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="fd181-316">Modyfikacja odbywa się tylko dla obiektu, którego stan sygnału spowodował spełnienie warunku oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-316">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="fd181-317">Na przykład liczba semaforów jest mniejsza o jeden.</span><span class="sxs-lookup"><span data-stu-id="fd181-317">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="fd181-318">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="fd181-318">Version Information</span></span>  
 <span data-ttu-id="fd181-319">Począwszy od .NET Framework w wersji 2,0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="fd181-319">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="fd181-320">We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-320">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fd181-321"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejszy niż-1.</span><span class="sxs-lookup"><span data-stu-id="fd181-321">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-322">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-322">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="fd181-323"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji.</span><span class="sxs-lookup"><span data-stu-id="fd181-323">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="fd181-324">Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></span><span class="sxs-lookup"><span data-stu-id="fd181-324">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="fd181-325">Delegat do wywołania <paramref name="waitObject" /> po zasygnalizowaniu parametru. <see cref="T:System.Threading.WaitOrTimerCallback" /></span><span class="sxs-lookup"><span data-stu-id="fd181-325">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-326">Obiekt przeszedł do delegata.</span><span class="sxs-lookup"><span data-stu-id="fd181-326">The object passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="fd181-327">Limit czasu reprezentowany przez <see cref="T:System.TimeSpan" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-327">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="fd181-328">Jeśli <paramref name="timeout" /> jest równa 0 (zero), funkcja testuje stan obiektu i natychmiast wraca.</span><span class="sxs-lookup"><span data-stu-id="fd181-328">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="fd181-329">Jeśli <paramref name="timeout" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</span><span class="sxs-lookup"><span data-stu-id="fd181-329">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="fd181-330"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-330"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="fd181-331">Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na <see cref="T:System.TimeSpan" /> określenie wartości limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-331">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="fd181-332"><see cref="T:System.Threading.RegisteredWaitHandle" /> To hermetyzuje uchwyt macierzysty.</span><span class="sxs-lookup"><span data-stu-id="fd181-332">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-333">Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-333">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="fd181-334">Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="fd181-334">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="fd181-335">Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-335">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="fd181-336"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda kolejkuje określony delegat do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-336">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="fd181-337">Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących wystąpień:</span><span class="sxs-lookup"><span data-stu-id="fd181-337">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="fd181-338">Określony obiekt jest w stanie zasygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="fd181-338">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="fd181-339">Upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-339">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="fd181-340">Metoda sprawdza bieżący stan określonego <xref:System.Threading.WaitHandle>obiektu. <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A></span><span class="sxs-lookup"><span data-stu-id="fd181-340">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="fd181-341">Jeśli stan obiektu jest Niesygnalizowane, Metoda rejestruje operację oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-341">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="fd181-342">Operacja oczekiwania jest wykonywana przez wątek z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-342">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="fd181-343">Delegat jest wykonywany przez wątek roboczy, gdy stan obiektu zostanie zasygnalizowania lub upłynie interwał limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-343">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="fd181-344">Jeśli parametr nie ma wartości 0 (zero), `executeOnlyOnce` a parametr ma `false`wartość, czasomierz jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane, lub upłynął limit czasu. `timeOutInterval`</span><span class="sxs-lookup"><span data-stu-id="fd181-344">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="fd181-345">Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-345">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="fd181-346">Zamiast elementu <xref:System.Threading.Mutex>należy <xref:System.Threading.Semaphore> używać z maksymalną liczbą 1.</span><span class="sxs-lookup"><span data-stu-id="fd181-346">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="fd181-347">Aby anulować operację oczekiwania, wywołaj <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-347">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="fd181-348">Wątek oczekiwania używa funkcji Win32 `WaitForMultipleObjects` do monitorowania zarejestrowanych operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-348">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="fd181-349">W związku z tym, jeśli konieczne jest użycie tego samego natywnego uchwytu systemu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>operacyjnego w wielu wywołaniach do, należy zduplikować `DuplicateHandle` uchwyt przy użyciu funkcji Win32.</span><span class="sxs-lookup"><span data-stu-id="fd181-349">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="fd181-350">Należy zauważyć, że nie należy przekazywać obiektu zdarzenia do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania może nie wykryć, że zdarzenie jest sygnalizowane przed zresetowaniem.</span><span class="sxs-lookup"><span data-stu-id="fd181-350">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="fd181-351">Przed zwróceniem funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="fd181-351">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="fd181-352">Modyfikacja odbywa się tylko dla obiektu, którego stan sygnału spowodował spełnienie warunku oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-352">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="fd181-353">Na przykład liczba semaforów jest mniejsza o jeden.</span><span class="sxs-lookup"><span data-stu-id="fd181-353">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="fd181-354">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="fd181-354">Version Information</span></span>  
 <span data-ttu-id="fd181-355">Począwszy od .NET Framework w wersji 2,0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="fd181-355">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="fd181-356">We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-356">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fd181-357"><paramref name="timeout" /> Parametr jest mniejszy niż-1.</span><span class="sxs-lookup"><span data-stu-id="fd181-357">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fd181-358">Parametr jest większy niż <see cref="F:System.Int32.MaxValue" />. <paramref name="timeout" /></span><span class="sxs-lookup"><span data-stu-id="fd181-358">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-359">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-359">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="fd181-360"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji.</span><span class="sxs-lookup"><span data-stu-id="fd181-360">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="fd181-361">Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></span><span class="sxs-lookup"><span data-stu-id="fd181-361">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="fd181-362">Delegat do wywołania <paramref name="waitObject" /> po zasygnalizowaniu parametru. <see cref="T:System.Threading.WaitOrTimerCallback" /></span><span class="sxs-lookup"><span data-stu-id="fd181-362">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-363">Obiekt przeszedł do delegata.</span><span class="sxs-lookup"><span data-stu-id="fd181-363">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="fd181-364">Limit czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-364">The time-out in milliseconds.</span></span> <span data-ttu-id="fd181-365"><paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="fd181-365">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="fd181-366">Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</span><span class="sxs-lookup"><span data-stu-id="fd181-366">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="fd181-367"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-367"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="fd181-368">Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na, określając 32-bitową liczbę całkowitą bez znaku dla limitu czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-368">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="fd181-369"><see cref="T:System.Threading.RegisteredWaitHandle" /> Służy do anulowania zarejestrowanej operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-369">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-370">Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-370">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="fd181-371">Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="fd181-371">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="fd181-372">Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-372">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="fd181-373"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda kolejkuje określony delegat do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-373">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="fd181-374">Wątek roboczy wykona delegata, gdy wystąpi jedno z następujących wystąpień:</span><span class="sxs-lookup"><span data-stu-id="fd181-374">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="fd181-375">Określony obiekt jest w stanie zasygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="fd181-375">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="fd181-376">Upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-376">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="fd181-377">Metoda sprawdza bieżący stan określonego <xref:System.Threading.WaitHandle>obiektu. <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A></span><span class="sxs-lookup"><span data-stu-id="fd181-377">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="fd181-378">Jeśli stan obiektu jest Niesygnalizowane, Metoda rejestruje operację oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-378">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="fd181-379">Operacja oczekiwania jest wykonywana przez wątek z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-379">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="fd181-380">Delegat jest wykonywany przez wątek roboczy, gdy stan obiektu zostanie zasygnalizowania lub upłynie interwał limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-380">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="fd181-381">Jeśli parametr nie ma wartości 0 (zero), `executeOnlyOnce` a parametr ma `false`wartość, czasomierz jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane, lub upłynął limit czasu. `timeOutInterval`</span><span class="sxs-lookup"><span data-stu-id="fd181-381">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="fd181-382">Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-382">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="fd181-383">Zamiast elementu <xref:System.Threading.Mutex>należy <xref:System.Threading.Semaphore> używać z maksymalną liczbą 1.</span><span class="sxs-lookup"><span data-stu-id="fd181-383">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="fd181-384">Aby anulować operację oczekiwania, wywołaj <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-384">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="fd181-385">Wątek oczekiwania używa funkcji Win32 `WaitForMultipleObjects` do monitorowania zarejestrowanych operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-385">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="fd181-386">W związku z tym, jeśli konieczne jest użycie tego samego natywnego uchwytu systemu <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>operacyjnego w wielu wywołaniach do, należy zduplikować `DuplicateHandle` uchwyt przy użyciu funkcji Win32.</span><span class="sxs-lookup"><span data-stu-id="fd181-386">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="fd181-387">Należy zauważyć, że nie należy przekazywać obiektu zdarzenia do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ wątek oczekiwania może nie wykryć, że zdarzenie jest sygnalizowane przed zresetowaniem.</span><span class="sxs-lookup"><span data-stu-id="fd181-387">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="fd181-388">Przed zwróceniem funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="fd181-388">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="fd181-389">Modyfikacja odbywa się tylko dla obiektu, którego stan sygnału spowodował spełnienie warunku oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-389">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="fd181-390">Na przykład liczba semaforów jest mniejsza o jeden.</span><span class="sxs-lookup"><span data-stu-id="fd181-390">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="fd181-391">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="fd181-391">Version Information</span></span>  
 <span data-ttu-id="fd181-392">Począwszy od .NET Framework w wersji 2,0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków roboczych umieszczonych w kolejce <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="fd181-392">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="fd181-393">We wcześniejszych wersjach nie są propagowane informacje podmiotu zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-393">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fd181-394">Poniższy przykład pokazuje, <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> jak używać metody do wykonywania określonej metody wywołania zwrotnego, gdy zostanie zasygnalizowani określone dojście oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-394">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="fd181-395">W tym przykładzie metoda wywołania zwrotnego ma `WaitProc`wartość, a uchwyt oczekiwania <xref:System.Threading.AutoResetEvent>to.</span><span class="sxs-lookup"><span data-stu-id="fd181-395">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="fd181-396">W przykładzie zdefiniowano `TaskInfo` klasę zawierającą informacje, które są przesyłane do wywołania zwrotnego, gdy jest ono wykonywane.</span><span class="sxs-lookup"><span data-stu-id="fd181-396">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="fd181-397">Przykład tworzy `TaskInfo` obiekt i przypisuje mu niektóre dane ciągu.</span><span class="sxs-lookup"><span data-stu-id="fd181-397">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="fd181-398">Wartość <xref:System.Threading.RegisteredWaitHandle> zwracana `TaskInfo` <xref:System.Threading.RegisteredWaitHandle>przez <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodęjestprzypisywanadopolaobiektu,takabyMetoda`Handle` wywołania zwrotnego miała dostęp do.</span><span class="sxs-lookup"><span data-stu-id="fd181-398">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="fd181-399">Oprócz `TaskInfo` określania jako obiektu, który ma zostać przekazany do metody wywołania zwrotnego, wywołanie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody Określa <xref:System.Threading.AutoResetEvent> <xref:System.Threading.WaitOrTimerCallback> , że zadanie będzie `WaitProc` oczekiwać dla, delegata, który reprezentuje metodę wywołania zwrotnego, a Drugi interwał limitu czasu i wiele wywołań zwrotnych.</span><span class="sxs-lookup"><span data-stu-id="fd181-399">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="fd181-400">Gdy główny wątek sygnalizuje <xref:System.Threading.AutoResetEvent> <xref:System.Threading.EventWaitHandle.Set%2A> wywołanie metody, <xref:System.Threading.WaitOrTimerCallback> obiekt delegowany jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="fd181-400">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="fd181-401">Metoda `WaitProc` sprawdza<xref:System.Threading.RegisteredWaitHandle> , czy wystąpiło przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="fd181-401">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="fd181-402">Jeśli wywołanie zwrotne zostało wywołane ze względu na to, że `WaitProc` dojście oczekiwania zostało zasygnalizowane, Metoda wyrejestruje <xref:System.Threading.RegisteredWaitHandle>, zatrzymując dodatkowe wywołania zwrotne.</span><span class="sxs-lookup"><span data-stu-id="fd181-402">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="fd181-403">W przypadku przekroczenia limitu czasu zadanie kontynuuje oczekiwanie.</span><span class="sxs-lookup"><span data-stu-id="fd181-403">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="fd181-404">`WaitProc` Metoda zostaje zakończona, drukując komunikat do konsoli.</span><span class="sxs-lookup"><span data-stu-id="fd181-404">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fd181-405"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejszy niż-1.</span><span class="sxs-lookup"><span data-stu-id="fd181-405">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-406">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-406">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="fd181-407">Maksymalna liczba wątków roboczych w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-407">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="fd181-408">Maksymalna liczba asynchronicznych wątków we/wy w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-408">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="fd181-409">Ustawia liczbę żądań do puli wątków, które mogą być aktywne współbieżnie.</span><span class="sxs-lookup"><span data-stu-id="fd181-409">Sets the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="fd181-410">Wszystkie żądania powyżej tej liczby pozostają w kolejce, dopóki wątki puli wątków staną się dostępne.</span><span class="sxs-lookup"><span data-stu-id="fd181-410">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <returns><span data-ttu-id="fd181-411"><see langword="true" />Jeśli zmiana zakończyła się pomyślnie; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="fd181-411"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-412">Nie można ustawić maksymalnej liczby wątków roboczych lub wątków zakończenia operacji we/wy na liczbę mniejszą niż liczba procesorów na komputerze.</span><span class="sxs-lookup"><span data-stu-id="fd181-412">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="fd181-413">Aby określić liczbę procesorów, należy pobrać wartość <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="fd181-413">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="fd181-414">Ponadto nie można ustawić maksymalnej liczby wątków roboczych lub wątków uzupełniania we/wy na liczbę mniejszą niż odpowiadająca im minimalna liczba wątków roboczych lub wątki zakończenia operacji we/wy.</span><span class="sxs-lookup"><span data-stu-id="fd181-414">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="fd181-415">Aby określić minimalny rozmiar puli wątków, wywołaj <xref:System.Threading.ThreadPool.GetMinThreads%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-415">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="fd181-416">Jeśli środowisko uruchomieniowe języka wspólnego jest hostowane, na przykład przez Internet Information Services (IIS) lub SQL Server, host może ograniczyć lub uniemożliwić zmiany rozmiaru puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-416">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="fd181-417">Należy zachować ostrożność w przypadku zmiany maksymalnej liczby wątków w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-417">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="fd181-418">Chociaż kod może korzystać z programu, zmiany mogą mieć niekorzystny wpływ na biblioteki kodu, których używasz.</span><span class="sxs-lookup"><span data-stu-id="fd181-418">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="fd181-419">Ustawienie zbyt dużego rozmiaru puli wątków może spowodować problemy z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="fd181-419">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="fd181-420">W przypadku wykonywania zbyt wielu wątków w tym samym czasie narzuty przełączenia zadań staną się istotnym czynnikiem.</span><span class="sxs-lookup"><span data-stu-id="fd181-420">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="fd181-421">dla zdolności kontroli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-421">for the ability to control threads.</span></span> <span data-ttu-id="fd181-422">Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="fd181-422">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="fd181-423">Minimalna liczba wątków roboczych, które tworzy Pula wątków na żądanie.</span><span class="sxs-lookup"><span data-stu-id="fd181-423">The minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="fd181-424">Minimalna liczba asynchronicznych wątków we/wy, które tworzy Pula wątków na żądanie.</span><span class="sxs-lookup"><span data-stu-id="fd181-424">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="fd181-425">Ustawia minimalną liczbę wątków tworzonych przez pulę wątków na żądanie, w miarę tworzenia nowych żądań przed przełączeniem do algorytmu zarządzania tworzeniem i zniszczeniem wątku.</span><span class="sxs-lookup"><span data-stu-id="fd181-425">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <returns><span data-ttu-id="fd181-426"><see langword="true" />Jeśli zmiana zakończyła się pomyślnie; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="fd181-426"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-427">Pula wątków udostępnia nowe wątki procesów roboczych lub wątki zakończenia operacji we/wy na żądanie do momentu osiągnięcia minimum dla każdej kategorii.</span><span class="sxs-lookup"><span data-stu-id="fd181-427">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="fd181-428">Po osiągnięciu wartości minimalnej Pula wątków może utworzyć dodatkowe wątki w tej kategorii lub poczekać na zakończenie niektórych zadań.</span><span class="sxs-lookup"><span data-stu-id="fd181-428">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="fd181-429">Począwszy od, Pula wątków tworzy i niszczy wątki w celu zoptymalizowania przepływności, która jest definiowana jako liczba zadań ukończonych na jednostkę czasu. [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</span><span class="sxs-lookup"><span data-stu-id="fd181-429">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="fd181-430">Zbyt mało wątków może nie optymalnie korzystać z dostępnych zasobów, a zbyt wiele wątków może zwiększyć rywalizację o zasoby.</span><span class="sxs-lookup"><span data-stu-id="fd181-430">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="fd181-431">Gdy zapotrzebowanie jest niskie, rzeczywista liczba wątków puli wątków może spaść poniżej wartości minimalnych.</span><span class="sxs-lookup"><span data-stu-id="fd181-431">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="fd181-432">Jeśli zostanie określona liczba ujemna lub liczba większa niż maksymalna liczba aktywnych wątków puli wątków (uzyskanych za pomocą <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), program <xref:System.Threading.ThreadPool.SetMinThreads%2A> zwraca `false` i nie zmienia żadnej wartości minimalnej.</span><span class="sxs-lookup"><span data-stu-id="fd181-432">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="fd181-433">Domyślnie minimalna liczba wątków jest ustawiona na liczbę procesorów w systemie.</span><span class="sxs-lookup"><span data-stu-id="fd181-433">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="fd181-434">Możesz użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metody, aby zwiększyć minimalną liczbę wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-434">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="fd181-435">Jednak niekonieczne zwiększenie tych wartości może spowodować problemy z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="fd181-435">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="fd181-436">Jeśli zbyt wiele zadań rozpocznie się w tym samym czasie, wszystkie z nich mogą wydawać się wolne.</span><span class="sxs-lookup"><span data-stu-id="fd181-436">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="fd181-437">W większości przypadków Pula wątków będzie działać lepiej wraz z własnym algorytmem do alokowania wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-437">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="fd181-438">Zmniejszenie wartości minimalnej do mniejszej niż liczba procesorów może również obniżyć wydajność.</span><span class="sxs-lookup"><span data-stu-id="fd181-438">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fd181-439">W poniższym przykładzie ustawiono minimalną liczbę wątków roboczych na cztery i zachowuje oryginalną wartość dla minimalnej liczby asynchronicznych wątków ukończenia operacji we/wy.</span><span class="sxs-lookup"><span data-stu-id="fd181-439">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="fd181-440">dla zdolności kontroli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-440">for the ability to control threads.</span></span> <span data-ttu-id="fd181-441">Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="fd181-441">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="ThreadCount">
      <MemberSignature Language="C#" Value="public static int ThreadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ThreadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.ThreadCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ThreadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ThreadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadCount : int" Usage="System.Threading.ThreadPool.ThreadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fd181-442">Pobiera liczbę wątków puli wątków, które obecnie istnieją.</span><span class="sxs-lookup"><span data-stu-id="fd181-442">Gets the number of thread pool threads that currently exist.</span></span></summary>
        <value><span data-ttu-id="fd181-443">Liczba wątków puli wątków, które obecnie istnieją.</span><span class="sxs-lookup"><span data-stu-id="fd181-443">The number of thread pool threads that currently exist.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="fd181-444">Jeśli implementacja puli wątków może mieć różne typy wątków, liczba obejmuje wszystkie typy.</span><span class="sxs-lookup"><span data-stu-id="fd181-444">If a thread pool implementation may have different types of threads, the count includes all types.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="overlapped"><span data-ttu-id="fd181-445"><see cref="T:System.Threading.NativeOverlapped" /> Struktura do kolejki.</span><span class="sxs-lookup"><span data-stu-id="fd181-445">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span></span></param>
        <summary><span data-ttu-id="fd181-446">Kolejkuje przychodzącą operację we/wy do wykonania.</span><span class="sxs-lookup"><span data-stu-id="fd181-446">Queues an overlapped I/O operation for execution.</span></span></summary>
        <returns><span data-ttu-id="fd181-447"><see langword="true" />Jeśli operacja została pomyślnie umieszczona w kolejce do portu zakończenia we/wy; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="fd181-447"><see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-448">Aby uzyskać informacje na temat korzystania z natywnego środowiska Win32 z nakładaniem <xref:System.Threading.Overlapped> operacji we/ <xref:System.Threading.NativeOverlapped> wy, zobacz Klasa `OVERLAPPED` , struktura i struktura w zestawie SDK platformy Win32.</span><span class="sxs-lookup"><span data-stu-id="fd181-448">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="fd181-449"><xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> Użycie metody może przypadkowo otworzyć otwór w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="fd181-449">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="fd181-450">Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="fd181-450">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="fd181-451">Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>użyciu, stos wątku puli wątków nie ma kontekstu rzeczywistych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="fd181-451">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="fd181-452">Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-452">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="fd181-453">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="fd181-453">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="fd181-454">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="fd181-454">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="fd181-455">Element roboczy do wywołania, gdy wątek w puli wątków Pobiera element roboczy.</span><span class="sxs-lookup"><span data-stu-id="fd181-455">The work item to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="fd181-456"><see langword="true" />Aby preferować kolejkowanie elementu pracy w kolejce blisko bieżącego wątku; <see langword="false" /> aby preferować kolejkowanie elementu pracy do kolejki udostępnionej puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-456"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="fd181-457">Kolejkuje określony obiekt elementu pracy w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-457">Queues the specified work item object to the thread pool.</span></span></summary>
        <returns><span data-ttu-id="fd181-458"><see langword="true" />Jeśli metoda się powiedzie; <see cref="T:System.OutOfMemoryException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="fd181-458"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="fd181-459">Pula wątków wywoła <xref:System.Threading.IThreadPoolWorkItem.Execute> metodę elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="fd181-459">The thread pool will invoke the work item's <xref:System.Threading.IThreadPoolWorkItem.Execute> method.</span></span> <span data-ttu-id="fd181-460">Jest odpowiedzialny za ten element roboczy do propagowania <xref:System.Threading.ExecutionContext> , jeśli jest to konieczne; Pula wątków nie zostanie tak przełączona.</span><span class="sxs-lookup"><span data-stu-id="fd181-460">It is the responsibility of that work item to propagate <xref:System.Threading.ExecutionContext> if it's needed; the thread pool will not do so.</span></span>

         ]]></format>
       </remarks>
         <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fd181-461"><paramref name="callback" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-461"><paramref name="callback" /> is <see langword="null" />.</span></span></exception>
         <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fd181-462">Element roboczy jest <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-462">The work item is a <see cref="T:System.Threading.Tasks.Task" />.</span></span></exception>
         <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="fd181-463">Nie można umieścić w kolejce elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="fd181-463">The work item could not be queued.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="fd181-464"><see cref="T:System.Threading.WaitCallback" /> Reprezentujący delegata do wywołania, gdy wątek w puli wątków Pobiera element roboczy.</span><span class="sxs-lookup"><span data-stu-id="fd181-464">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-465">Obiekt, który jest przesyłany do delegata, gdy jest obsługiwany z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-465">The object that is passed to the delegate when serviced from the thread pool.</span></span></param>
        <summary><span data-ttu-id="fd181-466">Kolejkuje określonego delegata do puli wątków, ale nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-466">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="fd181-467"><see langword="true" />Jeśli metoda się powiedzie; <see cref="T:System.OutOfMemoryException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="fd181-467"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-468">W przeciwieństwie <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> do metody <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> , nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-468">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="fd181-469">Dzięki temu kod może utracić stos wywołań i w związku z tym podwyższyć poziom uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-469">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="fd181-470">Korzystanie <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> z programu może przypadkowo otworzyć otwór w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="fd181-470">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="fd181-471">Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="fd181-471">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="fd181-472">Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>użyciu, stos wątku puli wątków nie będzie miał kontekstu rzeczywistych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="fd181-472">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="fd181-473">Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-473">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fd181-474">Obiekt wywołujący nie posiada wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-474">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="fd181-475">Napotkano warunek braku pamięci.</span><span class="sxs-lookup"><span data-stu-id="fd181-475">An out-of-memory condition was encountered.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="fd181-476">Nie można umieścić w kolejce elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="fd181-476">The work item could not be queued.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fd181-477"><paramref name="callBack" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-477"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="fd181-478">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="fd181-478">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="fd181-479">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="fd181-479">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-480">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-480">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="fd181-481">Typ elementów <paramref name="state" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-481">The type of elements of <paramref name="state" />.</span></span></typeparam>
        <param name="callBack"><span data-ttu-id="fd181-482">Delegat reprezentujący metodę do wykonania.</span><span class="sxs-lookup"><span data-stu-id="fd181-482">A delegate representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-483">Obiekt zawierający dane, które mają być używane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-483">An object containing data to be used by the method.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="fd181-484"><see langword="true" />Aby preferować kolejkowanie elementu pracy w kolejce blisko bieżącego wątku; <see langword="false" /> aby preferować kolejkowanie elementu pracy do kolejki udostępnionej puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-484"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="fd181-485">Kolejkuje metodę określoną przez <see cref="T:System.Action`1" /> delegata do wykonania i określa obiekt zawierający dane, które mają być używane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="fd181-485">Queues a method specified by an <see cref="T:System.Action`1" /> delegate for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="fd181-486">Metoda jest wykonywana po udostępnieniu wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-486">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="fd181-487"><see langword="true" />Jeśli metoda została pomyślnie umieszczona w kolejce; <see cref="T:System.NotSupportedException" /> jest zgłaszany, jeśli nie można umieścić w kolejce elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="fd181-487"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fd181-488"><paramref name="callback" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-488"><paramref name="callback" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fd181-489">Nie można umieścić w kolejce elementu pracy.</span><span class="sxs-lookup"><span data-stu-id="fd181-489">The work item could not be queued.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="fd181-490">Rejestruje delegata w celu oczekiwania na <see cref="T:System.Threading.WaitHandle" />, ale nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-490">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="fd181-491"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji.</span><span class="sxs-lookup"><span data-stu-id="fd181-491">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="fd181-492">Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></span><span class="sxs-lookup"><span data-stu-id="fd181-492">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="fd181-493">Delegat do wywołania po <paramref name="waitObject" /> zasygnalizowaniu parametru.</span><span class="sxs-lookup"><span data-stu-id="fd181-493">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-494">Obiekt, który jest przesyłany do delegata.</span><span class="sxs-lookup"><span data-stu-id="fd181-494">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="fd181-495">Limit czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-495">The time-out in milliseconds.</span></span> <span data-ttu-id="fd181-496"><paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="fd181-496">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="fd181-497">Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</span><span class="sxs-lookup"><span data-stu-id="fd181-497">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="fd181-498"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-498"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="fd181-499">Rejestruje delegata <see cref="T:System.Threading.WaitHandle" />, aby czekał na, przy użyciu 32-bitowej ze znakiem liczby całkowitej, aby przekroczyć limit czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-499">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="fd181-500">Ta metoda nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-500">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="fd181-501"><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiekt, którego można użyć do anulowania zarejestrowanej operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-501">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-502">W przeciwieństwie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> do metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> , nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-502">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="fd181-503">Dzięki temu kod może utracić stos wywołań i w związku z tym podwyższyć poziom uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-503">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="fd181-504">Korzystanie <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> z programu może przypadkowo otworzyć otwór w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="fd181-504">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="fd181-505">Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="fd181-505">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="fd181-506">Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>użyciu, stos wątku puli wątków nie będzie miał kontekstu rzeczywistych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="fd181-506">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="fd181-507">Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-507">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="fd181-508">Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-508">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="fd181-509">Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-509">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="fd181-510">Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="fd181-510">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="fd181-511">Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-511">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fd181-512"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejszy niż-1.</span><span class="sxs-lookup"><span data-stu-id="fd181-512">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fd181-513">Obiekt wywołujący nie posiada wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-513">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="fd181-514">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="fd181-514">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="fd181-515">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="fd181-515">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-516">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-516">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="fd181-517"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji.</span><span class="sxs-lookup"><span data-stu-id="fd181-517">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="fd181-518">Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></span><span class="sxs-lookup"><span data-stu-id="fd181-518">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="fd181-519">Delegat do wywołania po <paramref name="waitObject" /> zasygnalizowaniu parametru.</span><span class="sxs-lookup"><span data-stu-id="fd181-519">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-520">Obiekt, który jest przesyłany do delegata.</span><span class="sxs-lookup"><span data-stu-id="fd181-520">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="fd181-521">Limit czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-521">The time-out in milliseconds.</span></span> <span data-ttu-id="fd181-522"><paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="fd181-522">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="fd181-523">Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</span><span class="sxs-lookup"><span data-stu-id="fd181-523">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="fd181-524"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-524"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="fd181-525">Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na, określając 64-bitową liczbę całkowitą ze znakiem dla limitu czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-525">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="fd181-526">Ta metoda nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-526">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="fd181-527"><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiekt, którego można użyć do anulowania zarejestrowanej operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-527">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-528">W przeciwieństwie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> do metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> , nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-528">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="fd181-529">Dzięki temu kod może utracić stos wywołań i w związku z tym podwyższyć poziom uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-529">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="fd181-530">Korzystanie <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> z programu może przypadkowo otworzyć otwór w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="fd181-530">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="fd181-531">Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="fd181-531">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="fd181-532">Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>użyciu, stos wątku puli wątków nie będzie miał kontekstu rzeczywistych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="fd181-532">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="fd181-533">Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-533">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="fd181-534">Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-534">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="fd181-535">Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-535">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="fd181-536">Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="fd181-536">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="fd181-537">Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-537">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fd181-538"><paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejszy niż-1.</span><span class="sxs-lookup"><span data-stu-id="fd181-538">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fd181-539">Obiekt wywołujący nie posiada wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-539">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="fd181-540">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="fd181-540">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="fd181-541">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="fd181-541">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-542">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-542">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="fd181-543"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji.</span><span class="sxs-lookup"><span data-stu-id="fd181-543">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="fd181-544">Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></span><span class="sxs-lookup"><span data-stu-id="fd181-544">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="fd181-545">Delegat do wywołania po <paramref name="waitObject" /> zasygnalizowaniu parametru.</span><span class="sxs-lookup"><span data-stu-id="fd181-545">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-546">Obiekt, który jest przesyłany do delegata.</span><span class="sxs-lookup"><span data-stu-id="fd181-546">The object that is passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="fd181-547">Limit czasu reprezentowany przez <see cref="T:System.TimeSpan" />.</span><span class="sxs-lookup"><span data-stu-id="fd181-547">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="fd181-548">Jeśli <paramref name="timeout" /> jest równa 0 (zero), funkcja testuje stan obiektu i natychmiast wraca.</span><span class="sxs-lookup"><span data-stu-id="fd181-548">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="fd181-549">Jeśli <paramref name="timeout" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</span><span class="sxs-lookup"><span data-stu-id="fd181-549">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="fd181-550"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-550"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="fd181-551">Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na <see cref="T:System.TimeSpan" /> określenie wartości limitu czasu. Ta metoda nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-551">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="fd181-552"><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiekt, którego można użyć do anulowania zarejestrowanej operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-552">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-553">W przeciwieństwie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> do metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> , nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-553">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="fd181-554">Dzięki temu kod może utracić stos wywołań i w związku z tym podwyższyć poziom uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-554">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="fd181-555">Korzystanie <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> z programu może przypadkowo otworzyć otwór w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="fd181-555">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="fd181-556">Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="fd181-556">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="fd181-557">Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>użyciu, stos wątku puli wątków nie będzie miał kontekstu rzeczywistych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="fd181-557">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="fd181-558">Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-558">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="fd181-559">Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-559">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="fd181-560">Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-560">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="fd181-561">Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="fd181-561">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="fd181-562">Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-562">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fd181-563"><paramref name="timeout" /> Parametr jest mniejszy niż-1.</span><span class="sxs-lookup"><span data-stu-id="fd181-563">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fd181-564">Parametr jest większy niż <see cref="F:System.Int32.MaxValue" />. <paramref name="timeout" /></span><span class="sxs-lookup"><span data-stu-id="fd181-564">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fd181-565">Obiekt wywołujący nie posiada wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-565">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="fd181-566">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="fd181-566">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="fd181-567">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="fd181-567">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-568">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-568">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="fd181-569"><see cref="T:System.Threading.WaitHandle" /> Do rejestracji.</span><span class="sxs-lookup"><span data-stu-id="fd181-569">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="fd181-570">Użyj innego niż <see cref="T:System.Threading.Mutex" />. <see cref="T:System.Threading.WaitHandle" /></span><span class="sxs-lookup"><span data-stu-id="fd181-570">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="fd181-571">Delegat do wywołania po <paramref name="waitObject" /> zasygnalizowaniu parametru.</span><span class="sxs-lookup"><span data-stu-id="fd181-571">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="fd181-572">Obiekt, który jest przesyłany do delegata.</span><span class="sxs-lookup"><span data-stu-id="fd181-572">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="fd181-573">Limit czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-573">The time-out in milliseconds.</span></span> <span data-ttu-id="fd181-574"><paramref name="millisecondsTimeOutInterval" /> Jeśli parametr ma wartość 0 (zero), funkcja testuje stan obiektu i natychmiast zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="fd181-574">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="fd181-575">Jeśli <paramref name="millisecondsTimeOutInterval" /> wartość to-1, interwał limitu czasu funkcji nigdy nie upłynął.</span><span class="sxs-lookup"><span data-stu-id="fd181-575">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="fd181-576"><see langword="true" />Aby wskazać, że wątek nie będzie już oczekiwał na <paramref name="waitObject" /> parametr po wywołaniu delegata; <see langword="false" /> aby wskazać, że czasomierz jest resetowany za każdym razem, gdy operacja oczekiwania zostanie zakończona do momentu wyrejestrowania oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-576"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="fd181-577">Rejestruje delegata w celu oczekiwania <see cref="T:System.Threading.WaitHandle" />na, określając 32-bitową liczbę całkowitą bez znaku dla limitu czasu w milisekundach.</span><span class="sxs-lookup"><span data-stu-id="fd181-577">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span> <span data-ttu-id="fd181-578">Ta metoda nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-578">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="fd181-579"><see cref="T:System.Threading.RegisteredWaitHandle" /> Obiekt, którego można użyć do anulowania zarejestrowanej operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-579">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fd181-580">W przeciwieństwie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> do metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> , nie propaguje stosu wywołań do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="fd181-580">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="fd181-581">Dzięki temu kod może utracić stos wywołań i w związku z tym podwyższyć poziom uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="fd181-581">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="fd181-582">Korzystanie <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> z programu może przypadkowo otworzyć otwór w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="fd181-582">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="fd181-583">Zabezpieczenia dostępu kodu są podstawą sprawdzania uprawnień wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="fd181-583">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="fd181-584">Gdy praca jest umieszczona w kolejce puli wątków przy <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>użyciu, stos wątku puli wątków nie będzie miał kontekstu rzeczywistych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="fd181-584">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="fd181-585">Złośliwy kod może być w stanie wykorzystać ten sposób, aby uniknąć sprawdzania uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-585">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="fd181-586">Użycie elementu <xref:System.Threading.Mutex> for `waitObject` nie zapewnia wzajemnego wykluczania dla wywołań zwrotnych, ponieważ podstawowy interfejs API systemu `WT_EXECUTEDEFAULT` Windows używa flagi domyślnej, dlatego każde wywołanie zwrotne jest wysyłane w osobnym wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="fd181-586">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="fd181-587">Po zakończeniu korzystania z programu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę, należy <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> wywołać metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-587">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="fd181-588">Zalecamy, aby zawsze wywołać metodę, <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> nawet jeśli określisz `true` wartość for `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="fd181-588">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="fd181-589">Wyrzucanie elementów bezużytecznych działa wydajniej w przypadku wywołania <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody zamiast w zależności od zarejestrowanego dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="fd181-589">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="fd181-590">Obiekt wywołujący nie posiada wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="fd181-590">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="fd181-591">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="fd181-591">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="fd181-592">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="fd181-592">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="fd181-593">Zarządzana pula wątków</span><span class="sxs-lookup"><span data-stu-id="fd181-593">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
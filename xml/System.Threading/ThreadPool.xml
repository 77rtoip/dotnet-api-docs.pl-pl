<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50de54f2e0cde589b4af1c454e85fed39c9f40df" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="eb3a2-101">Udostępnia puli wątków, które mogą służyć do wykonywania zadań, publikowania elementów roboczych, Przetwarzanie asynchroniczne We/Wy, Oczekiwanie w imieniu innych wątków i przetworzyć czasomierze.</span>
      <span class="sxs-lookup">
        <span data-stu-id="eb3a2-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-102">Wiele aplikacji Tworzenie wątków, które spędzają na dużą ilość czasu w stanie uśpiony, oczekuje na wystąpienie zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="eb3a2-103">Inne wątki może przejść w stan uśpiony tylko do wznowione okresowo sondować zmiany lub zaktualizować informacje o stanie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="eb3a2-104">Pula wątków umożliwia korzystanie wątków wydajniej, udostępniając aplikację z pulą wątków roboczych, które są zarządzane przez system.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="eb3a2-105">Oto operacje, które używają wątków z puli wątków:</span><span class="sxs-lookup"><span data-stu-id="eb3a2-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="eb3a2-106">Po utworzeniu <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> obiektu w celu wykonania niektórych zadań asynchronicznie, domyślnie zadanie jest zaplanowane do uruchomienia w wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="eb3a2-107">Czasomierze asynchroniczne Użyj puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="eb3a2-108">Wątków z puli wątków wykonywania wywołań zwrotnych z <xref:System.Threading.Timer?displayProperty=nameWithType> klasy i wywoływanie zdarzeń od <xref:System.Timers.Timer?displayProperty=nameWithType> klasy.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="eb3a2-109">Gdy używasz uchwyty oczekiwania zarejestrowanych wątku systemu monitoruje stan uchwyty oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="eb3a2-110">Po ukończeniu operacji oczekiwania wątku roboczego z puli wątków wykonuje odpowiednie funkcja wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="eb3a2-111">Podczas wywoływania <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody do kolejki metody do wykonania w wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="eb3a2-112">Można to zrobić przez przekazanie metody <xref:System.Threading.WaitCallback> delegowanie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="eb3a2-113">Delegat ma sygnaturę</span><span class="sxs-lookup"><span data-stu-id="eb3a2-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="eb3a2-114">gdzie `state` jest obiekt, który zawiera dane, które mają być używane przez delegata.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="eb3a2-115">Rzeczywiste dane mogą zostać przekazane do delegata, wywołując <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eb3a2-116">Wątki w puli wątków zarządzanych są wątki w tle.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="eb3a2-117">Oznacza to, że ich <xref:System.Threading.Thread.IsBackground%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="eb3a2-118">Oznacza to, że <xref:System.Threading.ThreadPool> wątku nie zachowa aplikacji uruchomionej po zamknięciu wszystkie wątki pierwszego planu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eb3a2-119">Gdy puli wątków ponownie używa wątku, nie czyści danych lokalny magazyn wątków lub pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="eb3a2-120">W związku z tym, gdy metoda sprawdza, czy lokalny magazyn wątków lub pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut wartości znajdzie może pozostać za pośrednictwem z wcześniejszego użycia wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="eb3a2-121">Można również kolejki elementów pracy, które nie są powiązane z operacją oczekiwania do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="eb3a2-122">Aby zażądać, że element pracy ma być obsługiwany przez wątek w puli wątków, należy wywołać <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="eb3a2-123">Ta metoda przyjmuje jako parametr odwołania do metody lub delegata, która zostanie wywołana przez wątek z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="eb3a2-124">Nie istnieje sposób anulowania elementu roboczego po jego zostało umieszczone w kolejce.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="eb3a2-125">Czasomierze kolejki czasomierza i zarejestrowanych oczekiwania operacji również używają puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="eb3a2-126">Funkcje wywołania zwrotnego, ich są umieszczane w kolejce do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="eb3a2-127">Brak jednej puli wątków na proces.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-127">There is one thread pool per process.</span></span> <span data-ttu-id="eb3a2-128">Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], domyślny rozmiar puli wątków procesu zależy od wielu czynników, takich jak rozmiar wirtualnej przestrzeni adresowej.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="eb3a2-129">Proces może wywołać <xref:System.Threading.ThreadPool.GetMaxThreads%2A> metodę, aby określić liczbę wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="eb3a2-130">Liczba wątków w puli wątków można zmieniać za pomocą <xref:System.Threading.ThreadPool.SetMaxThreads%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="eb3a2-131">Każdy wątek używa domyślny rozmiar stosu i uruchamia priorytetem domyślne.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eb3a2-132">Niezarządzany kod, który jest hostem środowiska .NET Framework, można zmienić rozmiar puli wątków za pomocą `CorSetMaxThreads` funkcja zdefiniowana w pliku mscoree.h.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="eb3a2-133">Puli wątków zawiera nowe wątków roboczych lub wątków zakończenia We/Wy na żądanie, dopóki nie osiągnie minimum dla każdej kategorii.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="eb3a2-134">Po osiągnięciu minimum puli wątków można utworzyć dodatkowe wątki w tej kategorii lub zaczekaj na zakończenie niektórych zadań.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="eb3a2-135">Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], pulą wątków tworzy i niszczy wątków roboczych w celu zoptymalizowania przepustowości, która jest zdefiniowana jako liczba zadań, kończące się na jednostkę czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="eb3a2-136">Zbyt mało wątków może nie mieć optymalne wykorzystanie dostępnych zasobów, natomiast zbyt wiele wątków można zwiększyć rywalizacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eb3a2-137">Jeśli żądanie jest niska, rzeczywista liczba wątków z puli wątków można spadnie poniżej wartości minimalnej.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="eb3a2-138">Można użyć <xref:System.Threading.ThreadPool.GetMinThreads%2A> metodę, aby uzyskać te wartości minimalnej.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="eb3a2-139">Można użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodę, aby zwiększyć minimalną liczbę wątków roboczych.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="eb3a2-140">Jednak niepotrzebnie zwiększenie tych wartości może spowodować problemy z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="eb3a2-141">Jeśli zbyt wiele zadań jest uruchomiona w tym samym czasie, wszystkie z nich wydaje się powoli.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="eb3a2-142">W większości przypadków puli wątków będą działać lepiej z własną algorytmu alokacji wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eb3a2-143">W poniższym przykładzie wątku głównego aplikacji kolejki metodę o nazwie `ThreadProc` do wykonywania w wątku puli wątków, sen dla jednej sekundy, a następnie zamyka.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="eb3a2-144">`ThreadProc` Metoda po prostu zostanie wyświetlony komunikat.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="eb3a2-145">Jeśli komentarz wywołanie <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody wątku głównego jest kończona przed uruchomieniem metody w wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="eb3a2-146">Pula wątków używa wątki w tle, które nie jest przechowywana aplikacja była uruchomiona, jeśli wszystkie wątki pierwszoplanowe zostały zakończone.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="eb3a2-147">(Jest to prosty przykład sytuacja wyścigu).</span><span class="sxs-lookup"><span data-stu-id="eb3a2-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="eb3a2-148">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="eb3a2-148">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb3a2-149">Wiąże dojścia systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-149">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="eb3a2-150">
            <see cref="T:System.IntPtr" /> Przechowuje dojście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-150">An <see cref="T:System.IntPtr" /> that holds the handle.</span>
          </span>
          <span data-ttu-id="eb3a2-151">Dojście musi otwarte dla pokrywającej się z inną operacji We/Wy na stronie niezarządzane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-151">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-152">Wiąże dojścia systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-152">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-153">
            <see langword="true" /> Jeśli dojście jest powiązana; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-153">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="eb3a2-154">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-154">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="eb3a2-155">Aby uzyskać możliwość wywoływania niezarządzanego kodu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-155">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="eb3a2-156">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-156">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="eb3a2-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> przechowuje dojście systemu operacyjnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span>
          </span>
          <span data-ttu-id="eb3a2-158">Dojście musi otwarte dla pokrywającej się z inną operacji We/Wy na stronie niezarządzane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-158">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-159">Wiąże dojścia systemu operacyjnego do <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-159">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-160">
            <see langword="true" /> Jeśli dojście jest powiązana; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-160">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-161">`osHandle` Parametr powinien być <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, która pochodzi z klasy abstrakcyjnej <xref:System.Runtime.InteropServices.SafeHandle> klasy.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-161">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="eb3a2-162">
            <paramref name="osHandle" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-162">
              <paramref name="osHandle" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="eb3a2-163">Aby uzyskać możliwość wywoływania niezarządzanego kodu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-163">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="eb3a2-164">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-164">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="eb3a2-165">Liczba wątków roboczych dostępne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-165">The number of available worker threads.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="eb3a2-166">Liczba dostępnych asynchronicznych wątków We/Wy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-166">The number of available asynchronous I/O threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-167">Pobiera różnicę między maksymalną liczbę wątków z puli wątków zwrócony przez <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> — metoda i numer obecnie aktywne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-167">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-168">Gdy <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> zwraca określonej przez zmienną `workerThreads` zawiera liczbę wątków roboczych dodatkowe, które można uruchomić, a zmienna określony przez `completionPortThreads` zawiera liczbę dodatkowych asynchronicznych wątków We/Wy, które mogą być Rozpoczęto.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-168">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="eb3a2-169">Jeśli nie ma żadnych dostępnych wątków, żądania puli wątków dodatkowe pozostają w kolejce do momentu udostępnienie wątków z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-169">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eb3a2-170">W poniższym przykładzie przedstawiono liczbę wątków roboczych i wątków We/Wy dostępne po uruchomieniu prostej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-170">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="eb3a2-171">Maksymalna liczba wątków roboczych w puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-171">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="eb3a2-172">Maksymalna liczba asynchronicznych wątków We/Wy w puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-172">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-173">Pobiera liczbę żądań w puli wątków, które mogą być jednocześnie aktywne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-173">Retrieves the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="eb3a2-174">Wszystkie żądania powyżej tego numeru pozostają w kolejce do momentu udostępnienie wątków z puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-174">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-175">Gdy <xref:System.Threading.ThreadPool.GetMaxThreads%2A> zwraca określonej przez zmienną `workerThreads` zawiera maksymalną liczbę dozwolonych w puli wątków wątków roboczych, a zmienna określony przez `completionPortThreads` zawiera maksymalną liczbę asynchronicznych wątków We/Wy w Pula wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-175">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="eb3a2-176">Można użyć <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> metodę, aby określić rzeczywistą liczbę wątków w puli wątków w danym momencie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-176">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="eb3a2-177">Można użyć <xref:System.Threading.ThreadPool.SetMaxThreads%2A> Aby ustawić maksymalną liczbę wątków roboczych i asynchronicznych wątków We/Wy w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-177">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="eb3a2-178">Można dodać do kolejki jako wiele żądań w puli wątków zezwala pamięci systemowej.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-178">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="eb3a2-179">W przypadku żądań więcej niż wątków z puli wątków dodatkowe żądania pozostają w kolejce do momentu udostępnienie wątków z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-179">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eb3a2-180">Poniższy przykład kodu pokazuje, jak pobrać liczba maksymalna i dostępna liczba wątków w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-180">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="eb3a2-181">Element roboczy znajduje się w kolejce używającej `FileStream` do asynchronicznego zapisu do dwóch plików.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-181">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="eb3a2-182">Metody wywołania zwrotnego jest mierzony nakładanie się.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-182">The callback methods are timed to overlap.</span></span> <span data-ttu-id="eb3a2-183">Wątek roboczy obsługuje elementu roboczego i, w zależności od szybkości oraz liczby procesorów w komputerze, co najmniej dwóch wątków portu zakończenia obsługiwać operacje zapisu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-183">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="eb3a2-184">Gdy metoda zwróci wartość, zawiera minimalną liczbę wątków roboczych, utworzonych puli wątków na żądanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-184">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="eb3a2-185">Gdy metoda zwróci wartość, zawiera minimalną liczbę asynchronicznych wątków We/Wy, które tworzy puli wątków na żądanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-185">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-186">Pobiera minimalną liczbę wątków, jakiej puli wątków tworzy na żądanie, jak zostały wprowadzone nowe żądania, przed przełączeniem do zarządzania wątku tworzenie i likwidacja algorytm.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-186">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-187">Puli wątków zawiera nowe wątków roboczych lub wątków zakończenia We/Wy na żądanie, dopóki nie osiągnie minimum dla każdej kategorii.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-187">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="eb3a2-188">Minimalna liczba wątków domyślnie do liczby procesorów w systemie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-188">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="eb3a2-189">Po osiągnięciu wartości minimalnej puli wątków można utworzyć dodatkowe wątki w tej kategorii lub zaczekaj na zakończenie niektórych zadań.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-189">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="eb3a2-190">Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], pulą wątków tworzy i niszczy wątki w celu zoptymalizowania przepustowości, która jest zdefiniowana jako liczba zadań, kończące się na jednostkę czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-190">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="eb3a2-191">Zbyt mało wątków może nie mieć optymalne wykorzystanie dostępnych zasobów, natomiast zbyt wiele wątków można zwiększyć rywalizacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-191">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eb3a2-192">Jeśli żądanie jest niska, rzeczywista liczba wątków z puli wątków można spadnie poniżej wartości minimalnej.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-192">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eb3a2-193">Poniższy przykład Ustawia minimalną liczbę wątków roboczych cztery i zachowa oryginalnej wartości minimalną liczbę asynchronicznych wątków zakończenia We/Wy.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-193">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb3a2-194">Ustawia metodę do wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-194">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="eb3a2-195">Metoda jest wykonywana po udostępnieniu wątku puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-195">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="eb3a2-196">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący metodę do wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-196">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-197">Ustawia metodę do wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-197">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="eb3a2-198">Metoda jest wykonywana po udostępnieniu wątku puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-198">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-199">
            <see langword="true" /> Jeśli metoda pomyślnie znajduje się w kolejce; <see cref="T:System.NotSupportedException" /> jest generowany, jeśli nie można umieścić w kolejce elementu roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-199">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-200">Można umieścić dane wymagane przez metodę umieszczonych w kolejce w pól wystąpień klasy, w którym zdefiniowano metody, lub można użyć <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> przeciążenia, które akceptuje obiekt zawierający potrzebne dane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-200">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eb3a2-201">Użytkownicy programu Visual Basic można pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu użyj `AddressOf` operator podczas przekazywania metody wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-201">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="eb3a2-202">Visual Basic automatycznie wywołuje konstruktor delegata poprawne.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-202">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="eb3a2-203">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="eb3a2-203">Version Information</span></span>  
 <span data-ttu-id="eb3a2-204">W programie .NET Framework w wersji 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-204">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="eb3a2-205">We wcześniejszych wersjach głównych informacje nie są propagowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-205">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eb3a2-206">W poniższym przykładzie użyto <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> przeciążenie metody można umieścić w kolejce zadań, która jest reprezentowana przez `ThreadProc` metody do wykonania, gdy wątek staje się dostępny.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-206">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="eb3a2-207">Informacje o zadaniu są dostarczane z tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-207">No task information is supplied with this overload.</span></span> <span data-ttu-id="eb3a2-208">W związku z tym informacje, które są dostępne dla `ThreadProc` metody jest ograniczona do metody należy do obiektu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-208">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="eb3a2-209">
            <paramref name="callBack" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-209">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="eb3a2-210">Środowisko uruchomieniowe języka wspólnego (CLR) jest obsługiwana, i host nie obsługuje tej akcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-210">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="eb3a2-211">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący metodę do wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-211">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb3a2-212">Obiekt zawierający dane, które mają być używane przez metodę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-212">An object containing data to be used by the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-213">Metody wykonywania kolejek i określa obiekt zawierający dane, które mają być używane przez metodę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-213">Queues a method for execution, and specifies an object containing data to be used by the method.</span>
          </span>
          <span data-ttu-id="eb3a2-214">Metoda jest wykonywana po udostępnieniu wątku puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-214">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-215">
            <see langword="true" /> Jeśli metoda pomyślnie znajduje się w kolejce; <see cref="T:System.NotSupportedException" /> jest generowany, jeśli nie można umieścić w kolejce elementu roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-215">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-216">Jeśli metoda wywołania zwrotnego wymaga złożone dane, można zdefiniować klasy zawierają dane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-216">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eb3a2-217">Użytkownicy programu Visual Basic można pominąć <xref:System.Threading.WaitCallback> Konstruktor i po prostu użyj `AddressOf` operator podczas przekazywania metody wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-217">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="eb3a2-218">Visual Basic automatycznie wywołuje konstruktor delegata poprawne.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-218">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="eb3a2-219">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="eb3a2-219">Version Information</span></span>  
 <span data-ttu-id="eb3a2-220">W programie .NET Framework w wersji 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-220">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="eb3a2-221">We wcześniejszych wersjach głównych informacje nie są propagowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-221">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eb3a2-222">Poniższy przykład przedstawia sposób tworzenia obiektu, który zawiera informacje o zadaniu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-222">The following example shows how to create an object that contains task information.</span></span> <span data-ttu-id="eb3a2-223">Ilustruje też sposób przekazywania tego obiektu do umieszczonych w kolejce do wykonania zadania w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-223">It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="eb3a2-224">Środowisko uruchomieniowe języka wspólnego (CLR) jest obsługiwana, i host nie obsługuje tej akcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-224">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="eb3a2-225">
            <paramref name="callBack" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-225">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state, bool preferLocal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb3a2-226">Rejestruje delegata, który oczekuje na <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-226">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="eb3a2-227">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-227">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="eb3a2-228">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-228">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="eb3a2-229">
            <see cref="T:System.Threading.WaitOrTimerCallback" /> Delegata do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-229">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb3a2-230">Obiekt, który jest przekazywany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-230">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="eb3a2-231">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-231">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="eb3a2-232">Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-232">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="eb3a2-233">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-233">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="eb3a2-234">
            <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-234">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-235">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 32-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-235">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-236">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-236">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-237">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-237">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="eb3a2-238">Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-238">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="eb3a2-239">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-239">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="eb3a2-240"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-240">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="eb3a2-241">Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="eb3a2-241">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="eb3a2-242">Określony obiekt jest w stanie sygnałowego.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-242">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="eb3a2-243">Upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-243">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="eb3a2-244"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-244">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="eb3a2-245">Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-245">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="eb3a2-246">Operacja oczekiwania została wykonana przez wątek z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-246">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="eb3a2-247">Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-247">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="eb3a2-248">Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-248">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eb3a2-249">Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-249">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="eb3a2-250">Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> maksymalna liczba 1.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-250">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="eb3a2-251">Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-251">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="eb3a2-252">Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-252">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="eb3a2-253">W związku z tym należy używać tej samej uchwyt macierzysty system operacyjny w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-253">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="eb3a2-254">Należy pamiętać, że nie należy impulsów zdarzeń obiektu przekazanych do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-254">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="eb3a2-255">Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-255">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="eb3a2-256">Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-256">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="eb3a2-257">Na przykład Licznik semafora zostaje zmniejszona o jeden.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-257">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="eb3a2-258">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="eb3a2-258">Version Information</span></span>  
 <span data-ttu-id="eb3a2-259">W programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-259">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="eb3a2-260">We wcześniejszych wersjach głównych informacje nie są propagowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-260">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="eb3a2-261">
            <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-261">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="eb3a2-262">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-262">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="eb3a2-263">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-263">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="eb3a2-264">
            <see cref="T:System.Threading.WaitOrTimerCallback" /> Delegata do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-264">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb3a2-265">Obiekt przekazywany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-265">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="eb3a2-266">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-266">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="eb3a2-267">Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-267">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="eb3a2-268">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-268">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="eb3a2-269">
            <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-269">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-270">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 64-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-270">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-271">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-271">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-272">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-272">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="eb3a2-273">Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-273">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="eb3a2-274">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-274">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="eb3a2-275"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-275">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="eb3a2-276">Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="eb3a2-276">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="eb3a2-277">Określony obiekt jest w stanie sygnałowego.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-277">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="eb3a2-278">Upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-278">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="eb3a2-279"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-279">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="eb3a2-280">Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-280">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="eb3a2-281">Operacja oczekiwania została wykonana przez wątek z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-281">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="eb3a2-282">Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-282">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="eb3a2-283">Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-283">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eb3a2-284">Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-284">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="eb3a2-285">Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> maksymalna liczba 1.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-285">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="eb3a2-286">Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-286">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="eb3a2-287">Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-287">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="eb3a2-288">W związku z tym należy używać tej samej uchwyt macierzysty system operacyjny w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-288">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="eb3a2-289">Należy pamiętać, że nie należy impulsów zdarzeń obiektu przekazanych do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-289">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="eb3a2-290">Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-290">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="eb3a2-291">Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-291">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="eb3a2-292">Na przykład Licznik semafora zostaje zmniejszona o jeden.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-292">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="eb3a2-293">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="eb3a2-293">Version Information</span></span>  
 <span data-ttu-id="eb3a2-294">W programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-294">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="eb3a2-295">We wcześniejszych wersjach głównych informacje nie są propagowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-295">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="eb3a2-296">
            <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-296">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="eb3a2-297">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-297">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="eb3a2-298">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-298">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="eb3a2-299">
            <see cref="T:System.Threading.WaitOrTimerCallback" /> Delegata do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-299">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb3a2-300">Obiekt przekazywany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-300">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="eb3a2-301">Limit czasu reprezentowany przez <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-301">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="eb3a2-302">Jeśli <c>limitu czasu</c> jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-302">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="eb3a2-303">Jeśli <c>limitu czasu</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-303">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="eb3a2-304">
            <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-304">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-305">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określania <see cref="T:System.TimeSpan" /> wartość limitu czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-305">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-306">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Która hermetyzuje uchwyt macierzysty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-306">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-307">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-307">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="eb3a2-308">Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-308">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="eb3a2-309">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-309">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="eb3a2-310"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-310">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="eb3a2-311">Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="eb3a2-311">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="eb3a2-312">Określony obiekt jest w stanie sygnałowego.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-312">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="eb3a2-313">Upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-313">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="eb3a2-314"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-314">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="eb3a2-315">Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-315">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="eb3a2-316">Operacja oczekiwania została wykonana przez wątek z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-316">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="eb3a2-317">Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-317">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="eb3a2-318">Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-318">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eb3a2-319">Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-319">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="eb3a2-320">Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> maksymalna liczba 1.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-320">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="eb3a2-321">Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-321">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="eb3a2-322">Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-322">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="eb3a2-323">W związku z tym należy używać tej samej uchwyt macierzysty system operacyjny w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-323">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="eb3a2-324">Należy pamiętać, że nie należy impulsów zdarzeń obiektu przekazanych do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-324">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="eb3a2-325">Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-325">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="eb3a2-326">Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-326">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="eb3a2-327">Na przykład Licznik semafora zostaje zmniejszona o jeden.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-327">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="eb3a2-328">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="eb3a2-328">Version Information</span></span>  
 <span data-ttu-id="eb3a2-329">W programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-329">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="eb3a2-330">We wcześniejszych wersjach głównych informacje nie są propagowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-330">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="eb3a2-331">
            <paramref name="timeout" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-331">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="eb3a2-332">
            <paramref name="timeout" /> Parametru jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-332">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="eb3a2-333">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-333">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="eb3a2-334">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-334">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="eb3a2-335">
            <see cref="T:System.Threading.WaitOrTimerCallback" /> Delegata do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-335">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb3a2-336">Obiekt przekazywany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-336">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="eb3a2-337">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-337">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="eb3a2-338">Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-338">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="eb3a2-339">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-339">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="eb3a2-340">
            <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-340">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-341">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 32-bitową nieznakowaną liczbą całkowitą wartość limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-341">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-342">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Można anulować operacji zarejestrowanych oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-342">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-343">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-343">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="eb3a2-344">Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-344">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="eb3a2-345">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-345">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="eb3a2-346"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metody kolejki określonego delegata do puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-346">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="eb3a2-347">Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="eb3a2-347">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="eb3a2-348">Określony obiekt jest w stanie sygnałowego.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-348">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="eb3a2-349">Upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-349">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="eb3a2-350"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-350">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="eb3a2-351">Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-351">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="eb3a2-352">Operacja oczekiwania została wykonana przez wątek z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-352">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="eb3a2-353">Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-353">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="eb3a2-354">Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-354">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eb3a2-355">Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-355">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="eb3a2-356">Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore> maksymalna liczba 1.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-356">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="eb3a2-357">Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-357">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="eb3a2-358">Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-358">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="eb3a2-359">W związku z tym należy używać tej samej uchwyt macierzysty system operacyjny w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-359">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="eb3a2-360">Należy pamiętać, że nie należy impulsów zdarzeń obiektu przekazanych do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-360">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="eb3a2-361">Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-361">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="eb3a2-362">Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-362">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="eb3a2-363">Na przykład Licznik semafora zostaje zmniejszona o jeden.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-363">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="eb3a2-364">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="eb3a2-364">Version Information</span></span>  
 <span data-ttu-id="eb3a2-365">W programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-365">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="eb3a2-366">We wcześniejszych wersjach głównych informacje nie są propagowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-366">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eb3a2-367">Poniższy przykład przedstawia użycie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody próbę wykonania metody wywołania zwrotnego określony podczas oczekiwania określonego dojścia jest sygnalizowane.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-367">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="eb3a2-368">W tym przykładzie metoda wywołania zwrotnego jest `WaitProc`, i jest dojście oczekiwania <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-368">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="eb3a2-369">W przykładzie zdefiniowano `TaskInfo` klasy do przechowywania informacji, który jest przekazywany do wywołania zwrotnego, podczas wykonywania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-369">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="eb3a2-370">W przykładzie jest tworzony `TaskInfo` obiektów i przypisuje go niektórych danych ciągu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-370">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="eb3a2-371"><xref:System.Threading.RegisteredWaitHandle> Zwróconego przez <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody jest przypisany do `Handle` pole `TaskInfo` obiekt, tak aby metody wywołania zwrotnego ma dostęp do <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-371">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="eb3a2-372">Oprócz określenia `TaskInfo` jako obiekt, aby przekazać do metody wywołania zwrotnego, wywołanie <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> określa metodę <xref:System.Threading.AutoResetEvent> zadanie czeka, <xref:System.Threading.WaitOrTimerCallback> delegata, który reprezentuje `WaitProc` metody wywołania zwrotnego co drugi interwał limitu czasu i wielu wywołań zwrotnych.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-372">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="eb3a2-373">Jeśli sygnały wątku głównego <xref:System.Threading.AutoResetEvent> przez wywołanie jego <xref:System.Threading.EventWaitHandle.Set%2A> metody <xref:System.Threading.WaitOrTimerCallback> jest wywoływany delegat.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-373">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="eb3a2-374">`WaitProc` Testy metody <xref:System.Threading.RegisteredWaitHandle> ustalenie, czy upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-374">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="eb3a2-375">Jeśli wywołania zwrotnego został wywołany, ponieważ został sygnalizowane dojście oczekiwania, `WaitProc` wyrejestrowuje metody <xref:System.Threading.RegisteredWaitHandle>, zatrzymywanie dodatkowe wywołań zwrotnych.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-375">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="eb3a2-376">W przypadku przekroczenia limitu czasu zadanie nadal oczekuje.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-376">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="eb3a2-377">`WaitProc` Metoda kończy się wydrukowanie komunikat do konsoli.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-377">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="eb3a2-378">
            <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-378">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="eb3a2-379">Maksymalna liczba wątków roboczych w puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-379">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="eb3a2-380">Maksymalna liczba asynchronicznych wątków We/Wy w puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-380">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-381">Ustawia liczbę żądań w puli wątków, które mogą być jednocześnie aktywne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-381">Sets the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="eb3a2-382">Wszystkie żądania powyżej tego numeru pozostają w kolejce do momentu udostępnienie wątków z puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-382">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-383">
            <see langword="true" /> Jeśli zmiana zakończy się pomyślnie; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-383">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-384">Nie można ustawić maksymalną liczbę wątków roboczych lub wątków zakończenia We/Wy na liczbę mniejszą niż liczba procesorów na komputerze.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-384">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="eb3a2-385">Aby ustalić liczbę procesorów są obecne, pobrać wartość <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-385">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="eb3a2-386">Ponadto nie można ustawić maksymalną liczbę wątków roboczych lub zakończenia We/Wy wątków liczbą mniejszą niż odpowiedni minimalna liczba wątków roboczych lub wątków zakończenia We/Wy.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-386">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="eb3a2-387">Aby określić rozmiar puli wątków minimalne, należy wywołać <xref:System.Threading.ThreadPool.GetMinThreads%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-387">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="eb3a2-388">Jeśli środowisko uruchomieniowe języka wspólnego jest obsługiwana, na przykład przez Internet Information Services (IIS) lub SQL Server hosta można ograniczyć lub uniemożliwić zmiany rozmiaru puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-388">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="eb3a2-389">Należy zachować ostrożność podczas zmiany maksymalną liczbę wątków w puli wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-389">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="eb3a2-390">Gdy kod może korzystać, zmiany mogą mieć niekorzystny wpływ na bibliotekach kod, którego używasz.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-390">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="eb3a2-391">Ustawienie zbyt duży rozmiar puli wątków może spowodować problemy z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-391">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="eb3a2-392">Zbyt wiele wątków wykonywania jednocześnie przełączanie zadań nakładów pracy, staje się ważnym czynnikiem.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-392">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="eb3a2-393">możliwości, aby kontrolować wątki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-393">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="eb3a2-394">Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-394">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="eb3a2-395">Minimalna liczba wątków roboczych, utworzonych puli wątków na żądanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-395">The minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="eb3a2-396">Minimalna liczba asynchronicznych wątków We/Wy, które tworzy puli wątków na żądanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-396">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-397">Ustawia minimalną liczbę wątków, jakiej puli wątków tworzy na żądanie, wprowadzono nowe żądania, przed przełączeniem algorytm zarządzania wątku tworzenie i likwidacja.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-397">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-398">
            <see langword="true" /> Jeśli zmiana zakończy się pomyślnie; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-398">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-399">Puli wątków zawiera nowe wątków roboczych lub wątków zakończenia We/Wy na żądanie, dopóki nie osiągnie minimum dla każdej kategorii.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-399">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="eb3a2-400">Po osiągnięciu wartości minimalnej puli wątków można utworzyć dodatkowe wątki w tej kategorii lub zaczekaj na zakończenie niektórych zadań.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-400">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="eb3a2-401">Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], pulą wątków tworzy i niszczy wątki w celu zoptymalizowania przepustowości, która jest zdefiniowana jako liczba zadań, kończące się na jednostkę czasu.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-401">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="eb3a2-402">Zbyt mało wątków może nie mieć optymalne wykorzystanie dostępnych zasobów, natomiast zbyt wiele wątków można zwiększyć rywalizacji.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-402">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="eb3a2-403">Jeśli żądanie jest niska, rzeczywista liczba wątków z puli wątków można spadnie poniżej wartości minimalnej.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-403">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="eb3a2-404">Jeśli określono wartość ujemną lub większą niż maksymalna liczba aktywnych wątków z puli wątków liczbą (uzyskanych przy użyciu <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> zwraca `false` i nie zmienia się minimalnej wartości.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-404">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="eb3a2-405">Minimalna liczba wątków domyślnie do liczby procesorów w systemie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-405">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="eb3a2-406">Można użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodę, aby zwiększyć minimalna liczba ofthreads.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-406">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="eb3a2-407">Jednak niepotrzebnie zwiększenie tych wartości może spowodować problemy z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-407">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="eb3a2-408">Jeśli zbyt wiele zadań jest uruchomiona w tym samym czasie, wszystkie z nich wydaje się powoli.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-408">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="eb3a2-409">W większości przypadków puli wątków będą działać lepiej z własną algorytmu alokacji wątków.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-409">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="eb3a2-410">Zmniejszanie minimalnej na wartość mniejszą niż liczba procesorów również może pogarszać wydajność.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-410">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eb3a2-411">Poniższy przykład Ustawia minimalną liczbę wątków roboczych cztery i zachowa oryginalnej wartości minimalną liczbę asynchronicznych wątków zakończenia We/Wy.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-411">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="eb3a2-412">możliwości, aby kontrolować wątki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-412">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="eb3a2-413">Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-413">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <span data-ttu-id="eb3a2-414">
            <see cref="T:System.Threading.NativeOverlapped" /> Struktury do kolejki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-414">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-415">Kolejkuje pokrywającej się z inną operacji We/Wy do wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-415">Queues an overlapped I/O operation for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-416">
            <see langword="true" /> Operacja została pomyślnie umieszczane w kolejce do portu zakończenia We/Wy; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-416">
              <see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-417">Aby uzyskać informacji o korzystaniu z natywnego Win32 pokrywający się we/wy, zobacz <xref:System.Threading.Overlapped> klasy, <xref:System.Threading.NativeOverlapped> struktury i `OVERLAPPED` struktury w zestawie SDK platformy Win32.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-417">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="eb3a2-418">Przy użyciu <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> metody przypadkowo może otworzyć się luka w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-418">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="eb3a2-419">Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-419">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="eb3a2-420">Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, stosu wątku puli wątków nie ma kontekście rzeczywiste obiekty wywołujące.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-420">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="eb3a2-421">Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-421">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eb3a2-422">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-422">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eb3a2-423">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-423">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="eb3a2-424">A <see cref="T:System.Threading.WaitCallback" /> reprezentujący delegata do wywołania, gdy wątek w puli wątków przejmuje elementu roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-424">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb3a2-425">Obiekt, który jest przekazywany do delegata, gdy obsługiwany z puli wątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-425">The object that is passed to the delegate when serviced from the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-426">Kolejkuje określonego delegata do puli wątków, ale nie propaguje stosu wywołania do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-426">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-427">
            <see langword="true" /> Jeśli metoda zakończy się pomyślnie; <see cref="T:System.OutOfMemoryException" /> jest generowany, jeśli nie można umieścić w kolejce elementu roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-427">
              <see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-428">W odróżnieniu od <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metody <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> nie propaguje stosu wywołania do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-428">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="eb3a2-429">Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-429">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="eb3a2-430">Przy użyciu <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> może spowodować niezamierzoną otwarcia luka w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-430">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="eb3a2-431">Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-431">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="eb3a2-432">Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, stosu wątku puli wątków nie będą miały kontekście rzeczywiste obiekty wywołujące.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-432">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="eb3a2-433">Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-433">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="eb3a2-434">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-434">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="eb3a2-435">Wystąpił stan braku pamięci.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-435">An out-of-memory condition was encountered.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="eb3a2-436">Element roboczy nie można umieścić w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-436">The work item could not be queued.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="eb3a2-437">
            <paramref name="callBack" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-437">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eb3a2-438">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-438">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eb3a2-439">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-439">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb3a2-440">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, ale nie propaguje stosu wywołania do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-440">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="eb3a2-441">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-441">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="eb3a2-442">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-442">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="eb3a2-443">Delegat do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-443">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb3a2-444">Obiekt, który jest przekazywany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-444">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="eb3a2-445">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-445">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="eb3a2-446">Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-446">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="eb3a2-447">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-447">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="eb3a2-448">
            <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-448">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-449">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, przy użyciu 32-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-449">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="eb3a2-450">Ta metoda nie są propagowane stosu wywołania do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-450">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-451">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-451">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-452">W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołania do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-452">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="eb3a2-453">Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-453">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="eb3a2-454">Przy użyciu <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może spowodować niezamierzoną otwarcia luka w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-454">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="eb3a2-455">Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-455">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="eb3a2-456">Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku puli wątków nie będą miały kontekście rzeczywiste obiekty wywołujące.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-456">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="eb3a2-457">Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-457">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="eb3a2-458">Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-458">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="eb3a2-459">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-459">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="eb3a2-460">Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-460">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="eb3a2-461">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-461">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="eb3a2-462">
            <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-462">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="eb3a2-463">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-463">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eb3a2-464">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-464">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eb3a2-465">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-465">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="eb3a2-466">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-466">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="eb3a2-467">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-467">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="eb3a2-468">Delegat do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-468">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb3a2-469">Obiekt, który jest przekazywany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-469">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="eb3a2-470">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-470">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="eb3a2-471">Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-471">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="eb3a2-472">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-472">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="eb3a2-473">
            <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-473">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-474">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 64-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-474">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="eb3a2-475">Ta metoda nie są propagowane stosu wywołania do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-475">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-476">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-476">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-477">W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołania do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-477">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="eb3a2-478">Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-478">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="eb3a2-479">Przy użyciu <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może spowodować niezamierzoną otwarcia luka w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-479">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="eb3a2-480">Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-480">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="eb3a2-481">Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku puli wątków nie będą miały kontekście rzeczywiste obiekty wywołujące.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-481">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="eb3a2-482">Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-482">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="eb3a2-483">Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-483">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="eb3a2-484">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-484">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="eb3a2-485">Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-485">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="eb3a2-486">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-486">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="eb3a2-487">
            <paramref name="millisecondsTimeOutInterval" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-487">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="eb3a2-488">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-488">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eb3a2-489">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-489">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eb3a2-490">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-490">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="eb3a2-491">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-491">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="eb3a2-492">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-492">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="eb3a2-493">Delegat do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-493">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb3a2-494">Obiekt, który jest przekazywany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-494">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="eb3a2-495">Limit czasu reprezentowany przez <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-495">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="eb3a2-496">Jeśli <c>limitu czasu</c> jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-496">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="eb3a2-497">Jeśli <c>limitu czasu</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-497">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="eb3a2-498">
            <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-498">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-499">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określania <see cref="T:System.TimeSpan" /> wartość limitu czasu. Ta metoda nie są propagowane stosu wywołania do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-499">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-500">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-500">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-501">W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołania do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-501">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="eb3a2-502">Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-502">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="eb3a2-503">Przy użyciu <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może spowodować niezamierzoną otwarcia luka w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-503">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="eb3a2-504">Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-504">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="eb3a2-505">Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku puli wątków nie będą miały kontekście rzeczywiste obiekty wywołujące.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-505">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="eb3a2-506">Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-506">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="eb3a2-507">Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-507">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="eb3a2-508">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-508">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="eb3a2-509">Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-509">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="eb3a2-510">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-510">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="eb3a2-511">
            <paramref name="timeout" /> Parametr jest mniejsza niż -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-511">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="eb3a2-512">
            <paramref name="timeout" /> Parametru jest większa niż <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-512">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="eb3a2-513">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-513">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eb3a2-514">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-514">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eb3a2-515">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-515">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="eb3a2-516">
            <see cref="T:System.Threading.WaitHandle" /> Do zarejestrowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-516">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="eb3a2-517">Użyj <see cref="T:System.Threading.WaitHandle" /> innych niż <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-517">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="eb3a2-518">Delegat do wywołania, gdy <c>waitObject</c> zostanie zasygnalizowane parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-518">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb3a2-519">Obiekt, który jest przekazywany do delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-519">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="eb3a2-520">Limit czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-520">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="eb3a2-521">Jeśli <c>millisecondsTimeOutInterval</c> parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-521">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="eb3a2-522">Jeśli <c>millisecondsTimeOutInterval</c> wynosi -1, nigdy nie upłynie funkcji limitu czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-522">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="eb3a2-523">
            <see langword="true" /> Aby wskazać, że wątek nie będzie czekać <c>waitObject</c> parametru po wywołaniu delegata; <see langword="false" /> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-523">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb3a2-524">Rejestruje delegata oczekiwania <see cref="T:System.Threading.WaitHandle" />, określając 32-bitową nieznakowaną liczbą całkowitą wartość limitu czasu w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-524">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="eb3a2-525">Ta metoda nie są propagowane stosu wywołania do wątku roboczego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-525">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb3a2-526">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-526">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb3a2-527">W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metody <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> nie propaguje stosu wywołania do wątku roboczego.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-527">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="eb3a2-528">Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-528">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="eb3a2-529">Przy użyciu <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> może spowodować niezamierzoną otwarcia luka w zabezpieczeniach.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-529">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="eb3a2-530">Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-530">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="eb3a2-531">Gdy w kolejce pracy przy użyciu wątku puli wątków <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, stosu wątku puli wątków nie będą miały kontekście rzeczywiste obiekty wywołujące.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-531">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="eb3a2-532">Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-532">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="eb3a2-533">Przy użyciu <xref:System.Threading.Mutex> dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-533">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="eb3a2-534">Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle> , który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodę, aby zwolnić odwołania do dojścia oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-534">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="eb3a2-535">Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-535">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="eb3a2-536">Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> zamiast metody w zależności od finalizator dojście oczekiwania w zarejestrowany.</span><span class="sxs-lookup"><span data-stu-id="eb3a2-536">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="eb3a2-537">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-537">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eb3a2-538">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-538">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eb3a2-539">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb3a2-539">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>
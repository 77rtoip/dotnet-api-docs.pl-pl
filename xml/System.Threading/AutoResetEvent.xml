<Type Name="AutoResetEvent" FullName="System.Threading.AutoResetEvent">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9087366b105fd0db08981653c09c4fc5801df013" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30579232" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AutoResetEvent : System.Threading.EventWaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AutoResetEvent extends System.Threading.EventWaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.AutoResetEvent" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AutoResetEvent&#xA;Inherits EventWaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class AutoResetEvent sealed : System::Threading::EventWaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.EventWaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Powiadamia oczekiwania wątku, który wystąpiło zdarzenie. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `AutoResetEvent` Umożliwia wątków do komunikowania się ze sobą za sygnalizowania. Zazwyczaj za pomocą tej klasy wątków wyłącznego dostępu do zasobu.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 Wątek oczekuje na sygnał, wywołując <xref:System.Threading.WaitHandle.WaitOne%2A> na `AutoResetEvent`. Jeśli `AutoResetEvent` jest w stanie sygnalizowane bloki wątku, oczekiwania wątku że obecnie formantów zasobu sygnalizuje, że zasób jest dostępny, wywołując <xref:System.Threading.EventWaitHandle.Set%2A>.  
  
 Wywoływanie `Set` sygnały `AutoResetEvent` zwolnienia oczekiwania wątku. `AutoResetEvent` pozostaje zasygnalizować dopiero po zwolnieniu pojedynczego wątku oczekiwania i automatycznie zwraca stan sygnalizowane na. Jeśli nie ma wątków oczekujących, stan, pozostanie ona sygnałowego nieskończoność.  
  
 Jeśli wątek wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> podczas <xref:System.Threading.AutoResetEvent> jest w stanie sygnałowego wątku nie są blokowane. <xref:System.Threading.AutoResetEvent> Zwalnia wątek natychmiast, a następnie powróci do stanu sygnalizowane.  
  
> [!IMPORTANT]
>  Nie ma żadnych gwarancji, że każdego wywołania <xref:System.Threading.EventWaitHandle.Set%2A> metody opublikuje wątku. Jeśli dwa wywołania są zbyt blisko siebie tak, aby drugie wywołanie występuje przed wątek został zwolniony, tylko jeden wątek jest zwalniany. Jest tak, jakby nie nastąpiły drugie wywołanie. Ponadto jeśli <xref:System.Threading.EventWaitHandle.Set%2A> jest wywoływane, gdy nie ma żadnych wątków oczekujących i <xref:System.Threading.AutoResetEvent> zostało już zasygnalizowane, połączenie nie ma wpływu.  
  
 Można kontrolować początkowy stan `AutoResetEvent` przekazując wartość logiczną do konstruktora: `true` Jeśli stan początkowy jest sygnalizowane i `false` inaczej.  
  
 `AutoResetEvent` można również używać razem `static` <xref:System.Threading.WaitHandle.WaitAll%2A> i <xref:System.Threading.WaitHandle.WaitAny%2A> metody.  
  
 Aby uzyskać więcej informacji na temat mechanizmów synchronizacji wątku, zobacz [autoresetevent —](~/docs/standard/threading/autoresetevent.md) w dokumentacji koncepcyjnego.  
  
 Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Threading.AutoResetEvent> pochodzi z nowego <xref:System.Threading.EventWaitHandle> klasy. <xref:System.Threading.AutoResetEvent> Jest funkcjonalnym odpowiednikiem <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.  
  
> [!NOTE]
>  W odróżnieniu od <xref:System.Threading.AutoResetEvent> klasy <xref:System.Threading.EventWaitHandle> klasy zapewnia dostęp do systemu o nazwie zdarzenia synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.AutoResetEvent> zwolnienia jeden wątek pojedynczo, wywołując <xref:System.Threading.EventWaitHandle.Set%2A> — metoda (dla klasy podstawowej) każdego czasu użytkownik naciśnie **Enter** klucza. W przykładzie uruchomiono trzech wątków, które oczekiwanie na <xref:System.Threading.AutoResetEvent> utworzony w stanie sygnałowego. Pierwszym wątkiem zwolnieniu natychmiast, ponieważ <xref:System.Threading.AutoResetEvent> jest już w stanie sygnałowego. Spowoduje to zresetowanie <xref:System.Threading.AutoResetEvent> stan sygnalizowane tak, aby zablokować kolejnych wątków. Zablokowanych wątków nie są wydawane, dopóki użytkownik zwolni je jeden jednocześnie, naciskając klawisz **Enter** klucza.  
  
 Po wątki są wydawane z pierwszego <xref:System.Threading.AutoResetEvent>, będą oni czekać na innym <xref:System.Threading.AutoResetEvent> utworzony w stanie sygnalizowane. Blokuj wszystkie trzy wątki, więc <xref:System.Threading.EventWaitHandle.Set%2A> metoda musi zostać wywołana trzy razy zwolnienia je wszystkie.  
  
 [!code-cpp[System.Threading.AutoResetEvent#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CPP/simplerisbetter.cpp#3)]
 [!code-csharp[System.Threading.AutoResetEvent#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CS/simplerisbetter.cs#3)]
 [!code-vb[System.Threading.AutoResetEvent#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/VB/simplerisbetter.vb#3)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ta klasa jest bezpieczne dla wątków.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AutoResetEvent (bool initialState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AutoResetEvent(bool initialState);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> Aby ustawić stanu początkowego sygnalizuje; <see langword="false" /> Aby ustawić stan początkowy nie sygnalizuje.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.AutoResetEvent" /> klasy z wartość logiczną wskazującą, czy wartość stanu początkowego sygnałowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.AutoResetEvent> zsynchronizować działania dwoma wątkami. Wykonuje pierwszym wątkiem, czyli wątku aplikacji `Main`. Zapisuje wartości do chronionego zasobu, który jest `static` (`Shared` w języku Visual Basic) pola o nazwie `number`. Drugi wątek wykonuje statycznych `ThreadProc` metodę, która odczytuje wartości napisane przez `Main`.  
  
 `ThreadProc` Metoda oczekuje na <xref:System.Threading.AutoResetEvent>. Gdy `Main` wywołania <xref:System.Threading.EventWaitHandle.Set%2A> metoda <xref:System.Threading.AutoResetEvent>, `ThreadProc` metoda odczytuje jedną wartość. <xref:System.Threading.AutoResetEvent> Resetuje natychmiast, więc `ThreadProc` metoda oczekuje się ponownie.  
  
 Logika program gwarantuje, że `ThreadProc` metody nigdy nie odczyta tę samą wartość dwa razy. Go nie gwarantuje, że `ThreadProc` — metoda odczytuje każdej wartości napisane przez `Main`. Drugi wymagają gwarancji, że <xref:System.Threading.AutoResetEvent> blokady.  
  
 Po zakończeniu każdej operacji zapisu `Main` daje przez wywołanie metody <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody na umożliwieniu drugiego wątku do wykonania. W przeciwnym razie na komputerze z jednym procesorem `Main` zapisać wiele wartości między dowolne dwie operacje odczytu.  
  
 [!code-cpp[System.Threading.AutoResetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.AutoResetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CS/class1.cs#1)]
 [!code-vb[System.Threading.AutoResetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
      </Docs>
    </Member>
  </Members>
</Type>
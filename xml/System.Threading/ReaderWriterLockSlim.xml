<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7f8cf7b04c105b6589b9a0adbbf5930b0ae54096" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68393485" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="f54f2-101">Reprezentuje blokadę, która jest używana do zarządzania dostępem do zasobu, co pozwala wielu wątkom na odczyt lub wyłączny dostęp do zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-102">Służy <xref:System.Threading.ReaderWriterLockSlim> do ochrony zasobu, który jest odczytywany przez wiele wątków i w tym samym czasie zapisywana przez jeden wątek.</span><span class="sxs-lookup"><span data-stu-id="f54f2-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="f54f2-103"><xref:System.Threading.ReaderWriterLockSlim>zezwala na wiele wątków w trybie odczytu, umożliwia jednemu wątkowi w trybie zapisu z wyłączną własnością blokady i umożliwia jednemu wątkowi, który ma dostęp do odczytu w trybie odczytu możliwym do uaktualnienia, z którego wątek może uaktualnić do trybu zapisu bez konieczności wyłączania go s dostęp do odczytu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-104"><xref:System.Threading.ReaderWriterLockSlim>jest podobny do <xref:System.Threading.ReaderWriterLock>, ale ma uproszczone reguły dla rekursji i uaktualniania i obniżania stanu blokady.</span><span class="sxs-lookup"><span data-stu-id="f54f2-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="f54f2-105"><xref:System.Threading.ReaderWriterLockSlim>unika wielu przypadków potencjalnego zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="f54f2-106">Ponadto wydajność <xref:System.Threading.ReaderWriterLockSlim> jest znacznie lepsza niż <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="f54f2-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="f54f2-107"><xref:System.Threading.ReaderWriterLockSlim>jest zalecany w przypadku wszystkich nowych rozwiązań programistycznych.</span><span class="sxs-lookup"><span data-stu-id="f54f2-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="f54f2-108">Domyślnie nowe wystąpienia programu <xref:System.Threading.ReaderWriterLockSlim> są tworzone <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> z flagą i nie zezwalają na rekursję.</span><span class="sxs-lookup"><span data-stu-id="f54f2-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="f54f2-109">Ta zasada domyślna jest zalecana w przypadku wszystkich nowych rozwiązań programistycznych, ponieważ rekursja wprowadza niepotrzebne komplikacje i sprawia, że kod jest bardziej podatny na zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="f54f2-110">Aby uprościć migrację z istniejących projektów <xref:System.Threading.Monitor> wykorzystujących <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> lub <xref:System.Threading.ReaderWriterLock>, można użyć flagi <xref:System.Threading.ReaderWriterLockSlim> , aby utworzyć wystąpienia, które zezwalają na rekursję.</span><span class="sxs-lookup"><span data-stu-id="f54f2-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="f54f2-111">Wątek może wejść do blokady w trzech trybach: tryb odczytu, tryb zapisu i tryb odczytu do uaktualnienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="f54f2-112">(W pozostałej części tego tematu "tryb odczytu możliwy do uaktualnienia" jest określany jako "tryb uaktualniania" i fraza "Enter `x` Mode" jest używana w preferencjach do dłuższej frazy "Wejdź w `x` tryb blokady").</span><span class="sxs-lookup"><span data-stu-id="f54f2-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="f54f2-113">Niezależnie od zasad rekursji w dowolnym momencie tylko jeden wątek może być w trybie zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="f54f2-114">Gdy wątek działa w trybie zapisu, żaden inny wątek nie może wejść do blokady w żadnym trybie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="f54f2-115">Tylko jeden wątek może być w trybie do uaktualnienia w dowolnym momencie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="f54f2-116">Dowolna liczba wątków może być w trybie odczytu i może istnieć jeden wątek w trybie do uaktualnienia, podczas gdy inne wątki są w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f54f2-117">Ten typ implementuje <xref:System.IDisposable> interfejs.</span><span class="sxs-lookup"><span data-stu-id="f54f2-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="f54f2-118">Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio.</span><span class="sxs-lookup"><span data-stu-id="f54f2-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="f54f2-119">Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `catch` w bloku.</span><span class="sxs-lookup"><span data-stu-id="f54f2-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="f54f2-120">Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="f54f2-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="f54f2-121">Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="f54f2-122"><xref:System.Threading.ReaderWriterLockSlim>ma koligację zarządzanego wątku; oznacza to, że <xref:System.Threading.Thread> każdy obiekt musi wykonać własne wywołania metody, aby wejść i wyjść z trybu blokowania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="f54f2-123">Żaden wątek nie może zmienić trybu innego wątku.</span><span class="sxs-lookup"><span data-stu-id="f54f2-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="f54f2-124">Jeśli obiekt <xref:System.Threading.ReaderWriterLockSlim> nie zezwala na rekursję, wątek, który próbuje wprowadzić blokadę, może być blokowany z kilku powodów:</span><span class="sxs-lookup"><span data-stu-id="f54f2-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="f54f2-125">Wątek, który próbuje przejść do trybu odczytu, jeśli istnieją wątki oczekujące na przejście do trybu zapisu lub jeśli w trybie zapisu występuje pojedynczy wątek.</span><span class="sxs-lookup"><span data-stu-id="f54f2-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f54f2-126">Zablokowanie nowych czytników podczas umieszczania ich w kolejce jest zasadami sprawiedliwego blokowania, które preferują moduły zapisujące.</span><span class="sxs-lookup"><span data-stu-id="f54f2-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="f54f2-127">Bieżące zasady uczciwego zrównoważą atrakcyjność dla czytelników i autorów, aby wspierać przepływność w najbardziej typowych scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="f54f2-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="f54f2-128">Przyszłe wersje [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] programu mogą wprowadzać nowe zasady uczciwe.</span><span class="sxs-lookup"><span data-stu-id="f54f2-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="f54f2-129">Wątek, który próbuje wprowadzić bloki trybu możliwego do uaktualnienia, jeśli istnieje już wątek w trybie do uaktualnienia, jeśli istnieją wątki oczekujące na przejście do trybu zapisu lub jeśli w trybie zapisu występuje pojedynczy wątek.</span><span class="sxs-lookup"><span data-stu-id="f54f2-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="f54f2-130">Wątek, który próbuje wprowadzić bloki trybu zapisu, jeśli istnieje wątek w dowolnym z trzech trybów.</span><span class="sxs-lookup"><span data-stu-id="f54f2-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="f54f2-131">Uaktualnianie i obniżanie wersji blokad</span><span class="sxs-lookup"><span data-stu-id="f54f2-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="f54f2-132">Tryb uaktualniania jest przeznaczony dla przypadków, gdy wątek zwykle odczytuje z chronionego zasobu, ale może być konieczne zapisanie go w przypadku spełnienia pewnego warunku.</span><span class="sxs-lookup"><span data-stu-id="f54f2-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="f54f2-133">Wątek, który został wprowadzony <xref:System.Threading.ReaderWriterLockSlim> w trybie z możliwością uaktualnienia, ma dostęp do odczytu do chronionego zasobu i może przeprowadzić uaktualnienie do trybu zapisu, <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> wywołując metody lub.</span><span class="sxs-lookup"><span data-stu-id="f54f2-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="f54f2-134">Ponieważ w tym samym czasie może istnieć tylko jeden wątek, uaktualnienie do trybu zapisu nie jest możliwe, gdy rekursja jest niedozwolona, co jest zasadami domyślnymi.</span><span class="sxs-lookup"><span data-stu-id="f54f2-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f54f2-135">Niezależnie od zasad rekursji wątek, który początkowo wszedł w tryb odczytu, nie może być uaktualniany do trybu z możliwością uaktualnienia lub trybem zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="f54f2-136">Na przykład, jeśli dwa wątki w trybie odczytu próbują przejść do trybu zapisu, będą one zakleszczeni.</span><span class="sxs-lookup"><span data-stu-id="f54f2-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="f54f2-137">Tryb z modernizacją został zaprojektowany w celu uniknięcia takich zakleszczenii.</span><span class="sxs-lookup"><span data-stu-id="f54f2-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="f54f2-138">W przypadku innych wątków w trybie odczytu wątek, który uaktualnia bloki.</span><span class="sxs-lookup"><span data-stu-id="f54f2-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="f54f2-139">Gdy wątek jest zablokowany, inne wątki, które próbują przejść do trybu odczytu, są blokowane.</span><span class="sxs-lookup"><span data-stu-id="f54f2-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="f54f2-140">Gdy wszystkie wątki zostały zakończone z trybu odczytu, zablokowany wątek z możliwością uaktualnienia przechodzi w tryb zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="f54f2-141">Jeśli istnieją inne wątki oczekujące na przejście do trybu zapisu, pozostaną zablokowane, ponieważ pojedynczy wątek, który jest w trybie z możliwością uaktualnienia, uniemożliwia im uzyskanie wyłącznego dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="f54f2-142">Gdy wątek w trybie do uaktualnienia powoduje wyjście z trybu zapisu, inne wątki, które oczekują na przejście do trybu odczytu, mogą to zrobić, chyba że istnieją wątki oczekujące na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="f54f2-143">Wątek w trybie uaktualniania można uaktualnić i obniżać poziom w nieskończoność, o ile jest to jedyny wątek, który zapisuje dane do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f54f2-144">Jeśli zezwolisz wielu wątkom na przewprowadzanie trybu zapisu lub trybu możliwego do uaktualnienia, nie musisz zezwalać jednemu wątkowi na monopolize tryb uaktualniania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="f54f2-145">W przeciwnym razie wątki, które próbują wejść w tryb zapisu, będą blokowane w nieskończoność, a podczas gdy są blokowane, inne wątki nie będą mogły wejść w tryb odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="f54f2-146">Wątek w trybie do uaktualnienia może przejść do trybu odczytu, najpierw wywołując <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodę, a następnie <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> wywołując metodę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="f54f2-147">Ten wzorzec obniżania poziomu jest dozwolony dla wszystkich zasad rekursji <xref:System.Threading.LockRecursionPolicy.NoRecursion>blokady, nawet.</span><span class="sxs-lookup"><span data-stu-id="f54f2-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="f54f2-148">Po przeprowadzeniu obniżenia poziomu do trybu odczytu wątek nie może ponownie wprowadzić trybu możliwego do uaktualnienia, dopóki nie zostanie zakończony w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="f54f2-149">Wchodzenie cyklicznie</span><span class="sxs-lookup"><span data-stu-id="f54f2-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="f54f2-150">Można utworzyć obiekt <xref:System.Threading.ReaderWriterLockSlim> , który obsługuje cykliczny wpis blokady przy <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> użyciu konstruktora, który określa zasady blokowania i określając <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f54f2-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-151">Użycie rekursji nie jest zalecane w przypadku nowych rozwiązań, ponieważ wprowadza niepotrzebne komplikacje i sprawia, że kod jest bardziej podatny na zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="f54f2-152">Dla programu <xref:System.Threading.ReaderWriterLockSlim> , który umożliwia rekursję, można określić następujące informacje o trybach, które może wprowadzać wątek:</span><span class="sxs-lookup"><span data-stu-id="f54f2-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="f54f2-153">Wątek w trybie odczytu może przejść w tryb odczytu cyklicznie, ale nie może przejść do trybu zapisu ani trybu uaktualniania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="f54f2-154">Jeśli spróbuje to zrobić, <xref:System.Threading.LockRecursionException> zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="f54f2-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="f54f2-155">Przejście do trybu odczytu, a następnie przechodzenie do trybu zapisu lub tryb uaktualniania jest wzorcem ze silnym prawdopodobieństwem zakleszczenia, dlatego nie jest to dozwolone.</span><span class="sxs-lookup"><span data-stu-id="f54f2-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="f54f2-156">Jak wspomniano wcześniej, tryb możliwy do uaktualnienia jest udostępniany w przypadku, gdy konieczne jest uaktualnienie blokady.</span><span class="sxs-lookup"><span data-stu-id="f54f2-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="f54f2-157">Wątek w trybie możliwego do uaktualnienia może przejść do trybu zapisu i/lub trybu odczytu, a jednocześnie może wejść do jednego z trzech trybów cyklicznie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="f54f2-158">Jednak próba wprowadzenia bloków trybu zapisu, jeśli istnieją inne wątki w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="f54f2-159">Wątek w trybie zapisu może przejść do trybu odczytu i/lub z możliwością uaktualniania, a następnie wprowadzić wszystkie trzy tryby cyklicznie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="f54f2-160">Wątek, który nie wszedł w blokadę, może wejść w tryb.</span><span class="sxs-lookup"><span data-stu-id="f54f2-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="f54f2-161">Ta próba może blokować z tych samych powodów, co próba przejścia do blokady niecyklicznej.</span><span class="sxs-lookup"><span data-stu-id="f54f2-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="f54f2-162">Wątek może wyjść z trybu, który został wprowadzony w dowolnej kolejności, tak długo, jak zamyka każdy tryb dokładnie tyle razy, ile przeszedł ten tryb.</span><span class="sxs-lookup"><span data-stu-id="f54f2-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="f54f2-163">Jeśli wątek próbuje wyjść z trybu zbyt wiele razy lub aby wyjść z trybu, który nie został wprowadzony, <xref:System.Threading.SynchronizationLockException> jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="f54f2-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="f54f2-164">Stany blokad</span><span class="sxs-lookup"><span data-stu-id="f54f2-164">Lock States</span></span>  
 <span data-ttu-id="f54f2-165">Może się okazać, że warto zastanowić się, że blokada ma stan.</span><span class="sxs-lookup"><span data-stu-id="f54f2-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="f54f2-166"><xref:System.Threading.ReaderWriterLockSlim> Może być w jednym z czterech stanów: nie wprowadzono, odczytu, uaktualnienia i zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="f54f2-167">Nie wprowadzono: W tym stanie żaden wątek nie przeszedł blokady (lub wszystkie wątki zakończyły blokadę).</span><span class="sxs-lookup"><span data-stu-id="f54f2-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="f54f2-168">Przeczytaj W tym stanie co najmniej jeden wątek przeszedł blokadę dostępu do odczytu do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f54f2-169">Wątek może wejść do blokady w trybie odczytu przy użyciu <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metod lub <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> lub przez obniżenie wersji z trybu możliwego do uaktualnienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="f54f2-170">Uaktualniony W tym stanie jeden wątek przeszedł blokadę dostępu do odczytu z opcją uaktualnienia do zapisu (czyli w trybie uaktualnienia) i zero lub więcej wątków przeszedł blokadę dostępu do odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="f54f2-171">Nie więcej niż jeden wątek w danym momencie może przejść do blokady z opcją uaktualnienia; dodatkowe wątki, które próbują przejść do trybu z uaktualnieniem, są blokowane.</span><span class="sxs-lookup"><span data-stu-id="f54f2-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="f54f2-172">Prawem W tym stanie jeden wątek przeszedł blokadę dostępu do zapisu do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="f54f2-173">Ten wątek ma wyłączny dostęp do blokady.</span><span class="sxs-lookup"><span data-stu-id="f54f2-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="f54f2-174">Każdy inny wątek, który próbuje wprowadzić blokadę z dowolnego powodu, jest blokowany.</span><span class="sxs-lookup"><span data-stu-id="f54f2-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="f54f2-175">W poniższej tabeli opisano przejścia między Stanami blokady, w przypadku blokad, które nie zezwalają na rekursję `t` , gdy wątek wykonuje akcję opisaną w kolumnie z lewej strony.</span><span class="sxs-lookup"><span data-stu-id="f54f2-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="f54f2-176">W czasie trwania akcji `t` nie ma trybu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="f54f2-177">(Specjalny przypadek, w `t` którym jest w trybie z uaktualnieniem jest opisany w przypisach w tabeli). W górnym wierszu opisano stan początkowy blokady.</span><span class="sxs-lookup"><span data-stu-id="f54f2-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="f54f2-178">Komórki opisują, co się dzieje z wątkiem, i pokazują zmiany stanu blokady w nawiasach.</span><span class="sxs-lookup"><span data-stu-id="f54f2-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="f54f2-179">Nie wprowadzono (N)</span><span class="sxs-lookup"><span data-stu-id="f54f2-179">Not entered (N)</span></span>|<span data-ttu-id="f54f2-180">Odczyt (R)</span><span class="sxs-lookup"><span data-stu-id="f54f2-180">Read (R)</span></span>|<span data-ttu-id="f54f2-181">Uaktualnienie (U)</span><span class="sxs-lookup"><span data-stu-id="f54f2-181">Upgrade (U)</span></span>|<span data-ttu-id="f54f2-182">Zapis (W)</span><span class="sxs-lookup"><span data-stu-id="f54f2-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="f54f2-183">`t`przechodzi do trybu odczytu</span><span class="sxs-lookup"><span data-stu-id="f54f2-183">`t` enters read mode</span></span>|<span data-ttu-id="f54f2-184">`t`wejście (R).</span><span class="sxs-lookup"><span data-stu-id="f54f2-184">`t` enters (R).</span></span>|<span data-ttu-id="f54f2-185">`t`bloki, jeśli wątki oczekują na tryb zapisu; w przeciwnym razie wprowadza. `t`</span><span class="sxs-lookup"><span data-stu-id="f54f2-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="f54f2-186">`t`bloki, jeśli wątki oczekują na tryb zapisu; w przeciwnym razie wprowadza. `t` <sup> 1</sup></span><span class="sxs-lookup"><span data-stu-id="f54f2-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="f54f2-187">`t`propagowan.</span><span class="sxs-lookup"><span data-stu-id="f54f2-187">`t` blocks.</span></span>|  
|<span data-ttu-id="f54f2-188">`t`przechodzi do trybu z uaktualnieniem</span><span class="sxs-lookup"><span data-stu-id="f54f2-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="f54f2-189">`t`wprowadzenie (U).</span><span class="sxs-lookup"><span data-stu-id="f54f2-189">`t` enters (U).</span></span>|<span data-ttu-id="f54f2-190">`t`bloki, jeśli wątki oczekują na tryb zapisu lub tryb uaktualniania; w przeciwnym razie wprowadzi (U). `t`</span><span class="sxs-lookup"><span data-stu-id="f54f2-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="f54f2-191">`t`propagowan.</span><span class="sxs-lookup"><span data-stu-id="f54f2-191">`t` blocks.</span></span>|<span data-ttu-id="f54f2-192">`t`propagowan.</span><span class="sxs-lookup"><span data-stu-id="f54f2-192">`t` blocks.</span></span>|  
|<span data-ttu-id="f54f2-193">`t`przechodzi do trybu zapisu</span><span class="sxs-lookup"><span data-stu-id="f54f2-193">`t` enters write mode</span></span>|<span data-ttu-id="f54f2-194">`t`Wprowadź (W).</span><span class="sxs-lookup"><span data-stu-id="f54f2-194">`t` enters (W).</span></span>|<span data-ttu-id="f54f2-195">`t`propagowan.</span><span class="sxs-lookup"><span data-stu-id="f54f2-195">`t` blocks.</span></span>|<span data-ttu-id="f54f2-196">`t`propagowan. <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="f54f2-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="f54f2-197">`t`propagowan.</span><span class="sxs-lookup"><span data-stu-id="f54f2-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="f54f2-198"><sup>1</sup> Jeśli `t` program zostanie uruchomiony w trybie do uaktualnienia, przechodzi do trybu odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="f54f2-199">Ta akcja nigdy nie blokuje się.</span><span class="sxs-lookup"><span data-stu-id="f54f2-199">This action never blocks.</span></span> <span data-ttu-id="f54f2-200">Stan blokady nie zmienia się.</span><span class="sxs-lookup"><span data-stu-id="f54f2-200">The lock state does not change.</span></span> <span data-ttu-id="f54f2-201">(Wątek może następnie zakończyć proces obniżania poziomu do odczytu, kończąc tryb uaktualnienia).</span><span class="sxs-lookup"><span data-stu-id="f54f2-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="f54f2-202"><sup>2</sup> Jeśli `t` program jest uruchamiany w trybie do uaktualnienia, blokuje się, jeśli istnieją wątki w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="f54f2-203">W przeciwnym razie uaktualnia w trybie zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="f54f2-204">Stan blokady zmieni się na zapis (W).</span><span class="sxs-lookup"><span data-stu-id="f54f2-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="f54f2-205">Jeśli `t` bloki są wątkiem w trybie odczytu, przechodzi tryb zapisu zaraz po zakończeniu ostatniego wątku w trybie odczytu, nawet jeśli istnieją wątki oczekujące na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="f54f2-206">Gdy następuje zmiana stanu, ponieważ wątek opuszcza blokadę, Następny wątek do wznowienia jest wybierany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="f54f2-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="f54f2-207">Najpierw wątek, który oczekuje na tryb zapisu i jest już w trybie do uaktualnienia (może być co najwyżej jeden taki wątek).</span><span class="sxs-lookup"><span data-stu-id="f54f2-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="f54f2-208">Niepowodzenie, czyli wątek, który oczekuje na tryb zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="f54f2-209">Niepowodzenie, czyli wątek, który oczekuje na uaktualnienie trybu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="f54f2-210">Niepowodzenie, czyli wszystkie wątki czekające na tryb odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="f54f2-211">Kolejnym stanem blokady jest zawsze zapis (W) w pierwszych dwóch przypadkach i uaktualnienie (U) w trzecim przypadku, niezależnie od stanu blokady, gdy wątek wyjścia wywołał zmianę stanu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="f54f2-212">W ostatnim przypadku stan blokady jest uaktualniany (U), jeśli istnieje wątek w trybie możliwym do uaktualnienia po zmianie stanu i odczyt (R) w przeciwnym razie, niezależnie od poprzedniego stanu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-213">Poniższy przykład pokazuje prostą zsynchronizowaną pamięć podręczną, która przechowuje ciągi z kluczami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="f54f2-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="f54f2-214">Wystąpienie <xref:System.Threading.ReaderWriterLockSlim> jest używane do synchronizowania dostępu do programu <xref:System.Collections.Generic.Dictionary%602> , który służy jako wewnętrzna pamięć podręczna.</span><span class="sxs-lookup"><span data-stu-id="f54f2-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="f54f2-215">Przykład zawiera proste metody do dodania do pamięci podręcznej, usunięcia z pamięci podręcznej i odczytu z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="f54f2-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="f54f2-216">Aby wykazać limity czasu, przykład zawiera metodę, która dodaje do pamięci podręcznej tylko wtedy, gdy może to zrobić w określonym przedziale czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="f54f2-217">Aby zademonstrować tryb uaktualniania, przykład zawiera metodę, która pobiera wartość skojarzoną z kluczem i porównuje ją z nową wartością.</span><span class="sxs-lookup"><span data-stu-id="f54f2-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="f54f2-218">Jeśli wartość nie jest zmieniana, metoda zwraca stan wskazujący, że nie zmieni się.</span><span class="sxs-lookup"><span data-stu-id="f54f2-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="f54f2-219">Jeśli wartość klucza nie zostanie znaleziona, para klucz/wartość zostanie wstawiona.</span><span class="sxs-lookup"><span data-stu-id="f54f2-219">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="f54f2-220">Jeśli wartość została zmieniona, zostanie zaktualizowana.</span><span class="sxs-lookup"><span data-stu-id="f54f2-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="f54f2-221">Tryb uaktualniania pozwala wątku uaktualnić dostęp do odczytu w razie potrzeby do zapisu bez ryzyka zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="f54f2-222">Przykład zawiera zagnieżdżone Wyliczenie, które określa wartości zwracane dla metody, która pokazuje tryb uaktualniania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="f54f2-223">W przykładzie używa konstruktora bez parametrów, aby utworzyć blokadę, więc rekursja jest niedozwolona.</span><span class="sxs-lookup"><span data-stu-id="f54f2-223">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="f54f2-224"><xref:System.Threading.ReaderWriterLockSlim> Programowanie jest prostsze i mniej podatne na błędy, gdy blokada nie zezwala na rekursję.</span><span class="sxs-lookup"><span data-stu-id="f54f2-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="f54f2-225">Poniższy kod następnie używa `SynchronizedCache` obiektu do przechowywania słownika nazw warzyw.</span><span class="sxs-lookup"><span data-stu-id="f54f2-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="f54f2-226">Tworzy trzy zadania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-226">It creates three tasks.</span></span> <span data-ttu-id="f54f2-227">Najpierw zapisuje nazwy warzyw przechowywanych w tablicy do `SynchronizedCache` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="f54f2-228">Drugie i trzecie zadanie wyświetla nazwy warzyw, pierwsze w kolejności rosnącej (od dolnego indeksu do indeksu górnego), drugi w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="f54f2-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="f54f2-229">Zadanie końcowe wyszukuje ciąg "ogórki" i po jego znalezieniu wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony fasola".</span><span class="sxs-lookup"><span data-stu-id="f54f2-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="f54f2-230">Ten typ jest bezpieczny wątkowo.</span><span class="sxs-lookup"><span data-stu-id="f54f2-230">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f54f2-231">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f54f2-232">Inicjuje nowe wystąpienie <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy z domyślnymi wartościami właściwości.</span><span class="sxs-lookup"><span data-stu-id="f54f2-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-233">Obiekt <xref:System.Threading.ReaderWriterLockSlim> , który jest zainicjowany przy użyciu tego konstruktora, nie zezwala na rekursję.</span><span class="sxs-lookup"><span data-stu-id="f54f2-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="f54f2-234">Oznacza to, <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> że właściwość zwraca <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f54f2-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f54f2-235">Aby uzyskać więcej informacji na temat zasad rekursji i jej efektów <xref:System.Threading.LockRecursionPolicy> , zobacz Wyliczenie <xref:System.Threading.ReaderWriterLockSlim> i Klasa.</span><span class="sxs-lookup"><span data-stu-id="f54f2-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-236">Poniższy przykład pokazuje prostą zsynchronizowaną pamięć podręczną, która przechowuje ciągi z kluczami całkowitymi.</span><span class="sxs-lookup"><span data-stu-id="f54f2-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="f54f2-237">Wystąpienie <xref:System.Threading.ReaderWriterLockSlim> jest używane do synchronizowania dostępu do programu <xref:System.Collections.Generic.Dictionary%602> , który służy jako wewnętrzna pamięć podręczna.</span><span class="sxs-lookup"><span data-stu-id="f54f2-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="f54f2-238">Konstruktor bez parametrów jest używany do tworzenia blokady.</span><span class="sxs-lookup"><span data-stu-id="f54f2-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="f54f2-239">Przykład zawiera proste metody do dodania do pamięci podręcznej, usunięcia z pamięci podręcznej i odczytu z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="f54f2-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="f54f2-240">Aby wykazać limity czasu, przykład zawiera metodę, która dodaje do pamięci podręcznej tylko wtedy, gdy może to zrobić w określonym przedziale czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="f54f2-241">Aby zademonstrować tryb uaktualniania, przykład zawiera metodę, która pobiera wartość skojarzoną z kluczem i porównuje ją z nową wartością.</span><span class="sxs-lookup"><span data-stu-id="f54f2-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="f54f2-242">Jeśli wartość nie jest zmieniana, metoda zwraca stan wskazujący, że nie zmieni się.</span><span class="sxs-lookup"><span data-stu-id="f54f2-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="f54f2-243">Jeśli wartość klucza nie zostanie znaleziona, para klucz/wartość zostanie wstawiona.</span><span class="sxs-lookup"><span data-stu-id="f54f2-243">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="f54f2-244">Jeśli wartość została zmieniona, zostanie zaktualizowana.</span><span class="sxs-lookup"><span data-stu-id="f54f2-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="f54f2-245">Tryb uaktualniania pozwala wątku uaktualnić dostęp do odczytu w razie potrzeby do zapisu bez ryzyka zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="f54f2-246">Przykład zawiera zagnieżdżone Wyliczenie, które określa wartości zwracane dla metody, która pokazuje tryb uaktualniania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="f54f2-247">W przykładzie używa konstruktora bez parametrów, aby utworzyć blokadę, więc rekursja jest niedozwolona.</span><span class="sxs-lookup"><span data-stu-id="f54f2-247">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="f54f2-248"><xref:System.Threading.ReaderWriterLockSlim> Programowanie jest prostsze i mniej podatne na błędy, gdy blokada nie zezwala na rekursję.</span><span class="sxs-lookup"><span data-stu-id="f54f2-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="f54f2-249">Poniższy kod następnie używa `SynchronizedCache` obiektu do przechowywania słownika nazw warzyw.</span><span class="sxs-lookup"><span data-stu-id="f54f2-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="f54f2-250">Tworzy trzy zadania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-250">It creates three tasks.</span></span> <span data-ttu-id="f54f2-251">Najpierw zapisuje nazwy warzyw przechowywanych w tablicy do `SynchronizedCache` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="f54f2-252">Drugie i trzecie zadanie wyświetla nazwy warzyw, pierwsze w kolejności rosnącej (od dolnego indeksu do indeksu górnego), drugi w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="f54f2-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="f54f2-253">Zadanie końcowe wyszukuje ciąg "ogórki" i po jego znalezieniu wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony fasola".</span><span class="sxs-lookup"><span data-stu-id="f54f2-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy"><span data-ttu-id="f54f2-254">Jedna z wartości wyliczenia, która określa zasady blokowania rekursji.</span><span class="sxs-lookup"><span data-stu-id="f54f2-254">One of the enumeration values that specifies the lock recursion policy.</span></span></param>
        <summary><span data-ttu-id="f54f2-255">Inicjuje nowe wystąpienie <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy, określając zasady blokowania rekursji.</span><span class="sxs-lookup"><span data-stu-id="f54f2-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-256">Zasady rekursji określają ograniczenia dotyczące wątków, które wprowadzają blokadę więcej niż raz.</span><span class="sxs-lookup"><span data-stu-id="f54f2-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="f54f2-257">Na przykład, jeśli Blokada została utworzona przy użyciu <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> , a wątek przeszedł w tryb odczytu, jest generowany <xref:System.Threading.LockRecursionException> , jeśli wątek spróbuje ponownie wprowadzić blokadę w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="f54f2-258">Podobnie, jeśli wątek przeszedł w tryb zapisu, jest generowany, <xref:System.Threading.LockRecursionException> Jeśli wątek spróbuje ponownie wprowadzić blokadę w dowolnym trybie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-259">Wątek w trybie uaktualnienia można uaktualnić do trybu zapisu lub przeniżyć do trybu odczytu niezależnie od ustawienia zasad rekursji blokady.</span><span class="sxs-lookup"><span data-stu-id="f54f2-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="f54f2-260">Niezależnie od zasad rekursji wątek, który początkowo wszedł w tryb odczytu, nie może być uaktualniany do trybu z możliwością uaktualnienia lub trybem zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="f54f2-261">Aby uzyskać więcej informacji na temat zasad rekursji i jej efektów <xref:System.Threading.LockRecursionPolicy> , zobacz Wyliczenie <xref:System.Threading.ReaderWriterLockSlim> i Klasa.</span><span class="sxs-lookup"><span data-stu-id="f54f2-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-262">W poniższym przykładzie przedstawiono dwa scenariusze wyjątków, które są zależne od <xref:System.Threading.LockRecursionPolicy> ustawienia i jeden z nich.</span><span class="sxs-lookup"><span data-stu-id="f54f2-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="f54f2-263">W pierwszym scenariuszu wątek przechodzi w tryb odczytu, a następnie próbuje wejść w tryb odczytu cyklicznie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="f54f2-264">Jeśli jest tworzony przy użyciu konstruktora bez parametrów, który ustawia zasady rekursji na <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, zgłaszany jest wyjątek. <xref:System.Threading.ReaderWriterLockSlim></span><span class="sxs-lookup"><span data-stu-id="f54f2-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the parameterless constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="f54f2-265">Jeśli <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> jest używany do <xref:System.Threading.ReaderWriterLockSlim>tworzenia, nie jest zgłaszany żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f54f2-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="f54f2-266">W drugim scenariuszu wątek przechodzi do trybu odczytu, a następnie próbuje wejść w tryb zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="f54f2-267"><xref:System.Threading.LockRecursionException>jest zgłaszany niezależnie od zasad rekursji blokady.</span><span class="sxs-lookup"><span data-stu-id="f54f2-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="f54f2-268">Poniższy kod następnie używa `SynchronizedCache` obiektu do przechowywania słownika nazw warzyw.</span><span class="sxs-lookup"><span data-stu-id="f54f2-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="f54f2-269">Tworzy trzy zadania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-269">It creates three tasks.</span></span> <span data-ttu-id="f54f2-270">Najpierw zapisuje nazwy warzyw przechowywanych w tablicy do `SynchronizedCache` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="f54f2-271">Drugie i trzecie zadanie wyświetla nazwy warzyw, pierwsze w kolejności rosnącej (od dolnego indeksu do indeksu górnego), drugi w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="f54f2-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="f54f2-272">Zadanie końcowe wyszukuje ciąg "ogórki" i po jego znalezieniu wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony fasola".</span><span class="sxs-lookup"><span data-stu-id="f54f2-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-273">Pobiera łączną liczbę unikatowych wątków, które przeszły blokadę w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-273">Gets the total number of unique threads that have entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="f54f2-274">Liczba unikatowych wątków, które przeszły blokadę w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-274">The number of unique threads that have entered the lock in read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-275">Wątek jest liczony tylko raz, nawet jeśli blokada zezwala na rekursję, a wątek przeszedł wiele razy w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="f54f2-276">Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f54f2-277">Wyniki mogą ulec zmianie, gdy tylko zostały obliczone.</span><span class="sxs-lookup"><span data-stu-id="f54f2-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f54f2-278">W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="f54f2-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-279">Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> jak użyć właściwości w celu wygenerowania wpisu dziennika zdarzeń, jeśli liczba wątków w trybie odczytu przekracza próg.</span><span class="sxs-lookup"><span data-stu-id="f54f2-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f54f2-280">Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-281">Wywołaj <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> po zakończeniu korzystania z <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="f54f2-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="f54f2-282"><xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> Metoda<xref:System.Threading.ReaderWriterLockSlim> pozostawia w stanie niezdatnym do użytku.</span><span class="sxs-lookup"><span data-stu-id="f54f2-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="f54f2-283">Po wywołaniu <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>należy wydać wszystkie odwołania <xref:System.Threading.ReaderWriterLockSlim> do, aby moduł wyrzucania elementów bezużytecznych mógł odwoływać pamięć <xref:System.Threading.ReaderWriterLockSlim> , którą zajmował.</span><span class="sxs-lookup"><span data-stu-id="f54f2-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="f54f2-284">Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="f54f2-284">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-285">Zawsze wywołuj <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> przed wydaniem ostatniego odwołania <xref:System.Threading.ReaderWriterLockSlim> do obiektu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="f54f2-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="f54f2-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="f54f2-287">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-287">-or-</span></span> 
 <span data-ttu-id="f54f2-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="f54f2-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="f54f2-289">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-289">-or-</span></span> 
 <span data-ttu-id="f54f2-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />jest większa od zera.</span><span class="sxs-lookup"><span data-stu-id="f54f2-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f54f2-291">Próbuje wprowadzić blokadę w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-291">Tries to enter the lock in read mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-292">Ta metoda blokuje do momentu, aż wątek wywołujący przejdzie do blokady i w związku z tym może nigdy nie zwracać.</span><span class="sxs-lookup"><span data-stu-id="f54f2-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="f54f2-293"><xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> Użyj metody do blokowania dla określonego interwału, a następnie return, jeśli wątek wywołujący nie przeszedł w trybie odczytu w tym interwale.</span><span class="sxs-lookup"><span data-stu-id="f54f2-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="f54f2-294">Wiele wątków może jednocześnie przejść do trybu odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="f54f2-295">Jeśli co najmniej jeden wątek oczekuje na przejście do trybu zapisu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył działanie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-296">Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie odczytu, może przejść w tryb odczytu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="f54f2-297">Co najwyżej jeden wątek może być w trybie do uaktualnienia, podczas gdy inne wątki są w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="f54f2-298">Jeśli dodatkowe wątki oczekują na przejście do trybu z możliwością uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, wątki <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> , które wywołują metodę, przełączają się do trybu odczytu natychmiast i nie blokują.</span><span class="sxs-lookup"><span data-stu-id="f54f2-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-299">Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> jak używać metody do wprowadzania blokady w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="f54f2-300">Metoda pokazana w przykładzie pobiera wartość skojarzoną z kluczem.</span><span class="sxs-lookup"><span data-stu-id="f54f2-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="f54f2-301">Jeśli klucz nie zostanie znaleziony, wyjątek zgłoszony przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metodę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="f54f2-302">Blok jest używany do <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący kończy działanie trybu odczytu. `finally`</span><span class="sxs-lookup"><span data-stu-id="f54f2-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="f54f2-303">Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f54f2-304"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, a bieżący wątek próbował uzyskać blokadę odczytu, gdy ma już blokadę odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-304">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span></span>  
  
<span data-ttu-id="f54f2-305">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-305">-or-</span></span> 
<span data-ttu-id="f54f2-306"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, a bieżący wątek próbował uzyskać blokadę odczytu, gdy ma już blokadę zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span></span>  
  
<span data-ttu-id="f54f2-307">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-307">-or-</span></span> 
<span data-ttu-id="f54f2-308">Liczba rekursji przekroczy pojemność licznika.</span><span class="sxs-lookup"><span data-stu-id="f54f2-308">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f54f2-309">Ten limit jest tak duży, że aplikacje nie powinny napotkać tego wyjątku.</span><span class="sxs-lookup"><span data-stu-id="f54f2-309">This limit is so large that applications should never encounter this exception.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f54f2-310"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</span><span class="sxs-lookup"><span data-stu-id="f54f2-310">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f54f2-311">Próbuje wprowadzić blokadę w trybie z uaktualnieniem.</span><span class="sxs-lookup"><span data-stu-id="f54f2-311">Tries to enter the lock in upgradeable mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-312">Ta metoda blokuje do momentu, aż wątek wywołujący przejdzie do blokady i w związku z tym może nigdy nie zwracać.</span><span class="sxs-lookup"><span data-stu-id="f54f2-312">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="f54f2-313"><xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> Użyj metody do blokowania dla określonego interwału, a następnie Zwróć, jeśli wątek wywołujący nie przeszedł w tryb do uaktualnienia w tym interwale.</span><span class="sxs-lookup"><span data-stu-id="f54f2-313">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="f54f2-314">Trybu możliwego do uaktualnienia należy używać <xref:System.Threading.ReaderWriterLockSlim> w przypadku, gdy wątek zwykle uzyskuje dostęp do zasobu chronionego przez tryb odczytu, ale może być konieczne wprowadzenie trybu zapisu w przypadku spełnienia określonych warunków.</span><span class="sxs-lookup"><span data-stu-id="f54f2-314">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="f54f2-315">Wątek w trybie do uaktualnienia może przejść do trybu odczytu lub uaktualnić do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-315">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="f54f2-316">W danym momencie tylko jeden wątek może przejść w tryb umożliwiający uaktualnienie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-316">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="f54f2-317">Jeśli wątek jest w trybie do uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, dowolna liczba innych wątków może wejść w tryb odczytu, nawet jeśli istnieją wątki oczekujące na przejście do trybu z możliwością uaktualnienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-317">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="f54f2-318">Jeśli co najmniej jeden wątek oczekuje na przejście do trybu zapisu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył działanie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-318">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-319">Jeśli blokada zezwala na rekursję, wątek, który przeszedł do blokady w trybie z możliwością uaktualnienia, może przejść w tryb do uaktualnienia cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-319">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-320">Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> jak używać metody do przejścia w tryb umożliwiający uaktualnienie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-320">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="f54f2-321">Blok jest używany do <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący opuszcza tryb z uaktualnieniem. `finally`</span><span class="sxs-lookup"><span data-stu-id="f54f2-321">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="f54f2-322">Metoda pokazana w przykładzie pobiera wartość skojarzoną z kluczem i porównuje ją z nową wartością.</span><span class="sxs-lookup"><span data-stu-id="f54f2-322">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="f54f2-323">Jeśli wartość nie jest zmieniana, metoda zwraca stan wskazujący, że nie zmieni się.</span><span class="sxs-lookup"><span data-stu-id="f54f2-323">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="f54f2-324">Nie znaleziono wartości klucza, para klucz/wartość zostanie wstawiona.</span><span class="sxs-lookup"><span data-stu-id="f54f2-324">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="f54f2-325">Jeśli wartość została zmieniona, zostanie zaktualizowana.</span><span class="sxs-lookup"><span data-stu-id="f54f2-325">If the value has changed, it is updated.</span></span> <span data-ttu-id="f54f2-326">Tryb możliwy do uaktualnienia umożliwia wątkowi uaktualnienie blokady odczytu w razie potrzeby bez ryzyka zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-326">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="f54f2-327">W przykładzie używa konstruktora bez parametrów, aby utworzyć blokadę, więc rekursja jest niedozwolona.</span><span class="sxs-lookup"><span data-stu-id="f54f2-327">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="f54f2-328"><xref:System.Threading.ReaderWriterLockSlim> Programowanie jest prostsze i mniej podatne na błędy, gdy blokada nie zezwala na rekursję.</span><span class="sxs-lookup"><span data-stu-id="f54f2-328">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="f54f2-329">Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-329">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f54f2-330"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek przeszedł już blokadę w dowolnym trybie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-330">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="f54f2-331">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-331">-or-</span></span> 
<span data-ttu-id="f54f2-332">Bieżący wątek został wprowadzony w tryb odczytu, dlatego próba przejścia do trybu możliwego do uaktualnienia spowoduje utworzenie możliwości zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-332">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f54f2-333">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-333">-or-</span></span> 
<span data-ttu-id="f54f2-334">Liczba rekursji przekroczy pojemność licznika.</span><span class="sxs-lookup"><span data-stu-id="f54f2-334">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f54f2-335">Limit jest tak duży, że aplikacje nigdy nie napotkają go.</span><span class="sxs-lookup"><span data-stu-id="f54f2-335">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f54f2-336"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</span><span class="sxs-lookup"><span data-stu-id="f54f2-336">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f54f2-337">Próbuje wprowadzić blokadę w trybie zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-337">Tries to enter the lock in write mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-338">Ta metoda blokuje do momentu, aż wątek wywołujący przejdzie do blokady i w związku z tym może nigdy nie zwracać.</span><span class="sxs-lookup"><span data-stu-id="f54f2-338">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="f54f2-339"><xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> Użyj metody do blokowania dla określonego interwału, a następnie Zwróć, jeśli wątek wywołujący nie przeszedł w tym interwale w trybie zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-339">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="f54f2-340">Jeśli inne wątki przepełnią blokadę w trybie odczytu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> bloki metody do momentu zakończenia trybu odczytu przez te wątki.</span><span class="sxs-lookup"><span data-stu-id="f54f2-340">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="f54f2-341">Gdy istnieją wątki oczekujące na przejście do trybu zapisu, dodatkowe wątki, które próbują przejść do trybu odczytu lub bloku trybu do uaktualnienia, dopóki wszystkie wątki oczekujące na przejście do trybu zapisu przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończyły działanie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-341">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-342">Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie zapisu, może jednocześnie wprowadzać tryb zapisu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-342">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-343">Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> jak używać metody do wprowadzania blokady w trybie zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-343">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="f54f2-344">Metoda pokazana w przykładzie dodaje nową parę klucz/wartość do synchronizowanej pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="f54f2-344">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="f54f2-345">Jeśli klucz znajduje się już w pamięci podręcznej, wyjątek zgłoszony przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metodę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-345">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="f54f2-346">Blok jest używany do <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący kończy tryb zapisu. `finally`</span><span class="sxs-lookup"><span data-stu-id="f54f2-346">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="f54f2-347">Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-347">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f54f2-348"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek przeszedł już blokadę w dowolnym trybie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-348">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="f54f2-349">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-349">-or-</span></span> 
<span data-ttu-id="f54f2-350">Bieżący wątek został wprowadzony w tryb odczytu i nie jest już członkiem blokady zapisu, dlatego próba przejścia w tryb zapisu spowoduje utworzenie możliwości zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-350">The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f54f2-351">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-351">-or-</span></span> 
<span data-ttu-id="f54f2-352">Liczba rekursji przekroczy pojemność licznika.</span><span class="sxs-lookup"><span data-stu-id="f54f2-352">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f54f2-353">Limit jest tak duży, że aplikacje nigdy nie napotkają go.</span><span class="sxs-lookup"><span data-stu-id="f54f2-353">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f54f2-354"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</span><span class="sxs-lookup"><span data-stu-id="f54f2-354">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f54f2-355">Zmniejsza liczbę rekursji dla trybu odczytu i zamyka tryb odczytu, Jeśli wynikowa liczba wynosi 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="f54f2-355">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-356">Ta metoda nie jest uwzględniana w kolejności rekursji.</span><span class="sxs-lookup"><span data-stu-id="f54f2-356">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="f54f2-357">Na przykład jeśli wątek przechodzi w tryb do uaktualnienia, a następnie przechodzi do trybu odczytu, kolejność, w której wątek opuszcza dwa tryby, nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-357">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="f54f2-358">Jeśli blokada zezwala na rekursję, wątek może przejść do trybu zapisu blokady, a następnie wprowadzić rekursywnie w trybie odczytu. kolejność, w której wątek opuszcza tryb odczytu i tryb zapisu, nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-358">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="f54f2-359">Wyjście z blokady może sygnalizować inne oczekujące wątki.</span><span class="sxs-lookup"><span data-stu-id="f54f2-359">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-360">Poniższy przykład pokazuje, jak używać `finally` bloku do <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> wykonywania metody, aby upewnić się, że obiekt wywołujący kończy działanie trybu odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-360">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="f54f2-361">Metoda pokazana w przykładzie pobiera wartość skojarzoną z kluczem.</span><span class="sxs-lookup"><span data-stu-id="f54f2-361">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="f54f2-362">Jeśli klucz nie zostanie znaleziony, wyjątek zgłoszony przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metodę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-362">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="f54f2-363"><xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> Metoda jest używana do wprowadzania trybu odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-363">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="f54f2-364">Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-364">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="f54f2-365">Bieżący wątek nie został wprowadzony w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-365">The current thread has not entered the lock in read mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f54f2-366">Zmniejsza liczbę rekursji dla trybu z uaktualnieniem i zamyka tryb uaktualniania, Jeśli wynikowa liczba wynosi 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="f54f2-366">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-367">Ta metoda nie jest uwzględniana w kolejności rekursji.</span><span class="sxs-lookup"><span data-stu-id="f54f2-367">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="f54f2-368">Na przykład jeśli wątek przechodzi w tryb do uaktualnienia, a następnie przechodzi w tryb zapisu, kolejność, w której wątek opuszcza dwa tryby, nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-368">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="f54f2-369">Jeśli blokada zezwala na rekursję, wątek może przejść do trybu zapisu blokady, a następnie wprowadzić rekursywnie w trybie z możliwością uaktualnienia. kolejność, w której wątek opuszcza tryb uaktualniania i tryb zapisu, nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-369">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="f54f2-370">Wyjście z blokady może sygnalizować inne oczekujące wątki.</span><span class="sxs-lookup"><span data-stu-id="f54f2-370">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-371">Poniższy przykład pokazuje, jak używać `finally` bloku do <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący kończy tryb uaktualniania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-371">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="f54f2-372">Metoda pokazana w przykładzie pobiera wartość skojarzoną z kluczem i porównuje ją z nową wartością.</span><span class="sxs-lookup"><span data-stu-id="f54f2-372">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="f54f2-373">Jeśli wartość nie jest zmieniana, metoda zwraca stan wskazujący, że nie zmieni się.</span><span class="sxs-lookup"><span data-stu-id="f54f2-373">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="f54f2-374">Nie znaleziono wartości klucza, para klucz/wartość zostanie wstawiona.</span><span class="sxs-lookup"><span data-stu-id="f54f2-374">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="f54f2-375">Jeśli wartość została zmieniona, zostanie zaktualizowana.</span><span class="sxs-lookup"><span data-stu-id="f54f2-375">If the value has changed, it is updated.</span></span> <span data-ttu-id="f54f2-376">Tryb możliwy do uaktualnienia umożliwia wątkowi uaktualnienie blokady odczytu w razie potrzeby bez ryzyka zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-376">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="f54f2-377">W przykładzie używa konstruktora bez parametrów, aby utworzyć blokadę, więc rekursja jest niedozwolona.</span><span class="sxs-lookup"><span data-stu-id="f54f2-377">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="f54f2-378"><xref:System.Threading.ReaderWriterLockSlim> Programowanie jest prostsze i mniej podatne na błędy, gdy blokada nie zezwala na rekursję.</span><span class="sxs-lookup"><span data-stu-id="f54f2-378">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="f54f2-379">Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-379">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="f54f2-380">Bieżący wątek nie przeszedł do blokady w trybie uaktualniania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-380">The current thread has not entered the lock in upgradeable mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f54f2-381">Zmniejsza liczbę rekursji dla trybu zapisu i zamyka tryb zapisu, Jeśli wynikowa liczba to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="f54f2-381">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-382">Ta metoda nie jest uwzględniana w kolejności rekursji.</span><span class="sxs-lookup"><span data-stu-id="f54f2-382">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="f54f2-383">Na przykład jeśli wątek przechodzi w tryb do uaktualnienia, a następnie przechodzi w tryb zapisu, kolejność, w której wątek opuszcza dwa tryby, nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-383">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="f54f2-384">Jeśli blokada zezwala na rekursję, wątek może przejść do trybu zapisu blokady, a następnie wprowadzić rekursywnie w trybie odczytu. kolejność, w której wątek opuszcza tryb odczytu i tryb zapisu, nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-384">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="f54f2-385">Wyjście z blokady może sygnalizować inne oczekujące wątki.</span><span class="sxs-lookup"><span data-stu-id="f54f2-385">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-386">Poniższy przykład pokazuje, jak używać `finally` bloku do <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący kończy tryb zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-386">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="f54f2-387">Metoda pokazana w przykładzie dodaje nową parę klucz/wartość do synchronizowanej pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="f54f2-387">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="f54f2-388">Jeśli klucz znajduje się już w pamięci podręcznej, wyjątek zgłoszony przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metodę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-388">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="f54f2-389"><xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> Metoda jest używana do wprowadzania blokady w trybie zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-389">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="f54f2-390">Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-390">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="f54f2-391">Bieżący wątek nie został wprowadzony w trybie zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-391">The current thread has not entered the lock in write mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-392">Pobiera wartość wskazującą, czy bieżący wątek przeszedł do blokady w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-392">Gets a value that indicates whether the current thread has entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="f54f2-393"><see langword="true" />Jeśli bieżący wątek został wprowadzony w trybie odczytu; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="f54f2-393"><see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-394">Ta właściwość jest przeznaczona do użycia w potwierdzeniach lub do innych celów debugowania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-394">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="f54f2-395">Nie należy używać go do sterowania przepływem wykonywania programu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-395">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-396">Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> jak używać właściwości do generowania potwierdzenia, jeśli bieżący wątek przeszedł nieoczekiwanie w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-396">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-397">Pobiera wartość wskazującą, czy bieżący wątek przeszedł blokadę w trybie z możliwością uaktualnienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-397">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="f54f2-398"><see langword="true" />Jeśli bieżący wątek przeszedł do trybu uaktualniania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="f54f2-398"><see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-399">Ta właściwość jest przeznaczona do użycia w potwierdzeniach lub do innych celów debugowania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-399">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="f54f2-400">Nie należy używać go do sterowania przepływem wykonywania programu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-400">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-401">Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> jak używać właściwości do generowania potwierdzenia, jeśli bieżący wątek przeszedł nieoczekiwany tryb uaktualniania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-401">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-402">Pobiera wartość wskazującą, czy bieżący wątek przeszedł do blokady w trybie zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-402">Gets a value that indicates whether the current thread has entered the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="f54f2-403"><see langword="true" />Jeśli bieżący wątek został wprowadzony w trybie zapisu; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="f54f2-403"><see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-404">Ta właściwość jest przeznaczona do użycia w potwierdzeniach lub do innych celów debugowania.</span><span class="sxs-lookup"><span data-stu-id="f54f2-404">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="f54f2-405">Nie należy używać go do sterowania przepływem wykonywania programu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-405">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-406">Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> jak używać właściwości do generowania potwierdzenia, jeśli bieżący wątek został nieoczekiwanie wprowadzony w trybie zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-406">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-407">Pobiera wartość wskazującą zasady rekursji dla bieżącego <see cref="T:System.Threading.ReaderWriterLockSlim" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-407">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span></span></summary>
        <value><span data-ttu-id="f54f2-408">Jedna z wartości wyliczenia, która określa zasady blokowania rekursji.</span><span class="sxs-lookup"><span data-stu-id="f54f2-408">One of the enumeration values that specifies the lock recursion policy.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-409">Zasady rekursji określają ograniczenia dotyczące wątków, które wprowadzają blokadę więcej niż raz.</span><span class="sxs-lookup"><span data-stu-id="f54f2-409">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="f54f2-410">Na przykład, jeśli Blokada została utworzona przy użyciu <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> , a wątek przeszedł w tryb odczytu, jest generowany <xref:System.Threading.LockRecursionException> , jeśli wątek spróbuje ponownie wprowadzić blokadę w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-410">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-411">Wątek w trybie uaktualnienia można uaktualnić do trybu zapisu lub przeniżyć do trybu odczytu niezależnie od ustawienia zasad rekursji blokady.</span><span class="sxs-lookup"><span data-stu-id="f54f2-411">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="f54f2-412">Niezależnie od zasad rekursji wątek, który początkowo wszedł w tryb odczytu, nie może być uaktualniany do trybu z możliwością uaktualnienia lub trybem zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-412">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="f54f2-413">Aby uzyskać więcej informacji na temat zasad rekursji i jej efektów <xref:System.Threading.LockRecursionPolicy> , zobacz Wyliczenie <xref:System.Threading.ReaderWriterLockSlim> i Klasa.</span><span class="sxs-lookup"><span data-stu-id="f54f2-413">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-414">Pobiera informację o tym, ile razy bieżący wątek przeszedł w tryb odczytu jako wskazanie rekursji.</span><span class="sxs-lookup"><span data-stu-id="f54f2-414">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="f54f2-415">0 (zero), jeśli bieżący wątek nie przeszedł w tryb odczytu, 1, jeśli wątek przeszedł w tryb odczytu, ale nie został wprowadzony rekursywnie, lub *n* , jeśli wątek przeszedł cyklicznie *n* -1 razy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-415">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-416">Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-416">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f54f2-417">Wyniki mogą ulec zmianie, gdy tylko zostały obliczone.</span><span class="sxs-lookup"><span data-stu-id="f54f2-417">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f54f2-418">W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="f54f2-418">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-419">Pobiera informację o tym, ile razy bieżący wątek przeszedł w tryb do uaktualnienia, jako wskazanie rekursji.</span><span class="sxs-lookup"><span data-stu-id="f54f2-419">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="f54f2-420">0 Jeśli bieżący wątek nie wprowadza trybu możliwego do uaktualnienia, 1, jeśli wątek przeszedł w tryb do uaktualnienia, ale nie został wprowadzony rekursywnie, lub *n* Jeśli wątek przeszedł w tryb uaktualniania cyklicznie *n* -1 razy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-420">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-421">Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-421">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f54f2-422">Wyniki mogą ulec zmianie, gdy tylko zostały obliczone.</span><span class="sxs-lookup"><span data-stu-id="f54f2-422">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f54f2-423">W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="f54f2-423">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-424">Pobiera informację o tym, ile razy bieżący wątek przeszedł w tryb zapisu, jako wskazanie rekursji.</span><span class="sxs-lookup"><span data-stu-id="f54f2-424">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="f54f2-425">0 Jeśli bieżący wątek nie wprowadził trybu zapisu, 1, jeśli wątek wszedł w tryb zapisu, ale nie został wprowadzony rekursywnie, lub *n* , jeśli wątek przeszedł w tryb zapisu cyklicznie *n* -1 razy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-425">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-426">Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-426">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f54f2-427">Wyniki mogą ulec zmianie, gdy tylko zostały obliczone.</span><span class="sxs-lookup"><span data-stu-id="f54f2-427">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f54f2-428">W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="f54f2-428">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f54f2-429">Próbuje wprowadzić blokadę w trybie odczytu z opcjonalnym limitem czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-429">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f54f2-430">Liczba milisekund oczekiwania lub-1 (<see cref="F:System.Threading.Timeout.Infinite" />) oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="f54f2-430">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f54f2-431">Próbuje wprowadzić blokadę w trybie odczytu z opcjonalnym limitem czasu dla liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="f54f2-431">Tries to enter the lock in read mode, with an optional integer time-out.</span></span></summary>
        <returns><span data-ttu-id="f54f2-432"><see langword="true" />Jeśli wątek wywołujący wszedł w tryb odczytu, w <see langword="false" />przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-432"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-433">Jeśli `millisecondsTimeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.</span><span class="sxs-lookup"><span data-stu-id="f54f2-433">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f54f2-434">Wiele wątków może jednocześnie przejść do trybu odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-434">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="f54f2-435">Jeśli co najmniej jeden wątek oczekuje na przejście do trybu zapisu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył działanie lub do momentu wygaśnięcia interwału limitu czasu wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="f54f2-435">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-436">Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie odczytu, może przejść w tryb odczytu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-436">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="f54f2-437">Jeden wątek może być w trybie do uaktualnienia, podczas gdy inne wątki są w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-437">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="f54f2-438">Jeśli dodatkowe wątki oczekują na przejście do trybu z możliwością uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, wątki <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> , które wywołują metodę, przełączają się do trybu odczytu natychmiast i nie blokują.</span><span class="sxs-lookup"><span data-stu-id="f54f2-438">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f54f2-439"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-439">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f54f2-440">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-440">-or-</span></span> 
<span data-ttu-id="f54f2-441">Liczba rekursji przekroczy pojemność licznika.</span><span class="sxs-lookup"><span data-stu-id="f54f2-441">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f54f2-442">Limit jest tak duży, że aplikacje nigdy nie napotkają go.</span><span class="sxs-lookup"><span data-stu-id="f54f2-442">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f54f2-443">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa (-1), która jest jedyną dozwoloną wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="f54f2-443">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f54f2-444"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</span><span class="sxs-lookup"><span data-stu-id="f54f2-444">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f54f2-445">Interwał oczekiwania lub-1 milisekund oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="f54f2-445">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f54f2-446">Próbuje wprowadzić blokadę w trybie odczytu z opcjonalnym limitem czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-446">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="f54f2-447"><see langword="true" />Jeśli wątek wywołujący wszedł w tryb odczytu, w <see langword="false" />przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-447"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-448">Jeśli `timeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.</span><span class="sxs-lookup"><span data-stu-id="f54f2-448">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f54f2-449">Wiele wątków może jednocześnie przejść do trybu odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-449">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="f54f2-450">Jeśli co najmniej jeden wątek zostanie umieszczony w kolejce w celu przejścia do trybu zapisu, wątek <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> , który wywołuje bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył się z niego lub do czasu wygaśnięcia interwału limitu czasu wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="f54f2-450">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-451">Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie odczytu, może przejść w tryb odczytu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-451">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="f54f2-452">Jeden wątek może być w trybie do uaktualnienia, podczas gdy inne wątki są w trybie odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-452">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="f54f2-453">Jeśli dodatkowe wątki oczekują na przejście do trybu z możliwością uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, wątki <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> , które wywołują metodę, przełączają się do trybu odczytu natychmiast i nie blokują.</span><span class="sxs-lookup"><span data-stu-id="f54f2-453">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f54f2-454"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-454">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f54f2-455">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-455">-or-</span></span> 
<span data-ttu-id="f54f2-456">Liczba rekursji przekroczy pojemność licznika.</span><span class="sxs-lookup"><span data-stu-id="f54f2-456">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f54f2-457">Limit jest tak duży, że aplikacje nigdy nie napotkają go.</span><span class="sxs-lookup"><span data-stu-id="f54f2-457">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f54f2-458">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="f54f2-458">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="f54f2-459">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-459">-or-</span></span> 
<span data-ttu-id="f54f2-460">Wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekunda.</span><span class="sxs-lookup"><span data-stu-id="f54f2-460">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f54f2-461"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</span><span class="sxs-lookup"><span data-stu-id="f54f2-461">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f54f2-462">Podejmuje próbę przejścia w tryb uaktualniania z opcjonalnym limitem czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-462">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f54f2-463">Liczba milisekund oczekiwania lub-1 (<see cref="F:System.Threading.Timeout.Infinite" />) oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="f54f2-463">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f54f2-464">Podejmuje próbę przejścia w tryb uaktualniania z opcjonalnym limitem czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="f54f2-465"><see langword="true" />Jeśli wątek wywołujący przeszedł w tryb umożliwiający uaktualnienie <see langword="false" />, w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-465"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-466">Jeśli `millisecondsTimeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.</span><span class="sxs-lookup"><span data-stu-id="f54f2-466">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f54f2-467">Trybu możliwego do uaktualnienia należy używać <xref:System.Threading.ReaderWriterLockSlim> w przypadku, gdy wątek zwykle uzyskuje dostęp do zasobu chronionego przez tryb odczytu, ale może być konieczne wprowadzenie trybu zapisu w przypadku spełnienia określonych warunków.</span><span class="sxs-lookup"><span data-stu-id="f54f2-467">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="f54f2-468">Wątek w trybie uaktualniania można uaktualnić do trybu zapisu lub przeniżyć do trybu odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-468">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="f54f2-469">Tylko jeden wątek może w dowolnym momencie wprowadzić blokadę w trybie z możliwością uaktualnienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-469">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="f54f2-470">Jeśli wątek jest w trybie do uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, dowolna liczba innych wątków może wejść w tryb odczytu, nawet jeśli istnieją wątki oczekujące na przejście do trybu z możliwością uaktualnienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-470">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="f54f2-471">Jeśli co najmniej jeden wątek oczekuje na przejście do trybu zapisu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył działanie lub do momentu wygaśnięcia interwału limitu czasu wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="f54f2-471">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-472">Jeśli blokada zezwala na rekursję, wątek, który przeszedł do blokady w trybie z możliwością uaktualnienia, może przejść w tryb do uaktualnienia cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-472">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f54f2-473"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-473">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f54f2-474">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-474">-or-</span></span> 
<span data-ttu-id="f54f2-475">Bieżący wątek początkowo przeszedł do blokady w trybie odczytu i w związku z tym próba przejścia do trybu możliwego do uaktualnienia spowoduje utworzenie możliwości zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-475">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f54f2-476">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-476">-or-</span></span> 
<span data-ttu-id="f54f2-477">Liczba rekursji przekroczy pojemność licznika.</span><span class="sxs-lookup"><span data-stu-id="f54f2-477">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f54f2-478">Limit jest tak duży, że aplikacje nigdy nie napotkają go.</span><span class="sxs-lookup"><span data-stu-id="f54f2-478">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f54f2-479">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa (-1), która jest jedyną dozwoloną wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="f54f2-479">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f54f2-480"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</span><span class="sxs-lookup"><span data-stu-id="f54f2-480">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f54f2-481">Interwał oczekiwania lub-1 milisekund oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="f54f2-481">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f54f2-482">Podejmuje próbę przejścia w tryb uaktualniania z opcjonalnym limitem czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-482">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="f54f2-483"><see langword="true" />Jeśli wątek wywołujący przeszedł w tryb umożliwiający uaktualnienie <see langword="false" />, w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-483"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-484">Jeśli `timeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.</span><span class="sxs-lookup"><span data-stu-id="f54f2-484">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f54f2-485">Trybu możliwego do uaktualnienia należy używać <xref:System.Threading.ReaderWriterLockSlim> w przypadku, gdy wątek zwykle uzyskuje dostęp do zasobu chronionego przez w trybie odczytu, ale może być konieczne wprowadzenie trybu zapisu w przypadku spełnienia określonych warunków.</span><span class="sxs-lookup"><span data-stu-id="f54f2-485">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="f54f2-486">Wątek w trybie uaktualniania można uaktualnić do trybu zapisu lub przeniżyć do trybu odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-486">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="f54f2-487">Tylko jeden wątek może w dowolnym momencie wprowadzić blokadę w trybie z możliwością uaktualnienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-487">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="f54f2-488">Jeśli wątek jest w trybie do uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, dowolna liczba innych wątków może wejść w tryb odczytu, nawet jeśli istnieją wątki oczekujące na przejście do trybu z możliwością uaktualnienia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-488">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="f54f2-489">Jeśli co najmniej jeden wątek oczekuje na przejście do trybu zapisu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył działanie lub do momentu wygaśnięcia interwału limitu czasu wątku wywołującego.</span><span class="sxs-lookup"><span data-stu-id="f54f2-489">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-490">Jeśli blokada zezwala na rekursję, wątek, który przeszedł do blokady w trybie z możliwością uaktualnienia, może przejść w tryb do uaktualnienia cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-490">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f54f2-491"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-491">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f54f2-492">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-492">-or-</span></span> 
<span data-ttu-id="f54f2-493">Bieżący wątek początkowo przeszedł do blokady w trybie odczytu i w związku z tym próba przejścia do trybu możliwego do uaktualnienia spowoduje utworzenie możliwości zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-493">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f54f2-494">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-494">-or-</span></span> 
<span data-ttu-id="f54f2-495">Liczba rekursji przekroczy pojemność licznika.</span><span class="sxs-lookup"><span data-stu-id="f54f2-495">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f54f2-496">Limit jest tak duży, że aplikacje nigdy nie napotkają go.</span><span class="sxs-lookup"><span data-stu-id="f54f2-496">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f54f2-497">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="f54f2-497">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="f54f2-498">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-498">-or-</span></span> 
<span data-ttu-id="f54f2-499">Wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekunda.</span><span class="sxs-lookup"><span data-stu-id="f54f2-499">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f54f2-500"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</span><span class="sxs-lookup"><span data-stu-id="f54f2-500">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f54f2-501">Próbuje wprowadzić blokadę w trybie zapisu z opcjonalnym limitem czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-501">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f54f2-502">Liczba milisekund oczekiwania lub-1 (<see cref="F:System.Threading.Timeout.Infinite" />) oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="f54f2-502">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f54f2-503">Próbuje wprowadzić blokadę w trybie zapisu z opcjonalnym limitem czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-503">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="f54f2-504"><see langword="true" />Jeśli wątek wywołujący wszedł w tryb zapisu, w <see langword="false" />przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-504"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-505">Jeśli `millisecondsTimeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.</span><span class="sxs-lookup"><span data-stu-id="f54f2-505">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f54f2-506">Jeśli inne wątki przeszedł w tryb odczytu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> bloki metody do momentu, aż te wątki zakończą tryb odczytu lub do momentu, gdy upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-506">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="f54f2-507">Gdy wątki są zablokowane, oczekują na przejście do trybu zapisu, dodatkowe wątki, które próbują przejść do trybu odczytu lub bloku trybu do uaktualnienia, dopóki wszystkie wątki oczekujące na przejście do trybu zapisu przekroczą limit czasu lub przeszedł w tryb zapisu, a następnie zakończyły działanie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-507">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-508">Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie zapisu, może jednocześnie wprowadzać tryb zapisu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-508">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-509">Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metody do wprowadzania blokady w trybie zapisu z limitem czasu. Metoda pokazana w przykładzie dodaje nową parę klucz/wartość do synchronizowanej pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="f54f2-509">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="f54f2-510">Jeśli określony interwał limitu czasu upłynie, zanim wątek przejdzie do blokady, metoda zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="f54f2-510">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="f54f2-511">Metoda zwraca wartość `true` , jeśli para klucz/wartość jest dodawana.</span><span class="sxs-lookup"><span data-stu-id="f54f2-511">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="f54f2-512">Jeśli klucz znajduje się już w pamięci podręcznej, wyjątek zgłoszony przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metodę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-512">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="f54f2-513">Blok jest używany do <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący opuszcza blokadę. `finally`</span><span class="sxs-lookup"><span data-stu-id="f54f2-513">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="f54f2-514">Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.</span><span class="sxs-lookup"><span data-stu-id="f54f2-514">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f54f2-515"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-515">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f54f2-516">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-516">-or-</span></span> 
<span data-ttu-id="f54f2-517">Bieżący wątek początkowo przeszedł do blokady w trybie odczytu i w związku z tym próba przejścia do trybu zapisu spowoduje utworzenie możliwości zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-517">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f54f2-518">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-518">-or-</span></span> 
<span data-ttu-id="f54f2-519">Liczba rekursji przekroczy pojemność licznika.</span><span class="sxs-lookup"><span data-stu-id="f54f2-519">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f54f2-520">Limit jest tak duży, że aplikacje nigdy nie napotkają go.</span><span class="sxs-lookup"><span data-stu-id="f54f2-520">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f54f2-521">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa (-1), która jest jedyną dozwoloną wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="f54f2-521">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f54f2-522"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</span><span class="sxs-lookup"><span data-stu-id="f54f2-522">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f54f2-523">Interwał oczekiwania lub-1 milisekund oczekiwania na czas nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="f54f2-523">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f54f2-524">Próbuje wprowadzić blokadę w trybie zapisu z opcjonalnym limitem czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-524">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="f54f2-525"><see langword="true" />Jeśli wątek wywołujący wszedł w tryb zapisu, w <see langword="false" />przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-525"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-526">Jeśli `timeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.</span><span class="sxs-lookup"><span data-stu-id="f54f2-526">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="f54f2-527">Jeśli inne wątki przeszedł w tryb odczytu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> bloki metody do momentu, aż te wątki zakończą tryb odczytu lub do momentu, gdy upłynie limit czasu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-527">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="f54f2-528">Gdy wątki są zablokowane, oczekują na przejście do trybu zapisu, dodatkowe wątki, które próbują przejść do trybu odczytu lub bloku trybu do uaktualnienia, dopóki wszystkie wątki oczekujące na przejście do trybu zapisu przekroczą limit czasu lub przeszedł w tryb zapisu, a następnie zakończyły działanie.</span><span class="sxs-lookup"><span data-stu-id="f54f2-528">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f54f2-529">Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie zapisu, może jednocześnie wprowadzać tryb zapisu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-529">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="f54f2-530"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.</span><span class="sxs-lookup"><span data-stu-id="f54f2-530">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="f54f2-531">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-531">-or-</span></span> 
<span data-ttu-id="f54f2-532">Bieżący wątek początkowo przeszedł do blokady w trybie odczytu i w związku z tym próba przejścia do trybu zapisu spowoduje utworzenie możliwości zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f54f2-532">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="f54f2-533">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-533">-or-</span></span> 
<span data-ttu-id="f54f2-534">Liczba rekursji przekroczy pojemność licznika.</span><span class="sxs-lookup"><span data-stu-id="f54f2-534">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="f54f2-535">Limit jest tak duży, że aplikacje nigdy nie napotkają go.</span><span class="sxs-lookup"><span data-stu-id="f54f2-535">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f54f2-536">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="f54f2-536">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="f54f2-537">—lub—</span><span class="sxs-lookup"><span data-stu-id="f54f2-537">-or-</span></span> 
<span data-ttu-id="f54f2-538">Wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekunda.</span><span class="sxs-lookup"><span data-stu-id="f54f2-538">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f54f2-539"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</span><span class="sxs-lookup"><span data-stu-id="f54f2-539">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-540">Pobiera łączną liczbę wątków, które oczekują na przejście do trybu odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-540">Gets the total number of threads that are waiting to enter the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="f54f2-541">Całkowita liczba wątków, które oczekują na przejście do trybu odczytu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-541">The total number of threads that are waiting to enter read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-542">Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-542">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f54f2-543">Wyniki mogą ulec zmianie, gdy tylko zostały obliczone.</span><span class="sxs-lookup"><span data-stu-id="f54f2-543">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f54f2-544">W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="f54f2-544">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-545">Poniższy przykład pokazuje, jak użyć właściwości, <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> aby wygenerować wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, czeka na przejście do trybu odczytu, przekracza wartość progową.</span><span class="sxs-lookup"><span data-stu-id="f54f2-545">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-546">Pobiera łączną liczbę wątków, które oczekują na przejście do trybu z uaktualnieniem.</span><span class="sxs-lookup"><span data-stu-id="f54f2-546">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="f54f2-547">Całkowita liczba wątków, które oczekują na przejście do trybu z uaktualnieniem.</span><span class="sxs-lookup"><span data-stu-id="f54f2-547">The total number of threads that are waiting to enter upgradeable mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-548">Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-548">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f54f2-549">Wyniki mogą ulec zmianie, gdy tylko zostały obliczone.</span><span class="sxs-lookup"><span data-stu-id="f54f2-549">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f54f2-550">W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="f54f2-550">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-551">Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> jak użyć właściwości w celu wygenerowania wpisu dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, oczekujące na przejście do trybu z możliwością uaktualnienia, przekracza wartość progową.</span><span class="sxs-lookup"><span data-stu-id="f54f2-551">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f54f2-552">Pobiera łączną liczbę wątków, które oczekują na przejście do trybu zapisu blokady.</span><span class="sxs-lookup"><span data-stu-id="f54f2-552">Gets the total number of threads that are waiting to enter the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="f54f2-553">Całkowita liczba wątków, które oczekują na przejście do trybu zapisu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-553">The total number of threads that are waiting to enter write mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f54f2-554">Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu.</span><span class="sxs-lookup"><span data-stu-id="f54f2-554">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="f54f2-555">Wyniki mogą ulec zmianie, gdy tylko zostały obliczone.</span><span class="sxs-lookup"><span data-stu-id="f54f2-555">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="f54f2-556">W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="f54f2-556">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f54f2-557">Poniższy przykład pokazuje, jak użyć właściwości, <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> aby wygenerować wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, oczekujące na wprowadzenie trybu zapisu, przekracza wartość progową.</span><span class="sxs-lookup"><span data-stu-id="f54f2-557">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
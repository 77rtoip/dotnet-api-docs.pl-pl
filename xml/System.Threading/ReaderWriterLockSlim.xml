<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bccb975feff4e3305b575f6d69439f620330aec9" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69098808" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje blokadę, która jest używana do zarządzania dostępem do zasobu, co pozwala wielu wątkom na odczyt lub wyłączny dostęp do zapisu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Służy <xref:System.Threading.ReaderWriterLockSlim> do ochrony zasobu, który jest odczytywany przez wiele wątków i w tym samym czasie zapisywana przez jeden wątek. <xref:System.Threading.ReaderWriterLockSlim>zezwala na wiele wątków w trybie odczytu, umożliwia jednemu wątkowi w trybie zapisu z wyłączną własnością blokady i umożliwia jednemu wątkowi, który ma dostęp do odczytu w trybie odczytu możliwym do uaktualnienia, z którego wątek może uaktualnić do trybu zapisu bez konieczności wyłączania go s dostęp do odczytu do zasobu.  
  
> [!NOTE]
>  <xref:System.Threading.ReaderWriterLockSlim>jest podobny do <xref:System.Threading.ReaderWriterLock>, ale ma uproszczone reguły dla rekursji i uaktualniania i obniżania stanu blokady. <xref:System.Threading.ReaderWriterLockSlim>unika wielu przypadków potencjalnego zakleszczenia. Ponadto wydajność <xref:System.Threading.ReaderWriterLockSlim> jest znacznie lepsza niż <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim>jest zalecany w przypadku wszystkich nowych rozwiązań programistycznych.  
  
 Domyślnie nowe wystąpienia programu <xref:System.Threading.ReaderWriterLockSlim> są tworzone <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> z flagą i nie zezwalają na rekursję. Ta zasada domyślna jest zalecana w przypadku wszystkich nowych rozwiązań programistycznych, ponieważ rekursja wprowadza niepotrzebne komplikacje i sprawia, że kod jest bardziej podatny na zakleszczenie. Aby uprościć migrację z istniejących projektów <xref:System.Threading.Monitor> wykorzystujących <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> lub <xref:System.Threading.ReaderWriterLock>, można użyć flagi <xref:System.Threading.ReaderWriterLockSlim> , aby utworzyć wystąpienia, które zezwalają na rekursję.  
  
 Wątek może wejść do blokady w trzech trybach: tryb odczytu, tryb zapisu i tryb odczytu do uaktualnienia. (W pozostałej części tego tematu "tryb odczytu możliwy do uaktualnienia" jest określany jako "tryb uaktualniania" i fraza "Enter `x` Mode" jest używana w preferencjach do dłuższej frazy "Wejdź w `x` tryb blokady").  
  
 Niezależnie od zasad rekursji w dowolnym momencie tylko jeden wątek może być w trybie zapisu. Gdy wątek działa w trybie zapisu, żaden inny wątek nie może wejść do blokady w żadnym trybie. Tylko jeden wątek może być w trybie do uaktualnienia w dowolnym momencie. Dowolna liczba wątków może być w trybie odczytu i może istnieć jeden wątek w trybie do uaktualnienia, podczas gdy inne wątki są w trybie odczytu.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejs. Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio. Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `catch` w bloku. Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.  
  
 <xref:System.Threading.ReaderWriterLockSlim>ma koligację zarządzanego wątku; oznacza to, że <xref:System.Threading.Thread> każdy obiekt musi wykonać własne wywołania metody, aby wejść i wyjść z trybu blokowania. Żaden wątek nie może zmienić trybu innego wątku.  
  
 Jeśli obiekt <xref:System.Threading.ReaderWriterLockSlim> nie zezwala na rekursję, wątek, który próbuje wprowadzić blokadę, może być blokowany z kilku powodów:  
  
-   Wątek, który próbuje przejść do trybu odczytu, jeśli istnieją wątki oczekujące na przejście do trybu zapisu lub jeśli w trybie zapisu występuje pojedynczy wątek.  
  
    > [!NOTE]
    >  Zablokowanie nowych czytników podczas umieszczania ich w kolejce jest zasadami sprawiedliwego blokowania, które preferują moduły zapisujące. Bieżące zasady uczciwego zrównoważą atrakcyjność dla czytelników i autorów, aby wspierać przepływność w najbardziej typowych scenariuszach. Przyszłe wersje [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] programu mogą wprowadzać nowe zasady uczciwe.  
  
-   Wątek, który próbuje wprowadzić bloki trybu możliwego do uaktualnienia, jeśli istnieje już wątek w trybie do uaktualnienia, jeśli istnieją wątki oczekujące na przejście do trybu zapisu lub jeśli w trybie zapisu występuje pojedynczy wątek.  
  
-   Wątek, który próbuje wprowadzić bloki trybu zapisu, jeśli istnieje wątek w dowolnym z trzech trybów.  
  
## <a name="upgrading-and-downgrading-locks"></a>Uaktualnianie i obniżanie wersji blokad  
 Tryb uaktualniania jest przeznaczony dla przypadków, gdy wątek zwykle odczytuje z chronionego zasobu, ale może być konieczne zapisanie go w przypadku spełnienia pewnego warunku. Wątek, który został wprowadzony <xref:System.Threading.ReaderWriterLockSlim> w trybie z możliwością uaktualnienia, ma dostęp do odczytu do chronionego zasobu i może przeprowadzić uaktualnienie do trybu zapisu, <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> wywołując metody lub. Ponieważ w tym samym czasie może istnieć tylko jeden wątek, uaktualnienie do trybu zapisu nie jest możliwe, gdy rekursja jest niedozwolona, co jest zasadami domyślnymi.  
  
> [!IMPORTANT]
>  Niezależnie od zasad rekursji wątek, który początkowo wszedł w tryb odczytu, nie może być uaktualniany do trybu z możliwością uaktualnienia lub trybem zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia. Na przykład, jeśli dwa wątki w trybie odczytu próbują przejść do trybu zapisu, będą one zakleszczeni. Tryb z modernizacją został zaprojektowany w celu uniknięcia takich zakleszczenii.  
  
 W przypadku innych wątków w trybie odczytu wątek, który uaktualnia bloki. Gdy wątek jest zablokowany, inne wątki, które próbują przejść do trybu odczytu, są blokowane. Gdy wszystkie wątki zostały zakończone z trybu odczytu, zablokowany wątek z możliwością uaktualnienia przechodzi w tryb zapisu. Jeśli istnieją inne wątki oczekujące na przejście do trybu zapisu, pozostaną zablokowane, ponieważ pojedynczy wątek, który jest w trybie z możliwością uaktualnienia, uniemożliwia im uzyskanie wyłącznego dostępu do zasobu.  
  
 Gdy wątek w trybie do uaktualnienia powoduje wyjście z trybu zapisu, inne wątki, które oczekują na przejście do trybu odczytu, mogą to zrobić, chyba że istnieją wątki oczekujące na przejście do trybu zapisu. Wątek w trybie uaktualniania można uaktualnić i obniżać poziom w nieskończoność, o ile jest to jedyny wątek, który zapisuje dane do chronionego zasobu.  
  
> [!IMPORTANT]
>  Jeśli zezwolisz wielu wątkom na przewprowadzanie trybu zapisu lub trybu możliwego do uaktualnienia, nie musisz zezwalać jednemu wątkowi na monopolize tryb uaktualniania. W przeciwnym razie wątki, które próbują wejść w tryb zapisu, będą blokowane w nieskończoność, a podczas gdy są blokowane, inne wątki nie będą mogły wejść w tryb odczytu.  
  
 Wątek w trybie do uaktualnienia może przejść do trybu odczytu, najpierw wywołując <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodę, a następnie <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> wywołując metodę. Ten wzorzec obniżania poziomu jest dozwolony dla wszystkich zasad rekursji <xref:System.Threading.LockRecursionPolicy.NoRecursion>blokady, nawet.  
  
 Po przeprowadzeniu obniżenia poziomu do trybu odczytu wątek nie może ponownie wprowadzić trybu możliwego do uaktualnienia, dopóki nie zostanie zakończony w trybie odczytu.  
  
## <a name="entering-the-lock-recursively"></a>Wchodzenie cyklicznie  
 Można utworzyć obiekt <xref:System.Threading.ReaderWriterLockSlim> , który obsługuje cykliczny wpis blokady przy <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> użyciu konstruktora, który określa zasady blokowania i określając <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Użycie rekursji nie jest zalecane w przypadku nowych rozwiązań, ponieważ wprowadza niepotrzebne komplikacje i sprawia, że kod jest bardziej podatny na zakleszczenie.  
  
 Dla programu <xref:System.Threading.ReaderWriterLockSlim> , który umożliwia rekursję, można określić następujące informacje o trybach, które może wprowadzać wątek:  
  
-   Wątek w trybie odczytu może przejść w tryb odczytu cyklicznie, ale nie może przejść do trybu zapisu ani trybu uaktualniania. Jeśli spróbuje to zrobić, <xref:System.Threading.LockRecursionException> zostanie zgłoszony. Przejście do trybu odczytu, a następnie przechodzenie do trybu zapisu lub tryb uaktualniania jest wzorcem ze silnym prawdopodobieństwem zakleszczenia, dlatego nie jest to dozwolone. Jak wspomniano wcześniej, tryb możliwy do uaktualnienia jest udostępniany w przypadku, gdy konieczne jest uaktualnienie blokady.  
  
-   Wątek w trybie możliwego do uaktualnienia może przejść do trybu zapisu i/lub trybu odczytu, a jednocześnie może wejść do jednego z trzech trybów cyklicznie. Jednak próba wprowadzenia bloków trybu zapisu, jeśli istnieją inne wątki w trybie odczytu.  
  
-   Wątek w trybie zapisu może przejść do trybu odczytu i/lub z możliwością uaktualniania, a następnie wprowadzić wszystkie trzy tryby cyklicznie.  
  
-   Wątek, który nie wszedł w blokadę, może wejść w tryb. Ta próba może blokować z tych samych powodów, co próba przejścia do blokady niecyklicznej.  
  
 Wątek może wyjść z trybu, który został wprowadzony w dowolnej kolejności, tak długo, jak zamyka każdy tryb dokładnie tyle razy, ile przeszedł ten tryb. Jeśli wątek próbuje wyjść z trybu zbyt wiele razy lub aby wyjść z trybu, który nie został wprowadzony, <xref:System.Threading.SynchronizationLockException> jest zgłaszany.  
  
## <a name="lock-states"></a>Stany blokad  
 Może się okazać, że warto zastanowić się, że blokada ma stan. <xref:System.Threading.ReaderWriterLockSlim> Może być w jednym z czterech stanów: nie wprowadzono, odczytu, uaktualnienia i zapisu.  
  
-   Nie wprowadzono: W tym stanie żaden wątek nie przeszedł blokady (lub wszystkie wątki zakończyły blokadę).  
  
-   Przeczytaj W tym stanie co najmniej jeden wątek przeszedł blokadę dostępu do odczytu do chronionego zasobu.  
  
    > [!NOTE]
    >  Wątek może wejść do blokady w trybie odczytu przy użyciu <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metod lub <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> lub przez obniżenie wersji z trybu możliwego do uaktualnienia.  
  
-   Uaktualniony W tym stanie jeden wątek przeszedł blokadę dostępu do odczytu z opcją uaktualnienia do zapisu (czyli w trybie uaktualnienia) i zero lub więcej wątków przeszedł blokadę dostępu do odczytu. Nie więcej niż jeden wątek w danym momencie może przejść do blokady z opcją uaktualnienia; dodatkowe wątki, które próbują przejść do trybu z uaktualnieniem, są blokowane.  
  
-   Prawem W tym stanie jeden wątek przeszedł blokadę dostępu do zapisu do chronionego zasobu. Ten wątek ma wyłączny dostęp do blokady. Każdy inny wątek, który próbuje wprowadzić blokadę z dowolnego powodu, jest blokowany.  
  
 W poniższej tabeli opisano przejścia między Stanami blokady, w przypadku blokad, które nie zezwalają na rekursję `t` , gdy wątek wykonuje akcję opisaną w kolumnie z lewej strony. W czasie trwania akcji `t` nie ma trybu. (Specjalny przypadek, w `t` którym jest w trybie z uaktualnieniem jest opisany w przypisach w tabeli). W górnym wierszu opisano stan początkowy blokady. Komórki opisują, co się dzieje z wątkiem, i pokazują zmiany stanu blokady w nawiasach.  
  
||Nie wprowadzono (N)|Odczyt (R)|Uaktualnienie (U)|Zapis (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t`przechodzi do trybu odczytu|`t`wejście (R).|`t`bloki, jeśli wątki oczekują na tryb zapisu; w przeciwnym razie wprowadza. `t`|`t`bloki, jeśli wątki oczekują na tryb zapisu; w przeciwnym razie wprowadza. `t` <sup> 1</sup>|`t`propagowan.|  
|`t`przechodzi do trybu z uaktualnieniem|`t`wprowadzenie (U).|`t`bloki, jeśli wątki oczekują na tryb zapisu lub tryb uaktualniania; w przeciwnym razie wprowadzi (U). `t`|`t`propagowan.|`t`propagowan.|  
|`t`przechodzi do trybu zapisu|`t`Wprowadź (W).|`t`propagowan.|`t`propagowan. <sup>2</sup>|`t`propagowan.|  
  
 <sup>1</sup> Jeśli `t` program zostanie uruchomiony w trybie do uaktualnienia, przechodzi do trybu odczytu. Ta akcja nigdy nie blokuje się. Stan blokady nie zmienia się. (Wątek może następnie zakończyć proces obniżania poziomu do odczytu, kończąc tryb uaktualnienia).  
  
 <sup>2</sup> Jeśli `t` program jest uruchamiany w trybie do uaktualnienia, blokuje się, jeśli istnieją wątki w trybie odczytu. W przeciwnym razie uaktualnia w trybie zapisu. Stan blokady zmieni się na zapis (W). Jeśli `t` bloki są wątkiem w trybie odczytu, przechodzi tryb zapisu zaraz po zakończeniu ostatniego wątku w trybie odczytu, nawet jeśli istnieją wątki oczekujące na przejście do trybu zapisu.  
  
 Gdy następuje zmiana stanu, ponieważ wątek opuszcza blokadę, Następny wątek do wznowienia jest wybierany w następujący sposób:  
  
-   Najpierw wątek, który oczekuje na tryb zapisu i jest już w trybie do uaktualnienia (może być co najwyżej jeden taki wątek).  
  
-   Niepowodzenie, czyli wątek, który oczekuje na tryb zapisu.  
  
-   Niepowodzenie, czyli wątek, który oczekuje na uaktualnienie trybu.  
  
-   Niepowodzenie, czyli wszystkie wątki czekające na tryb odczytu.  
  
 Kolejnym stanem blokady jest zawsze zapis (W) w pierwszych dwóch przypadkach i uaktualnienie (U) w trzecim przypadku, niezależnie od stanu blokady, gdy wątek wyjścia wywołał zmianę stanu. W ostatnim przypadku stan blokady jest uaktualniany (U), jeśli istnieje wątek w trybie możliwym do uaktualnienia po zmianie stanu i odczyt (R) w przeciwnym razie, niezależnie od poprzedniego stanu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje prostą zsynchronizowaną pamięć podręczną, która przechowuje ciągi z kluczami całkowitymi. Wystąpienie <xref:System.Threading.ReaderWriterLockSlim> jest używane do synchronizowania dostępu do programu <xref:System.Collections.Generic.Dictionary%602> , który służy jako wewnętrzna pamięć podręczna.  
  
 Przykład zawiera proste metody do dodania do pamięci podręcznej, usunięcia z pamięci podręcznej i odczytu z pamięci podręcznej. Aby wykazać limity czasu, przykład zawiera metodę, która dodaje do pamięci podręcznej tylko wtedy, gdy może to zrobić w określonym przedziale czasu.  
  
 Aby zademonstrować tryb uaktualniania, przykład zawiera metodę, która pobiera wartość skojarzoną z kluczem i porównuje ją z nową wartością. Jeśli wartość nie jest zmieniana, metoda zwraca stan wskazujący, że nie zmieni się. Jeśli wartość klucza nie zostanie znaleziona, para klucz/wartość zostanie wstawiona. Jeśli wartość została zmieniona, zostanie zaktualizowana. Tryb uaktualniania pozwala wątku uaktualnić dostęp do odczytu w razie potrzeby do zapisu bez ryzyka zakleszczenia.  
  
 Przykład zawiera zagnieżdżone Wyliczenie, które określa wartości zwracane dla metody, która pokazuje tryb uaktualniania.  
  
 W przykładzie używa konstruktora bez parametrów, aby utworzyć blokadę, więc rekursja jest niedozwolona. <xref:System.Threading.ReaderWriterLockSlim> Programowanie jest prostsze i mniej podatne na błędy, gdy blokada nie zezwala na rekursję.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 Poniższy kod następnie używa `SynchronizedCache` obiektu do przechowywania słownika nazw warzyw. Tworzy trzy zadania. Najpierw zapisuje nazwy warzyw przechowywanych w tablicy do `SynchronizedCache` wystąpienia. Drugie i trzecie zadanie wyświetla nazwy warzyw, pierwsze w kolejności rosnącej (od dolnego indeksu do indeksu górnego), drugi w kolejności malejącej. Zadanie końcowe wyszukuje ciąg "ogórki" i po jego znalezieniu wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony fasola".  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy z domyślnymi wartościami właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt <xref:System.Threading.ReaderWriterLockSlim> , który jest zainicjowany przy użyciu tego konstruktora, nie zezwala na rekursję. Oznacza to, <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> że właściwość zwraca <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.  
  
 Aby uzyskać więcej informacji na temat zasad rekursji i jej efektów <xref:System.Threading.LockRecursionPolicy> , zobacz Wyliczenie <xref:System.Threading.ReaderWriterLockSlim> i Klasa.  
  
   
  
## Examples  
 Poniższy przykład pokazuje prostą zsynchronizowaną pamięć podręczną, która przechowuje ciągi z kluczami całkowitymi. Wystąpienie <xref:System.Threading.ReaderWriterLockSlim> jest używane do synchronizowania dostępu do programu <xref:System.Collections.Generic.Dictionary%602> , który służy jako wewnętrzna pamięć podręczna. Konstruktor bez parametrów jest używany do tworzenia blokady.  
  
 Przykład zawiera proste metody do dodania do pamięci podręcznej, usunięcia z pamięci podręcznej i odczytu z pamięci podręcznej. Aby wykazać limity czasu, przykład zawiera metodę, która dodaje do pamięci podręcznej tylko wtedy, gdy może to zrobić w określonym przedziale czasu.  
  
 Aby zademonstrować tryb uaktualniania, przykład zawiera metodę, która pobiera wartość skojarzoną z kluczem i porównuje ją z nową wartością. Jeśli wartość nie jest zmieniana, metoda zwraca stan wskazujący, że nie zmieni się. Jeśli wartość klucza nie zostanie znaleziona, para klucz/wartość zostanie wstawiona. Jeśli wartość została zmieniona, zostanie zaktualizowana. Tryb uaktualniania pozwala wątku uaktualnić dostęp do odczytu w razie potrzeby do zapisu bez ryzyka zakleszczenia.  
  
 Przykład zawiera zagnieżdżone Wyliczenie, które określa wartości zwracane dla metody, która pokazuje tryb uaktualniania.  
  
 W przykładzie używa konstruktora bez parametrów, aby utworzyć blokadę, więc rekursja jest niedozwolona. <xref:System.Threading.ReaderWriterLockSlim> Programowanie jest prostsze i mniej podatne na błędy, gdy blokada nie zezwala na rekursję.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 Poniższy kod następnie używa `SynchronizedCache` obiektu do przechowywania słownika nazw warzyw. Tworzy trzy zadania. Najpierw zapisuje nazwy warzyw przechowywanych w tablicy do `SynchronizedCache` wystąpienia. Drugie i trzecie zadanie wyświetla nazwy warzyw, pierwsze w kolejności rosnącej (od dolnego indeksu do indeksu górnego), drugi w kolejności malejącej. Zadanie końcowe wyszukuje ciąg "ogórki" i po jego znalezieniu wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony fasola".  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">Jedna z wartości wyliczenia, która określa zasady blokowania rekursji.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy, określając zasady blokowania rekursji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasady rekursji określają ograniczenia dotyczące wątków, które wprowadzają blokadę więcej niż raz. Na przykład, jeśli Blokada została utworzona przy użyciu <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> , a wątek przeszedł w tryb odczytu, jest generowany <xref:System.Threading.LockRecursionException> , jeśli wątek spróbuje ponownie wprowadzić blokadę w trybie odczytu. Podobnie, jeśli wątek przeszedł w tryb zapisu, jest generowany, <xref:System.Threading.LockRecursionException> Jeśli wątek spróbuje ponownie wprowadzić blokadę w dowolnym trybie.  
  
> [!NOTE]
>  Wątek w trybie uaktualnienia można uaktualnić do trybu zapisu lub przeniżyć do trybu odczytu niezależnie od ustawienia zasad rekursji blokady.  
  
 Niezależnie od zasad rekursji wątek, który początkowo wszedł w tryb odczytu, nie może być uaktualniany do trybu z możliwością uaktualnienia lub trybem zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia.  
  
 Aby uzyskać więcej informacji na temat zasad rekursji i jej efektów <xref:System.Threading.LockRecursionPolicy> , zobacz Wyliczenie <xref:System.Threading.ReaderWriterLockSlim> i Klasa.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono dwa scenariusze wyjątków, które są zależne od <xref:System.Threading.LockRecursionPolicy> ustawienia i jeden z nich.  
  
 W pierwszym scenariuszu wątek przechodzi w tryb odczytu, a następnie próbuje wejść w tryb odczytu cyklicznie. Jeśli jest tworzony przy użyciu konstruktora bez parametrów, który ustawia zasady rekursji na <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, zgłaszany jest wyjątek. <xref:System.Threading.ReaderWriterLockSlim> Jeśli <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> jest używany do <xref:System.Threading.ReaderWriterLockSlim>tworzenia, nie jest zgłaszany żaden wyjątek.  
  
 W drugim scenariuszu wątek przechodzi do trybu odczytu, a następnie próbuje wejść w tryb zapisu. <xref:System.Threading.LockRecursionException>jest zgłaszany niezależnie od zasad rekursji blokady.  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 Poniższy kod następnie używa `SynchronizedCache` obiektu do przechowywania słownika nazw warzyw. Tworzy trzy zadania. Najpierw zapisuje nazwy warzyw przechowywanych w tablicy do `SynchronizedCache` wystąpienia. Drugie i trzecie zadanie wyświetla nazwy warzyw, pierwsze w kolejności rosnącej (od dolnego indeksu do indeksu górnego), drugi w kolejności malejącej. Zadanie końcowe wyszukuje ciąg "ogórki" i po jego znalezieniu wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony fasola".  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną liczbę unikatowych wątków, które przeszły blokadę w trybie odczytu.</summary>
        <value>Liczba unikatowych wątków, które przeszły blokadę w trybie odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek jest liczony tylko raz, nawet jeśli blokada zezwala na rekursję, a wątek przeszedł wiele razy w trybie odczytu.  
  
 Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu. Wyniki mogą ulec zmianie, gdy tylko zostały obliczone. W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> jak użyć właściwości w celu wygenerowania wpisu dziennika zdarzeń, jeśli liczba wątków w trybie odczytu przekracza próg.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> po zakończeniu korzystania z <xref:System.Threading.ReaderWriterLockSlim>. <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> Metoda<xref:System.Threading.ReaderWriterLockSlim> pozostawia w stanie niezdatnym do użytku. Po wywołaniu <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>należy wydać wszystkie odwołania <xref:System.Threading.ReaderWriterLockSlim> do, aby moduł wyrzucania elementów bezużytecznych mógł odwoływać pamięć <xref:System.Threading.ReaderWriterLockSlim> , którą zajmował. Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> przed wydaniem ostatniego odwołania <xref:System.Threading.ReaderWriterLockSlim> do obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />jest większa od zera.  
  
—lub— 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />jest większa od zera.  
  
—lub— 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />jest większa od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Próbuje wprowadzić blokadę w trybie odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda blokuje do momentu, aż wątek wywołujący przejdzie do blokady i w związku z tym może nigdy nie zwracać. <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> Użyj metody do blokowania dla określonego interwału, a następnie return, jeśli wątek wywołujący nie przeszedł w trybie odczytu w tym interwale.  
  
 Wiele wątków może jednocześnie przejść do trybu odczytu.  
  
 Jeśli co najmniej jeden wątek oczekuje na przejście do trybu zapisu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył działanie.  
  
> [!NOTE]
>  Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie odczytu, może przejść w tryb odczytu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.  
  
 Co najwyżej jeden wątek może być w trybie do uaktualnienia, podczas gdy inne wątki są w trybie odczytu. Jeśli dodatkowe wątki oczekują na przejście do trybu z możliwością uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, wątki <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> , które wywołują metodę, przełączają się do trybu odczytu natychmiast i nie blokują.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> jak używać metody do wprowadzania blokady w trybie odczytu. Metoda pokazana w przykładzie pobiera wartość skojarzoną z kluczem. Jeśli klucz nie zostanie znaleziony, wyjątek zgłoszony przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metodę. Blok jest używany do <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący kończy działanie trybu odczytu. `finally`  
  
 Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, a bieżący wątek próbował uzyskać blokadę odczytu, gdy ma już blokadę odczytu.  
  
—lub— 
<see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, a bieżący wątek próbował uzyskać blokadę odczytu, gdy ma już blokadę zapisu.  
  
—lub— 
Liczba rekursji przekroczy pojemność licznika. Ten limit jest tak duży, że aplikacje nie powinny napotkać tego wyjątku.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Próbuje wprowadzić blokadę w trybie z uaktualnieniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda blokuje do momentu, aż wątek wywołujący przejdzie do blokady i w związku z tym może nigdy nie zwracać. <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> Użyj metody do blokowania dla określonego interwału, a następnie Zwróć, jeśli wątek wywołujący nie przeszedł w tryb do uaktualnienia w tym interwale.  
  
 Trybu możliwego do uaktualnienia należy używać <xref:System.Threading.ReaderWriterLockSlim> w przypadku, gdy wątek zwykle uzyskuje dostęp do zasobu chronionego przez tryb odczytu, ale może być konieczne wprowadzenie trybu zapisu w przypadku spełnienia określonych warunków. Wątek w trybie do uaktualnienia może przejść do trybu odczytu lub uaktualnić do trybu zapisu.  
  
 W danym momencie tylko jeden wątek może przejść w tryb umożliwiający uaktualnienie. Jeśli wątek jest w trybie do uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, dowolna liczba innych wątków może wejść w tryb odczytu, nawet jeśli istnieją wątki oczekujące na przejście do trybu z możliwością uaktualnienia.  
  
 Jeśli co najmniej jeden wątek oczekuje na przejście do trybu zapisu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył działanie.  
  
> [!NOTE]
>  Jeśli blokada zezwala na rekursję, wątek, który przeszedł do blokady w trybie z możliwością uaktualnienia, może przejść w tryb do uaktualnienia cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> jak używać metody do przejścia w tryb umożliwiający uaktualnienie. Blok jest używany do <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący opuszcza tryb z uaktualnieniem. `finally`  
  
 Metoda pokazana w przykładzie pobiera wartość skojarzoną z kluczem i porównuje ją z nową wartością. Jeśli wartość nie jest zmieniana, metoda zwraca stan wskazujący, że nie zmieni się. Nie znaleziono wartości klucza, para klucz/wartość zostanie wstawiona. Jeśli wartość została zmieniona, zostanie zaktualizowana. Tryb możliwy do uaktualnienia umożliwia wątkowi uaktualnienie blokady odczytu w razie potrzeby bez ryzyka zakleszczenia.  
  
 W przykładzie używa konstruktora bez parametrów, aby utworzyć blokadę, więc rekursja jest niedozwolona. <xref:System.Threading.ReaderWriterLockSlim> Programowanie jest prostsze i mniej podatne na błędy, gdy blokada nie zezwala na rekursję.  
  
 Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek przeszedł już blokadę w dowolnym trybie.  
  
—lub— 
Bieżący wątek został wprowadzony w tryb odczytu, dlatego próba przejścia do trybu możliwego do uaktualnienia spowoduje utworzenie możliwości zakleszczenia.  
  
—lub— 
Liczba rekursji przekroczy pojemność licznika. Limit jest tak duży, że aplikacje nigdy nie napotkają go.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Próbuje wprowadzić blokadę w trybie zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda blokuje do momentu, aż wątek wywołujący przejdzie do blokady i w związku z tym może nigdy nie zwracać. <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> Użyj metody do blokowania dla określonego interwału, a następnie Zwróć, jeśli wątek wywołujący nie przeszedł w tym interwale w trybie zapisu.  
  
 Jeśli inne wątki przepełnią blokadę w trybie odczytu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> bloki metody do momentu zakończenia trybu odczytu przez te wątki. Gdy istnieją wątki oczekujące na przejście do trybu zapisu, dodatkowe wątki, które próbują przejść do trybu odczytu lub bloku trybu do uaktualnienia, dopóki wszystkie wątki oczekujące na przejście do trybu zapisu przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończyły działanie.  
  
> [!NOTE]
>  Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie zapisu, może jednocześnie wprowadzać tryb zapisu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> jak używać metody do wprowadzania blokady w trybie zapisu. Metoda pokazana w przykładzie dodaje nową parę klucz/wartość do synchronizowanej pamięci podręcznej. Jeśli klucz znajduje się już w pamięci podręcznej, wyjątek zgłoszony przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metodę. Blok jest używany do <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący kończy tryb zapisu. `finally`  
  
 Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek przeszedł już blokadę w dowolnym trybie.  
  
—lub— 
Bieżący wątek został wprowadzony w tryb odczytu i nie jest już członkiem blokady zapisu, dlatego próba przejścia w tryb zapisu spowoduje utworzenie możliwości zakleszczenia.  
  
—lub— 
Liczba rekursji przekroczy pojemność licznika. Limit jest tak duży, że aplikacje nigdy nie napotkają go.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę rekursji dla trybu odczytu i zamyka tryb odczytu, Jeśli wynikowa liczba wynosi 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest uwzględniana w kolejności rekursji. Na przykład jeśli wątek przechodzi w tryb do uaktualnienia, a następnie przechodzi do trybu odczytu, kolejność, w której wątek opuszcza dwa tryby, nie ma znaczenia. Jeśli blokada zezwala na rekursję, wątek może przejść do trybu zapisu blokady, a następnie wprowadzić rekursywnie w trybie odczytu. kolejność, w której wątek opuszcza tryb odczytu i tryb zapisu, nie ma znaczenia.  
  
 Wyjście z blokady może sygnalizować inne oczekujące wątki.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać `finally` bloku do <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> wykonywania metody, aby upewnić się, że obiekt wywołujący kończy działanie trybu odczytu. Metoda pokazana w przykładzie pobiera wartość skojarzoną z kluczem. Jeśli klucz nie zostanie znaleziony, wyjątek zgłoszony przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metodę. <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> Metoda jest używana do wprowadzania trybu odczytu.  
  
 Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie został wprowadzony w trybie odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę rekursji dla trybu z uaktualnieniem i zamyka tryb uaktualniania, Jeśli wynikowa liczba wynosi 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest uwzględniana w kolejności rekursji. Na przykład jeśli wątek przechodzi w tryb do uaktualnienia, a następnie przechodzi w tryb zapisu, kolejność, w której wątek opuszcza dwa tryby, nie ma znaczenia. Jeśli blokada zezwala na rekursję, wątek może przejść do trybu zapisu blokady, a następnie wprowadzić rekursywnie w trybie z możliwością uaktualnienia. kolejność, w której wątek opuszcza tryb uaktualniania i tryb zapisu, nie ma znaczenia.  
  
 Wyjście z blokady może sygnalizować inne oczekujące wątki.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać `finally` bloku do <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący kończy tryb uaktualniania.  
  
 Metoda pokazana w przykładzie pobiera wartość skojarzoną z kluczem i porównuje ją z nową wartością. Jeśli wartość nie jest zmieniana, metoda zwraca stan wskazujący, że nie zmieni się. Nie znaleziono wartości klucza, para klucz/wartość zostanie wstawiona. Jeśli wartość została zmieniona, zostanie zaktualizowana. Tryb możliwy do uaktualnienia umożliwia wątkowi uaktualnienie blokady odczytu w razie potrzeby bez ryzyka zakleszczenia.  
  
 W przykładzie używa konstruktora bez parametrów, aby utworzyć blokadę, więc rekursja jest niedozwolona. <xref:System.Threading.ReaderWriterLockSlim> Programowanie jest prostsze i mniej podatne na błędy, gdy blokada nie zezwala na rekursję.  
  
 Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie przeszedł do blokady w trybie uaktualniania.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę rekursji dla trybu zapisu i zamyka tryb zapisu, Jeśli wynikowa liczba to 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest uwzględniana w kolejności rekursji. Na przykład jeśli wątek przechodzi w tryb do uaktualnienia, a następnie przechodzi w tryb zapisu, kolejność, w której wątek opuszcza dwa tryby, nie ma znaczenia. Jeśli blokada zezwala na rekursję, wątek może przejść do trybu zapisu blokady, a następnie wprowadzić rekursywnie w trybie odczytu. kolejność, w której wątek opuszcza tryb odczytu i tryb zapisu, nie ma znaczenia.  
  
 Wyjście z blokady może sygnalizować inne oczekujące wątki.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać `finally` bloku do <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący kończy tryb zapisu. Metoda pokazana w przykładzie dodaje nową parę klucz/wartość do synchronizowanej pamięci podręcznej. Jeśli klucz znajduje się już w pamięci podręcznej, wyjątek zgłoszony przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metodę. <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> Metoda jest używana do wprowadzania blokady w trybie zapisu.  
  
 Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie został wprowadzony w trybie zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek przeszedł do blokady w trybie odczytu.</summary>
        <value><see langword="true" />Jeśli bieżący wątek został wprowadzony w trybie odczytu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do użycia w potwierdzeniach lub do innych celów debugowania. Nie należy używać go do sterowania przepływem wykonywania programu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> jak używać właściwości do generowania potwierdzenia, jeśli bieżący wątek przeszedł nieoczekiwanie w trybie odczytu.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek przeszedł blokadę w trybie z możliwością uaktualnienia.</summary>
        <value><see langword="true" />Jeśli bieżący wątek przeszedł do trybu uaktualniania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do użycia w potwierdzeniach lub do innych celów debugowania. Nie należy używać go do sterowania przepływem wykonywania programu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> jak używać właściwości do generowania potwierdzenia, jeśli bieżący wątek przeszedł nieoczekiwany tryb uaktualniania.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek przeszedł do blokady w trybie zapisu.</summary>
        <value><see langword="true" />Jeśli bieżący wątek został wprowadzony w trybie zapisu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do użycia w potwierdzeniach lub do innych celów debugowania. Nie należy używać go do sterowania przepływem wykonywania programu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> jak używać właściwości do generowania potwierdzenia, jeśli bieżący wątek został nieoczekiwanie wprowadzony w trybie zapisu.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą zasady rekursji dla bieżącego <see cref="T:System.Threading.ReaderWriterLockSlim" /> obiektu.</summary>
        <value>Jedna z wartości wyliczenia, która określa zasady blokowania rekursji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasady rekursji określają ograniczenia dotyczące wątków, które wprowadzają blokadę więcej niż raz. Na przykład, jeśli Blokada została utworzona przy użyciu <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> , a wątek przeszedł w tryb odczytu, jest generowany <xref:System.Threading.LockRecursionException> , jeśli wątek spróbuje ponownie wprowadzić blokadę w trybie odczytu.  
  
> [!NOTE]
>  Wątek w trybie uaktualnienia można uaktualnić do trybu zapisu lub przeniżyć do trybu odczytu niezależnie od ustawienia zasad rekursji blokady.  
  
 Niezależnie od zasad rekursji wątek, który początkowo wszedł w tryb odczytu, nie może być uaktualniany do trybu z możliwością uaktualnienia lub trybem zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia.  
  
 Aby uzyskać więcej informacji na temat zasad rekursji i jej efektów <xref:System.Threading.LockRecursionPolicy> , zobacz Wyliczenie <xref:System.Threading.ReaderWriterLockSlim> i Klasa.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację o tym, ile razy bieżący wątek przeszedł w tryb odczytu jako wskazanie rekursji.</summary>
        <value>0 (zero), jeśli bieżący wątek nie przeszedł w tryb odczytu, 1, jeśli wątek przeszedł w tryb odczytu, ale nie został wprowadzony rekursywnie, lub *n* , jeśli wątek przeszedł cyklicznie *n* -1 razy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu. Wyniki mogą ulec zmianie, gdy tylko zostały obliczone. W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację o tym, ile razy bieżący wątek przeszedł w tryb do uaktualnienia, jako wskazanie rekursji.</summary>
        <value>0 Jeśli bieżący wątek nie wprowadza trybu możliwego do uaktualnienia, 1, jeśli wątek przeszedł w tryb do uaktualnienia, ale nie został wprowadzony rekursywnie, lub *n* Jeśli wątek przeszedł w tryb uaktualniania cyklicznie *n* -1 razy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu. Wyniki mogą ulec zmianie, gdy tylko zostały obliczone. W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację o tym, ile razy bieżący wątek przeszedł w tryb zapisu, jako wskazanie rekursji.</summary>
        <value>0 Jeśli bieżący wątek nie wprowadził trybu zapisu, 1, jeśli wątek wszedł w tryb zapisu, ale nie został wprowadzony rekursywnie, lub *n* , jeśli wątek przeszedł w tryb zapisu cyklicznie *n* -1 razy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu. Wyniki mogą ulec zmianie, gdy tylko zostały obliczone. W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje wprowadzić blokadę w trybie odczytu z opcjonalnym limitem czasu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub-1 (<see cref="F:System.Threading.Timeout.Infinite" />) oczekiwania na czas nieokreślony.</param>
        <summary>Próbuje wprowadzić blokadę w trybie odczytu z opcjonalnym limitem czasu dla liczby całkowitej.</summary>
        <returns><see langword="true" />Jeśli wątek wywołujący wszedł w tryb odczytu, w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.  
  
 Wiele wątków może jednocześnie przejść do trybu odczytu.  
  
 Jeśli co najmniej jeden wątek oczekuje na przejście do trybu zapisu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył działanie lub do momentu wygaśnięcia interwału limitu czasu wątku wywołującego.  
  
> [!NOTE]
>  Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie odczytu, może przejść w tryb odczytu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.  
  
 Jeden wątek może być w trybie do uaktualnienia, podczas gdy inne wątki są w trybie odczytu. Jeśli dodatkowe wątki oczekują na przejście do trybu z możliwością uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, wątki <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> , które wywołują metodę, przełączają się do trybu odczytu natychmiast i nie blokują.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.  
  
—lub— 
Liczba rekursji przekroczy pojemność licznika. Limit jest tak duży, że aplikacje nigdy nie napotkają go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa (-1), która jest jedyną dozwoloną wartością ujemną.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał oczekiwania lub-1 milisekund oczekiwania na czas nieokreślony.</param>
        <summary>Próbuje wprowadzić blokadę w trybie odczytu z opcjonalnym limitem czasu.</summary>
        <returns><see langword="true" />Jeśli wątek wywołujący wszedł w tryb odczytu, w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.  
  
 Wiele wątków może jednocześnie przejść do trybu odczytu.  
  
 Jeśli co najmniej jeden wątek zostanie umieszczony w kolejce w celu przejścia do trybu zapisu, wątek <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> , który wywołuje bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył się z niego lub do czasu wygaśnięcia interwału limitu czasu wątku wywołującego.  
  
> [!NOTE]
>  Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie odczytu, może przejść w tryb odczytu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.  
  
 Jeden wątek może być w trybie do uaktualnienia, podczas gdy inne wątki są w trybie odczytu. Jeśli dodatkowe wątki oczekują na przejście do trybu z możliwością uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, wątki <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> , które wywołują metodę, przełączają się do trybu odczytu natychmiast i nie blokują.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.  
  
—lub— 
Liczba rekursji przekroczy pojemność licznika. Limit jest tak duży, że aplikacje nigdy nie napotkają go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartością ujemną.  
  
—lub— 
Wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekunda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Podejmuje próbę przejścia w tryb uaktualniania z opcjonalnym limitem czasu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub-1 (<see cref="F:System.Threading.Timeout.Infinite" />) oczekiwania na czas nieokreślony.</param>
        <summary>Podejmuje próbę przejścia w tryb uaktualniania z opcjonalnym limitem czasu.</summary>
        <returns><see langword="true" />Jeśli wątek wywołujący przeszedł w tryb umożliwiający uaktualnienie <see langword="false" />, w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.  
  
 Trybu możliwego do uaktualnienia należy używać <xref:System.Threading.ReaderWriterLockSlim> w przypadku, gdy wątek zwykle uzyskuje dostęp do zasobu chronionego przez tryb odczytu, ale może być konieczne wprowadzenie trybu zapisu w przypadku spełnienia określonych warunków. Wątek w trybie uaktualniania można uaktualnić do trybu zapisu lub przeniżyć do trybu odczytu.  
  
 Tylko jeden wątek może w dowolnym momencie wprowadzić blokadę w trybie z możliwością uaktualnienia. Jeśli wątek jest w trybie do uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, dowolna liczba innych wątków może wejść w tryb odczytu, nawet jeśli istnieją wątki oczekujące na przejście do trybu z możliwością uaktualnienia.  
  
 Jeśli co najmniej jeden wątek oczekuje na przejście do trybu zapisu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył działanie lub do momentu wygaśnięcia interwału limitu czasu wątku wywołującego.  
  
> [!NOTE]
>  Jeśli blokada zezwala na rekursję, wątek, który przeszedł do blokady w trybie z możliwością uaktualnienia, może przejść w tryb do uaktualnienia cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.  
  
—lub— 
Bieżący wątek początkowo przeszedł do blokady w trybie odczytu i w związku z tym próba przejścia do trybu możliwego do uaktualnienia spowoduje utworzenie możliwości zakleszczenia.  
  
—lub— 
Liczba rekursji przekroczy pojemność licznika. Limit jest tak duży, że aplikacje nigdy nie napotkają go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa (-1), która jest jedyną dozwoloną wartością ujemną.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał oczekiwania lub-1 milisekund oczekiwania na czas nieokreślony.</param>
        <summary>Podejmuje próbę przejścia w tryb uaktualniania z opcjonalnym limitem czasu.</summary>
        <returns><see langword="true" />Jeśli wątek wywołujący przeszedł w tryb umożliwiający uaktualnienie <see langword="false" />, w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.  
  
 Trybu możliwego do uaktualnienia należy używać <xref:System.Threading.ReaderWriterLockSlim> w przypadku, gdy wątek zwykle uzyskuje dostęp do zasobu chronionego przez w trybie odczytu, ale może być konieczne wprowadzenie trybu zapisu w przypadku spełnienia określonych warunków. Wątek w trybie uaktualniania można uaktualnić do trybu zapisu lub przeniżyć do trybu odczytu.  
  
 Tylko jeden wątek może w dowolnym momencie wprowadzić blokadę w trybie z możliwością uaktualnienia. Jeśli wątek jest w trybie do uaktualnienia i nie ma wątków oczekujących na przejście do trybu zapisu, dowolna liczba innych wątków może wejść w tryb odczytu, nawet jeśli istnieją wątki oczekujące na przejście do trybu z możliwością uaktualnienia.  
  
 Jeśli co najmniej jeden wątek oczekuje na przejście do trybu zapisu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> bloki metody do momentu, aż te wątki przekroczą limit czasu lub przeszedł tryb zapisu, a następnie zakończył działanie lub do momentu wygaśnięcia interwału limitu czasu wątku wywołującego.  
  
> [!NOTE]
>  Jeśli blokada zezwala na rekursję, wątek, który przeszedł do blokady w trybie z możliwością uaktualnienia, może przejść w tryb do uaktualnienia cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.  
  
—lub— 
Bieżący wątek początkowo przeszedł do blokady w trybie odczytu i w związku z tym próba przejścia do trybu możliwego do uaktualnienia spowoduje utworzenie możliwości zakleszczenia.  
  
—lub— 
Liczba rekursji przekroczy pojemność licznika. Limit jest tak duży, że aplikacje nigdy nie napotkają go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartością ujemną.  
  
—lub— 
Wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekunda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje wprowadzić blokadę w trybie zapisu z opcjonalnym limitem czasu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub-1 (<see cref="F:System.Threading.Timeout.Infinite" />) oczekiwania na czas nieokreślony.</param>
        <summary>Próbuje wprowadzić blokadę w trybie zapisu z opcjonalnym limitem czasu.</summary>
        <returns><see langword="true" />Jeśli wątek wywołujący wszedł w tryb zapisu, w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.  
  
 Jeśli inne wątki przeszedł w tryb odczytu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> bloki metody do momentu, aż te wątki zakończą tryb odczytu lub do momentu, gdy upłynie limit czasu. Gdy wątki są zablokowane, oczekują na przejście do trybu zapisu, dodatkowe wątki, które próbują przejść do trybu odczytu lub bloku trybu do uaktualnienia, dopóki wszystkie wątki oczekujące na przejście do trybu zapisu przekroczą limit czasu lub przeszedł w tryb zapisu, a następnie zakończyły działanie.  
  
> [!NOTE]
>  Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie zapisu, może jednocześnie wprowadzać tryb zapisu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metody do wprowadzania blokady w trybie zapisu z limitem czasu. Metoda pokazana w przykładzie dodaje nową parę klucz/wartość do synchronizowanej pamięci podręcznej. Jeśli określony interwał limitu czasu upłynie, zanim wątek przejdzie do blokady, metoda zwraca `false`. Metoda zwraca wartość `true` , jeśli para klucz/wartość jest dodawana.  
  
 Jeśli klucz znajduje się już w pamięci podręcznej, wyjątek zgłoszony przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metodę. Blok jest używany do <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> wykonywania metody, co zapewnia, że obiekt wywołujący opuszcza blokadę. `finally`  
  
 Ten kod jest częścią większego przykładu dostarczonego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.  
  
—lub— 
Bieżący wątek początkowo przeszedł do blokady w trybie odczytu i w związku z tym próba przejścia do trybu zapisu spowoduje utworzenie możliwości zakleszczenia.  
  
—lub— 
Liczba rekursji przekroczy pojemność licznika. Limit jest tak duży, że aplikacje nigdy nie napotkają go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa (-1), która jest jedyną dozwoloną wartością ujemną.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał oczekiwania lub-1 milisekund oczekiwania na czas nieokreślony.</param>
        <summary>Próbuje wprowadzić blokadę w trybie zapisu z opcjonalnym limitem czasu.</summary>
        <returns><see langword="true" />Jeśli wątek wywołujący wszedł w tryb zapisu, w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest równa 0 (zero), ta metoda sprawdza stan blokady i `false` zwraca natychmiast, jeśli żądany stan jest niedostępny.  
  
 Jeśli inne wątki przeszedł w tryb odczytu, wątek, który wywołuje <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> bloki metody do momentu, aż te wątki zakończą tryb odczytu lub do momentu, gdy upłynie limit czasu. Gdy wątki są zablokowane, oczekują na przejście do trybu zapisu, dodatkowe wątki, które próbują przejść do trybu odczytu lub bloku trybu do uaktualnienia, dopóki wszystkie wątki oczekujące na przejście do trybu zapisu przekroczą limit czasu lub przeszedł w tryb zapisu, a następnie zakończyły działanie.  
  
> [!NOTE]
>  Jeśli blokada zezwala na rekursję, wątek, który przeszedł blokadę w trybie zapisu, może jednocześnie wprowadzać tryb zapisu cyklicznie, nawet jeśli inne wątki oczekują na przejście do trybu zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już wszedł w blokadę.  
  
—lub— 
Bieżący wątek początkowo przeszedł do blokady w trybie odczytu i w związku z tym próba przejścia do trybu zapisu spowoduje utworzenie możliwości zakleszczenia.  
  
—lub— 
Liczba rekursji przekroczy pojemność licznika. Limit jest tak duży, że aplikacje nigdy nie napotkają go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartością ujemną.  
  
—lub— 
Wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekunda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną liczbę wątków, które oczekują na przejście do trybu odczytu.</summary>
        <value>Całkowita liczba wątków, które oczekują na przejście do trybu odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu. Wyniki mogą ulec zmianie, gdy tylko zostały obliczone. W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak użyć właściwości, <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> aby wygenerować wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, czeka na przejście do trybu odczytu, przekracza wartość progową.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną liczbę wątków, które oczekują na przejście do trybu z uaktualnieniem.</summary>
        <value>Całkowita liczba wątków, które oczekują na przejście do trybu z uaktualnieniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu. Wyniki mogą ulec zmianie, gdy tylko zostały obliczone. W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> jak użyć właściwości w celu wygenerowania wpisu dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, oczekujące na przejście do trybu z możliwością uaktualnienia, przekracza wartość progową.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną liczbę wątków, które oczekują na przejście do trybu zapisu blokady.</summary>
        <value>Całkowita liczba wątków, które oczekują na przejście do trybu zapisu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy używać tylko na potrzeby debugowania, profilowania i rejestrowania, a nie do sterowania zachowaniem algorytmu. Wyniki mogą ulec zmianie, gdy tylko zostały obliczone. W związku z tym nie jest bezpieczne podejmowanie decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak użyć właściwości, <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> aby wygenerować wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, oczekujące na wprowadzenie trybu zapisu, przekracza wartość progową.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

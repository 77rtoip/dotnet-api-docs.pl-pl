<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c054992aa5b458c405c83dbc79a506889a9ffc87" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407191" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje blokady, która jest używana do zarządzania dostęp do zasobów, dzięki czemu wiele wątków do odczytu lub wyłącznego dostępu do zapisu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Threading.ReaderWriterLockSlim> ochrony z zasobem, który jest odczytywany przez wiele wątków i zapisana przez jeden wątek na raz. <xref:System.Threading.ReaderWriterLockSlim> zezwala na wiele wątków w trybie do odczytu, umożliwia jeden wątek, aby być w trybie wyłączności na własność blokady zapisu i pozwala jeden wątek, który ma dostęp do odczytu w trybie możliwej do odczytu, w którym Wątek można uaktualnić do zapisu tryb bez konieczności zrzeka się on s dostęp do odczytu do zasobu.  
  
> [!NOTE]
>  <xref:System.Threading.ReaderWriterLockSlim> przypomina <xref:System.Threading.ReaderWriterLock>, ale jest prostszy zasady rekursji oraz uaktualniania i zmiany na starszą wersję stan blokady. <xref:System.Threading.ReaderWriterLockSlim> pozwala uniknąć wielu przypadkach potencjalnych zakleszczenia. Ponadto wydajność <xref:System.Threading.ReaderWriterLockSlim> jest znacznie lepszą niż <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> jest zalecana dla wszystkich nowych wdrożeń.  
  
 Domyślnie nowe wystąpienia klasy <xref:System.Threading.ReaderWriterLockSlim> są tworzone za pomocą <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> Flaga i nie pozwalają rekursji. Zasada domyślna jest zalecane dla wszystkich nowych aplikacji, ponieważ rekursji wprowadzono niepotrzebnych komplikacji i sprawia, że kod jest bardziej podatne na zakleszczenie. W celu uproszczenia migracji z istniejących projektów używające <xref:System.Threading.Monitor> lub <xref:System.Threading.ReaderWriterLock>, można użyć <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flagę w celu utworzenia wystąpienia <xref:System.Threading.ReaderWriterLockSlim> umożliwiające rekursji.  
  
 Wątek można wprowadzić blokady w trzech trybów: tryb, w trybie zapisu i trybie możliwej do odczytu do odczytu. (W pozostałej części tego tematu, "Tryb odczytu możliwej" nazywa się "Tryb możliwej" i frazę "Wprowadź `x` tryb" jest używana zamiast dłużej frazy "Wprowadź blokady w `x` tryb".)  
  
 Niezależnie od zasady rekursji tylko jeden wątek może być w trybie zapisu w dowolnym momencie. Gdy wątek jest w trybie zapisu, nie inne wątku można wprowadzić blokady w dowolnym trybie. Tylko jeden wątek może być w trybie możliwej w dowolnym momencie. Dowolnej liczby wątków może być w trybie do odczytu i może być jeden wątek w trybie możliwej podczas gdy inne wątki są w trybie do odczytu.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 <xref:System.Threading.ReaderWriterLockSlim> zarządza koligacji wątku; oznacza to, że każdy <xref:System.Threading.Thread> obiektu należy własną wywołania metody i wyjścia tryby blokady. Wątek nie można zmienić trybu inny wątek.  
  
 Jeśli <xref:System.Threading.ReaderWriterLockSlim> nie zezwala na rekursji, wątek, aby zablokować próbuje wpisz blokady z kilku powodów:  
  
-   Wątek, który próbuje wpisz bloków w trybie do odczytu, jeśli istnieją wątków oczekujących wprowadzić w trybie zapisu lub jeśli w trybie zapisu jest pojedynczym wątku.  
  
    > [!NOTE]
    >  Blokowanie nowych czytników podczas zapisywania są umieszczane w kolejce są to zasady sprawiedliwe przydzielanie zasobów blokady, które ma autorów. Bieżące zasady sprawiedliwe przydzielanie zasobów równoważy sprawiedliwe przydzielanie zasobów dla czytników i zapisywania, aby podwyższyć poziom przepływności w najbardziej typowych scenariuszy. Kolejne wersje [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] mogą wprowadzać nowe zasady sprawiedliwe przydzielanie zasobów.  
  
-   Wątek próbował wpisać bloków w trybie możliwej, jeśli istnieje już wątku w trybie możliwej, jeśli istnieją wątków oczekujących do trybu zapisu lub w trybie zapisu jest pojedynczym wątku.  
  
-   Wątek, który próbuje wpisz bloki tryb zapisu, jeśli jest wątku w jednym z trzech trybów.  
  
## <a name="upgrading-and-downgrading-locks"></a>Trwa uaktualnianie i zmiany na starszą wersję blokuje  
 Tryb możliwej jest przeznaczony dla przypadków, w którym wątek zwykle odczytuje z chronionych zasobów, ale może być konieczne zapisanie w nim Jeśli niektóre warunki są spełnione. Wątek wszedł <xref:System.Threading.ReaderWriterLockSlim> w trybie możliwej ma dostęp do odczytu do chronionych zasobów i przeprowadzić uaktualnienie do zapisu tryb wywołując <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> lub <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metody. Ponieważ może istnieć tylko jeden wątek w trybie możliwej w czasie, uaktualnienie do zapisu trybu nie zakleszczenie rekursji jest niedozwolony, która jest domyślne zasady.  
  
> [!IMPORTANT]
>  Niezależnie od zasady rekursji wątku, który początkowo wprowadzona odczytać tryb nie jest dozwolone do uaktualnienia do trybu możliwej lub zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia. Na przykład jeśli dwa wątki w trybie odczytu, który zarówno spróbuj wprowadzić tryb zapisu, ich będzie zakleszczenie. Tryb możliwej zaprojektowano w celu uniknięcia takiej zakleszczenie.  
  
 Jeśli istnieją inne wątki w trybie do odczytu, wątku, który jest uaktualnienie bloków. Gdy wątek jest zablokowany lub innych wątków, które wprowadzona w trybie do odczytu są zablokowane. Po zamknięciu wszystkich wątków w trybie do odczytu, zablokowanych wątków możliwej przechodzi trybie zapisu. Jeśli istnieją inne wątki oczekujące na wprowadź zapisu tryb, pozostają zablokowane, ponieważ jeden wątek, który jest w trybie możliwej zapobiega ich uzyskania wyłącznego dostępu do zasobu.  
  
 Innych wątków, które oczekują na wprowadzanie trybie do odczytu w wątku w trybie możliwej opuszcza tryb zapisu, należy tak, chyba że wątków oczekujących na Wprowadź tryb zapisu. Wątek w trybie możliwej można uaktualnić i obniżyć przez czas nieokreślony, tak długo, jak to tylko wątku, który zapisuje do chronionego zasobu.  
  
> [!IMPORTANT]
>  Jeśli zezwolisz na używanie wielu wątków wprowadzić zapisu trybu lub możliwej, nie może dopuszczać jeden wątek, aby zająć całych możliwej tryb. W przeciwnym razie wątków, które próbują wprowadź zapisu tryb bezpośrednio będą blokowane przez nieograniczony czas i gdy są one blokowane, inne wątki nie będzie można wprowadzić w trybie do odczytu.  
  
 Wątek w trybie możliwej mogłoby obniżyć poziom trybu odczytu przy pierwszym wywołaniu <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> — metoda i wywołując <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> metody. Ten wzorzec obniżenia poziomu jest dozwolony dla wszystkich zasad rekursji blokady, nawet <xref:System.Threading.LockRecursionPolicy.NoRecursion>.  
  
 Po zmiany na starszą wersję trybu odczytu, wątku nie można ponownie tryb możliwej do momentu zakończył się w trybie do odczytu.  
  
## <a name="entering-the-lock-recursively"></a>Wprowadzanie rekursywnie blokady  
 Można utworzyć <xref:System.Threading.ReaderWriterLockSlim> obsługującej cykliczne blokady zapisu przy użyciu <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> Konstruktor, który określa zasady blokowania i określając <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Rekursji nie jest zalecane dla nowych aplikacji, ponieważ wprowadza niepotrzebnych komplikacji i sprawia, że kod jest bardziej podatne na zakleszczenie.  
  
 Aby uzyskać <xref:System.Threading.ReaderWriterLockSlim> umożliwiająca rekursji, następujące powiedzieć, temat trybów wątku można wprowadzić:  
  
-   Wątek w trybie do odczytu można wprowadzić rekursywnie w trybie do odczytu, ale nie można wprowadzić w trybie zapisu lub możliwej. Jeśli spróbuje to zrobić, <xref:System.Threading.LockRecursionException> jest generowany. Wprowadzenie do odczytu tryb zapisu w trybie, a następnie wpisując lub tryb możliwej jest wzorca zawierającego silne prawdopodobieństwo zakleszczenia, przez co nie jest dozwolone. Jak już wspomniano, tryb możliwej jest dostępna dla przypadkach, gdy jest niezbędne do uaktualnienia blokady.  
  
-   Wątek w trybie możliwej można wprowadzić w trybie zapisu i/lub w trybie odczytu i wprowadzić żadnego z trzech trybów rekursywnie. Jednak próba wprowadź zapisu bloków w trybie Jeśli istnieją inne wątki w trybie do odczytu.  
  
-   Wątek w trybie zapisu można wprowadzić w trybie odczytu i/lub tryb możliwej i wprowadzić żadnego z trzech trybów rekursywnie.  
  
-   Wątek, który nie przeszedł blokady można wprowadzić dowolny tryb. Ta próba może zablokować z tego samego powodu, próba Podaj niecyklicznego blokady.  
  
 Wątek może wyjść tryby, wprowadzona w dowolnej kolejności, tak długo, jak kończy działanie każdej tryb dokładnie dowolną liczbę razy, ile pojawił się trybie. Jeśli spróbuje wątek, aby wyjść z trybu zbyt wiele razy lub aby wyjść z trybu nie została wprowadzona, <xref:System.Threading.SynchronizationLockException> jest generowany.  
  
## <a name="lock-states"></a>Stany blokady  
 Mogą być przydatne Rozważmy blokady względem jego stanów. A <xref:System.Threading.ReaderWriterLockSlim> może znajdować się w jednej z czterech stanów: zostały wprowadzone, należy przeczytać, uaktualniania i zapisu.  
  
-   Nie wprowadzono: W tym stanie nie wątków zostały wprowadzone blokady (lub wszystkie wątki zamknięciu blokady).  
  
-   Przeczytaj: W tym stanie, co najmniej jeden wątek wprowadzony blokady dla dostępu do odczytu do chronionego zasobu.  
  
    > [!NOTE]
    >  Wątek można wprowadzić blokady w trybie do odczytu za pomocą <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> lub <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metody, lub zmiany na starszą wersję z trybu możliwej.  
  
-   Uaktualnianie: W tym stanie jeden wątek wszedł blokady dla dostępu do odczytu z możliwością uaktualnienia do zapisu (to znaczy w możliwej tryb), oraz zero lub więcej wątków wprowadzony blokady dla dostępu do odczytu. Nie więcej niż jeden wątek na raz można wprowadzić blokady przy użyciu z opcji uaktualnienia; Spróbuj przejść do trybu możliwej dodatkowe wątki są zablokowane.  
  
-   Zapisu: W tym stanie jeden wątek wszedł blokady dla dostęp do zapisu do chronionego zasobu. Wątek jest posiadanie wyłącznej blokady. Innego wątku, który próbuje wprowadź blokady jakiegokolwiek powodu została zablokowana.  
  
 W poniższej tabeli opisano przejścia między Stanami blokady, blokad, które nie zezwalają na rekursji, gdy wątek `t` podejmuje działania opisane w lewej kolumnie. W tym czasie zajmuje akcji, `t` nie trybem. (Szczególnych przypadkach gdy `t` jest w trybie możliwej jest opisany w przypisach tabeli.) Pierwszy wiersz zawiera opis początkowy stan blokady. Komórki opisano, co się dzieje z wątku i wyświetlać zmiany stanu blokady w nawiasach.  
  
||Nie podano (N)|Read (R)|Uaktualnienie (U)|Zapisu (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` wprowadza trybie do odczytu|`t` wprowadza (R).|`t` bloki Jeśli wątków oczekuje na tryb zapisu; w przeciwnym razie `t` wejścia.|`t` bloki Jeśli wątków oczekuje na tryb zapisu; w przeciwnym razie `t` wprowadza.<sup> 1</sup>|`t` bloki.|  
|`t` Przechodzi do trybu możliwej|`t` wprowadza (U).|`t` bloki Jeśli wątków oczekuje na zapis trybu lub uaktualnienia; w przeciwnym razie `t` wejścia (U).|`t` bloki.|`t` bloki.|  
|`t` Przechodzi do trybu zapisu|`t` wprowadza (M).|`t` bloki.|`t` bloki. <sup>2</sup>|`t` bloki.|  
  
 <sup>1</sup> Jeśli `t` uruchamia się w trybie możliwej, wejdzie ona trybie do odczytu. Ta akcja nie blokuje. Stan blokady nie ulega zmianie. (Wątku mogą zakończyć obniżania trybu odczytu podczas zamykania możliwej tryb).  
  
 <sup>2</sup> Jeśli `t` zostanie uruchomiony w trybie możliwej, blokuje w przypadku wątków w trybie do odczytu. W przeciwnym razie uaktualnia trybie zapisu. Zmiany stanu blokady zapisu (W). Jeśli `t` blokuje, ponieważ istnieją wątki w trybie do odczytu, wejdzie ona trybie zapisu, jak ostatni wątek kończy pracę w trybie do odczytu, nawet jeśli istnieją wątków oczekujących na wprowadź zapis tryb.  
  
 Po zmianie stanu ponieważ blokada kończy działanie wątku, na wznowione następnym wątku jest wybrane w następujący sposób:  
  
-   Najpierw wątku, który oczekuje na tryb zapisu i jest już w trybie możliwej (może mieć co najwyżej jeden taki wątek).  
  
-   Awarii, który wątku, który oczekuje na trybie zapisu.  
  
-   Który wątku, który oczekuje na tryb możliwej awarii.  
  
-   Awarii, wszystkie wątki, które czekają w trybie odczytu.  
  
 Kolejne stan blokady jest zawsze zapisu (W) w pierwszym przypadków i uaktualnienia (U) w przypadku trzeciej, bez względu na stan blokady, gdy wątek istniejącym wyzwalane po zmianie stanu. W przypadku ostatniego stanu blokady wynosi uaktualnienia (U) wątek w trybie możliwej po zmianie stanu i Read (R) w przeciwnym razie niezależnie od poprzedniego stanu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono prosty zsynchronizowane pamięci podręcznej, który przechowuje ciągi z kluczami liczby całkowitej. Wystąpienie <xref:System.Threading.ReaderWriterLockSlim> służy do synchronizowania dostęp do <xref:System.Collections.Generic.Dictionary%602> służy jako wewnętrznej pamięci podręcznej.  
  
 Przykład zawiera proste metody do dodawania do pamięci podręcznej, Usuń z pamięci podręcznej i odczytu z pamięci podręcznej. Aby zademonstrować limity czasu, przykładzie zawiera metodę, która dodaje do pamięci podręcznej tylko wtedy, gdy jest on to zrobić w ramach określonego limitu czasu.  
  
 Aby zaprezentować tryb możliwej, przykładzie zawiera metodę, która pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością. Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian. Go nie jest znaleziono wartości dla klucza, jest wstawiany parę klucza i wartości. Jeśli wartość została zmieniona, jest aktualizowana. Tryb możliwej pozwala na uaktualnienie dostęp do odczytu do zapisu w razie potrzeby bez ryzyka zakleszczenie wątku.  
  
 Przykład zawiera zagnieżdżone wyliczenia, określająca wartości zwracanych przez metodę, która przedstawia możliwej tryb.  
  
 W przykładzie użyto domyślnego konstruktora do utworzenia blokady, więc rekursji jest niedozwolone. Programowanie <xref:System.Threading.ReaderWriterLockSlim> jest prostsza i mniej podatne na błędy podczas blokady nie zezwala na rekursji.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 Poniższy kod używa następnie `SynchronizedCache` obiekt, aby zapisać słownik nazw materiałem. Tworzy trzy zadania. Pierwszy zapisuje nazw warzyw przechowywane w tablicy do `SynchronizedCache` wystąpienia. Drugi i trzeci zadań wyświetlane nazwy warzyw, pierwszy w kolejności rosnącej (od niskiej indeksu indeks wysokiej), drugi w kolejności malejącej. Ostatnim zadaniem wyszukuje ciąg "Ogórek" i, gdy uzna, wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony ziarna".  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.ReaderWriterLockSlim" /> z domyślnymi wartościami właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Threading.ReaderWriterLockSlim> który został zainicjowany z tym Konstruktor nie zezwala na rekursji. Oznacza to <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> zwraca właściwość <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.  
  
 Aby uzyskać więcej informacji o zasadach rekursji i jej wpływ, zobacz <xref:System.Threading.LockRecursionPolicy> wyliczenie i <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono prosty zsynchronizowane pamięci podręcznej, który przechowuje ciągi z kluczami liczby całkowitej. Wystąpienie <xref:System.Threading.ReaderWriterLockSlim> służy do synchronizowania dostęp do <xref:System.Collections.Generic.Dictionary%602> służy jako wewnętrznej pamięci podręcznej. Konstruktor bez parametrów służy do tworzenia blokady.  
  
 Przykład zawiera proste metody do dodawania do pamięci podręcznej, Usuń z pamięci podręcznej i odczytu z pamięci podręcznej. Aby zademonstrować limity czasu, przykładzie zawiera metodę, która dodaje do pamięci podręcznej tylko wtedy, gdy jest on to zrobić w ramach określonego limitu czasu.  
  
 Aby zaprezentować tryb możliwej, przykładzie zawiera metodę, która pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością. Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian. Go nie jest znaleziono wartości dla klucza, jest wstawiany parę klucza i wartości. Jeśli wartość została zmieniona, jest aktualizowana. Tryb możliwej pozwala na uaktualnienie dostęp do odczytu do zapisu w razie potrzeby bez ryzyka zakleszczenie wątku.  
  
 Przykład zawiera zagnieżdżone wyliczenia, określająca wartości zwracanych przez metodę, która przedstawia możliwej tryb.  
  
 W przykładzie użyto domyślnego konstruktora do utworzenia blokady, więc rekursji jest niedozwolone. Programowanie <xref:System.Threading.ReaderWriterLockSlim> jest prostsza i mniej podatne na błędy podczas blokady nie zezwala na rekursji.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 Poniższy kod używa następnie `SynchronizedCache` obiekt, aby zapisać słownik nazw materiałem. Tworzy trzy zadania. Pierwszy zapisuje nazw warzyw przechowywane w tablicy do `SynchronizedCache` wystąpienia. Drugi i trzeci zadań wyświetlane nazwy warzyw, pierwszy w kolejności rosnącej (od niskiej indeksu indeks wysokiej), drugi w kolejności malejącej. Ostatnim zadaniem wyszukuje ciąg "Ogórek" i, gdy uzna, wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony ziarna".  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">Jedna z wartości wyliczenia, które określa zasady blokowania rekursji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy określenie zasad rekursji blokady.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasada rekursji określa ograniczenia dotyczące wątków, które wprowadź blokady więcej niż raz. Na przykład, jeśli utworzono blokady <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> i Wątek wszedł blokady w trybie do odczytu, <xref:System.Threading.LockRecursionException> jest generowany, jeśli wątek spróbuje ponownie blokady w trybie do odczytu. Podobnie, jeśli wątek wszedł blokady w trybie zapisu <xref:System.Threading.LockRecursionException> jest generowany, jeśli wątek spróbuje ponownie blokady w dowolnym trybie.  
  
> [!NOTE]
>  Wątek w trybie możliwej można uaktualnić do zapisu w trybie lub starszą wersję trybu bez względu na ustawienie zasad rekursji blokady odczytu.  
  
 Niezależnie od zasady rekursji wątku, który początkowo wprowadzona odczytać tryb nie jest dozwolone do uaktualnienia do trybu możliwej lub zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia.  
  
 Aby uzyskać więcej informacji o zasadach rekursji i jej wpływ, zobacz <xref:System.Threading.LockRecursionPolicy> wyliczenie i <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia dwa scenariusze wyjątek, który jest zależny od <xref:System.Threading.LockRecursionPolicy> ustawienie i jedną, która nie.  
  
 W pierwszym scenariuszu wątek przejdzie do trybu odczytu i próbuje wpisz rekursywnie w trybie do odczytu. Jeśli <xref:System.Threading.ReaderWriterLockSlim> jest tworzona przy użyciu domyślnego konstruktora, który ustawia zasady rekursji <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, jest zgłaszany wyjątek. Jeśli <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> służy do tworzenia <xref:System.Threading.ReaderWriterLockSlim>, nie jest wyjątek.  
  
 W drugim scenariuszu wątek przechodzi w trybie do odczytu, a następnie próbuje wpisz wpisz tryb. <xref:System.Threading.LockRecursionException> jest generowany, niezależnie od zasady rekursji blokady.  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 Poniższy kod używa następnie `SynchronizedCache` obiekt, aby zapisać słownik nazw materiałem. Tworzy trzy zadania. Pierwszy zapisuje nazw warzyw przechowywane w tablicy do `SynchronizedCache` wystąpienia. Drugi i trzeci zadań wyświetlane nazwy warzyw, pierwszy w kolejności rosnącej (od niskiej indeksu indeks wysokiej), drugi w kolejności malejącej. Ostatnim zadaniem wyszukuje ciąg "Ogórek" i, gdy uzna, wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony ziarna".  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowita liczba unikatowych wątków, które zostały wprowadzone blokady w trybie do odczytu.</summary>
        <value>Liczba unikatowych wątków, które zostały wprowadzone blokady w trybie do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek tylko raz, nawet jeśli blokady umożliwia rekursji i wątek został przełączony w trybie do odczytu wiele razy.  
  
 Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu. Wyniki można zmienić, jak zostały obliczone. W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> Generuj wpis dziennika zdarzeń, jeśli liczba wątków w trybie odczytu przekracza próg dla właściwości.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> po zakończeniu przy użyciu <xref:System.Threading.ReaderWriterLockSlim>. <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> Pozostawia metody <xref:System.Threading.ReaderWriterLockSlim> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Threading.ReaderWriterLockSlim> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.Threading.ReaderWriterLockSlim> klasy. Aby uzyskać więcej informacji, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> przed zwolnieniem ostatniego odwołania do <xref:System.Threading.ReaderWriterLockSlim> obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> jest większa niż zero.  - lub - <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> jest większa od zera.  - lub - <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> jest większa od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Próbuje wpisz blokady w trybie do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten bloki metody aż wątek wywołujący wprowadza blokady, a w związku z tym może nigdy nie zwraca. Użyj <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> trybu odczytu metodę, aby zablokować dla określonego interwału, a następnie wróć, jeśli wątek wywołujący nie została wprowadzona podczas tego interwału.  
  
 Wiele wątków można wprowadzić trybie do odczytu, w tym samym czasie.  
  
 Jeśli jeden lub więcej wątków oczekujących na tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> bloki metody do momentu mieć tych wątków upłynął limit czasu lub przełączony w tryb zapisu i następnie zakończył działanie z niego.  
  
> [!NOTE]
>  Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie do odczytu można wprowadzić rekursywnie w trybie do odczytu, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
 Co najwyżej jeden wątek może być w trybie możliwej, podczas gdy inne wątki są w trybie do odczytu. Jeśli dodatkowe wątków oczekujących do trybu możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, wątki tego wywołania <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metoda natychmiast wprowadź trybie do odczytu i nie blokują.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodę, aby wprowadzić blokady w trybie do odczytu. Pokazano w przykładzie metoda pobiera wartość skojarzoną z kluczem. Jeśli klucz nie zostanie znaleziony, wyjątku zgłoszonego przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metody. A `finally` blok służy do wykonywania <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> metody, zapewniając, że obiekt wywołujący kończy pracę w trybie do odczytu.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Bieżący wątek nie może uzyskać blokady zapisu, gdy posiada blokady odczytu.  - lub - <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> właściwość jest <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, a bieżący wątek próbował uzyskać blokady odczytu, gdy już utrzymuje blokady odczytu.  - lub - <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> właściwość jest <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, a bieżący wątek próbował uzyskać blokady odczytu, gdy już utrzymuje blokadę zapisu.  - lub - numer rekursji przekracza pojemność licznika. Ten limit jest tak duża, że aplikacje nigdy nie powinni napotkać tego wyjątku.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Próbuje wpisz blokady w trybie możliwej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten bloki metody aż wątek wywołujący wprowadza blokady, a w związku z tym może nigdy nie zwraca. Użyj <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metodę, aby zablokować dla określonego interwału, a następnie wróć, jeśli wątek wywołujący nie przeszedł w tryb możliwej tego interwału.  
  
 Użyj trybu możliwej gdy wątek zwykle uzyska dostęp do zasobu, która jest chroniona przez <xref:System.Threading.ReaderWriterLockSlim> w trybie do odczytu, ale może być konieczne podanie trybie zapisu, jeśli są spełnione następujące warunki. Wątek w trybie możliwej można obniżyć trybu odczytu lub uaktualnienia do zapisu w trybie.  
  
 Tylko jeden wątek można wprowadzić tryb możliwej w danym momencie. Jeśli wątek jest w trybie możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, dowolna liczba innych wątków można wprowadzić trybie do odczytu, nawet jeśli istnieją wątków oczekujących do trybu możliwej.  
  
 Jeśli jeden lub więcej wątków oczekujących na tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> bloki metody do momentu mieć tych wątków upłynął limit czasu lub przełączony w tryb zapisu i następnie zakończył działanie z niego.  
  
> [!NOTE]
>  Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie możliwej wprowadzić rekursywnie możliwej tryb, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby wprowadzić w trybie możliwej blokady. A `finally` blok służy do wykonywania <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> metody zapewnienie, że obiekt wywołujący opuszcza tryb możliwej.  
  
 Pokazano w przykładzie metoda pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością. Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian. Go nie jest znaleziono wartości dla klucza, jest wstawiany parę klucza i wartości. Jeśli wartość została zmieniona, jest aktualizowana. Tryb możliwej umożliwia wątku do uaktualnienia blokady odczytu bez ryzyko zakleszczenia.  
  
 W przykładzie użyto domyślnego konstruktora do utworzenia blokady, więc rekursji jest niedozwolone. Programowanie <xref:System.Threading.ReaderWriterLockSlim> jest prostsza i mniej podatne na błędy podczas blokady nie zezwala na rekursji.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek został już wprowadzony blokady w dowolnym trybie.  - lub - bieżący wątek wszedł w trybie do odczytu, więc próby przejścia w tryb możliwej spowodowałoby utworzenie możliwości zakleszczenie.  - lub - numer rekursji przekracza pojemność licznika. Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Próbuje wpisz blokady w trybie zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten bloki metody aż wątek wywołujący wprowadza blokady, a w związku z tym może nigdy nie zwraca. Użyj <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodę, aby zablokować dla określonego interwału, a następnie wróć, jeśli wątek wywołujący nie przeszedł w trybie zapisu podczas tego interwału.  
  
 Jeśli inne wątki zostały wprowadzone blokady w trybie do odczytu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> bloki metody do momentu zamknięciu tych wątków trybu odczytu. W przypadku wątków oczekujących do trybu zapisu dodatkowe wątki wprowadzona trybie do odczytu lub tryb możliwej bloku, dopóki wszystkie wątki oczekujące na tryb zapisu mieć upłynął limit czasu lub przełączony w tryb zapisu i następnie zakończył działanie z niego.  
  
> [!NOTE]
>  Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie zapisu można wprowadzić rekursywnie tryb zapisu, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metodę, aby wprowadzić blokady w trybie zapisu. Metoda pokazano w przykładzie dodaje nową parę klucz wartość do pamięci podręcznej zsynchronizowane. Jeśli klucz jest już w pamięci podręcznej, wyjątku zgłoszonego przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metody. A `finally` blok służy do wykonywania <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> metody zapewnienie, że obiekt wywołujący kończy działanie w trybie zapisu.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek został już wprowadzony blokady w dowolnym trybie.  - lub - bieżący wątek wszedł w trybie do odczytu, więc próby wprowadź blokady w trybie zapisu spowoduje utworzenie możliwość zakleszczenia.  - lub - numer rekursji przekracza pojemność licznika. Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę rekursji w trybie odczytu i kończy działanie trybie do odczytu, jeśli wynikowa liczba 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest wrażliwe na kolejność rekursji. Na przykład jeśli wątek wprowadza blokady w trybie możliwej, a następnie wprowadzi blokady w trybie do odczytu, kolejność, w którym kończy działanie wątku dwa tryby nie ma znaczenia. Jeśli blokady umożliwia rekursji, Wątek można wprowadzić w trybie blokady, a następnie wprowadzić rekursywnie w trybie do odczytu; kolejność, w którym kończy działanie wątku trybu odczytu i zapisu trybu nie ma znaczenia.  
  
 Kończenie blokady może sygnalizować innych wątków oczekujących.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `finally` bloku do wykonania <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> metody, zapewniając, że obiekt wywołujący kończy pracę w trybie do odczytu. Pokazano w przykładzie metoda pobiera wartość skojarzoną z kluczem. Jeśli klucz nie zostanie znaleziony, wyjątku zgłoszonego przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metody. <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> Metoda służy do wprowadzania trybie do odczytu.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie została wprowadzona blokady w trybie do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę rekursji dla trybu możliwej i zamyka tryb możliwej, jeśli wynikowa liczba 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest wrażliwe na kolejność rekursji. Na przykład jeśli wątek wprowadza blokady w trybie możliwej, a następnie wprowadzi blokady w trybie zapisu, kolejność, w którym kończy działanie wątku dwa tryby nie ma znaczenia. Jeśli blokady umożliwia rekursji, Wątek można wprowadzić w trybie blokady, a następnie wprowadzić rekursywnie w trybie możliwej; kolejność, w którym kończy działanie wątku możliwej tryb trybu i zapisu nie ma znaczenia.  
  
 Kończenie blokady może sygnalizować innych wątków oczekujących.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `finally` bloku do wykonania <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> metody zapewnienie, że obiekt wywołujący opuszcza tryb możliwej.  
  
 Pokazano w przykładzie metoda pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością. Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian. Go nie jest znaleziono wartości dla klucza, jest wstawiany parę klucza i wartości. Jeśli wartość została zmieniona, jest aktualizowana. Tryb możliwej umożliwia wątku do uaktualnienia blokady odczytu bez ryzyko zakleszczenia.  
  
 W przykładzie użyto domyślnego konstruktora do utworzenia blokady, więc rekursji jest niedozwolone. Programowanie <xref:System.Threading.ReaderWriterLockSlim> jest prostsza i mniej podatne na błędy podczas blokady nie zezwala na rekursji.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie została wprowadzona blokady w trybie możliwej.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę rekursji dla trybu zapisu i zamyka tryb zapisu, jeśli wynikowa liczba 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest wrażliwe na kolejność rekursji. Na przykład jeśli wątek wprowadza blokady w trybie możliwej, a następnie wprowadzi blokady w trybie zapisu, kolejność, w którym kończy działanie wątku dwa tryby nie ma znaczenia. Jeśli blokady umożliwia rekursji, Wątek można wprowadzić w trybie blokady, a następnie wprowadzić rekursywnie w trybie do odczytu; kolejność, w którym kończy działanie wątku trybu odczytu i zapisu trybu nie ma znaczenia.  
  
 Kończenie blokady może sygnalizować innych wątków oczekujących.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `finally` bloku do wykonania <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> metody zapewnienie, że obiekt wywołujący kończy działanie w trybie zapisu. Metoda pokazano w przykładzie dodaje nową parę klucz wartość do pamięci podręcznej zsynchronizowane. Jeśli klucz jest już w pamięci podręcznej, wyjątku zgłoszonego przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metody. <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> Metoda służy do wprowadzania blokady w trybie zapisu.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie została wprowadzona blokady w trybie zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek wszedł blokady w trybie do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący wątek wszedł w tryb; odczytu w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do użycia w deklaracji rozkazujących lub do innych celów debugowania. Nie jest używana do sterowania przepływem wykonywania programu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> właściwość, aby wygenerować assert, jeśli bieżący wątek wszedł trybu odczytu nieoczekiwane.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek wszedł blokady w trybie możliwej.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący wątek został przełączony w tryb możliwej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do użycia w deklaracji rozkazujących lub do innych celów debugowania. Nie jest używana do sterowania przepływem wykonywania programu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> właściwość, aby wygenerować assert, jeśli bieżący wątek wszedł w tryb możliwej nieoczekiwanie.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek wszedł blokady w trybie zapisu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący wątek został przełączony w tryb zapisu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do użycia w deklaracji rozkazujących lub do innych celów debugowania. Nie jest używana do sterowania przepływem wykonywania programu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> właściwość, aby wygenerować assert, jeśli bieżący wątek wszedł w tryb zapisu nieoczekiwanie.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą zasad rekursji dla bieżącego <see cref="T:System.Threading.ReaderWriterLockSlim" /> obiektu.</summary>
        <value>Jedna z wartości wyliczenia, które określa zasady blokowania rekursji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasada rekursji określa ograniczenia dotyczące wątków, które wprowadź blokady więcej niż raz. Na przykład, jeśli utworzono blokady <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> i Wątek wszedł blokady w trybie do odczytu, <xref:System.Threading.LockRecursionException> jest generowany, jeśli wątek spróbuje ponownie blokady w trybie do odczytu.  
  
> [!NOTE]
>  Wątek w trybie możliwej można uaktualnić do zapisu w trybie lub starszą wersję trybu bez względu na ustawienie zasad rekursji blokady odczytu.  
  
 Niezależnie od zasady rekursji wątku, który początkowo wprowadzona odczytać tryb nie jest dozwolone do uaktualnienia do trybu możliwej lub zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia.  
  
 Aby uzyskać więcej informacji o zasadach rekursji i jej wpływ, zobacz <xref:System.Threading.LockRecursionPolicy> wyliczenie i <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę razy bieżący wątek wszedł blokady w trybie do odczytu, jako wskazanie rekursji.</summary>
        <value>0 (zero), jeśli bieżący wątek nie przeszedł w tryb odczytu, 1, jeśli wątek został przełączony w tryb odczytu, ale nie został wprowadzony rekursywnie, lub * n * Jeśli wątek wszedł rekursywnie blokady * n * - 1 godziny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu. Wyniki można zmienić, jak zostały obliczone. W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę razy bieżący wątek wszedł blokady w trybie możliwej jako wskazanie rekursji.</summary>
        <value>0, jeśli bieżący wątek nie został przełączony w tryb możliwej, 1, jeśli wątek został przełączony w tryb możliwej, ale nie weszła jej rekursywnie, lub * n * Jeśli wątek został przełączony w tryb możliwej rekursywnie * n * - 1 godziny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu. Wyniki można zmienić, jak zostały obliczone. W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę razy bieżący wątek wszedł blokady w trybie zapisu jako wskazanie rekursji.</summary>
        <value>0, jeśli bieżący wątek nie przeszedł w tryb zapisu, 1, jeśli wątek został przełączony w tryb zapisu, ale nie został wprowadzony rekursywnie, lub * n * Jeśli wątek wszedł rekursywnie trybie zapisu * n * - 1 godziny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu. Wyniki można zmienić, jak zostały obliczone. W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje wprowadzić w trybie odczytu z opcjonalne limitu czasu blokady.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub wartość -1 (<see cref="F:System.Threading.Timeout.Infinite" />) będzie czekać w nieskończoność.</param>
        <summary>Próbuje wprowadź blokady w trybie odczytu z limitem czasu opcjonalna liczba całkowita.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący wprowadzone do odczytu, tryb, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Wiele wątków można wprowadzić trybie do odczytu, w tym samym czasie.  
  
 Jeśli jeden lub więcej wątków oczekujących na tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metody blokuje tych wątków albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niej, lub do chwili osiągnięcia limitu czasu własnym wątku wywołującym.  
  
> [!NOTE]
>  Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie do odczytu można wprowadzić rekursywnie w trybie do odczytu, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
 Jeden wątek może być w trybie możliwej, podczas gdy inne wątki są w trybie do odczytu. Jeśli dodatkowe wątków oczekujących do trybu możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, wątki tego wywołania <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metoda natychmiast wprowadź trybie do odczytu i nie blokują.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek został już wprowadzony blokady.  - lub - numer rekursji przekracza pojemność licznika. Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (-1), która jest jedyną dozwoloną wartość ujemną.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał oczekiwania, lub wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Próbuje wprowadzić w trybie odczytu z opcjonalne limitu czasu blokady.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący wprowadzone do odczytu, tryb, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Wiele wątków można wprowadzić blokady w trybie do odczytu, w tym samym czasie.  
  
 Jeden lub więcej wątków są umieszczane w kolejce do trybu zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metody blokuje tych wątków albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niej, lub do chwili osiągnięcia limitu czasu własnym wątku wywołującym.  
  
> [!NOTE]
>  Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie do odczytu można wprowadzić rekursywnie w trybie do odczytu, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
 Jeden wątek może być w trybie możliwej, podczas gdy inne wątki są w trybie do odczytu. Jeśli dodatkowe wątków oczekujących do trybu możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, wątki tego wywołania <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metoda natychmiast wprowadź trybie do odczytu i nie blokują.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek został już wprowadzony blokady.  - lub - numer rekursji przekracza pojemność licznika. Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartość ujemną.  - lub - wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje wprowadzić w trybie możliwej z opcjonalne limitu czasu blokady.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub wartość -1 (<see cref="F:System.Threading.Timeout.Infinite" />) będzie czekać w nieskończoność.</param>
        <summary>Próbuje wprowadzić w trybie możliwej z opcjonalne limitu czasu blokady.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący przełączony w tryb możliwej, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Użyj trybu możliwej gdy wątek zwykle uzyska dostęp do zasobu, która jest chroniona przez <xref:System.Threading.ReaderWriterLockSlim> w trybie do odczytu, ale może być konieczne podanie trybie zapisu, jeśli są spełnione następujące warunki. Wątek w trybie możliwej można uaktualnić do zapisu w trybie lub starszą wersję trybu odczytu.  
  
 Tylko jeden wątek można wprowadzić w trybie możliwej blokady w danym momencie. Jeśli wątek jest w trybie możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, dowolna liczba innych wątków można wprowadzić trybie do odczytu, nawet jeśli istnieją wątków oczekujących do trybu możliwej.  
  
 Jeśli jeden lub więcej wątków oczekujących na tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metody blokuje tych wątków albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niej, lub do chwili osiągnięcia limitu czasu własnym wątku wywołującym.  
  
> [!NOTE]
>  Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie możliwej wprowadzić rekursywnie możliwej tryb, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek został już wprowadzony blokady.  - lub - bieżący wątek początkowo wprowadzić blokady w trybie odczytu i w związku z tym próby przejścia w tryb możliwej spowodowałoby utworzenie możliwość zakleszczenia.  - lub - numer rekursji przekracza pojemność licznika. Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (-1), która jest jedyną dozwoloną wartość ujemną.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał oczekiwania, lub wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Próbuje wprowadzić w trybie możliwej z opcjonalne limitu czasu blokady.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący przełączony w tryb możliwej, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Użyj trybu możliwej gdy wątek zwykle dostęp do zasobów chronionych przez <xref:System.Threading.ReaderWriterLockSlim> w trybie do odczytu, ale może być konieczne podanie trybie zapisu, jeśli są spełnione następujące warunki. Wątek w trybie możliwej można uaktualnić do zapisu w trybie lub starszą wersję trybu odczytu.  
  
 Tylko jeden wątek można wprowadzić w trybie możliwej blokady w danym momencie. Jeśli wątek jest w trybie możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, dowolna liczba innych wątków można wprowadzić trybie do odczytu, nawet jeśli istnieją wątków oczekujących do trybu możliwej.  
  
 Jeśli jeden lub więcej wątków oczekujących na tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metody blokuje tych wątków albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niej, lub do chwili osiągnięcia limitu czasu własnym wątku wywołującym.  
  
> [!NOTE]
>  Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie możliwej wprowadzić rekursywnie możliwej tryb, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek został już wprowadzony blokady.  - lub - bieżący wątek początkowo wprowadzić blokady w trybie odczytu i w związku z tym próby przejścia w tryb możliwej spowodowałoby utworzenie możliwość zakleszczenia.  - lub - numer rekursji przekracza pojemność licznika. Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartość ujemną.  - lub - wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje wprowadzić w trybie zapisu z opcjonalne limitu czasu blokady.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub wartość -1 (<see cref="F:System.Threading.Timeout.Infinite" />) będzie czekać w nieskończoność.</param>
        <summary>Próbuje wprowadzić w trybie zapisu z opcjonalne limitu czasu blokady.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący przełączony w tryb zapisu, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` jest 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Jeśli inne wątki zostały wprowadzone blokady w trybie do odczytu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> blokuje metody do momentu tych wątków zamknięciu trybie do odczytu lub upłynął limit czasu. Podczas wątki są zablokowane, oczekiwanie na tryb zapisu, dodatkowe wątki wprowadzona w trybie odczytu lub możliwej bloku, dopóki wszystkie wątki oczekujące na Wprowadź tryb zapisu albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niego.  
  
> [!NOTE]
>  Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie zapisu można wprowadzić rekursywnie tryb zapisu, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodę, aby wprowadzić w trybie zapisu z limit czasu blokady. Metoda pokazano w przykładzie dodaje nową parę klucz wartość do pamięci podręcznej zsynchronizowane. Jeśli określony limit czasu musi upłynąć, zanim wątek wprowadza blokady, metoda zwraca `false`. Metoda zwraca `true` Jeśli para klucza i wartości zostanie dodany.  
  
 Jeśli klucz jest już w pamięci podręcznej, wyjątku zgłoszonego przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> może zakończyć metody. A `finally` blok służy do wykonywania <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> metody zapewnienie, że obiekt wywołujący opuszcza blokady.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek został już wprowadzony blokady.  - lub - bieżący wątek początkowo wprowadzić blokady w trybie odczytu i w związku z tym próby przejścia w tryb zapisu spowoduje utworzenie możliwość zakleszczenia.  - lub - numer rekursji przekracza pojemność licznika. Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (-1), która jest jedyną dozwoloną wartość ujemną.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał oczekiwania, lub wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Próbuje wprowadzić w trybie zapisu z opcjonalne limitu czasu blokady.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący przełączony w tryb zapisu, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` jest 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Jeśli inne wątki zostały wprowadzone blokady w trybie do odczytu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> blokuje metody do momentu tych wątków zamknięciu trybie do odczytu lub upłynął limit czasu. Podczas wątki są zablokowane, oczekiwanie na tryb zapisu, dodatkowe wątki wprowadzona w trybie odczytu lub możliwej bloku, dopóki wszystkie wątki oczekujące na Wprowadź tryb zapisu albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niego.  
  
> [!NOTE]
>  Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie zapisu można wprowadzić rekursywnie tryb zapisu, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość jest <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek został już wprowadzony blokady.  - lub - bieżący wątek początkowo wprowadzić blokady w trybie odczytu i w związku z tym próby przejścia w tryb zapisu spowoduje utworzenie możliwość zakleszczenia.  - lub - numer rekursji przekracza pojemność licznika. Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartość ujemną.  - lub - wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączna liczba wątków, które oczekują na wprowadzanie blokady w trybie do odczytu.</summary>
        <value>Całkowita liczba wątków, które oczekują na wprowadzanie trybie do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu. Wyniki można zmienić, jak zostały obliczone. W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> Generuj wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, oczekiwanie na tryb odczytu przekracza próg dla właściwości.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę wątków, które oczekują na wprowadzanie blokady w trybie możliwej.</summary>
        <value>Całkowita liczba wątków, które oczekują na tryb możliwej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu. Wyniki można zmienić, jak zostały obliczone. W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> Generuj wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, oczekiwanie na tryb możliwej przekracza próg dla właściwości.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączna liczba wątków, które oczekują na wprowadzanie blokady w trybie zapisu.</summary>
        <value>Całkowita liczba wątków, które oczekują na tryb zapisu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu. Wyniki można zmienić, jak zostały obliczone. W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> Generuj wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, oczekiwanie na tryb zapisu przekracza próg dla właściwości.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
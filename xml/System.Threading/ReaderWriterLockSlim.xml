<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ReaderWriterLockSlim.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52ff770bb9446d6ebe71649784ebe115f60734cc0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2ff770bb9446d6ebe71649784ebe115f60734cc0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</source>
          <target state="translated">Reprezentuje blokady, która jest używana do zarządzania dostęp do zasobów, dzięki czemu wiele wątków do odczytu lub wyłącznego dostępu do zapisu.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> to protect a resource that is read by multiple threads and written to by one thread at a time.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> ochrony z zasobem, który jest odczytywany przez wiele wątków i zapisana przez jeden wątek na raz.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> zezwala na wiele wątków w trybie do odczytu, umożliwia jeden wątek, aby być w trybie wyłączności na własność blokady zapisu i pozwala jeden wątek, który ma dostęp do odczytu w trybie możliwej do odczytu, w którym Wątek można uaktualnić do zapisu tryb bez konieczności zrzeka się on s dostęp do odczytu do zasobu.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> przypomina <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, ale jest prostszy zasady rekursji oraz uaktualniania i zmiany na starszą wersję stan blokady.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> avoids many cases of potential deadlock.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> pozwala uniknąć wielu przypadkach potencjalnych zakleszczenia.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>In addition, the performance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is significantly better than <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Ponadto wydajność <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> jest znacznie lepszą niż <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is recommended for all new development.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> jest zalecana dla wszystkich nowych wdrożeń.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>By default, new instances of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> are created with the <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> flag and do not allow recursion.</source>
          <target state="translated">Domyślnie nowe wystąpienia klasy <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> są tworzone za pomocą <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> Flaga i nie pozwalają rekursji.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</source>
          <target state="translated">Zasada domyślna jest zalecane dla wszystkich nowych aplikacji, ponieważ rekursji wprowadzono niepotrzebnych komplikacji i sprawia, że kod jest bardziej podatne na zakleszczenie.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To simplify migration from existing projects that use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, you can use the <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> flag to create instances of <ph id="ph4">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allow recursion.</source>
          <target state="translated">W celu uproszczenia migracji z istniejących projektów używające <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> lub <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, można użyć <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> flagę w celu utworzenia wystąpienia <ph id="ph4">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> umożliwiające rekursji.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</source>
          <target state="translated">Wątek można wprowadzić blokady w trzech trybów: tryb, w trybie zapisu i trybie możliwej do odczytu do odczytu.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter <ph id="ph1">`x`</ph> mode" is used in preference to the longer phrase "enter the lock in <ph id="ph2">`x`</ph> mode".)</source>
          <target state="translated">(W pozostałej części tego tematu, "Tryb odczytu możliwej" nazywa się "Tryb możliwej" i frazę "Wprowadź <ph id="ph1">`x`</ph> tryb" jest używana zamiast dłużej frazy "Wprowadź blokady w <ph id="ph2">`x`</ph> tryb".)</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Regardless of recursion policy, only one thread can be in write mode at any time.</source>
          <target state="translated">Niezależnie od zasady rekursji tylko jeden wątek może być w trybie zapisu w dowolnym momencie.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When a thread is in write mode, no other thread can enter the lock in any mode.</source>
          <target state="translated">Gdy wątek jest w trybie zapisu, nie inne wątku można wprowadzić blokady w dowolnym trybie.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Only one thread can be in upgradeable mode at any time.</source>
          <target state="translated">Tylko jeden wątek może być w trybie możliwej w dowolnym momencie.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Dowolnej liczby wątków może być w trybie do odczytu i może być jeden wątek w trybie możliwej podczas gdy inne wątki są w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Ten typ implementuje <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Do usuwania tego typu, należy wywołać jej <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> metody w <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloku.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak <ph id="ph1">`using`</ph> (w języku C#) lub <ph id="ph2">`Using`</ph> (w języku Visual Basic).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfejsu tematu.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> has managed thread affinity; that is, each <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> object must make its own method calls to enter and exit lock modes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> zarządza koligacji wątku; oznacza to, że każdy <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> obiektu należy własną wywołania metody i wyjścia tryby blokady.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>No thread can change the mode of another thread.</source>
          <target state="translated">Wątek nie można zmienić trybu inny wątek.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> nie zezwala na rekursji, wątek, aby zablokować próbuje wpisz blokady z kilku powodów:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</source>
          <target state="translated">Wątek, który próbuje wpisz bloków w trybie do odczytu, jeśli istnieją wątków oczekujących wprowadzić w trybie zapisu lub jeśli w trybie zapisu jest pojedynczym wątku.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Blocking new readers when writers are queued is a lock fairness policy that favors writers.</source>
          <target state="translated">Blokowanie nowych czytników podczas zapisywania są umieszczane w kolejce są to zasady sprawiedliwe przydzielanie zasobów blokady, które ma autorów.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</source>
          <target state="translated">Bieżące zasady sprawiedliwe przydzielanie zasobów równoważy sprawiedliwe przydzielanie zasobów dla czytników i zapisywania, aby podwyższyć poziom przepływności w najbardziej typowych scenariuszy.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Future versions of the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> may introduce new fairness policies.</source>
          <target state="translated">Kolejne wersje <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> mogą wprowadzać nowe zasady sprawiedliwe przydzielanie zasobów.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</source>
          <target state="translated">Wątek próbował wpisać bloków w trybie możliwej, jeśli istnieje już wątku w trybie możliwej, jeśli istnieją wątków oczekujących do trybu zapisu lub w trybie zapisu jest pojedynczym wątku.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</source>
          <target state="translated">Wątek, który próbuje wpisz bloki tryb zapisu, jeśli jest wątku w jednym z trzech trybów.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrading and Downgrading Locks</source>
          <target state="translated">Trwa uaktualnianie i zmiany na starszą wersję blokuje</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</source>
          <target state="translated">Tryb możliwej jest przeznaczony dla przypadków, w którym wątek zwykle odczytuje z chronionych zasobów, ale może być konieczne zapisanie w nim Jeśli niektóre warunki są spełnione.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that has entered a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> methods.</source>
          <target state="translated">Wątek wszedł <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> w trybie możliwej ma dostęp do odczytu do chronionych zasobów i przeprowadzić uaktualnienie do zapisu tryb wywołując <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> lub <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</source>
          <target state="translated">Ponieważ może istnieć tylko jeden wątek w trybie możliwej w czasie, uaktualnienie do zapisu trybu nie zakleszczenie rekursji jest niedozwolony, która jest domyślne zasady.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Niezależnie od zasady rekursji wątku, który początkowo wprowadzona odczytać tryb nie jest dozwolone do uaktualnienia do trybu możliwej lub zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For example, if two threads in read mode both try to enter write mode, they will deadlock.</source>
          <target state="translated">Na przykład jeśli dwa wątki w trybie odczytu, który zarówno spróbuj wprowadzić tryb zapisu, ich będzie zakleszczenie.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode is designed to avoid such deadlocks.</source>
          <target state="translated">Tryb możliwej zaprojektowano w celu uniknięcia takiej zakleszczenie.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If there are other threads in read mode, the thread that is upgrading blocks.</source>
          <target state="translated">Jeśli istnieją inne wątki w trybie do odczytu, wątku, który jest uaktualnienie bloków.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>While the thread is blocked, other threads that try to enter read mode are blocked.</source>
          <target state="translated">Gdy wątek jest zablokowany lub innych wątków, które wprowadzona w trybie do odczytu są zablokowane.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</source>
          <target state="translated">Po zamknięciu wszystkich wątków w trybie do odczytu, zablokowanych wątków możliwej przechodzi trybie zapisu.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</source>
          <target state="translated">Jeśli istnieją inne wątki oczekujące na wprowadź zapisu tryb, pozostają zablokowane, ponieważ jeden wątek, który jest w trybie możliwej zapobiega ich uzyskania wyłącznego dostępu do zasobu.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</source>
          <target state="translated">Innych wątków, które oczekują na wprowadzanie trybie do odczytu w wątku w trybie możliwej opuszcza tryb zapisu, należy tak, chyba że wątków oczekujących na Wprowadź tryb zapisu.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</source>
          <target state="translated">Wątek w trybie możliwej można uaktualnić i obniżyć przez czas nieokreślony, tak długo, jak to tylko wątku, który zapisuje do chronionego zasobu.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</source>
          <target state="translated">Jeśli zezwolisz na używanie wielu wątków wprowadzić zapisu trybu lub możliwej, nie może dopuszczać jeden wątek, aby zająć całych możliwej tryb.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</source>
          <target state="translated">W przeciwnym razie wątków, które próbują wprowadź zapisu tryb bezpośrednio będą blokowane przez nieograniczony czas i gdy są one blokowane, inne wątki nie będzie można wprowadzić w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in upgradeable mode can downgrade to read mode by first calling the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method and then calling the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method.</source>
          <target state="translated">Wątek w trybie możliwej mogłoby obniżyć poziom trybu odczytu przy pierwszym wywołaniu <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> — metoda i wywołując <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This downgrade pattern is allowed for all lock recursion policies, even <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>.</source>
          <target state="translated">Ten wzorzec obniżenia poziomu jest dozwolony dla wszystkich zasad rekursji blokady, nawet <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</source>
          <target state="translated">Po zmiany na starszą wersję trybu odczytu, wątku nie można ponownie tryb możliwej do momentu zakończył się w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Entering the Lock Recursively</source>
          <target state="translated">Wprowadzanie rekursywnie blokady</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that supports recursive lock entry by using the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph> constructor that specifies lock policy, and specifying <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Można utworzyć <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> obsługującej cykliczne blokady zapisu przy użyciu <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph> Konstruktor, który określa zasady blokowania i określając <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</source>
          <target state="translated">Rekursji nie jest zalecane dla nowych aplikacji, ponieważ wprowadza niepotrzebnych komplikacji i sprawia, że kod jest bardziej podatne na zakleszczenie.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allows recursion, the following can be said about the modes a thread can enter:</source>
          <target state="translated">Aby uzyskać <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> umożliwiająca rekursji, następujące powiedzieć, temat trybów wątku można wprowadzić:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</source>
          <target state="translated">Wątek w trybie do odczytu można wprowadzić rekursywnie w trybie do odczytu, ale nie można wprowadzić w trybie zapisu lub możliwej.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If it tries to do this, a <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown.</source>
          <target state="translated">Jeśli spróbuje to zrobić, <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</source>
          <target state="translated">Wprowadzenie do odczytu tryb zapisu w trybie, a następnie wpisując lub tryb możliwej jest wzorca zawierającego silne prawdopodobieństwo zakleszczenia, przez co nie jest dozwolone.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</source>
          <target state="translated">Jak już wspomniano, tryb możliwej jest dostępna dla przypadkach, gdy jest niezbędne do uaktualnienia blokady.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</source>
          <target state="translated">Wątek w trybie możliwej można wprowadzić w trybie zapisu i/lub w trybie odczytu i wprowadzić żadnego z trzech trybów rekursywnie.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>However, an attempt to enter write mode blocks if there are other threads in read mode.</source>
          <target state="translated">Jednak próba wprowadź zapisu bloków w trybie Jeśli istnieją inne wątki w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</source>
          <target state="translated">Wątek w trybie zapisu można wprowadzić w trybie odczytu i/lub tryb możliwej i wprowadzić żadnego z trzech trybów rekursywnie.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that has not entered the lock can enter any mode.</source>
          <target state="translated">Wątek, który nie przeszedł blokady można wprowadzić dowolny tryb.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</source>
          <target state="translated">Ta próba może zablokować z tego samego powodu, próba Podaj niecyklicznego blokady.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</source>
          <target state="translated">Wątek może wyjść tryby, wprowadzona w dowolnej kolejności, tak długo, jak kończy działanie każdej tryb dokładnie dowolną liczbę razy, ile pojawił się trybie.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> is thrown.</source>
          <target state="translated">Jeśli spróbuje wątek, aby wyjść z trybu zbyt wiele razy lub aby wyjść z trybu nie została wprowadzona, <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Lock States</source>
          <target state="translated">Stany blokady</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>You may find it useful to think of the lock in terms of its states.</source>
          <target state="translated">Mogą być przydatne Rozważmy blokady względem jego stanów.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> can be in one of four states: not entered, read, upgrade, and write.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> może znajdować się w jednej z czterech stanów: zostały wprowadzone, należy przeczytać, uaktualniania i zapisu.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</source>
          <target state="translated">Nie wprowadzono: W tym stanie nie wątków zostały wprowadzone blokady (lub wszystkie wątki zamknięciu blokady).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Read: In this state, one or more threads have entered the lock for read access to the protected resource.</source>
          <target state="translated">Przeczytaj: W tym stanie, co najmniej jeden wątek wprowadzony blokady dla dostępu do odczytu do chronionego zasobu.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can enter the lock in read mode by using the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> methods, or by downgrading from upgradeable mode.</source>
          <target state="translated">Wątek można wprowadzić blokady w trybie do odczytu za pomocą <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> metody, lub zmiany na starszą wersję z trybu możliwej.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</source>
          <target state="translated">Uaktualnianie: W tym stanie jeden wątek wszedł blokady dla dostępu do odczytu z możliwością uaktualnienia do zapisu (to znaczy w możliwej tryb), oraz zero lub więcej wątków wprowadzony blokady dla dostępu do odczytu.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</source>
          <target state="translated">Nie więcej niż jeden wątek na raz można wprowadzić blokady przy użyciu z opcji uaktualnienia; Spróbuj przejść do trybu możliwej dodatkowe wątki są zablokowane.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Write: In this state, one thread has entered the lock for write access to the protected resource.</source>
          <target state="translated">Zapisu: W tym stanie jeden wątek wszedł blokady dla dostęp do zapisu do chronionego zasobu.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>That thread has exclusive possession of the lock.</source>
          <target state="translated">Wątek jest posiadanie wyłącznej blokady.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Any other thread that tries to enter the lock for any reason is blocked.</source>
          <target state="translated">Innego wątku, który próbuje wprowadź blokady jakiegokolwiek powodu została zablokowana.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread <ph id="ph1">`t`</ph> takes the action described in the leftmost column.</source>
          <target state="translated">W poniższej tabeli opisano przejścia między Stanami blokady, blokad, które nie zezwalają na rekursji, gdy wątek <ph id="ph1">`t`</ph> podejmuje działania opisane w lewej kolumnie.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>At the time it takes the action, <ph id="ph1">`t`</ph> has no mode.</source>
          <target state="translated">W tym czasie zajmuje akcji, <ph id="ph1">`t`</ph> nie trybem.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(The special case where <ph id="ph1">`t`</ph> is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</source>
          <target state="translated">(Szczególnych przypadkach gdy <ph id="ph1">`t`</ph> jest w trybie możliwej jest opisany w przypisach tabeli.) Pierwszy wiersz zawiera opis początkowy stan blokady.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The cells describe what happens to the thread, and show changes to the lock state in parentheses.</source>
          <target state="translated">Komórki opisano, co się dzieje z wątku i wyświetlać zmiany stanu blokady w nawiasach.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Not entered (N)</source>
          <target state="translated">Nie podano (N)</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Read (R)</source>
          <target state="translated">Read (R)</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrade (U)</source>
          <target state="translated">Uaktualnienie (U)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Write (W)</source>
          <target state="translated">Zapisu (W)</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters read mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> wprowadza trybie do odczytu</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (R).</source>
          <target state="translated"><ph id="ph1">`t`</ph> wprowadza (R).</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id="ph2">`t`</ph> enters.</source>
          <target state="translated"><ph id="ph1">`t`</ph> bloki Jeśli wątków oczekuje na tryb zapisu; w przeciwnym razie <ph id="ph2">`t`</ph> wejścia.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id="ph2">`t`</ph> enters.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
          <target state="translated"><ph id="ph1">`t`</ph> bloki Jeśli wątków oczekuje na tryb zapisu; w przeciwnym razie <ph id="ph2">`t`</ph> wprowadza.<bpt id="p1">&lt;sup&gt;</bpt> 1<ept id="p1">&lt;/sup&gt;</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> bloki.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters upgradeable mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> Przechodzi do trybu możliwej</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (U).</source>
          <target state="translated"><ph id="ph1">`t`</ph> wprowadza (U).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode or upgrade mode; otherwise, <ph id="ph2">`t`</ph> enters (U).</source>
          <target state="translated"><ph id="ph1">`t`</ph> bloki Jeśli wątków oczekuje na zapis trybu lub uaktualnienia; w przeciwnym razie <ph id="ph2">`t`</ph> wejścia (U).</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> bloki.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> bloki.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters write mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> Przechodzi do trybu zapisu</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (W).</source>
          <target state="translated"><ph id="ph1">`t`</ph> wprowadza (M).</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> bloki.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept></source>
          <target state="translated"><ph id="ph1">`t`</ph> bloki. <bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept></target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> bloki.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept> If <ph id="ph1">`t`</ph> starts out in upgradeable mode, it enters read mode.</source>
          <target state="translated"><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept> Jeśli <ph id="ph1">`t`</ph> uruchamia się w trybie możliwej, wejdzie ona trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This action never blocks.</source>
          <target state="translated">Ta akcja nie blokuje.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The lock state does not change.</source>
          <target state="translated">Stan blokady nie ulega zmianie.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</source>
          <target state="translated">(Wątku mogą zakończyć obniżania trybu odczytu podczas zamykania możliwej tryb).</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> If <ph id="ph1">`t`</ph> starts out in upgradeable mode, it blocks if there are threads in read mode.</source>
          <target state="translated"><bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> Jeśli <ph id="ph1">`t`</ph> zostanie uruchomiony w trybie możliwej, blokuje w przypadku wątków w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Otherwise it upgrades to write mode.</source>
          <target state="translated">W przeciwnym razie uaktualnia trybie zapisu.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The lock state changes to Write (W).</source>
          <target state="translated">Zmiany stanu blokady zapisu (W).</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If <ph id="ph1">`t`</ph> blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</source>
          <target state="translated">Jeśli <ph id="ph1">`t`</ph> blokuje, ponieważ istnieją wątki w trybie do odczytu, wejdzie ona trybie zapisu, jak ostatni wątek kończy pracę w trybie do odczytu, nawet jeśli istnieją wątków oczekujących na wprowadź zapis tryb.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</source>
          <target state="translated">Po zmianie stanu ponieważ blokada kończy działanie wątku, na wznowione następnym wątku jest wybrane w następujący sposób:</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</source>
          <target state="translated">Najpierw wątku, który oczekuje na tryb zapisu i jest już w trybie możliwej (może mieć co najwyżej jeden taki wątek).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, a thread that is waiting for write mode.</source>
          <target state="translated">Awarii, który wątku, który oczekuje na trybie zapisu.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, a thread that is waiting for upgradeable mode.</source>
          <target state="translated">Który wątku, który oczekuje na tryb możliwej awarii.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, all threads that are waiting for read mode.</source>
          <target state="translated">Awarii, wszystkie wątki, które czekają w trybie odczytu.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</source>
          <target state="translated">Kolejne stan blokady jest zawsze zapisu (W) w pierwszym przypadków i uaktualnienia (U) w przypadku trzeciej, bez względu na stan blokady, gdy wątek istniejącym wyzwalane po zmianie stanu.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</source>
          <target state="translated">W przypadku ostatniego stanu blokady wynosi uaktualnienia (U) wątek w trybie możliwej po zmianie stanu i Read (R) w przeciwnym razie niezależnie od poprzedniego stanu.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following example shows a simple synchronized cache that holds strings with integer keys.</source>
          <target state="translated">W poniższym przykładzie przedstawiono prosty zsynchronizowane pamięci podręcznej, który przechowuje ciągi z kluczami liczby całkowitej.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>An instance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> that serves as the inner cache.</source>
          <target state="translated">Wystąpienie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> służy do synchronizowania dostęp do <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> służy jako wewnętrznej pamięci podręcznej.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</source>
          <target state="translated">Przykład zawiera proste metody do dodawania do pamięci podręcznej, Usuń z pamięci podręcznej i odczytu z pamięci podręcznej.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</source>
          <target state="translated">Aby zademonstrować limity czasu, przykładzie zawiera metodę, która dodaje do pamięci podręcznej tylko wtedy, gdy jest on to zrobić w ramach określonego limitu czasu.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Aby zaprezentować tryb możliwej, przykładzie zawiera metodę, która pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Go nie jest znaleziono wartości dla klucza, jest wstawiany parę klucza i wartości.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Jeśli wartość została zmieniona, jest aktualizowana.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</source>
          <target state="translated">Tryb możliwej pozwala na uaktualnienie dostęp do odczytu do zapisu w razie potrzeby bez ryzyka zakleszczenie wątku.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</source>
          <target state="translated">Przykład zawiera zagnieżdżone wyliczenia, określająca wartości zwracanych przez metodę, która przedstawia możliwej tryb.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">W przykładzie użyto domyślnego konstruktora do utworzenia blokady, więc rekursji jest niedozwolone.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programowanie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> jest prostsza i mniej podatne na błędy podczas blokady nie zezwala na rekursji.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">Poniższy kod używa następnie <ph id="ph1">`SynchronizedCache`</ph> obiekt, aby zapisać słownik nazw materiałem.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>It creates three tasks.</source>
          <target state="translated">Tworzy trzy zadania.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Pierwszy zapisuje nazw warzyw przechowywane w tablicy do <ph id="ph1">`SynchronizedCache`</ph> wystąpienia.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">Drugi i trzeci zadań wyświetlane nazwy warzyw, pierwszy w kolejności rosnącej (od niskiej indeksu indeks wysokiej), drugi w kolejności malejącej.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">Ostatnim zadaniem wyszukuje ciąg "Ogórek" i, gdy uzna, wywołuje <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> metodę, aby zastąpić ciąg "zielony ziarna".</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This type is thread safe.</source>
          <target state="translated">Ten typ jest bezpieczny wątkowo.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class with default property values.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> z domyślnymi wartościami właściwości.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that is initialized with this constructor does not allow recursion.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> który został zainicjowany z tym Konstruktor nie zezwala na rekursji.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>That is, the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property returns <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Oznacza to <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> zwraca właściwość <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Aby uzyskać więcej informacji o zasadach rekursji i jej wpływ, zobacz <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> wyliczenie i <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The following example shows a simple synchronized cache that holds strings with integer keys.</source>
          <target state="translated">W poniższym przykładzie przedstawiono prosty zsynchronizowane pamięci podręcznej, który przechowuje ciągi z kluczami liczby całkowitej.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>An instance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> that serves as the inner cache.</source>
          <target state="translated">Wystąpienie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> służy do synchronizowania dostęp do <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> służy jako wewnętrznej pamięci podręcznej.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The parameterless constructor is used to create the lock.</source>
          <target state="translated">Konstruktor bez parametrów służy do tworzenia blokady.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</source>
          <target state="translated">Przykład zawiera proste metody do dodawania do pamięci podręcznej, Usuń z pamięci podręcznej i odczytu z pamięci podręcznej.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</source>
          <target state="translated">Aby zademonstrować limity czasu, przykładzie zawiera metodę, która dodaje do pamięci podręcznej tylko wtedy, gdy jest on to zrobić w ramach określonego limitu czasu.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Aby zaprezentować tryb możliwej, przykładzie zawiera metodę, która pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Go nie jest znaleziono wartości dla klucza, jest wstawiany parę klucza i wartości.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Jeśli wartość została zmieniona, jest aktualizowana.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</source>
          <target state="translated">Tryb możliwej pozwala na uaktualnienie dostęp do odczytu do zapisu w razie potrzeby bez ryzyka zakleszczenie wątku.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</source>
          <target state="translated">Przykład zawiera zagnieżdżone wyliczenia, określająca wartości zwracanych przez metodę, która przedstawia możliwej tryb.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">W przykładzie użyto domyślnego konstruktora do utworzenia blokady, więc rekursji jest niedozwolone.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programowanie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> jest prostsza i mniej podatne na błędy podczas blokady nie zezwala na rekursji.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">Poniższy kod używa następnie <ph id="ph1">`SynchronizedCache`</ph> obiekt, aby zapisać słownik nazw materiałem.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>It creates three tasks.</source>
          <target state="translated">Tworzy trzy zadania.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Pierwszy zapisuje nazw warzyw przechowywane w tablicy do <ph id="ph1">`SynchronizedCache`</ph> wystąpienia.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">Drugi i trzeci zadań wyświetlane nazwy warzyw, pierwszy w kolejności rosnącej (od niskiej indeksu indeks wysokiej), drugi w kolejności malejącej.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">Ostatnim zadaniem wyszukuje ciąg "Ogórek" i, gdy uzna, wywołuje <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> metodę, aby zastąpić ciąg "zielony ziarna".</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>One of the enumeration values that specifies the lock recursion policy.</source>
          <target state="translated">Jedna z wartości wyliczenia, które określa zasady blokowania rekursji.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class, specifying the lock recursion policy.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> klasy określenie zasad rekursji blokady.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Recursion policy determines the restrictions on threads that enter the lock more than once.</source>
          <target state="translated">Zasada rekursji określa ograniczenia dotyczące wątków, które wprowadź blokady więcej niż raz.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>For example, if a lock was created with <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> and a thread has entered the lock in read mode, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.</source>
          <target state="translated">Na przykład, jeśli utworzono blokady <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> i Wątek wszedł blokady w trybie do odczytu, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> jest generowany, jeśli wątek spróbuje ponownie blokady w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Similarly, if a thread has entered the lock in write mode, <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in any mode.</source>
          <target state="translated">Podobnie, jeśli wątek wszedł blokady w trybie zapisu <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> jest generowany, jeśli wątek spróbuje ponownie blokady w dowolnym trybie.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</source>
          <target state="translated">Wątek w trybie możliwej można uaktualnić do zapisu w trybie lub starszą wersję trybu bez względu na ustawienie zasad rekursji blokady odczytu.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Niezależnie od zasady rekursji wątku, który początkowo wprowadzona odczytać tryb nie jest dozwolone do uaktualnienia do trybu możliwej lub zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Aby uzyskać więcej informacji o zasadach rekursji i jej wpływ, zobacz <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> wyliczenie i <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The following example shows two exception scenarios, one that depends on the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> setting and one that does not.</source>
          <target state="translated">Poniższy przykład przedstawia dwa scenariusze wyjątek, który jest zależny od <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> ustawienie i jedną, która nie.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</source>
          <target state="translated">W pierwszym scenariuszu wątek przejdzie do trybu odczytu i próbuje wpisz rekursywnie w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is created by using the default constructor, which sets recursion policy to <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> jest tworzona przy użyciu domyślnego konstruktora, który ustawia zasady rekursji <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>, jest zgłaszany wyjątek.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> is used to create the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> służy do tworzenia <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, nie jest wyjątek.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>In the second scenario, the thread enters read mode and then tries to enter write mode.</source>
          <target state="translated">W drugim scenariuszu wątek przechodzi w trybie do odczytu, a następnie próbuje wpisz wpisz tryb.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown regardless of the lock recursion policy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> jest generowany, niezależnie od zasady rekursji blokady.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">Poniższy kod używa następnie <ph id="ph1">`SynchronizedCache`</ph> obiekt, aby zapisać słownik nazw materiałem.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>It creates three tasks.</source>
          <target state="translated">Tworzy trzy zadania.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Pierwszy zapisuje nazw warzyw przechowywane w tablicy do <ph id="ph1">`SynchronizedCache`</ph> wystąpienia.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">Drugi i trzeci zadań wyświetlane nazwy warzyw, pierwszy w kolejności rosnącej (od niskiej indeksu indeks wysokiej), drugi w kolejności malejącej.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">Ostatnim zadaniem wyszukuje ciąg "Ogórek" i, gdy uzna, wywołuje <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> metodę, aby zastąpić ciąg "zielony ziarna".</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Gets the total number of unique threads that have entered the lock in read mode.</source>
          <target state="translated">Pobiera całkowita liczba unikatowych wątków, które zostały wprowadzone blokady w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The number of unique threads that have entered the lock in read mode.</source>
          <target state="translated">Liczba unikatowych wątków, które zostały wprowadzone blokady w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</source>
          <target state="translated">Wątek tylko raz, nawet jeśli blokady umożliwia rekursji i wątek został przełączony w trybie do odczytu wiele razy.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Wyniki można zmienić, jak zostały obliczone.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A&gt;</ph> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A&gt;</ph> Generuj wpis dziennika zdarzeń, jeśli liczba wątków w trybie odczytu przekracza próg dla właściwości.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class.</source>
          <target state="translated">Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</source>
          <target state="translated">Wywołanie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> po zakończeniu przy użyciu <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in an unusable state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> Pozostawia metody <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> w stanie uniemożliwiającym jego używanie.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>After calling <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> was occupying.</source>
          <target state="translated">Po wywołaniu <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>, konieczne jest zwolnienie wszystkich odwołań do <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Aby uzyskać więcej informacji, zobacz <bpt id="p1">[</bpt>czyszczenie zasobów niezarządzanych<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> i <bpt id="p2">[</bpt>implementacja metody Dispose<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Always call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> object.</source>
          <target state="translated">Wywoływanie zawsze <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> przed zwolnieniem ostatniego odwołania do <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /&gt;</ph> jest większa niż zero.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /&gt;</ph> jest większa niż zero.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /&gt;</ph> jest większa niż zero.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Tries to enter the lock in read mode.</source>
          <target state="translated">Próbuje wpisz blokady w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Ten bloki metody aż wątek wywołujący wprowadza blokady, a w związku z tym może nigdy nie zwraca.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> trybu odczytu metodę, aby zablokować dla określonego interwału, a następnie wróć, jeśli wątek wywołujący nie została wprowadzona podczas tego interwału.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Multiple threads can enter read mode at the same time.</source>
          <target state="translated">Wiele wątków można wprowadzić trybie do odczytu, w tym samym czasie.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Jeśli jeden lub więcej wątków oczekujących na tryb zapisu, wątku wywołującym <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> bloki metody do momentu mieć tych wątków upłynął limit czasu lub przełączony w tryb zapisu i następnie zakończył działanie z niego.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie do odczytu można wprowadzić rekursywnie w trybie do odczytu, nawet w przypadku innych wątków oczekujących na tryb zapisu.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>At most one thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Co najwyżej jeden wątek może być w trybie możliwej, podczas gdy inne wątki są w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Jeśli dodatkowe wątków oczekujących do trybu możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, wątki tego wywołania <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> metoda natychmiast wprowadź trybie do odczytu i nie blokują.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method to enter the lock in read mode.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> metodę, aby wprowadzić blokady w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The method shown in the example retrieves the value associated with a key.</source>
          <target state="translated">Pokazano w przykładzie metoda pobiera wartość skojarzoną z kluczem.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If the key is not found, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Jeśli klucz nie zostanie znaleziony, wyjątku zgłoszonego przez wewnętrzny <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> może zakończyć metody.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> method, ensuring that the caller exits read mode.</source>
          <target state="translated">A <ph id="ph1">`finally`</ph> blok służy do wykonywania <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> metody, zapewniając, że obiekt wywołujący kończy pracę w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Ten kod jest częścią większego przykładu udostępnionego dla <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The current thread cannot acquire the write lock when it holds the read lock.</source>
          <target state="translated">Bieżący wątek nie może uzyskać blokady zapisu, gdy posiada blokady odczytu.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the read lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> Właściwość jest <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, a bieżący wątek próbował uzyskać blokady odczytu, gdy już utrzymuje blokady odczytu.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the write lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> Właściwość jest <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, a bieżący wątek próbował uzyskać blokady odczytu, gdy już utrzymuje blokadę zapisu.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Liczba rekursji przekroczy pojemności licznika.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This limit is so large that applications should never encounter this exception.</source>
          <target state="translated">Ten limit jest tak duża, że aplikacje nigdy nie powinni napotkać tego wyjątku.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> Obiekt został usunięty.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Tries to enter the lock in upgradeable mode.</source>
          <target state="translated">Próbuje wpisz blokady w trybie możliwej.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Ten bloki metody aż wątek wywołujący wprowadza blokady, a w związku z tym może nigdy nie zwraca.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> metodę, aby zablokować dla określonego interwału, a następnie wróć, jeśli wątek wywołujący nie przeszedł w tryb możliwej tego interwału.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Użyj trybu możliwej gdy wątek zwykle uzyska dostęp do zasobu, która jest chroniona przez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> w trybie do odczytu, ale może być konieczne podanie trybie zapisu, jeśli są spełnione następujące warunki.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</source>
          <target state="translated">Wątek w trybie możliwej można obniżyć trybu odczytu lub uaktualnienia do zapisu w trybie.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Only one thread can enter upgradeable mode at any given time.</source>
          <target state="translated">Tylko jeden wątek można wprowadzić tryb możliwej w danym momencie.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Jeśli wątek jest w trybie możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, dowolna liczba innych wątków można wprowadzić trybie do odczytu, nawet jeśli istnieją wątków oczekujących do trybu możliwej.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Jeśli jeden lub więcej wątków oczekujących na tryb zapisu, wątku wywołującym <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> bloki metody do momentu mieć tych wątków upłynął limit czasu lub przełączony w tryb zapisu i następnie zakończył działanie z niego.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie możliwej wprowadzić rekursywnie możliwej tryb, nawet w przypadku innych wątków oczekujących na tryb zapisu.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method to enter the lock in upgradeable mode.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> metodę, aby wprowadzić w trybie możliwej blokady.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method, ensuring that the caller exits upgradeable mode.</source>
          <target state="translated">A <ph id="ph1">`finally`</ph> blok służy do wykonywania <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> metody zapewnienie, że obiekt wywołujący opuszcza tryb możliwej.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The method shown in the example retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Pokazano w przykładzie metoda pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Go nie jest znaleziono wartości dla klucza, jest wstawiany parę klucza i wartości.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Jeśli wartość została zmieniona, jest aktualizowana.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</source>
          <target state="translated">Tryb możliwej umożliwia wątku do uaktualnienia blokady odczytu bez ryzyko zakleszczenia.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">W przykładzie użyto domyślnego konstruktora do utworzenia blokady, więc rekursji jest niedozwolone.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programowanie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> jest prostsza i mniej podatne na błędy podczas blokady nie zezwala na rekursji.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Ten kod jest częścią większego przykładu udostępnionego dla <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock in any mode.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> Właściwość jest <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> i bieżący wątek został już wprowadzony blokady w dowolnym trybie.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Bieżący wątek został przełączony w tryb odczytu, więc próby przejścia w tryb możliwej spowodowałoby utworzenie możliwości zakleszczenie.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Liczba rekursji przekroczy pojemności licznika.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> Obiekt został usunięty.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>Tries to enter the lock in write mode.</source>
          <target state="translated">Próbuje wpisz blokady w trybie zapisu.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Ten bloki metody aż wątek wywołujący wprowadza blokady, a w związku z tym może nigdy nie zwraca.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> metodę, aby zablokować dla określonego interwału, a następnie wróć, jeśli wątek wywołujący nie przeszedł w trybie zapisu podczas tego interwału.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode.</source>
          <target state="translated">Jeśli inne wątki zostały wprowadzone blokady w trybie do odczytu, wątku wywołującym <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> bloki metody do momentu zamknięciu tych wątków trybu odczytu.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">W przypadku wątków oczekujących do trybu zapisu dodatkowe wątki wprowadzona trybie do odczytu lub tryb możliwej bloku, dopóki wszystkie wątki oczekujące na tryb zapisu mieć upłynął limit czasu lub przełączony w tryb zapisu i następnie zakończył działanie z niego.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie zapisu można wprowadzić rekursywnie tryb zapisu, nawet w przypadku innych wątków oczekujących na tryb zapisu.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method to enter the lock in write mode.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> metodę, aby wprowadzić blokady w trybie zapisu.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Metoda pokazano w przykładzie dodaje nową parę klucz wartość do pamięci podręcznej zsynchronizowane.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Jeśli klucz jest już w pamięci podręcznej, wyjątku zgłoszonego przez wewnętrzny <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> może zakończyć metody.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits write mode.</source>
          <target state="translated">A <ph id="ph1">`finally`</ph> blok służy do wykonywania <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> metody zapewnienie, że obiekt wywołujący kończy działanie w trybie zapisu.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Ten kod jest częścią większego przykładu udostępnionego dla <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock in any mode.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> Właściwość jest <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> i bieżący wątek został już wprowadzony blokady w dowolnym trybie.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</source>
          <target state="translated">Bieżący wątek został przełączony w tryb odczytu, więc wprowadzasz blokady w trybie zapisu spowoduje utworzenie możliwości zakleszczenie.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Liczba rekursji przekroczy pojemności licznika.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> Obiekt został usunięty.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</source>
          <target state="translated">Zmniejsza liczbę rekursji w trybie odczytu i kończy działanie trybie do odczytu, jeśli wynikowa liczba 0 (zero).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Ta metoda nie jest wrażliwe na kolejność rekursji.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Na przykład jeśli wątek wprowadza blokady w trybie możliwej, a następnie wprowadzi blokady w trybie do odczytu, kolejność, w którym kończy działanie wątku dwa tryby nie ma znaczenia.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, Wątek można wprowadzić w trybie blokady, a następnie wprowadzić rekursywnie w trybie do odczytu; kolejność, w którym kończy działanie wątku trybu odczytu i zapisu trybu nie ma znaczenia.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">Kończenie blokady może sygnalizować innych wątków oczekujących.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> method, ensuring that the caller exits read mode.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">`finally`</ph> bloku do wykonania <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> metody, zapewniając, że obiekt wywołujący kończy pracę w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The method shown in the example retrieves the value associated with a key.</source>
          <target state="translated">Pokazano w przykładzie metoda pobiera wartość skojarzoną z kluczem.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>If the key is not found, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Jeśli klucz nie zostanie znaleziony, wyjątku zgłoszonego przez wewnętrzny <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> może zakończyć metody.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method is used to enter read mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> Metoda służy do wprowadzania trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Ten kod jest częścią większego przykładu udostępnionego dla <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The current thread has not entered the lock in read mode.</source>
          <target state="translated">Bieżący wątek nie została wprowadzona blokady w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</source>
          <target state="translated">Zmniejsza liczbę rekursji dla trybu możliwej i zamyka tryb możliwej, jeśli wynikowa liczba 0 (zero).</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Ta metoda nie jest wrażliwe na kolejność rekursji.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Na przykład jeśli wątek wprowadza blokady w trybie możliwej, a następnie wprowadzi blokady w trybie zapisu, kolejność, w którym kończy działanie wątku dwa tryby nie ma znaczenia.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, Wątek można wprowadzić w trybie blokady, a następnie wprowadzić rekursywnie w trybie możliwej; kolejność, w którym kończy działanie wątku możliwej tryb trybu i zapisu nie ma znaczenia.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">Kończenie blokady może sygnalizować innych wątków oczekujących.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method, ensuring that the caller exits upgradeable mode.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">`finally`</ph> bloku do wykonania <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> metody zapewnienie, że obiekt wywołujący opuszcza tryb możliwej.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The method shown in the example retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Pokazano w przykładzie metoda pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Go nie jest znaleziono wartości dla klucza, jest wstawiany parę klucza i wartości.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Jeśli wartość została zmieniona, jest aktualizowana.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</source>
          <target state="translated">Tryb możliwej umożliwia wątku do uaktualnienia blokady odczytu bez ryzyko zakleszczenia.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">W przykładzie użyto domyślnego konstruktora do utworzenia blokady, więc rekursji jest niedozwolone.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programowanie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> jest prostsza i mniej podatne na błędy podczas blokady nie zezwala na rekursji.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Ten kod jest częścią większego przykładu udostępnionego dla <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The current thread has not entered the lock in upgradeable mode.</source>
          <target state="translated">Bieżący wątek nie została wprowadzona blokady w trybie możliwej.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</source>
          <target state="translated">Zmniejsza liczbę rekursji dla trybu zapisu i zamyka tryb zapisu, jeśli wynikowa liczba 0 (zero).</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Ta metoda nie jest wrażliwe na kolejność rekursji.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Na przykład jeśli wątek wprowadza blokady w trybie możliwej, a następnie wprowadzi blokady w trybie zapisu, kolejność, w którym kończy działanie wątku dwa tryby nie ma znaczenia.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, Wątek można wprowadzić w trybie blokady, a następnie wprowadzić rekursywnie w trybie do odczytu; kolejność, w którym kończy działanie wątku trybu odczytu i zapisu trybu nie ma znaczenia.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">Kończenie blokady może sygnalizować innych wątków oczekujących.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits write mode.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">`finally`</ph> bloku do wykonania <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> metody zapewnienie, że obiekt wywołujący kończy działanie w trybie zapisu.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Metoda pokazano w przykładzie dodaje nową parę klucz wartość do pamięci podręcznej zsynchronizowane.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Jeśli klucz jest już w pamięci podręcznej, wyjątku zgłoszonego przez wewnętrzny <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> może zakończyć metody.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method is used to enter the lock in write mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> Metoda służy do wprowadzania blokady w trybie zapisu.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Ten kod jest częścią większego przykładu udostępnionego dla <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The current thread has not entered the lock in write mode.</source>
          <target state="translated">Bieżący wątek nie została wprowadzona blokady w trybie zapisu.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in read mode.</source>
          <target state="translated">Pobiera wartość wskazującą, czy bieżący wątek wszedł blokady w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered read mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli bieżący wątek wszedł w tryb; odczytu w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Ta właściwość jest przeznaczona do użycia w deklaracji rozkazujących lub do innych celów debugowania.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Nie jest używana do sterowania przepływem wykonywania programu.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered read mode unexpectedly.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A&gt;</ph> właściwość, aby wygenerować assert, jeśli bieżący wątek wszedł trybu odczytu nieoczekiwane.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</source>
          <target state="translated">Pobiera wartość wskazującą, czy bieżący wątek wszedł blokady w trybie możliwej.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered upgradeable mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli bieżący wątek został przełączony w tryb możliwej; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Ta właściwość jest przeznaczona do użycia w deklaracji rozkazujących lub do innych celów debugowania.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Nie jest używana do sterowania przepływem wykonywania programu.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A&gt;</ph> właściwość, aby wygenerować assert, jeśli bieżący wątek wszedł w tryb możliwej nieoczekiwanie.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in write mode.</source>
          <target state="translated">Pobiera wartość wskazującą, czy bieżący wątek wszedł blokady w trybie zapisu.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered write mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli bieżący wątek został przełączony w tryb zapisu; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Ta właściwość jest przeznaczona do użycia w deklaracji rozkazujących lub do innych celów debugowania.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Nie jest używana do sterowania przepływem wykonywania programu.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered write mode unexpectedly.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A&gt;</ph> właściwość, aby wygenerować assert, jeśli bieżący wątek wszedł w tryb zapisu nieoczekiwanie.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Gets a value that indicates the recursion policy for the current <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object.</source>
          <target state="translated">Pobiera wartość wskazującą zasad rekursji dla bieżącego <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>One of the enumeration values that specifies the lock recursion policy.</source>
          <target state="translated">Jedna z wartości wyliczenia, które określa zasady blokowania rekursji.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Recursion policy determines the restrictions on threads that enter the lock more than once.</source>
          <target state="translated">Zasada rekursji określa ograniczenia dotyczące wątków, które wprowadź blokady więcej niż raz.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>For example, if a lock was created with <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> and a thread has entered the lock in read mode, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.</source>
          <target state="translated">Na przykład, jeśli utworzono blokady <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> i Wątek wszedł blokady w trybie do odczytu, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> jest generowany, jeśli wątek spróbuje ponownie blokady w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</source>
          <target state="translated">Wątek w trybie możliwej można uaktualnić do zapisu w trybie lub starszą wersję trybu bez względu na ustawienie zasad rekursji blokady odczytu.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Niezależnie od zasady rekursji wątku, który początkowo wprowadzona odczytać tryb nie jest dozwolone do uaktualnienia do trybu możliwej lub zapisu, ponieważ ten wzorzec tworzy silne prawdopodobieństwo zakleszczenia.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Aby uzyskać więcej informacji o zasadach rekursji i jej wpływ, zobacz <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> wyliczenie i <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</source>
          <target state="translated">Pobiera liczbę razy bieżący wątek wszedł blokady w trybie do odczytu, jako wskazanie rekursji.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered the lock recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0 (zero), jeśli bieżący wątek nie przeszedł w tryb odczytu, 1, jeśli wątek został przełączony w tryb odczytu, ale nie został wprowadzony rekursywnie, lub <bpt id="p1">*</bpt>n<ept id="p1">*</ept> Jeśli wątek wszedł rekursywnie blokady <bpt id="p2">*</bpt>n<ept id="p2">*</ept> — 1 godziny.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Wyniki można zmienić, jak zostały obliczone.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</source>
          <target state="translated">Pobiera liczbę razy bieżący wątek wszedł blokady w trybie możliwej jako wskazanie rekursji.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered upgradeable mode recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0, jeśli bieżący wątek nie został przełączony w tryb możliwej, 1, jeśli wątek został przełączony w tryb możliwej, ale nie weszła jej rekursywnie, lub <bpt id="p1">*</bpt>n<ept id="p1">*</ept> Jeśli wątek został przełączony w tryb możliwej rekursywnie <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 razy.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Wyniki można zmienić, jak zostały obliczone.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</source>
          <target state="translated">Pobiera liczbę razy bieżący wątek wszedł blokady w trybie zapisu jako wskazanie rekursji.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered write mode recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0, jeśli bieżący wątek nie przeszedł w tryb zapisu, 1, jeśli wątek został przełączony w tryb zapisu, ale nie został wprowadzony rekursywnie, lub <bpt id="p1">*</bpt>n<ept id="p1">*</ept> Jeśli wątek wszedł rekursywnie trybie zapisu <bpt id="p2">*</bpt>n<ept id="p2">*</ept> — 1 godziny.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Wyniki można zmienić, jak zostały obliczone.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in read mode, with an optional time-out.</source>
          <target state="translated">Próbuje wprowadzić w trybie odczytu z opcjonalne limitu czasu blokady.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Wyrażony w milisekundach czas oczekiwania, lub wartość -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) będzie czekać w nieskończoność.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>Tries to enter the lock in read mode, with an optional integer time-out.</source>
          <target state="translated">Próbuje wprowadź blokady w trybie odczytu z limitem czasu opcjonalna liczba całkowita.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered read mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli wątek wywołujący wprowadzone do odczytu, tryb, w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Jeśli <ph id="ph1">`millisecondsTimeout`</ph> jest 0 (zero), ta metoda sprawdza stan blokady i zwraca <ph id="ph2">`false`</ph> natychmiast, jeśli żądany stan jest niedostępny.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>Multiple threads can enter read mode at the same time.</source>
          <target state="translated">Wiele wątków można wprowadzić trybie do odczytu, w tym samym czasie.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Jeśli jeden lub więcej wątków oczekujących na tryb zapisu, wątku wywołującym <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> metody blokuje tych wątków albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niej, lub do chwili osiągnięcia limitu czasu własnym wątku wywołującym.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie do odczytu można wprowadzić rekursywnie w trybie do odczytu, nawet w przypadku innych wątków oczekujących na tryb zapisu.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>One thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Jeden wątek może być w trybie możliwej, podczas gdy inne wątki są w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Jeśli dodatkowe wątków oczekujących do trybu możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, wątki tego wywołania <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> metoda natychmiast wprowadź trybie do odczytu i nie blokują.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> Właściwość jest <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> i bieżący wątek został już wprowadzony blokady.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Liczba rekursji przekroczy pojemności licznika.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Wartość <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> jest ujemna, ale nie jest równa <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), która jest jedyną dozwoloną wartość ujemną.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> Obiekt został usunięty.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Interwał oczekiwania, lub wartość-1 milisekund oczekiwania przez czas nieokreślony.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>Tries to enter the lock in read mode, with an optional time-out.</source>
          <target state="translated">Próbuje wprowadzić w trybie odczytu z opcjonalne limitu czasu blokady.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered read mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli wątek wywołujący wprowadzone do odczytu, tryb, w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Jeśli <ph id="ph1">`timeout`</ph> jest 0 (zero), ta metoda sprawdza stan blokady i zwraca <ph id="ph2">`false`</ph> natychmiast, jeśli żądany stan jest niedostępny.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>Multiple threads can enter the lock in read mode at the same time.</source>
          <target state="translated">Wiele wątków można wprowadzić blokady w trybie do odczytu, w tym samym czasie.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If one or more threads are queued to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Jeden lub więcej wątków są umieszczane w kolejce do trybu zapisu, wątku wywołującym <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> metody blokuje tych wątków albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niej, lub do chwili osiągnięcia limitu czasu własnym wątku wywołującym.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie do odczytu można wprowadzić rekursywnie w trybie do odczytu, nawet w przypadku innych wątków oczekujących na tryb zapisu.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>One thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Jeden wątek może być w trybie możliwej, podczas gdy inne wątki są w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Jeśli dodatkowe wątków oczekujących do trybu możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, wątki tego wywołania <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> metoda natychmiast wprowadź trybie do odczytu i nie blokują.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> Właściwość jest <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> i bieżący wątek został już wprowadzony blokady.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Liczba rekursji przekroczy pojemności licznika.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Wartość <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartość ujemną.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Wartość <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> jest większa niż <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milisekund.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> Obiekt został usunięty.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Próbuje wprowadzić w trybie możliwej z opcjonalne limitu czasu blokady.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Wyrażony w milisekundach czas oczekiwania, lub wartość -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) będzie czekać w nieskończoność.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Próbuje wprowadzić w trybie możliwej z opcjonalne limitu czasu blokady.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered upgradeable mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli wątek wywołujący przełączony w tryb możliwej, w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Jeśli <ph id="ph1">`millisecondsTimeout`</ph> jest 0 (zero), ta metoda sprawdza stan blokady i zwraca <ph id="ph2">`false`</ph> natychmiast, jeśli żądany stan jest niedostępny.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Użyj trybu możliwej gdy wątek zwykle uzyska dostęp do zasobu, która jest chroniona przez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> w trybie do odczytu, ale może być konieczne podanie trybie zapisu, jeśli są spełnione następujące warunki.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</source>
          <target state="translated">Wątek w trybie możliwej można uaktualnić do zapisu w trybie lub starszą wersję trybu odczytu.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Only one thread can enter a lock in upgradeable mode at any given time.</source>
          <target state="translated">Tylko jeden wątek można wprowadzić w trybie możliwej blokady w danym momencie.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Jeśli wątek jest w trybie możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, dowolna liczba innych wątków można wprowadzić trybie do odczytu, nawet jeśli istnieją wątków oczekujących do trybu możliwej.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Jeśli jeden lub więcej wątków oczekujących na tryb zapisu, wątku wywołującym <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> metody blokuje tych wątków albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niej, lub do chwili osiągnięcia limitu czasu własnym wątku wywołującym.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie możliwej wprowadzić rekursywnie możliwej tryb, nawet w przypadku innych wątków oczekujących na tryb zapisu.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> Właściwość jest <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> i bieżący wątek został już wprowadzony blokady.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Bieżący wątek początkowo wprowadzić blokady w trybie odczytu i w związku z tym próby przejścia w tryb możliwej spowodowałoby utworzenie możliwość zakleszczenia.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Liczba rekursji przekroczy pojemności licznika.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Wartość <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> jest ujemna, ale nie jest równa <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), która jest jedyną dozwoloną wartość ujemną.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> Obiekt został usunięty.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Interwał oczekiwania, lub wartość-1 milisekund oczekiwania przez czas nieokreślony.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Próbuje wprowadzić w trybie możliwej z opcjonalne limitu czasu blokady.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered upgradeable mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli wątek wywołujący przełączony w tryb możliwej, w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Jeśli <ph id="ph1">`timeout`</ph> jest 0 (zero), ta metoda sprawdza stan blokady i zwraca <ph id="ph2">`false`</ph> natychmiast, jeśli żądany stan jest niedostępny.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Use upgradeable mode when a thread usually accesses the resource protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Użyj trybu możliwej gdy wątek zwykle dostęp do zasobów chronionych przez <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> w trybie do odczytu, ale może być konieczne podanie trybie zapisu, jeśli są spełnione następujące warunki.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</source>
          <target state="translated">Wątek w trybie możliwej można uaktualnić do zapisu w trybie lub starszą wersję trybu odczytu.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Only one thread can enter a lock in upgradeable mode at any given time.</source>
          <target state="translated">Tylko jeden wątek można wprowadzić w trybie możliwej blokady w danym momencie.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Jeśli wątek jest w trybie możliwej i nie ma żadnych wątków oczekujących na tryb zapisu, dowolna liczba innych wątków można wprowadzić trybie do odczytu, nawet jeśli istnieją wątków oczekujących do trybu możliwej.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Jeśli jeden lub więcej wątków oczekujących na tryb zapisu, wątku wywołującym <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> metody blokuje tych wątków albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niej, lub do chwili osiągnięcia limitu czasu własnym wątku wywołującym.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie możliwej wprowadzić rekursywnie możliwej tryb, nawet w przypadku innych wątków oczekujących na tryb zapisu.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> Właściwość jest <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> i bieżący wątek został już wprowadzony blokady.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Bieżący wątek początkowo wprowadzić blokady w trybie odczytu i w związku z tym próby przejścia w tryb możliwej spowodowałoby utworzenie możliwość zakleszczenia.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Liczba rekursji przekroczy pojemności licznika.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Wartość <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartość ujemną.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Wartość <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> jest większa niż <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milisekund.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> Obiekt został usunięty.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Próbuje wprowadzić w trybie zapisu z opcjonalne limitu czasu blokady.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Wyrażony w milisekundach czas oczekiwania, lub wartość -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) będzie czekać w nieskończoność.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Próbuje wprowadzić w trybie zapisu z opcjonalne limitu czasu blokady.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered write mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli wątek wywołujący przełączony w tryb zapisu, w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Jeśli <ph id="ph1">`millisecondsTimeout`</ph> jest 0 (zero), ta metoda sprawdza stan blokady i zwraca <ph id="ph2">`false`</ph> natychmiast, jeśli żądany stan jest niedostępny.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</source>
          <target state="translated">Jeśli inne wątki zostały wprowadzone blokady w trybie do odczytu, wątku wywołującym <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> blokuje metody do momentu tych wątków zamknięciu trybie do odczytu lub upłynął limit czasu.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Podczas wątki są zablokowane, oczekiwanie na tryb zapisu, dodatkowe wątki wprowadzona w trybie odczytu lub możliwej bloku, dopóki wszystkie wątki oczekujące na Wprowadź tryb zapisu albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niego.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie zapisu można wprowadzić rekursywnie tryb zapisu, nawet w przypadku innych wątków oczekujących na tryb zapisu.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> metodę, aby wprowadzić w trybie zapisu z limit czasu blokady. Metoda pokazano w przykładzie dodaje nową parę klucz wartość do pamięci podręcznej zsynchronizowane.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If the specified time-out interval elapses before the thread enters the lock, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Jeśli określony limit czasu musi upłynąć, zanim wątek wprowadza blokady, metoda zwraca <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The method returns <ph id="ph1">`true`</ph> if the key/value pair is added.</source>
          <target state="translated">Metoda zwraca <ph id="ph1">`true`</ph> Jeśli para klucza i wartości zostanie dodany.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Jeśli klucz jest już w pamięci podręcznej, wyjątku zgłoszonego przez wewnętrzny <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> może zakończyć metody.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits the lock.</source>
          <target state="translated">A <ph id="ph1">`finally`</ph> blok służy do wykonywania <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> metody zapewnienie, że obiekt wywołujący opuszcza blokady.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Ten kod jest częścią większego przykładu udostępnionego dla <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> Właściwość jest <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> i bieżący wątek został już wprowadzony blokady.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</source>
          <target state="translated">Bieżący wątek początkowo wprowadzić blokady w trybie odczytu i w związku z tym próby przejścia w tryb zapisu spowoduje utworzenie możliwość zakleszczenia.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Liczba rekursji przekroczy pojemności licznika.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Wartość <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> jest ujemna, ale nie jest równa <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), która jest jedyną dozwoloną wartość ujemną.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> Obiekt został usunięty.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Interwał oczekiwania, lub wartość-1 milisekund oczekiwania przez czas nieokreślony.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Próbuje wprowadzić w trybie zapisu z opcjonalne limitu czasu blokady.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered write mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli wątek wywołujący przełączony w tryb zapisu, w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Jeśli <ph id="ph1">`timeout`</ph> jest 0 (zero), ta metoda sprawdza stan blokady i zwraca <ph id="ph2">`false`</ph> natychmiast, jeśli żądany stan jest niedostępny.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</source>
          <target state="translated">Jeśli inne wątki zostały wprowadzone blokady w trybie do odczytu, wątku wywołującym <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> blokuje metody do momentu tych wątków zamknięciu trybie do odczytu lub upłynął limit czasu.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Podczas wątki są zablokowane, oczekiwanie na tryb zapisu, dodatkowe wątki wprowadzona w trybie odczytu lub możliwej bloku, dopóki wszystkie wątki oczekujące na Wprowadź tryb zapisu albo Przekroczono limit czasu lub wprowadzeniu trybie zapisu i następnie zakończył działanie z niego.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Jeśli blokady umożliwia rekursji, wątku, który wprowadził blokady w trybie zapisu można wprowadzić rekursywnie tryb zapisu, nawet w przypadku innych wątków oczekujących na tryb zapisu.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> Właściwość jest <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> i bieżący wątek został już wprowadzony blokady.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</source>
          <target state="translated">Bieżący wątek początkowo wprowadzić blokady w trybie odczytu i w związku z tym próby przejścia w tryb zapisu spowoduje utworzenie możliwość zakleszczenia.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Liczba rekursji przekroczy pojemności licznika.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Limit jest tak duża aplikacji należy go nigdy nie wystąpi.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Wartość <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> jest ujemna, ale nie jest równa-1 milisekund, która jest jedyną dozwoloną wartość ujemną.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Wartość <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> jest większa niż <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milisekund.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> Obiekt został usunięty.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Gets the total number of threads that are waiting to enter the lock in read mode.</source>
          <target state="translated">Pobiera łączna liczba wątków, które oczekują na wprowadzanie blokady w trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The total number of threads that are waiting to enter read mode.</source>
          <target state="translated">Całkowita liczba wątków, które oczekują na wprowadzanie trybie do odczytu.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Wyniki można zmienić, jak zostały obliczone.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A&gt;</ph> Generuj wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, oczekiwanie na tryb odczytu przekracza próg dla właściwości.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</source>
          <target state="translated">Pobiera całkowitą liczbę wątków, które oczekują na wprowadzanie blokady w trybie możliwej.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The total number of threads that are waiting to enter upgradeable mode.</source>
          <target state="translated">Całkowita liczba wątków, które oczekują na tryb możliwej.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Wyniki można zmienić, jak zostały obliczone.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A&gt;</ph> Generuj wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, oczekiwanie na tryb możliwej przekracza próg dla właściwości.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Gets the total number of threads that are waiting to enter the lock in write mode.</source>
          <target state="translated">Pobiera łączna liczba wątków, które oczekują na wprowadzanie blokady w trybie zapisu.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The total number of threads that are waiting to enter write mode.</source>
          <target state="translated">Całkowita liczba wątków, które oczekują na tryb zapisu.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Tej właściwości należy użyć tylko w przypadku debugowania, profilowania i rejestrowanie celów, a nie do sterowania zachowaniem algorytmu.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">Wyniki można zmienić, jak zostały obliczone.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">W związku z tym nie jest bezpieczne podjęcie decyzji na podstawie tej właściwości.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A&gt;</ph> Generuj wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane, oczekiwanie na tryb zapisu przekracza próg dla właściwości.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
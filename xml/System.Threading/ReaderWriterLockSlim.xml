<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="48493860686ba3e73ed0b66dc031975b80866a90" />
    <Meta Name="ms.sourcegitcommit" Value="7f3e5d4d5deda98f172984f1084d8a18bfc04dbc" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/23/2018" />
    <Meta Name="ms.locfileid" Value="42709134" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje blokady, który jest używany do zarządzania dostęp do zasobów, dzięki czemu wiele wątków do odczytu lub wyłączny dostęp do zapisu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Threading.ReaderWriterLockSlim> ochrony z zasobem, który jest odczytywany przez wiele wątków i zapisana przez jeden wątek jednocześnie. <xref:System.Threading.ReaderWriterLockSlim> zezwala na wiele wątków w trybie do odczytu, umożliwia jeden wątek być w trybie wyłączności na własność blokadę zapisu i umożliwia jeden wątek, który ma dostęp do odczytu w trybie możliwość uaktualnienia do odczytu, z którego wątku można uaktualnić do zapisu trybu bez konieczności zrzeka się go s dostęp do odczytu do tego zasobu.  
  
> [!NOTE]
>  <xref:System.Threading.ReaderWriterLockSlim> jest podobny do <xref:System.Threading.ReaderWriterLock>, ale oferuje uproszczone, zasady rekursji oraz uaktualnianie i zmiany na starszą wersję stan blokady. <xref:System.Threading.ReaderWriterLockSlim> pozwala uniknąć wielu przypadkach potencjalnych zakleszczenia. Ponadto wydajność <xref:System.Threading.ReaderWriterLockSlim> jest znacznie lepsze niż <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> jest zalecana dla wszystkich nowych wdrożeń.  
  
 Domyślnie nowe wystąpienia <xref:System.Threading.ReaderWriterLockSlim> są tworzone za pomocą <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> Flaga, a nie zezwalaj na rekursji. Ta zasada domyślna jest zalecane dla wszystkich nowych wdrożeniach, ponieważ rekursji wprowadza niepotrzebnych komplikacji i sprawia, że Twój kod jest bardziej podatna na zakleszczenia. Aby uprościć migrację z istniejących projektów używających <xref:System.Threading.Monitor> lub <xref:System.Threading.ReaderWriterLock>, możesz użyć <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flagi do tworzenia wystąpień <xref:System.Threading.ReaderWriterLockSlim> umożliwiające rekursji.  
  
 Wątek wprowadzić blokady w trzech trybów: Odczyt tryb, w trybie zapisu oraz możliwość uaktualnienia trybie do odczytu. (W pozostałej części tego tematu, "możliwość uaktualnienia trybie do odczytu" jest określany jako "Tryb możliwość uaktualnienia" i frazy "Wprowadź `x` trybu" jest używana mieszcząca dłużej frazy "Wprowadź blokadę w `x` trybu".)  
  
 Niezależnie od tego, zasady rekursji tylko jeden wątek może być w trybie zapisu w dowolnym momencie. Gdy wątek jest w trybie zapisu, nie z innego wątku można wprowadzić blokady w dowolnym trybie. Tylko jeden wątek może być w trybie możliwość uaktualnienia w dowolnej chwili. Dowolna liczba wątków może być w trybie do odczytu i może istnieć jeden wątek w trybie możliwość uaktualnienia podczas gdy inne wątki są w trybie do odczytu.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niej. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> method in Class metoda `try` / `catch` bloku. Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.  
  
 <xref:System.Threading.ReaderWriterLockSlim> zarządzane koligacji wątku; oznacza to, że każdy <xref:System.Threading.Thread> obiektu należy własne wywołania metody i wyjścia tryby blokowania. Żaden wątek nie można zmienić trybu z innego wątku.  
  
 Jeśli <xref:System.Threading.ReaderWriterLockSlim> nie zezwala na rekursji, wątek, czy zablokować próbuje wprowadzić blokadę z kilku powodów:  
  
-   Wątek, który próbuje wprowadzić bloków w trybie do odczytu, jeśli istnieją wątki oczekujące wprowadzić w trybie zapisu czy też istnieje pojedynczy wątek w trybie zapisu.  
  
    > [!NOTE]
    >  Blokowanie nowych czytników, gdy moduły zapisujące są umieszczane w kolejce jest zasady sprawiedliwe blokady, które preferuje modułów zapisujących. Bieżące zasady sprawiedliwe równoważy sprawiedliwe czytników i składników zapisywania, podwyższenie poziomu przepływności w najbardziej typowych scenariuszy. Przyszłe wersje [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] mogą wprowadzać nowe zasady sprawiedliwe.  
  
-   Wątek, który próbuje wprowadzić bloków w trybie możliwość uaktualnienia, czy istnieje już wątku w trybie możliwość uaktualnienia, jeśli istnieją wątki oczekujące na tryb zapisu w przypadku pojedynczego wątku w trybie zapisu.  
  
-   Wątek, który próbuje wprowadzić bloki tryb zapisu, jeśli wątek w jednym z trzech trybów.  
  
## <a name="upgrading-and-downgrading-locks"></a>Uaktualnianie i zmiany na starszą wersję blokad  
 Możliwość uaktualnienia tryb jest przeznaczony w przypadkach, gdy wątek zwykle odczytuje z chronionego zasobu, ale może być konieczne zapisanie w nim, jeśli spełniony jest jakiś warunek. Wątek, który wprowadził <xref:System.Threading.ReaderWriterLockSlim> w trybie możliwość uaktualnienia ma dostęp do odczytu do chronionego zasobu, a następnie przeprowadzić uaktualnienie do tryb zapisu przez wywołanie metody <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> lub <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metody. Ponieważ może istnieć tylko jeden wątek w trybie możliwość uaktualnienia w danym momencie, uaktualnienie do tryb zapisu nie zakleszczenie rekursji jest niedozwolony, który jest domyślne zasady.  
  
> [!IMPORTANT]
>  Niezależnie od tego, zasady rekursji wątek, który początkowo wprowadzone odczytu tryb nie jest dozwolona uaktualnić do trybu możliwość uaktualnienia lub zapisu, ponieważ tego wzorca tworzy silne prawdopodobieństwo zakleszczenia. Na przykład jeśli dwa wątki w trybie do odczytu, które obie próbować Wprowadź tryb zapisu, ich będzie zakleszczenie. Możliwość uaktualnienia tryb zaprojektowano w celu uniknięcia zakleszczenia takie.  
  
 W przypadku innych wątków w trybie do odczytu, wątek, który jest uaktualniany bloków. Podczas gdy wątek jest zablokowany, inne wątki, w których podejmowana jest próba przejść do trybu odczytu są blokowane. Po zamknięciu wszystkich wątków w trybie do odczytu, zablokowany wątek możliwość uaktualnienia przechodzi w tryb zapisu. W przypadku innych wątków oczekujących na wejście zapisu trybu, pozostają zablokowane, ponieważ pojedynczego wątku, który jest w trybie możliwość uaktualnienia zapobiega ich uzyskania wyłącznego dostępu do zasobu.  
  
 Inne wątki, które czekają na tryb odczytu w wątku w trybie możliwość uaktualnienia opuszcza tryb zapisu, tworzyć, chyba że istnieją wątki oczekujące, aby wprowadzić tryb zapisu. Wątek w trybie możliwość uaktualnienia można uaktualnić i obniżyć przez czas nieokreślony, tak długo, jak to tylko wątku, który zapisuje do chronionego zasobu.  
  
> [!IMPORTANT]
>  Jeśli zezwolisz na wiele wątków wprowadzić zapisu trybu lub możliwość uaktualnienia, nie wolno zezwalać na jeden wątek, aby zająć całych tryb możliwość uaktualnienia. W przeciwnym razie wątków, w których podejmowana jest próba wprowadź i zapisywać w trybie bezpośrednio zostaną zablokowane przez czas nieokreślony, gdy są one zablokowane, inne wątki nie będzie można wprowadzić w trybie do odczytu.  
  
 Wątek w trybie możliwość uaktualnienia mogą obniżyć wersję trybu odczytu za pośrednictwem pierwszego wywołania <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metody, a następnie wywołując <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> metody. Ten wzorzec obniżenia poziomu jest dozwolona dla wszystkich zasad rekursji blokady nawet <xref:System.Threading.LockRecursionPolicy.NoRecursion>.  
  
 Po zmiany na starszą wersję trybu odczytu, wątku nie można ponownie tryb możliwość uaktualnienia, dopóki nie zostało zakończone w trybie do odczytu.  
  
## <a name="entering-the-lock-recursively"></a>Wprowadzanie rekursywnie blokady  
 Możesz utworzyć <xref:System.Threading.ReaderWriterLockSlim> obsługujący cyklicznego blokadę zapisu przy użyciu <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> Konstruktor, który określa zasady blokowania i określając <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Rekursji nie jest zalecane w nowych wdrożeniach, ponieważ wprowadza niepotrzebnych komplikacji i sprawia, że Twój kod jest bardziej podatna na zakleszczenia.  
  
 Aby uzyskać <xref:System.Threading.ReaderWriterLockSlim> umożliwiająca rekursji, następujące powiedzieć, informacje o trybach wątku można wprowadzić:  
  
-   Wątek w trybie do odczytu można wprowadzić cyklicznie w trybie do odczytu, ale nie można wprowadzić w trybie zapisu lub możliwość uaktualnienia. Jeśli spróbuje to zrobić, <xref:System.Threading.LockRecursionException> zgłaszany. Wprowadzenie do odczytu trybu, a następnie wprowadzają tryb zapisu lub tryb możliwość uaktualnienia jest wzorcu przy użyciu silnego prawdopodobieństwo zakleszczenia, więc nie jest dozwolone. Zgodnie z wcześniejszym opisem tryb możliwość uaktualnienia znajduje się w sytuacjach, gdzie jest niezbędne do uaktualnienia blokady.  
  
-   Wątek w trybie możliwość uaktualnienia można wprowadzić w trybie zapisu i/lub w trybie do odczytu, a następnie wprowadzić dowolne rekursywnie trzech trybów. Jednak próba wprowadź napisać bloków w trybie czy istnieją inne wątki w trybie do odczytu.  
  
-   Wątek w trybie zapisu można wprowadzić w trybie do odczytu i/lub tryb możliwość uaktualnienia, a następnie wprowadzić dowolne rekursywnie trzech trybów.  
  
-   Wątku, która nie została wprowadzona blokady można wprowadzić w dowolnym trybie. Ta próba może zablokować powodów próba wprowadź blokadę niecyklicznego.  
  
 Wątek wyjść tryby, wprowadzona w dowolnej kolejności, tak długo, jak kończy działanie każdego trybu dokładnie dowolną liczbę razy, ile on umieszczony ten tryb. Jeśli wątek spróbuje, aby wyjść z trybu zbyt wiele razy lub aby wyjść z trybu, nie została wprowadzona, <xref:System.Threading.SynchronizationLockException> zgłaszany.  
  
## <a name="lock-states"></a>Stany blokady  
 Może okazać się wyobrazić sobie blokady w warunkach użytkowania krajach. Element <xref:System.Threading.ReaderWriterLockSlim> może mieć jeden z czterech stanów: nie wprowadzono, odczytu, uaktualniania i zapisu.  
  
-   Nie wprowadzono: W tym stanie żadne wątki nie zostały wprowadzone na blokadę (lub wszystkie wątki opuścili blokady).  
  
-   Odczyt: W tym stanie jeden lub więcej wątków wprowadzono Zablokuj dostęp do odczytu do chronionego zasobu.  
  
    > [!NOTE]
    >  Wątek wprowadzić blokada w trybie do odczytu za pomocą <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> lub <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metod, lub z trybu możliwość uaktualnienia wersji.  
  
-   Uaktualnienie: W tym stanie jeden wątek wprowadził Zablokuj dostęp do odczytu z opcji uaktualnienia do dostęp do zapisu (czyli w możliwość uaktualnienia tryb), oraz zero lub więcej wątków, wprowadzony Zablokuj dostęp do odczytu. Nie więcej niż jeden wątek jednocześnie można wprowadzić blokady przy użyciu opcji uaktualnienia; dodatkowe wątki, w których podejmowana jest próba przejść do trybu możliwość uaktualnienia są blokowane.  
  
-   Zapis: W tym stanie jeden wątek został wprowadzony blokady dla dostępu do zapisu do chronionego zasobu. Wątek znajduje się w posiadaniu wyłącznej blokady. Innego wątku, który próbuje wprowadzić blokady dla jakiegokolwiek powodu jest zablokowany.  
  
 W poniższej tabeli opisano przejścia między Stanami blokady, blokad, które nie zezwalają na rekursji, gdy wątek `t` podejmuje działania opisane w skrajnej lewej kolumnie. W tym czasie zajmuje się akcji, `t` nie trybem. (Szczególny przypadek gdzie `t` znajduje się w trybie możliwość uaktualnienia jest opisana w przypisy tabeli.) Pierwszy wiersz w tym artykule opisano początkowy stan blokady. Komórki opisano, co się dzieje z wątku, a następnie wyświetlać zmiany w stan blokady w nawiasach.  
  
||Nie podano (N)|Read (R)|Uaktualnienie (U)|Zapis (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` Przechodzi trybie do odczytu|`t` wprowadzenie (R).|`t` bloki, jeśli wątków oczekują na tryb zapisu; w przeciwnym razie `t` przechodzi.|`t` bloki, jeśli wątków oczekują na tryb zapisu; w przeciwnym razie `t` wprowadza.<sup> 1</sup>|`t` bloki.|  
|`t` przechodzi w tryb możliwość uaktualnienia|`t` wprowadzenie (U).|`t` bloki, jeśli wątków oczekiwania na zapis trybu lub uaktualnienia; w przeciwnym razie `t` wprowadza (U).|`t` bloki.|`t` bloki.|  
|`t` przechodzi w tryb zapisu|`t` wprowadza (W).|`t` bloki.|`t` bloki. <sup>2</sup>|`t` bloki.|  
  
 <sup>1</sup> Jeśli `t` rozpoczyna się w trybie możliwość uaktualnienia, go przechodzi trybie do odczytu. Ta akcja nigdy nie blokuje. Stan blokady nie zmienia się. (Wątek będziesz w stanie ukończyć starszą wersję trybu odczytu podczas zamykania trybu możliwość uaktualnienia.)  
  
 <sup>2</sup> Jeśli `t` jest uruchamiana w trybie możliwość uaktualnienia, blokuje w przypadku wątków w trybie do odczytu. W przeciwnym razie uaktualnienie do tryb zapisu. Zmiany stanu blokady zapisu (W). Jeśli `t` blokuje, ponieważ istnieją wątki w trybie do odczytu, go przechodzi w tryb zapisu tak szybko, jak ostatni wątek kończy działanie w trybie do odczytu, nawet w przypadku wątków oczekujących wprowadzenia tryb zapisu.  
  
 W przypadku zmiany stanu występuje, ponieważ wątek kończy działanie blokady, następny wątek wznowione, zostaje wybrany w następujący sposób:  
  
-   Po pierwsze wątek, który oczekuje na tryb zapisu i jest już w trybie możliwość uaktualnienia (może mieć co najwyżej jeden taki wątek).  
  
-   Kończy się niepowodzeniem, wątek, który jest Oczekiwanie w trybie zapisu.  
  
-   Kończy się niepowodzeniem, wątek, który oczekuje na tryb możliwość uaktualnienia.  
  
-   Kończy niepowodzeniem, wszystkie wątki, które oczekują w trybie odczytu.  
  
 Kolejne stan blokady jest zawsze zapisu (W) w dwóch przypadkach pierwszy i uaktualnienia (U) w przypadku trzeciej, bez względu na stan blokady wyzwolenia istniejącej wątku zmiany stanu. W ostatnim przypadku stan blokady jest uaktualnienia (U), w przypadku wątku w trybie możliwość uaktualnienia po zmianie stanu i Read (R) w przeciwnym razie niezależnie od wcześniejszego stanu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje prosty zsynchronizowane pamięć podręczna, która zawiera ciągi przy użyciu kluczy liczby całkowitej. Wystąpienie <xref:System.Threading.ReaderWriterLockSlim> służy do synchronizowania dostępu do <xref:System.Collections.Generic.Dictionary%602> służy jako wewnętrzny pamięci podręcznej.  
  
 Przykład zawiera prostego metod dodawania do pamięci podręcznej, Usuń z pamięci podręcznej i odczytu z pamięci podręcznej. Aby zademonstrować limity czasu, przykład zawiera metody, która dodaje do pamięci podręcznej, tylko wtedy, gdy go można to zrobić w określonym limicie czasu.  
  
 Aby zaprezentować tryb możliwość uaktualnienia, przykład zawiera metodę, która pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością. Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian. Jeśli wartość nie zostanie znaleziony dla klucza, jest wstawiany pary klucz/wartość. Jeśli wartość została zmieniona, jest aktualizowana. Możliwość uaktualnienia tryb umożliwia wątku uaktualnić do odczytu dostęp do zapisu, zgodnie z potrzebami, bez ryzyka zakleszczenia.  
  
 Przykład zawiera zagnieżdżone wyliczenie, które określa wartości zwracanych przez metodę, która pokazuje tryb możliwość uaktualnienia.  
  
 W przykładzie użyto domyślnego konstruktora, tworzenie lock, rekursja jest niedozwolone. Programowanie <xref:System.Threading.ReaderWriterLockSlim> jest prostsza i mniej podatne na błędy, jeśli blokada nie zezwalają na rekursji.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 Poniższy kod używa następnie `SynchronizedCache` obiekt ma być przechowywany słownik nazw roślinnego. Tworzy trzy zadania. Pierwszy zapisuje nazw warzyw przechowywane w tablicy `SynchronizedCache` wystąpienia. Drugie i trzecie zadanie wyświetlanie nazw warzywa, pierwszy w kolejności rosnącej (od niskiej indeksu indeks wysoką), drugi w kolejności malejącej. Ostatnim zadaniem wyszukuje ciąg "Ogórek" i, gdy znajdzie, wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony bean".  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy przy użyciu domyślnych wartości właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Threading.ReaderWriterLockSlim> który jest inicjowany za pomocą tego konstruktora nie zezwala na rekursji. Oznacza to, że <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> właściwość zwraca <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.  
  
 Aby uzyskać więcej informacji na temat zasad rekursji i jej wpływ, zobacz <xref:System.Threading.LockRecursionPolicy> wyliczenie i <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje prosty zsynchronizowane pamięć podręczna, która zawiera ciągi przy użyciu kluczy liczby całkowitej. Wystąpienie <xref:System.Threading.ReaderWriterLockSlim> służy do synchronizowania dostępu do <xref:System.Collections.Generic.Dictionary%602> służy jako wewnętrzny pamięci podręcznej. Konstruktora bez parametrów jest używany do tworzenia blokady.  
  
 Przykład zawiera prostego metod dodawania do pamięci podręcznej, Usuń z pamięci podręcznej i odczytu z pamięci podręcznej. Aby zademonstrować limity czasu, przykład zawiera metody, która dodaje do pamięci podręcznej, tylko wtedy, gdy go można to zrobić w określonym limicie czasu.  
  
 Aby zaprezentować tryb możliwość uaktualnienia, przykład zawiera metodę, która pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością. Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian. Jego wartość nie znajduje się klucza, jest wstawiany pary klucz/wartość. Jeśli wartość została zmieniona, jest aktualizowana. Możliwość uaktualnienia tryb umożliwia wątku uaktualnić do odczytu dostęp do zapisu, zgodnie z potrzebami, bez ryzyka zakleszczenia.  
  
 Przykład zawiera zagnieżdżone wyliczenie, które określa wartości zwracanych przez metodę, która pokazuje tryb możliwość uaktualnienia.  
  
 W przykładzie użyto domyślnego konstruktora, tworzenie lock, rekursja jest niedozwolone. Programowanie <xref:System.Threading.ReaderWriterLockSlim> jest prostsza i mniej podatne na błędy, jeśli blokada nie zezwalają na rekursji.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 Poniższy kod używa następnie `SynchronizedCache` obiekt ma być przechowywany słownik nazw roślinnego. Tworzy trzy zadania. Pierwszy zapisuje nazw warzyw przechowywane w tablicy `SynchronizedCache` wystąpienia. Drugie i trzecie zadanie wyświetlanie nazw warzywa, pierwszy w kolejności rosnącej (od niskiej indeksu indeks wysoką), drugi w kolejności malejącej. Ostatnim zadaniem wyszukuje ciąg "Ogórek" i, gdy znajdzie, wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony bean".  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">Jedna z wartości wyliczenia, które określa zasady rekursji blokady.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy, określając zasady rekursji blokady.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasady rekursji określają ograniczenia w wątkach, które więcej niż jeden raz wprowadź blokadę. Na przykład, jeśli blokada została utworzona przy użyciu <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> i wątku, który wprowadził blokada w trybie do odczytu, <xref:System.Threading.LockRecursionException> jest generowany, jeśli wątek próbuje ponownie blokady w trybie do odczytu. Podobnie, jeśli wątek, który wprowadził blokada w trybie zapisu <xref:System.Threading.LockRecursionException> jest generowany, jeśli wątek próbuje ponownie blokady w dowolnym trybie.  
  
> [!NOTE]
>  Wątek w trybie możliwość uaktualnienia można uaktualnić do tryb zapisu lub starszą wersję trybu bez względu na ustawienie zasad rekursji blokady odczytu.  
  
 Niezależnie od tego, zasady rekursji wątek, który początkowo wprowadzone odczytu tryb nie jest dozwolona uaktualnić do trybu możliwość uaktualnienia lub zapisu, ponieważ tego wzorca tworzy silne prawdopodobieństwo zakleszczenia.  
  
 Aby uzyskać więcej informacji na temat zasad rekursji i jej wpływ, zobacz <xref:System.Threading.LockRecursionPolicy> wyliczenie i <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano dwa scenariusze wyjątek, który jest zależny od <xref:System.Threading.LockRecursionPolicy> ustawienie i jedną, która nie ma.  
  
 W pierwszego scenariusza wątku przechodzi trybie do odczytu, a następnie próbuje wprowadzić cyklicznie w trybie do odczytu. Jeśli <xref:System.Threading.ReaderWriterLockSlim> jest tworzona przy użyciu konstruktora domyślnego, który ustawia zasady rekursji <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, zgłaszany jest wyjątek. Jeśli <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> służy do tworzenia <xref:System.Threading.ReaderWriterLockSlim>, jest zgłaszany żaden wyjątek.  
  
 W drugim scenariuszu wątku przechodzi trybie do odczytu, a następnie próbuje wprowadzić tryb zapisu. <xref:System.Threading.LockRecursionException> jest generowany, niezależnie od tego, zasady rekursji blokady.  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 Poniższy kod używa następnie `SynchronizedCache` obiekt ma być przechowywany słownik nazw roślinnego. Tworzy trzy zadania. Pierwszy zapisuje nazw warzyw przechowywane w tablicy `SynchronizedCache` wystąpienia. Drugie i trzecie zadanie wyświetlanie nazw warzywa, pierwszy w kolejności rosnącej (od niskiej indeksu indeks wysoką), drugi w kolejności malejącej. Ostatnim zadaniem wyszukuje ciąg "Ogórek" i, gdy znajdzie, wywołuje <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby zastąpić ciąg "zielony bean".  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę unikatowych wątków, które zostały wprowadzone blokada w trybie do odczytu.</summary>
        <value>Liczba unikatowych wątków, które zostały wprowadzone blokada w trybie do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek tylko raz, nawet jeśli blokada umożliwia rekursji i wątku wprowadzony w trybie do odczytu wiele razy.  
  
 Tylko w przypadku debugowania, profilowania i rejestrowania do celów, a nie kontrolują zachowanie algorytmu, należy użyć tej właściwości. Wyniki można zmienić tak szybko, jak zostały obliczone. W związku z tym nie jest bezpieczne do podejmowania decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> właściwość Generuj wpis dziennika zdarzeń, jeśli liczba wątków w trybie do odczytu przekroczy próg.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.ReaderWriterLockSlim" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> po zakończeniu przy użyciu <xref:System.Threading.ReaderWriterLockSlim>. <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> Pozostawia metoda <xref:System.Threading.ReaderWriterLockSlim> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, trzeba zwolnić wszystkie odwołania do <xref:System.Threading.ReaderWriterLockSlim> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.Threading.ReaderWriterLockSlim> zajmowaną przez wystąpienie. Aby uzyskać więcej informacji, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> przed publikacją swoje ostatnie odwołanie do <xref:System.Threading.ReaderWriterLockSlim> obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> jest większa niż zero.  
  
—lub— 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> jest większa niż zero.  
  
—lub— 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> jest większa niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody bloki, aż wątek wywołujący przechodzi blokadę, a w związku z tym może nigdy nie zwraca. Użyj <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> trybu odczytu metodę, aby zablokować na określonym przedziale czasu, a następnie wróć, jeśli wątek wywołujący nie została wprowadzona podczas tego interwału.  
  
 Wiele wątków można wprowadzić trybie do odczytu, w tym samym czasie.  
  
 Jeśli jeden lub więcej wątków oczekują na tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> bloków metody, dopóki te wątki mieć przekroczyła limit czasu lub wprowadzone w trybie zapisu i następnie zakończył działanie z niego.  
  
> [!NOTE]
>  Jeśli blokada umożliwia rekursji, wątek, który wprowadził blokada w trybie do odczytu można wprowadzić cyklicznie w trybie do odczytu, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
 Co najwyżej jeden wątek może być w trybie możliwość uaktualnienia, podczas gdy inne wątki są w trybie do odczytu. Jeśli dodatkowe wątki nie oczekują na tryb możliwość uaktualnienia, a nie istnieją wątki oczekujące na tryb zapisu, wątki tego wywołania <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metody odczytu tryb natychmiast i nie blokują.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodę, aby wprowadzić blokada w trybie do odczytu. Metoda pokazano w przykładzie pobiera wartość skojarzoną z kluczem. Jeśli klucz nie zostanie znaleziony, wyjątek zgłaszany przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> mogła zakończyć metody. A `finally` blok służy do wykonywania <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> metody, zapewniając, że obiekt wywołujący kończy pracę w trybie do odczytu.  
  
 Ten kod jest częścią większego przykładu przewidzianego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, oraz bieżący wątek próbował uzyskać blokadę odczytu, gdy już posiada blokadę odczytu.  
  
—lub— 
<see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, oraz bieżący wątek próbował uzyskać blokadę odczytu, gdy już posiada blokadę zapisu.  
  
—lub— 
Liczba rekursji spowoduje przekroczenie pojemności licznika. Ten limit jest tak duża, że aplikacje nigdy nie powinni napotkać tego wyjątku.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie możliwość uaktualnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody bloki, aż wątek wywołujący przechodzi blokadę, a w związku z tym może nigdy nie zwraca. Użyj <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metodę, aby zablokować na określonym przedziale czasu, a następnie wróć, jeśli wątek wywołujący nie wprowadził możliwość uaktualnienia tryb ten przedział czasu.  
  
 Użyj trybu możliwość uaktualnienia gdy wątek uzyskuje dostęp zwykle do zasobu, który jest chroniony przez <xref:System.Threading.ReaderWriterLockSlim> w trybie odczytu, ale może być konieczne wprowadzenie tryb zapisu, jeśli są spełnione określone warunki. Wątek w trybie możliwość uaktualnienia mogą obniżyć wersję trybu odczytu lub Uaktualnij do tryb zapisu.  
  
 Tylko jeden wątek można wprowadzić możliwość uaktualnienia tryb, w dowolnym momencie. Jeśli wątek jest w trybie możliwość uaktualnienia, a nie istnieją wątki oczekujące na tryb zapisu, dowolna liczba innych wątków można wprowadzić trybie do odczytu, nawet jeśli istnieją wątki oczekujące na tryb możliwość uaktualnienia.  
  
 Jeśli jeden lub więcej wątków oczekują na tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> bloków metody, dopóki te wątki mieć przekroczyła limit czasu lub wprowadzone w trybie zapisu i następnie zakończył działanie z niego.  
  
> [!NOTE]
>  Jeśli blokada umożliwia rekursji, wątek, który wprowadził blokada w trybie możliwość uaktualnienia można wprowadzić możliwość uaktualnienia tryb cyklicznie, nawet wtedy, gdy inne wątki oczekujące na tryb zapisu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodę, aby wprowadzić blokada w trybie możliwość uaktualnienia. A `finally` blok służy do wykonywania <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> metody, zapewniając, że obiekt wywołujący opuszcza tryb możliwość uaktualnienia.  
  
 Metoda pokazano w przykładzie pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością. Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian. Jego wartość nie znajduje się klucza, jest wstawiany pary klucz/wartość. Jeśli wartość została zmieniona, jest aktualizowana. Możliwość uaktualnienia tryb umożliwia wątku do uaktualnienia blokady odczytu, zgodnie z potrzebami, bez ryzyka zakleszczenia.  
  
 W przykładzie użyto domyślnego konstruktora, tworzenie lock, rekursja jest niedozwolone. Programowanie <xref:System.Threading.ReaderWriterLockSlim> jest prostsza i mniej podatne na błędy, jeśli blokada nie zezwalają na rekursji.  
  
 Ten kod jest częścią większego przykładu przewidzianego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już została wprowadzona w dowolnym trybie blokady.  
  
—lub— 
Bieżący wątek została wprowadzona trybie do odczytu, więc próby możliwość uaktualnienia tryb spowodowałoby utworzenie możliwość zakleszczenia.  
  
—lub— 
Liczba rekursji spowoduje przekroczenie pojemności licznika. Limit jest tak duża, że aplikacje nigdy nie powinni napotkać go.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody bloki, aż wątek wywołujący przechodzi blokadę, a w związku z tym może nigdy nie zwraca. Użyj <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodę, aby zablokować na określonym przedziale czasu, a następnie wróć, jeśli wątek wywołujący nie została wprowadzona trybie zapisu podczas tego interwału.  
  
 Jeśli inne wątki wprowadzono blokada w trybie do odczytu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> trybu odczytu bloków metody, dopóki opuścili te wątki. W przypadku wątków oczekujących na tryb zapisu dodatkowe wątki, w których podejmowana jest próba wprowadź trybie do odczytu lub możliwość uaktualnienia tryb bloku, dopóki wszystkie wątki oczekujące na tryb zapisu mieć przekroczyło limit czasu lub wprowadzić tryb zapisu i następnie zakończył działanie z niego.  
  
> [!NOTE]
>  Jeśli blokada umożliwia rekursji, wątek, który wprowadził blokada w trybie zapisu, można wprowadzić rekursywnie tryb zapisu, nawet wtedy, gdy inne wątki oczekujące na tryb zapisu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metodę, aby wprowadzić blokada w trybie zapisu. Metoda pokazano w przykładzie dodaje nową parę kluczy/wartości do synchronizowanych pamięci podręcznej. Jeśli klucz jest już w pamięci podręcznej, wyjątek zgłaszany przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> mogła zakończyć metody. A `finally` blok służy do wykonywania <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> metody, zapewniając, że obiekt wywołujący opuszcza tryb zapisu.  
  
 Ten kod jest częścią większego przykładu przewidzianego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek już została wprowadzona w dowolnym trybie blokady.  
  
—lub— 
Bieżący wątek wprowadzony w trybie do odczytu i już nie posiada blokadę zapisu, dzięki czemu wprowadzasz blokada w trybie zapisu czy tworzyć możliwości zakleszczenie.  
  
—lub— 
Liczba rekursji spowoduje przekroczenie pojemności licznika. Limit jest tak duża, że aplikacje nigdy nie powinni napotkać go.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę rekursji w trybie odczytu, a następnie kończy działanie trybie do odczytu, jeśli liczba wynikowy to 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest wrażliwa na kolejność rekursji. Na przykład jeśli wątek wchodzi blokadę w trybie możliwość uaktualnienia i następnie wprowadza blokada w trybie do odczytu, kolejność, w którym wątek kończy działanie dwa tryby nie ma znaczenia. Jeśli blokada umożliwia rekursji, wątku można wprowadzić blokada w trybie zapisu, a następnie wprowadzić cyklicznie w trybie do odczytu; kolejność, w którym kończy działanie wątku trybu odczytu i zapisu czy tryb nie ma znaczenia.  
  
 Kończenie blokady może być sygnał innych wątków oczekujących.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać `finally` bloku do wykonania <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> metody, zapewniając, że obiekt wywołujący kończy pracę w trybie do odczytu. Metoda pokazano w przykładzie pobiera wartość skojarzoną z kluczem. Jeśli klucz nie zostanie znaleziony, wyjątek zgłaszany przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> mogła zakończyć metody. <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> Metodę używaną do wprowadzania trybie do odczytu.  
  
 Ten kod jest częścią większego przykładu przewidzianego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie została wprowadzona blokada w trybie do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę rekursji dla trybu możliwość uaktualnienia, a następnie zamyka tryb możliwość uaktualnienia, jeśli liczba wynikowy to 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest wrażliwa na kolejność rekursji. Na przykład jeśli wątek wchodzi blokadę w trybie możliwość uaktualnienia i następnie wprowadza blokada w trybie zapisu, kolejność, w którym wątek kończy działanie dwa tryby nie ma znaczenia. Jeśli blokada umożliwia rekursji, wątku można wprowadzić blokada w trybie zapisu, a następnie wprowadzić cyklicznie w trybie możliwość uaktualnienia; kolejność, w którym wątek kończy działanie możliwość uaktualnienia tryb zapisu i trybie nie ma znaczenia.  
  
 Kończenie blokady może być sygnał innych wątków oczekujących.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać `finally` bloku do wykonania <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> metody, zapewniając, że obiekt wywołujący opuszcza tryb możliwość uaktualnienia.  
  
 Metoda pokazano w przykładzie pobiera wartość skojarzoną z kluczem i porównuje go z nową wartością. Jeśli wartość jest bez zmian, metoda zwraca stan wskazujący bez zmian. Jego wartość nie znajduje się klucza, jest wstawiany pary klucz/wartość. Jeśli wartość została zmieniona, jest aktualizowana. Możliwość uaktualnienia tryb umożliwia wątku do uaktualnienia blokady odczytu, zgodnie z potrzebami, bez ryzyka zakleszczenia.  
  
 W przykładzie użyto domyślnego konstruktora, tworzenie lock, rekursja jest niedozwolone. Programowanie <xref:System.Threading.ReaderWriterLockSlim> jest prostsza i mniej podatne na błędy, jeśli blokada nie zezwalają na rekursji.  
  
 Ten kod jest częścią większego przykładu przewidzianego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie została wprowadzona blokada w trybie możliwość uaktualnienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę rekursji dla trybu zapisu, a następnie zamyka tryb zapisu, jeśli liczba wynikowy to 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest wrażliwa na kolejność rekursji. Na przykład jeśli wątek wchodzi blokadę w trybie możliwość uaktualnienia i następnie wprowadza blokada w trybie zapisu, kolejność, w którym wątek kończy działanie dwa tryby nie ma znaczenia. Jeśli blokada umożliwia rekursji, wątku można wprowadzić blokada w trybie zapisu, a następnie wprowadzić cyklicznie w trybie do odczytu; kolejność, w którym kończy działanie wątku trybu odczytu i zapisu czy tryb nie ma znaczenia.  
  
 Kończenie blokady może być sygnał innych wątków oczekujących.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać `finally` bloku do wykonania <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> metody, zapewniając, że obiekt wywołujący opuszcza tryb zapisu. Metoda pokazano w przykładzie dodaje nową parę kluczy/wartości do synchronizowanych pamięci podręcznej. Jeśli klucz jest już w pamięci podręcznej, wyjątek zgłaszany przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> mogła zakończyć metody. <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> Metoda służy do wprowadzania blokada w trybie zapisu.  
  
 Ten kod jest częścią większego przykładu przewidzianego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie została wprowadzona blokada w trybie zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek wprowadził blokada w trybie do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący wątek został wprowadzony zapoznaj się z trybu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do użycia w deklaracji rozkazujących lub do innych celów debugowania. Nie jest używana do sterowania przepływem wykonania programu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> nieoczekiwanie trybu odczytu właściwości Generuj potwierdzenie, jeśli wprowadzony w bieżącym wątku.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek wprowadził blokada w trybie możliwość uaktualnienia.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący wątek przeszedł do trybu możliwość uaktualnienia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do użycia w deklaracji rozkazujących lub do innych celów debugowania. Nie jest używana do sterowania przepływem wykonania programu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> właściwość, aby wygenerować assert, jeśli bieżący wątek przeszła w tryb możliwość uaktualnienia nieoczekiwanie.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek wprowadził blokada w trybie zapisu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący wątek przeszła w tryb zapisu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do użycia w deklaracji rozkazujących lub do innych celów debugowania. Nie jest używana do sterowania przepływem wykonania programu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> właściwość, aby wygenerować assert, jeśli bieżący wątek przeszła w tryb zapisu nieoczekiwanie.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, zasady rekursji dla bieżącego <see cref="T:System.Threading.ReaderWriterLockSlim" /> obiektu.</summary>
        <value>Jedna z wartości wyliczenia, które określa zasady rekursji blokady.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasady rekursji określają ograniczenia w wątkach, które więcej niż jeden raz wprowadź blokadę. Na przykład, jeśli blokada została utworzona przy użyciu <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> i wątku, który wprowadził blokada w trybie do odczytu, <xref:System.Threading.LockRecursionException> jest generowany, jeśli wątek próbuje ponownie blokady w trybie do odczytu.  
  
> [!NOTE]
>  Wątek w trybie możliwość uaktualnienia można uaktualnić do tryb zapisu lub starszą wersję trybu bez względu na ustawienie zasad rekursji blokady odczytu.  
  
 Niezależnie od tego, zasady rekursji wątek, który początkowo wprowadzone odczytu tryb nie jest dozwolona uaktualnić do trybu możliwość uaktualnienia lub zapisu, ponieważ tego wzorca tworzy silne prawdopodobieństwo zakleszczenia.  
  
 Aby uzyskać więcej informacji na temat zasad rekursji i jej wpływ, zobacz <xref:System.Threading.LockRecursionPolicy> wyliczenie i <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę razy bieżącego wątku wprowadził blokada w trybie do odczytu w celu wskazania rekursji.</summary>
        <value>0 (zero), jeśli bieżący wątek nie została wprowadzona. Zapoznaj się z trybu, 1, jeśli wątek wprowadzony w trybie do odczytu, ale nie został wprowadzony cyklicznie, lub *n* Jeśli wątek wprowadził rekursywnie blokady *n* — 1 godziny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w przypadku debugowania, profilowania i rejestrowania do celów, a nie kontrolują zachowanie algorytmu, należy użyć tej właściwości. Wyniki można zmienić tak szybko, jak zostały obliczone. W związku z tym nie jest bezpieczne do podejmowania decyzji na podstawie tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę razy bieżącego wątku wprowadził blokada w trybie możliwość uaktualnienia w celu wskazania rekursji.</summary>
        <value>0, jeśli bieżący wątek nie przeszedł do trybu możliwość uaktualnienia, 1, jeśli wątek przeszła w tryb możliwość uaktualnienia, ale nie została wprowadzona go cyklicznie, lub *n* Jeśli wątek wprowadził możliwość uaktualnienia tryb rekursywnie *n* - 1 czasy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w przypadku debugowania, profilowania i rejestrowania do celów, a nie kontrolują zachowanie algorytmu, należy użyć tej właściwości. Wyniki można zmienić tak szybko, jak zostały obliczone. W związku z tym nie jest bezpieczne do podejmowania decyzji na podstawie tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę razy bieżącego wątku wprowadził blokada w trybie zapisu w celu wskazania rekursji.</summary>
        <value>0, jeśli bieżący wątek nie została wprowadzona tryb zapisu, 1 Jeśli wątek przeszła w tryb zapisu, ale nie został wprowadzony cyklicznie, lub *n* Jeśli wątek wprowadził rekursywnie tryb zapisu *n* — 1 godziny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w przypadku debugowania, profilowania i rejestrowania do celów, a nie kontrolują zachowanie algorytmu, należy użyć tej właściwości. Wyniki można zmienić tak szybko, jak zostały obliczone. W związku z tym nie jest bezpieczne do podejmowania decyzji na podstawie tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie do odczytu, za pomocą opcjonalnych limitu czasu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub wartość -1 (<see cref="F:System.Threading.Timeout.Infinite" />) czekanie w nieskończoność.</param>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie do odczytu, z limitem czasu opcjonalną liczbą całkowitą.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący, wprowadzone do odczytu, tryb, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Wiele wątków można wprowadzić trybie do odczytu, w tym samym czasie.  
  
 Jeśli jeden lub więcej wątków oczekują na tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metoda blokuje, dopóki te wątki albo Przekroczono limit czasu lub wprowadzeniu tryb zapisu i następnie zakończył działanie z niego lub do czasu wygaśnięcia interwału limitu czasu wywołania dla wątku.  
  
> [!NOTE]
>  Jeśli blokada umożliwia rekursji, wątek, który wprowadził blokada w trybie do odczytu można wprowadzić cyklicznie w trybie do odczytu, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
 Jeden wątek może być w trybie możliwość uaktualnienia, podczas gdy inne wątki są w trybie do odczytu. Jeśli dodatkowe wątki nie oczekują na tryb możliwość uaktualnienia, a nie istnieją wątki oczekujące na tryb zapisu, wątki tego wywołania <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metody odczytu tryb natychmiast i nie blokują.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek ma już blokadę.  
  
—lub— 
Liczba rekursji spowoduje przekroczenie pojemności licznika. Limit jest tak duża, że aplikacje nigdy nie powinni napotkać go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (-1), który jest jedyną dozwoloną wartość ujemną.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał oczekiwania, lub wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie do odczytu, za pomocą opcjonalnych limitu czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący, wprowadzone do odczytu, tryb, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Wiele wątków można wprowadzić blokada w trybie do odczytu, w tym samym czasie.  
  
 Jeśli jeden lub więcej wątków umieszczonych w kolejce do tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metoda blokuje, dopóki te wątki albo Przekroczono limit czasu lub wprowadzeniu tryb zapisu i następnie zakończył działanie z niego lub do czasu wygaśnięcia interwału limitu czasu wywołania dla wątku.  
  
> [!NOTE]
>  Jeśli blokada umożliwia rekursji, wątek, który wprowadził blokada w trybie do odczytu można wprowadzić cyklicznie w trybie do odczytu, nawet w przypadku innych wątków oczekujących na tryb zapisu.  
  
 Jeden wątek może być w trybie możliwość uaktualnienia, podczas gdy inne wątki są w trybie do odczytu. Jeśli dodatkowe wątki nie oczekują na tryb możliwość uaktualnienia, a nie istnieją wątki oczekujące na tryb zapisu, wątki tego wywołania <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metody odczytu tryb natychmiast i nie blokują.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek ma już blokadę.  
  
—lub— 
Liczba rekursji spowoduje przekroczenie pojemności licznika. Limit jest tak duża, że aplikacje nigdy nie powinni napotkać go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równy MS-1, która jest jedyną dozwoloną wartość ujemną.  
  
—lub— 
Wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie możliwość uaktualnienia z opcjonalny limit czasu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub wartość -1 (<see cref="F:System.Threading.Timeout.Infinite" />) czekanie w nieskończoność.</param>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie możliwość uaktualnienia z opcjonalny limit czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący wprowadzono możliwość uaktualnienia tryb, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Użyj trybu możliwość uaktualnienia gdy wątek uzyskuje dostęp zwykle do zasobu, który jest chroniony przez <xref:System.Threading.ReaderWriterLockSlim> w trybie odczytu, ale może być konieczne wprowadzenie tryb zapisu, jeśli są spełnione określone warunki. Wątek w trybie możliwość uaktualnienia można uaktualnić do tryb zapisu lub starszą wersję trybu odczytu.  
  
 Tylko jeden wątek można wprowadzić w trybie możliwość uaktualnienia blokady w danym momencie. Jeśli wątek jest w trybie możliwość uaktualnienia, a nie istnieją wątki oczekujące na tryb zapisu, dowolna liczba innych wątków można wprowadzić trybie do odczytu, nawet jeśli istnieją wątki oczekujące na tryb możliwość uaktualnienia.  
  
 Jeśli jeden lub więcej wątków oczekują na tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metoda blokuje, dopóki te wątki albo Przekroczono limit czasu lub wprowadzeniu tryb zapisu i następnie zakończył działanie z niego lub do czasu wygaśnięcia interwału limitu czasu wywołania dla wątku.  
  
> [!NOTE]
>  Jeśli blokada umożliwia rekursji, wątek, który wprowadził blokada w trybie możliwość uaktualnienia można wprowadzić możliwość uaktualnienia tryb cyklicznie, nawet wtedy, gdy inne wątki oczekujące na tryb zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek ma już blokadę.  
  
—lub— 
Bieżący wątek początkowo wprowadzona blokada w trybie do odczytu, a w związku z tym podjęcie próby, aby przejść do trybu możliwość uaktualnienia spowodowałoby utworzenie możliwości zakleszczenie.  
  
—lub— 
Liczba rekursji spowoduje przekroczenie pojemności licznika. Limit jest tak duża, że aplikacje nigdy nie powinni napotkać go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (-1), który jest jedyną dozwoloną wartość ujemną.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał oczekiwania, lub wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie możliwość uaktualnienia z opcjonalny limit czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący wprowadzono możliwość uaktualnienia tryb, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Użyj trybu możliwość uaktualnienia gdy wątek uzyskuje dostęp zwykle do zasobów chronionych przez <xref:System.Threading.ReaderWriterLockSlim> w trybie odczytu, ale może być konieczne wprowadzenie tryb zapisu, jeśli są spełnione określone warunki. Wątek w trybie możliwość uaktualnienia można uaktualnić do tryb zapisu lub starszą wersję trybu odczytu.  
  
 Tylko jeden wątek można wprowadzić w trybie możliwość uaktualnienia blokady w danym momencie. Jeśli wątek jest w trybie możliwość uaktualnienia, a nie istnieją wątki oczekujące na tryb zapisu, dowolna liczba innych wątków można wprowadzić trybie do odczytu, nawet jeśli istnieją wątki oczekujące na tryb możliwość uaktualnienia.  
  
 Jeśli jeden lub więcej wątków oczekują na tryb zapisu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metoda blokuje, dopóki te wątki albo Przekroczono limit czasu lub wprowadzeniu tryb zapisu i następnie zakończył działanie z niego lub do czasu wygaśnięcia interwału limitu czasu wywołania dla wątku.  
  
> [!NOTE]
>  Jeśli blokada umożliwia rekursji, wątek, który wprowadził blokada w trybie możliwość uaktualnienia można wprowadzić możliwość uaktualnienia tryb cyklicznie, nawet wtedy, gdy inne wątki oczekujące na tryb zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek ma już blokadę.  
  
—lub— 
Bieżący wątek początkowo wprowadzona blokada w trybie do odczytu, a w związku z tym podjęcie próby, aby przejść do trybu możliwość uaktualnienia spowodowałoby utworzenie możliwości zakleszczenie.  
  
—lub— 
Liczba rekursji spowoduje przekroczenie pojemności licznika. Limit jest tak duża, że aplikacje nigdy nie powinni napotkać go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równy MS-1, która jest jedyną dozwoloną wartość ujemną.  
  
—lub— 
Wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie zapisu z opcjonalny limit czasu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub wartość -1 (<see cref="F:System.Threading.Timeout.Infinite" />) czekanie w nieskończoność.</param>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie zapisu z opcjonalny limit czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący wprowadzone tryb zapisu, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Jeśli inne wątki wprowadzono blokada w trybie do odczytu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metoda blokuje, dopóki te wątki opuścili trybie do odczytu lub dopóki nie upłynie limit czasu. Podczas oczekiwania na tryb zapisu są blokowane wątki, dodatkowe wątki, w których podejmowana jest próba wprowadzić w trybie odczytu lub możliwość uaktualnienia blokuje, dopóki wszystkie wątki oczekujące na Wprowadź tryb zapisu, albo Przekroczono limit czasu lub wprowadzeniu tryb zapisu i następnie zakończył działanie z niego.  
  
> [!NOTE]
>  Jeśli blokada umożliwia rekursji, wątek, który wprowadził blokada w trybie zapisu, można wprowadzić rekursywnie tryb zapisu, nawet wtedy, gdy inne wątki oczekujące na tryb zapisu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodę, aby wprowadzić blokada w trybie zapisu z upływu limitu czasu. Metoda pokazano w przykładzie dodaje nową parę kluczy/wartości do synchronizowanych pamięci podręcznej. Jeśli określony limit czasu musi upłynąć, zanim wątku przechodzi blokady, metoda zwraca `false`. Metoda ta zwraca `true` Jeśli para klucza i wartości jest dodawany.  
  
 Jeśli klucz jest już w pamięci podręcznej, wyjątek zgłaszany przez wewnętrzny <xref:System.Collections.Generic.Dictionary%602> mogła zakończyć metody. A `finally` blok służy do wykonywania <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> metody zapewnienia, że obiekt wywołujący zamyka blokady.  
  
 Ten kod jest częścią większego przykładu przewidzianego dla <xref:System.Threading.ReaderWriterLockSlim> klasy.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek ma już blokadę.  
  
—lub— 
Bieżący wątek początkowo wprowadzona blokada w trybie do odczytu, a w związku z tym próby tryb zapisu spowodowałoby utworzenie możliwości zakleszczenie.  
  
—lub— 
Liczba rekursji spowoduje przekroczenie pojemności licznika. Limit jest tak duża, że aplikacje nigdy nie powinni napotkać go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, ale nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (-1), który jest jedyną dozwoloną wartość ujemną.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał oczekiwania, lub wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Maksymalna liczba prób wprowadzenia blokada w trybie zapisu z opcjonalny limit czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek wywołujący wprowadzone tryb zapisu, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi 0 (zero), ta metoda sprawdza stan blokady i zwraca `false` natychmiast, jeśli żądany stan jest niedostępny.  
  
 Jeśli inne wątki wprowadzono blokada w trybie do odczytu, wątku wywołującym <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metoda blokuje, dopóki te wątki opuścili trybie do odczytu lub dopóki nie upłynie limit czasu. Podczas oczekiwania na tryb zapisu są blokowane wątki, dodatkowe wątki, w których podejmowana jest próba wprowadzić w trybie odczytu lub możliwość uaktualnienia blokuje, dopóki wszystkie wątki oczekujące na Wprowadź tryb zapisu, albo Przekroczono limit czasu lub wprowadzeniu tryb zapisu i następnie zakończył działanie z niego.  
  
> [!NOTE]
>  Jeśli blokada umożliwia rekursji, wątek, który wprowadził blokada w trybie zapisu, można wprowadzić rekursywnie tryb zapisu, nawet wtedy, gdy inne wątki oczekujące na tryb zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Właściwość <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> i bieżący wątek ma już blokadę.  
  
—lub— 
Bieżący wątek początkowo wprowadzona blokada w trybie do odczytu, a w związku z tym próby tryb zapisu spowodowałoby utworzenie możliwości zakleszczenie.  
  
—lub— 
Liczba rekursji spowoduje przekroczenie pojemności licznika. Limit jest tak duża, że aplikacje nigdy nie powinni napotkać go.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, ale nie jest równy MS-1, która jest jedyną dozwoloną wartość ujemną.  
  
—lub— 
Wartość <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> Obiekt został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę wątków, które oczekują na wprowadzanie blokada w trybie do odczytu.</summary>
        <value>Całkowita liczba wątków, które oczekują, aby przejść do trybu odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w przypadku debugowania, profilowania i rejestrowania do celów, a nie kontrolują zachowanie algorytmu, należy użyć tej właściwości. Wyniki można zmienić tak szybko, jak zostały obliczone. W związku z tym nie jest bezpieczne do podejmowania decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> właściwość Generuj wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane; Trwa oczekiwanie, aby przejść do trybu odczytu przekracza wartość progową.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę wątków, które oczekują na wprowadzanie blokada w trybie możliwość uaktualnienia.</summary>
        <value>Całkowita liczba wątków, które oczekują, aby przejść do trybu możliwość uaktualnienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w przypadku debugowania, profilowania i rejestrowania do celów, a nie kontrolują zachowanie algorytmu, należy użyć tej właściwości. Wyniki można zmienić tak szybko, jak zostały obliczone. W związku z tym nie jest bezpieczne do podejmowania decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> właściwość Generuj wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane; Trwa oczekiwanie na tryb możliwość uaktualnienia przekracza wartość progową.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę wątków, które oczekują na wprowadzanie blokada w trybie zapisu.</summary>
        <value>Całkowita liczba wątków, które czekają na tryb zapisu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko w przypadku debugowania, profilowania i rejestrowania do celów, a nie kontrolują zachowanie algorytmu, należy użyć tej właściwości. Wyniki można zmienić tak szybko, jak zostały obliczone. W związku z tym nie jest bezpieczne do podejmowania decyzji na podstawie tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> właściwość Generuj wpis dziennika zdarzeń, jeśli liczba wątków, które są zablokowane; Trwa oczekiwanie na tryb zapisu przekracza wartość progową.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ManualResetEvent" FullName="System.Threading.ManualResetEvent">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3c19185907e45c5b7b80aae8627946c15d4efd4f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36605909" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ManualResetEvent : System.Threading.EventWaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ManualResetEvent extends System.Threading.EventWaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ManualResetEvent" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ManualResetEvent&#xA;Inherits EventWaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class ManualResetEvent sealed : System::Threading::EventWaitHandle" />
  <TypeSignature Language="F#" Value="type ManualResetEvent = class&#xA;    inherit EventWaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.EventWaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Powiadamia wątków oczekujących, które wystąpiło zdarzenie. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 2.0 <xref:System.Threading.ManualResetEvent> pochodzi z nowego <xref:System.Threading.EventWaitHandle> klasy. A <xref:System.Threading.ManualResetEvent> jest funkcjonalnym odpowiednikiem <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>.  
  
> [!NOTE]
>  W odróżnieniu od <xref:System.Threading.ManualResetEvent> klasy <xref:System.Threading.EventWaitHandle> klasy zapewnia dostęp do systemu o nazwie zdarzenia synchronizacji.  
  
 <xref:System.Threading.ManualResetEvent> Umożliwia wątków do komunikowania się ze sobą za sygnalizowania. Zazwyczaj tej komunikacji dotyczy zadań, które jeden wątek musi zakończyć się przed kontynuowaniem inne wątki.  
  
 Gdy wątek rozpocznie działanie, które należy wykonać przed innymi kontynuować wątków, wywołuje <xref:System.Threading.EventWaitHandle.Reset%2A> umieścić `ManualResetEvent` w stanie sygnalizowane. Ten wątek można traktować jako kontrolowanie `ManualResetEvent`. Wątki tego wywołania <xref:System.Threading.WaitHandle.WaitOne%2A> na `ManualResetEvent` zablokuje oczekiwanie na sygnał. Po ukończeniu działania kontrolowanie wątku wywołuje <xref:System.Threading.EventWaitHandle.Set%2A> sygnalizują, że można kontynuować wątków oczekujących. Są wydawane wszystkich wątków oczekujących.  
  
 Po zostały sygnalizuje, `ManualResetEvent` pozostaje sygnałowego, dopóki zostanie zresetowane ręcznie. Oznacza to, wywołań `WaitOne` zwracać natychmiast.  
  
 Można kontrolować początkowy stan `ManualResetEvent` przez przekazanie do konstruktora, wartość logiczna `true` Jeśli stan początkowy jest sygnalizowane i `false` inaczej.  
  
 `ManualResetEvent` można również używać razem `static` <xref:System.Threading.WaitHandle.WaitAll%2A> i <xref:System.Threading.WaitHandle.WaitAny%2A> metody.  
  
 Aby uzyskać więcej informacji na temat mechanizmów synchronizacji wątku, zobacz [ManualResetEvent i ManualResetEventSlim](~/docs/standard/threading/manualresetevent-and-manualreseteventslim.md) w dokumentacji koncepcyjnego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób <xref:System.Threading.ManualResetEvent> działa. Przykład rozpoczyna się od <xref:System.Threading.ManualResetEvent> w stanie unsignaled (to znaczy `false` jest przekazany do konstruktora). W przykładzie jest tworzony trzech wątków, każdy które bloki na <xref:System.Threading.ManualResetEvent> przez wywołanie jego <xref:System.Threading.WaitHandle.WaitOne%2A> — metoda. Gdy użytkownik naciśnie **Enter** klucza wywołania przykład <xref:System.Threading.EventWaitHandle.Set%2A> metodę, która udostępnia wszystkie trzy wątki. Natomiast to z zachowaniem <xref:System.Threading.AutoResetEvent> klasy, co zwalnia wątków co w czasie, zostanie automatycznie przywrócona po każdej wersji.  
  
 Naciśnięcie przycisku **Enter** klucz ponownie wykaże, że <xref:System.Threading.ManualResetEvent> pozostaje w stanie sygnałowego, aż do jej <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana: W przykładzie uruchomiono dwóch kolejnych wątków. Wątki te nie blokują przy wywoływaniu <xref:System.Threading.WaitHandle.WaitOne%2A> metody, zamiast tego uruchomić do zakończenia.  
  
 Naciśnięcie przycisku **Enter** klucz ponownie powoduje przykład wywołać <xref:System.Threading.EventWaitHandle.Reset%2A> — metoda i uruchomić jeden wątek więcej, która zablokuje wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A>. Naciśnięcie przycisku **Enter** klucza jednego wywołania końcowego czasu <xref:System.Threading.EventWaitHandle.Set%2A> zwolnienia ostatni wątek, a program kończy się.  
  
 [!code-cpp[System.Threading.ManualResetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ManualResetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/CS/source.cs#1)]
 [!code-vb[System.Threading.ManualResetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ta klasa jest bezpieczne dla wątków.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ManualResetEvent (bool initialState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ManualResetEvent(bool initialState);" />
      <MemberSignature Language="F#" Value="new System.Threading.ManualResetEvent : bool -&gt; System.Threading.ManualResetEvent" Usage="new System.Threading.ManualResetEvent initialState" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> Aby ustawić stanu początkowego sygnalizuje; <see langword="false" /> Aby ustawić stan początkowy nonsignaled.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.ManualResetEvent" /> klasy z wartość logiczną wskazującą, czy wartość stanu początkowego sygnałowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli początkowy stan <xref:System.Threading.ManualResetEvent> zostanie zasygnalizowane (to znaczy, jeśli jest tworzony przez przekazanie `true` dla `initialState`), wątki oczekiwania na <xref:System.Threading.ManualResetEvent> nie blokują. Jeśli stan początkowy jest nonsignaled, wątki zablokować do <xref:System.Threading.EventWaitHandle.Set%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
      </Docs>
    </Member>
  </Members>
</Type>
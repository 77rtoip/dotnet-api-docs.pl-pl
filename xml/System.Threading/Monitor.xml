<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4fb10be5601161de84aea8fd8f2a00a50eba6966" /><Meta Name="ms.sourcegitcommit" Value="5c332e8417c001736f7e2f33a84791feebba2cd7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/30/2019" /><Meta Name="ms.locfileid" Value="68632369" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="340b3-101">Zapewnia mechanizm, który synchronizuje dostęp do obiektów.</span><span class="sxs-lookup"><span data-stu-id="340b3-101">Provides a mechanism that synchronizes access to objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-102">Klasa pozwala synchronizować dostęp do regionu kodu przez pobranie i zwolnienie blokady dla określonego obiektu przez <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>wywołanie metod, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, i <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>. <xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="340b3-102">The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="340b3-103">Blokady obiektów zapewniają możliwość ograniczenia dostępu do bloku kodu, który jest często określany jako sekcja krytyczna.</span><span class="sxs-lookup"><span data-stu-id="340b3-103">Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</span></span> <span data-ttu-id="340b3-104">Gdy wątek jest właścicielem blokady obiektu, żaden inny wątek nie może uzyskać tej blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-104">While a thread owns the lock for an object, no other thread can acquire that lock.</span></span> <span data-ttu-id="340b3-105">Można również użyć <xref:System.Threading.Monitor> klasy, aby upewnić się, że żaden inny wątek nie może uzyskać dostępu do sekcji kodu aplikacji wykonywanej przez właściciela blokady, chyba że inny wątek wykonuje kod przy użyciu innego zablokowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-105">You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</span></span>  
  
 <span data-ttu-id="340b3-106">W tym artykule:</span><span class="sxs-lookup"><span data-stu-id="340b3-106">In this article:</span></span>  
  
 <span data-ttu-id="340b3-107">[Klasa monitora: Przegląd](#Overview) </span><span class="sxs-lookup"><span data-stu-id="340b3-107">[The Monitor class: An overview](#Overview) </span></span>  
 <span data-ttu-id="340b3-108">[Obiekt blokady](#Lock) </span><span class="sxs-lookup"><span data-stu-id="340b3-108">[The lock object](#Lock) </span></span>  
 <span data-ttu-id="340b3-109">[Sekcja krytyczna](#CriticalSection) </span><span class="sxs-lookup"><span data-stu-id="340b3-109">[The critical section](#CriticalSection) </span></span>  
 <span data-ttu-id="340b3-110">[Puls, PulseAll i Wait](#Pulse) </span><span class="sxs-lookup"><span data-stu-id="340b3-110">[Pulse, PulseAll, and Wait](#Pulse) </span></span>  
 [<span data-ttu-id="340b3-111">Monitory i uchwyty oczekiwania</span><span class="sxs-lookup"><span data-stu-id="340b3-111">Monitors and wait handles</span></span>](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a><span data-ttu-id="340b3-112">Klasa monitora: Przegląd</span><span class="sxs-lookup"><span data-stu-id="340b3-112">The Monitor class: An overview</span></span>  
 <span data-ttu-id="340b3-113"><xref:System.Threading.Monitor>ma następujące funkcje:</span><span class="sxs-lookup"><span data-stu-id="340b3-113"><xref:System.Threading.Monitor> has the following features:</span></span>  
  
-   <span data-ttu-id="340b3-114">Jest ona skojarzona z obiektem na żądanie.</span><span class="sxs-lookup"><span data-stu-id="340b3-114">It is associated with an object on demand.</span></span>  
  
-   <span data-ttu-id="340b3-115">Jest on niepowiązany, co oznacza, że może być wywoływana bezpośrednio z dowolnego kontekstu.</span><span class="sxs-lookup"><span data-stu-id="340b3-115">It is unbound, which means it can be called directly from any context.</span></span>  
  
-   <span data-ttu-id="340b3-116">Nie można utworzyć wystąpienia <xref:System.Threading.Monitor> klasy; metody <xref:System.Threading.Monitor> klasy są statyczne.</span><span class="sxs-lookup"><span data-stu-id="340b3-116">An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static.</span></span> <span data-ttu-id="340b3-117">Każda metoda jest przenoszona do synchronizowanego obiektu, który kontroluje dostęp do sekcji krytycznej.</span><span class="sxs-lookup"><span data-stu-id="340b3-117">Each method is passed the synchronized object that controls access to the critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-118">Użyj klasy <xref:System.Threading.Monitor> , aby zablokować obiekty inne niż ciągi (czyli typy odwołań inne niż <xref:System.String>), a nie typy wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-118">Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types.</span></span> <span data-ttu-id="340b3-119">Aby uzyskać szczegółowe informacje, zobacz przeciążenia <xref:System.Threading.Monitor.Enter%2A> metody i [blokady obiektu](#Lock) w dalszej części tego artykułu.</span><span class="sxs-lookup"><span data-stu-id="340b3-119">For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.</span></span>  
  
 <span data-ttu-id="340b3-120">W poniższej tabeli opisano akcje, które mogą być podejmowane przez wątki, które uzyskują dostęp do synchronizowanych obiektów:</span><span class="sxs-lookup"><span data-stu-id="340b3-120">The following table describes the actions that can be taken by threads that access synchronized objects:</span></span>  
  
|<span data-ttu-id="340b3-121">Akcja</span><span class="sxs-lookup"><span data-stu-id="340b3-121">Action</span></span>|<span data-ttu-id="340b3-122">Opis</span><span class="sxs-lookup"><span data-stu-id="340b3-122">Description</span></span>|  
|------------|-----------------|  
|<span data-ttu-id="340b3-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span><span class="sxs-lookup"><span data-stu-id="340b3-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span></span>|<span data-ttu-id="340b3-124">Uzyskuje blokadę dla obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-124">Acquires a lock for an object.</span></span> <span data-ttu-id="340b3-125">Ta akcja oznacza również początek sekcji krytycznej.</span><span class="sxs-lookup"><span data-stu-id="340b3-125">This action also marks the beginning of a critical section.</span></span> <span data-ttu-id="340b3-126">Żaden inny wątek nie może wejść do sekcji krytycznej, chyba że wykonuje instrukcje w sekcji krytycznej przy użyciu innego zablokowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-126">No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</span></span>|  
|<xref:System.Threading.Monitor.Wait%2A>|<span data-ttu-id="340b3-127">Zwalnia blokadę obiektu w celu zezwolenia innym wątkom na zablokowanie i uzyskanie dostępu do obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-127">Releases the lock on an object in order to permit other threads to lock and access the object.</span></span> <span data-ttu-id="340b3-128">Wątek wywołujący czeka, gdy inny wątek uzyskuje dostęp do obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-128">The calling thread waits while another thread accesses the object.</span></span> <span data-ttu-id="340b3-129">Sygnały pulsu służą do powiadamiania oczekujących wątków o zmianach stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-129">Pulse signals are used to notify waiting threads about changes to an object's state.</span></span>|  
|<span data-ttu-id="340b3-130"><xref:System.Threading.Monitor.Pulse%2A>(sygnał),<xref:System.Threading.Monitor.PulseAll%2A></span><span class="sxs-lookup"><span data-stu-id="340b3-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span></span>|<span data-ttu-id="340b3-131">Wysyła sygnał do co najmniej jednego oczekującego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-131">Sends a signal to one or more waiting threads.</span></span> <span data-ttu-id="340b3-132">Sygnał powiadamia wątek oczekujący, że stan zablokowanego obiektu został zmieniony, a właściciel blokady jest gotowy do zwolnienia blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-132">The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</span></span> <span data-ttu-id="340b3-133">Wątek oczekujący jest umieszczany w kolejce gotowości obiektu, tak aby mógł ostatecznie odebrać blokadę dla obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-133">The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</span></span> <span data-ttu-id="340b3-134">Gdy wątek ma blokadę, może sprawdzić nowy stan obiektu, aby sprawdzić, czy wymagany stan został osiągnięty.</span><span class="sxs-lookup"><span data-stu-id="340b3-134">Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</span></span>|  
|<xref:System.Threading.Monitor.Exit%2A>|<span data-ttu-id="340b3-135">Zwalnia blokadę obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-135">Releases the lock on an object.</span></span> <span data-ttu-id="340b3-136">Ta akcja oznacza również koniec sekcji krytycznej chronionej przez zablokowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="340b3-136">This action also marks the end of a critical section protected by the locked object.</span></span>|  
  
 <span data-ttu-id="340b3-137">Począwszy od <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.TryEnter%2A> , istnieją dwa zestawy przeciążenia dla metod i. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="340b3-137">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods.</span></span> <span data-ttu-id="340b3-138">Jeden zbiór przeciążeń ma `ref` parametr ( C#in) `ByRef` lub (w Visual Basic <xref:System.Boolean> ), który jest niepodzielnie `true` ustawiony na wartość, jeśli zaznaczono blokadę, nawet jeśli wystąpi wyjątek podczas uzyskiwania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-138">One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock.</span></span> <span data-ttu-id="340b3-139">Użyj tych przeciążeń, jeśli ma krytyczne znaczenie dla zwolnienia blokady we wszystkich przypadkach, nawet jeśli zasoby, które są chronione przez blokadę, mogą nie być w spójnym stanie.</span><span class="sxs-lookup"><span data-stu-id="340b3-139">Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</span></span>  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a><span data-ttu-id="340b3-140">Obiekt blokady</span><span class="sxs-lookup"><span data-stu-id="340b3-140">The lock object</span></span>  
 <span data-ttu-id="340b3-141">Klasa monitora składa się `static` z metod C#(in `Shared` ) lub (w Visual Basic), które działają na obiekcie, który kontroluje dostęp do sekcji krytycznej.</span><span class="sxs-lookup"><span data-stu-id="340b3-141">The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.</span></span>  <span data-ttu-id="340b3-142">Dla każdego synchronizowanego obiektu są utrzymywane następujące informacje:</span><span class="sxs-lookup"><span data-stu-id="340b3-142">The following information is maintained for each synchronized object:</span></span>  
  
-   <span data-ttu-id="340b3-143">Odwołanie do wątku, w którym aktualnie znajduje się blokada.</span><span class="sxs-lookup"><span data-stu-id="340b3-143">A reference to the thread that currently holds the lock.</span></span>  
  
-   <span data-ttu-id="340b3-144">Odwołanie do kolejki gotowości, która zawiera wątki gotowe do uzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-144">A reference to a ready queue, which contains the threads that are ready to obtain the lock.</span></span>  
  
-   <span data-ttu-id="340b3-145">Odwołanie do oczekującej kolejki, która zawiera wątki czekające na powiadomienie zmiany stanu zablokowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-145">A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</span></span>  
  
 <span data-ttu-id="340b3-146"><xref:System.Threading.Monitor>blokuje obiekty (czyli typy odwołań), a nie typy wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-146"><xref:System.Threading.Monitor> locks objects (that is, reference types), not value types.</span></span> <span data-ttu-id="340b3-147">Można przekazać typ wartości do <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A>, jest on opakowany oddzielnie dla każdego wywołania.</span><span class="sxs-lookup"><span data-stu-id="340b3-147">While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call.</span></span> <span data-ttu-id="340b3-148">Ponieważ każde wywołanie tworzy oddzielny obiekt <xref:System.Threading.Monitor.Enter%2A> , nigdy nie bloki, a kod, który jest supposedly chroniący, nie jest w rzeczywistości synchronizowany.</span><span class="sxs-lookup"><span data-stu-id="340b3-148">Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized.</span></span> <span data-ttu-id="340b3-149">Ponadto obiekt przekazano do <xref:System.Threading.Monitor.Exit%2A> jest inny niż obiekt przekazano do <xref:System.Threading.Monitor.Enter%2A>, więc <xref:System.Threading.Monitor> zgłasza <xref:System.Threading.SynchronizationLockException> wyjątek z komunikatem "Metoda synchronizacji obiektów została wywołana z niezsynchronizowanego bloku kodu".</span><span class="sxs-lookup"><span data-stu-id="340b3-149">In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message "Object synchronization method was called from an unsynchronized block of code."</span></span>  
  
 <span data-ttu-id="340b3-150">Poniższy przykład ilustruje ten problem.</span><span class="sxs-lookup"><span data-stu-id="340b3-150">The following example illustrates this problem.</span></span> <span data-ttu-id="340b3-151">Uruchamia dziesięć zadań, z których każdy stanie się uśpiony przez 250 milisekund.</span><span class="sxs-lookup"><span data-stu-id="340b3-151">It launches ten tasks, each of which just sleeps for 250 milliseconds.</span></span> <span data-ttu-id="340b3-152">Każde zadanie aktualizuje zmienną `nTasks`licznika, która jest przeznaczona do policzania liczby zadań, które faktycznie zostały uruchomione i wykonane.</span><span class="sxs-lookup"><span data-stu-id="340b3-152">Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed.</span></span> <span data-ttu-id="340b3-153">Ponieważ `nTasks` jest zmienną globalną, która może być aktualizowana jednocześnie przez wiele zadań, monitor służy do ochrony przed jednoczesnymi modyfikacjami przez wiele zadań.</span><span class="sxs-lookup"><span data-stu-id="340b3-153">Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</span></span> <span data-ttu-id="340b3-154">Jednak dane wyjściowe z przykładu pokazują, że każdy z zadań zgłasza <xref:System.Threading.SynchronizationLockException> wyjątek.</span><span class="sxs-lookup"><span data-stu-id="340b3-154">However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 <span data-ttu-id="340b3-155">Każde zadanie zgłasza <xref:System.Threading.SynchronizationLockException> wyjątek, `nTasks` ponieważ zmienna jest opakowana <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> przed wywołaniem metody w każdym zadaniu.</span><span class="sxs-lookup"><span data-stu-id="340b3-155">Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method in each task.</span></span> <span data-ttu-id="340b3-156">Innymi słowy, każde wywołanie metody jest przekazanie oddzielnej zmiennej, która jest niezależna od innych.</span><span class="sxs-lookup"><span data-stu-id="340b3-156">In other words, each method call is passed a separate variable that is independent of the others.</span></span> <span data-ttu-id="340b3-157">`nTasks`jest ponownie opakowany w wywołaniu <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-157">`nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="340b3-158">Ponownie spowoduje to utworzenie dziesięciu nowych zmiennych opakowanych, które są niezależne od siebie, `nTasks`oraz dziesięciu zmiennych opakowanych utworzonych w wywołaniu <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-158">Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="340b3-159">Wyjątek jest zgłaszany, a następnie, ponieważ nasz kod próbuje zwolnić blokadę dla nowo utworzonej zmiennej, która nie została wcześniej zablokowana.</span><span class="sxs-lookup"><span data-stu-id="340b3-159">The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</span></span>  
  
 <span data-ttu-id="340b3-160">Chociaż można wpisać zmienną typu wartości przed wywołaniem <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A>, jak pokazano w poniższym przykładzie, i przekazać ten sam obiekt opakowany do obu tych metod, nie ma to żadnego znaczenia.</span><span class="sxs-lookup"><span data-stu-id="340b3-160">Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</span></span> <span data-ttu-id="340b3-161">Zmiany w zmiennej nieopakowanej nie są uwzględniane w kopii w ramce i nie ma sposobu zmiany wartości kopii w ramce.</span><span class="sxs-lookup"><span data-stu-id="340b3-161">Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 <span data-ttu-id="340b3-162">Podczas wybierania obiektu do synchronizowania należy zablokować tylko w obiektach prywatnych i wewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="340b3-162">When selecting an object on which to synchronize, you should lock only on private or internal objects.</span></span> <span data-ttu-id="340b3-163">Zablokowanie obiektów zewnętrznych może spowodować zakleszczenie, ponieważ niezwiązany kod może wybrać te same obiekty do zablokowania w różnych celach.</span><span class="sxs-lookup"><span data-stu-id="340b3-163">Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</span></span>  
  
 <span data-ttu-id="340b3-164">Należy pamiętać, że można synchronizować obiekt w wielu domenach aplikacji, jeśli obiekt używany do blokowania pochodzi od <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="340b3-164">Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a><span data-ttu-id="340b3-165">Sekcja krytyczna</span><span class="sxs-lookup"><span data-stu-id="340b3-165">The critical section</span></span>  
 <span data-ttu-id="340b3-166">Użyj metod <xref:System.Threading.Monitor.Exit%2A> i, aby oznaczyć początek i koniec sekcji krytycznej. <xref:System.Threading.Monitor.Enter%2A></span><span class="sxs-lookup"><span data-stu-id="340b3-166">Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-167">Funkcje zapewniane przez <xref:System.Threading.Monitor.Enter%2A> metody i <xref:System.Threading.Monitor.Exit%2A> są takie same jak podane przez instrukcję [Lock](~/docs/csharp/language-reference/keywords/lock-statement.md) w C# i instrukcji [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) w Visual Basic, z tą różnicą, że konstrukcja języka otacza <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType>Przeciążenie metody i <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> `try`metody w...`finally`</span><span class="sxs-lookup"><span data-stu-id="340b3-167">The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in a `try`…`finally`</span></span> <span data-ttu-id="340b3-168">Blokuj, aby upewnić się, że monitor został opublikowany.</span><span class="sxs-lookup"><span data-stu-id="340b3-168">block to ensure that the monitor is released.</span></span>  
  
 <span data-ttu-id="340b3-169">Jeśli Sekcja krytyczna jest zbiorem instrukcji ciągłych, blokada uzyskana przez <xref:System.Threading.Monitor.Enter%2A> metodę gwarantuje, że tylko jeden wątek może wykonać załączony kod z zablokowanym obiektem.</span><span class="sxs-lookup"><span data-stu-id="340b3-169">If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object.</span></span> <span data-ttu-id="340b3-170">W tym przypadku zalecamy umieszczenie tego kodu w `try` bloku i umieszczenie wywołania <xref:System.Threading.Monitor.Exit%2A> metody w `finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="340b3-170">In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block.</span></span> <span data-ttu-id="340b3-171">Gwarantuje to, że blokada zostanie wydana, nawet jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="340b3-171">This ensures that the lock is released even if an exception occurs.</span></span> <span data-ttu-id="340b3-172">Poniższy fragment kodu ilustruje ten wzorzec.</span><span class="sxs-lookup"><span data-stu-id="340b3-172">The following code fragment illustrates this pattern.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 <span data-ttu-id="340b3-173">Ta funkcja jest zwykle używana do synchronizowania dostępu do statycznej metody lub klasy wystąpień.</span><span class="sxs-lookup"><span data-stu-id="340b3-173">This facility is typically used to synchronize access to a static or instance method of a class.</span></span>  
  
 <span data-ttu-id="340b3-174">Jeśli Sekcja krytyczna obejmuje całą metodę, funkcję blokowania można osiągnąć, umieszczając ją <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> na metodzie i <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> określając <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>wartość w konstruktorze.</span><span class="sxs-lookup"><span data-stu-id="340b3-174">If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="340b3-175">W przypadku korzystania z <xref:System.Threading.Monitor.Enter%2A> tego atrybutu wywołania metod i <xref:System.Threading.Monitor.Exit%2A> nie są potrzebne.</span><span class="sxs-lookup"><span data-stu-id="340b3-175">When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed.</span></span> <span data-ttu-id="340b3-176">Poniższy fragment kodu ilustruje ten wzorzec:</span><span class="sxs-lookup"><span data-stu-id="340b3-176">The following code fragment illustrates this pattern:</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 <span data-ttu-id="340b3-177">Należy zauważyć, że ten atrybut powoduje, że bieżący wątek utrzymuje blokadę do momentu, gdy metoda zwróci wartość; Jeśli blokada może być wydawana wcześniej, należy użyć <xref:System.Threading.Monitor> klasy, C# instrukcji [Lock](~/docs/csharp/language-reference/keywords/lock-statement.md) lub instrukcji Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) wewnątrz metody zamiast atrybutu.</span><span class="sxs-lookup"><span data-stu-id="340b3-177">Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement, or the Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement inside of the method instead of the attribute.</span></span>  
  
 <span data-ttu-id="340b3-178">Chociaż można <xref:System.Threading.Monitor.Enter%2A> wykonać instrukcje i <xref:System.Threading.Monitor.Exit%2A> , które zablokują i zwalniają dany obiekt do granic składowych lub klas, lub obie te metody nie są zalecane.</span><span class="sxs-lookup"><span data-stu-id="340b3-178">While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</span></span>  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a><span data-ttu-id="340b3-179">Puls, PulseAll i Wait</span><span class="sxs-lookup"><span data-stu-id="340b3-179">Pulse, PulseAll, and Wait</span></span>  
 <span data-ttu-id="340b3-180">Gdy wątek jest właścicielem blokady i wprowadzono sekcję krytyczną, która jest chroniona przez blokadę, może wywołać <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>metody <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>,, <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> i.</span><span class="sxs-lookup"><span data-stu-id="340b3-180">Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="340b3-181">Gdy wątek, który przechowuje wywołania <xref:System.Threading.Monitor.Wait%2A>blokady, blokada zostaje wydana i wątek zostanie dodany do oczekującej kolejki synchronizowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-181">When the thread that holds the lock calls <xref:System.Threading.Monitor.Wait%2A>, the lock is released and the thread is added to the waiting queue of the synchronized object.</span></span> <span data-ttu-id="340b3-182">Pierwszy wątek w kolejce gotowości, jeśli istnieje, uzyskuje blokadę i wprowadza sekcję krytyczną.</span><span class="sxs-lookup"><span data-stu-id="340b3-182">The first thread in the ready queue, if any, acquires the lock and enters the critical section.</span></span> <span data-ttu-id="340b3-183">Wątek, który został <xref:System.Threading.Monitor.Wait%2A> wywołany, jest przenoszony z kolejki oczekujące do kolejki gotowości, <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> gdy <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> lub metoda jest wywoływana przez wątek, który przechowuje blokadę (do przeniesienia, wątek musi znajdować się na końcu kolejki oczekiwania).</span><span class="sxs-lookup"><span data-stu-id="340b3-183">The thread that called <xref:System.Threading.Monitor.Wait%2A> is moved from the waiting queue to the ready queue when either the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> or the <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> method is called by the thread that holds the lock (to be moved, the thread must be at the head of the waiting queue).</span></span> <span data-ttu-id="340b3-184"><xref:System.Threading.Monitor.Wait%2A> Metoda zwraca, gdy wątek wywołujący ponownie uzyskuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-184">The <xref:System.Threading.Monitor.Wait%2A> method returns when the calling thread reacquires the lock.</span></span>  
  
 <span data-ttu-id="340b3-185">Gdy wątek, który przechowuje wywołania <xref:System.Threading.Monitor.Pulse%2A>blokady, wątek w nagłówku oczekującej kolejki zostanie przeniesiony do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-185">When the thread that holds the lock calls <xref:System.Threading.Monitor.Pulse%2A>, the thread at the head of the waiting queue is moved to the ready queue.</span></span> <span data-ttu-id="340b3-186">Wywołanie <xref:System.Threading.Monitor.PulseAll%2A> metody przenosi wszystkie wątki z oczekującej kolejki do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-186">The call to the <xref:System.Threading.Monitor.PulseAll%2A> method moves all the threads from the waiting queue to the ready queue.</span></span>  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a><span data-ttu-id="340b3-187">Monitory i uchwyty oczekiwania</span><span class="sxs-lookup"><span data-stu-id="340b3-187">Monitors and wait handles</span></span>  
 <span data-ttu-id="340b3-188">Ważne jest, aby zauważyć rozróżnienie między użyciem <xref:System.Threading.Monitor> klasy i <xref:System.Threading.WaitHandle> obiektów.</span><span class="sxs-lookup"><span data-stu-id="340b3-188">It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.</span></span>  
  
-   <span data-ttu-id="340b3-189"><xref:System.Threading.Monitor> Klasa jest całkowicie zarządzana, w pełni przenośna i może być bardziej wydajna w zakresie wymagań dotyczących zasobów systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="340b3-189">The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</span></span>  
  
-   <span data-ttu-id="340b3-190"><xref:System.Threading.WaitHandle>obiekty reprezentują obiekty oczekiwane w systemie operacyjnym, są przydatne do synchronizowania kodu zarządzanego i niezarządzanego oraz uwidaczniają pewne zaawansowane funkcje systemu operacyjnego, takie jak możliwość oczekiwania na wiele obiektów jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="340b3-190"><xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="340b3-191">Poniższy przykład używa <xref:System.Threading.Monitor> klasy do synchronizowania dostępu do jednego wystąpienia generatora liczb losowych reprezentowanego <xref:System.Random> przez klasę.</span><span class="sxs-lookup"><span data-stu-id="340b3-191">The following example uses the <xref:System.Threading.Monitor> class to synchronize access to a single instance of a random number generator represented by the <xref:System.Random> class.</span></span> <span data-ttu-id="340b3-192">Przykład tworzy dziesięć zadań, z których każdy jest wykonywany asynchronicznie w wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="340b3-192">The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</span></span> <span data-ttu-id="340b3-193">Każde zadanie generuje liczbę losową 10 000, oblicza ich średnią i aktualizuje dwie zmienne na poziomie procedury, które utrzymują liczbę liczb losowych wygenerowanych i ich sumę.</span><span class="sxs-lookup"><span data-stu-id="340b3-193">Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</span></span> <span data-ttu-id="340b3-194">Po wykonaniu wszystkich zadań te dwie wartości są następnie używane do obliczania średniej.</span><span class="sxs-lookup"><span data-stu-id="340b3-194">After all tasks have executed, these two values are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="340b3-195">Ponieważ można uzyskać do nich dostęp z dowolnego zadania uruchomionego w wątku puli wątków, należy również zsynchronizować `total` dostęp `n` do zmiennych i.</span><span class="sxs-lookup"><span data-stu-id="340b3-195">Because they can be accessed from any task running on a thread pool thread, access to the variables `total` and `n` must also be synchronized.</span></span> <span data-ttu-id="340b3-196"><xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> Metoda jest używana do tego celu.</span><span class="sxs-lookup"><span data-stu-id="340b3-196">The <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method is used for this purpose.</span></span>  
  
 <span data-ttu-id="340b3-197">Poniższy przykład <xref:System.Threading.Monitor> demonstruje użycie klasy (zaimplementowane `lock` z lub `SyncLock` <xref:System.Threading.AutoResetEvent> konstrukcja języka), <xref:System.Threading.Interlocked> klasy i klasy.</span><span class="sxs-lookup"><span data-stu-id="340b3-197">The following example demonstrates the combined use of the <xref:System.Threading.Monitor> class (implemented with the `lock` or `SyncLock` language construct), the <xref:System.Threading.Interlocked> class, and the <xref:System.Threading.AutoResetEvent> class.</span></span> <span data-ttu-id="340b3-198">`internal` Definiuje dwie (w C#) lub `Friend` (w Visual Basic) klasy `SyncResource` i `UnSyncResource`, które odpowiednio zapewniają synchronizację i niezsynchronizowany dostęp do zasobu.</span><span class="sxs-lookup"><span data-stu-id="340b3-198">It defines two `internal` (in C#) or `Friend` (in Visual Basic) classes, `SyncResource` and `UnSyncResource`, that respectively provide synchronized and unsynchronized access to a resource.</span></span> <span data-ttu-id="340b3-199">Aby zapewnić, że przykład ilustruje różnicę między synchronizowanym i niezsynchronizowanym dostępem (może to być przypadek, jeśli każde wywołanie metody zostanie szybko zakończone), metoda obejmuje losowe opóźnienie: dla wątków, których <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> właściwość jest parzysta, wywołuje <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodę, aby wprowadzić opóźnienie 2 000 milisekund.</span><span class="sxs-lookup"><span data-stu-id="340b3-199">To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property is even, the method calls <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> to introduce a delay of 2,000 milliseconds.</span></span> <span data-ttu-id="340b3-200">Należy zauważyć, że ponieważ `SyncResource` Klasa nie jest publiczna, żaden kod klienta nie ma blokady w synchronizowanym zasobie; sama sama klasa przyjmuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-200">Note that, because the `SyncResource` class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</span></span> <span data-ttu-id="340b3-201">Zapobiega to zablokowaniu obiektu publicznego przez złośliwy kod.</span><span class="sxs-lookup"><span data-stu-id="340b3-201">This prevents malicious code from taking a lock on a public object.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 <span data-ttu-id="340b3-202">W przykładzie zdefiniowano zmienną, `numOps`która definiuje liczbę wątków, które będą próbować uzyskać dostęp do zasobu.</span><span class="sxs-lookup"><span data-stu-id="340b3-202">The example defines a variable, `numOps`, that defines the number of threads that will attempt to access the resource.</span></span> <span data-ttu-id="340b3-203">Wątek aplikacji wywołuje metodę, <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> aby zsynchronizować i niezsynchronizowany dostęp pięć razy każdy.</span><span class="sxs-lookup"><span data-stu-id="340b3-203">The application thread calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method for synchronized and unsynchronized access five times each.</span></span> <span data-ttu-id="340b3-204"><xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> Metoda ma jeden parametr, delegat, który nie akceptuje parametrów i nie zwraca żadnej wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-204">The <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method has a single parameter, a delegate that accepts no parameters and returns no value.</span></span> <span data-ttu-id="340b3-205">W przypadku dostępu zsynchronizowanego `SyncUpdateResource` metoda wywołuje metodę; w przypadku niezsynchronizowanego dostępu `UnSyncUpdateResource` wywołuje metodę.</span><span class="sxs-lookup"><span data-stu-id="340b3-205">For synchronized access, it invokes the `SyncUpdateResource` method; for unsynchronized access, it invokes the `UnSyncUpdateResource` method.</span></span> <span data-ttu-id="340b3-206">Po każdym zestawie wywołań metod wątek aplikacji wywołuje metodę [AutoResetEvent. WaitOne](xref:System.Threading.WaitHandle.WaitOne*) , aby blokowała do momentu <xref:System.Threading.AutoResetEvent> zasygnalizowania wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="340b3-206">After each set of method calls, the application thread calls the [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) method so that it blocks until the <xref:System.Threading.AutoResetEvent> instance is signaled.</span></span>  
  
 <span data-ttu-id="340b3-207">Każde wywołanie `SyncUpdateResource` metody `numOps` wywołuje `SyncResource.Access` metodę wewnętrzną, a następnie wywołuje metodęwceluzmniejszenialicznika.<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="340b3-207">Each call to the `SyncUpdateResource` method calls the internal `SyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="340b3-208"><xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Metoda jest używana do zmniejszania licznika, ponieważ w przeciwnym razie nie można mieć pewności, że drugi wątek będzie miał dostęp do wartości przed zapisaniem w zmiennej wartości w pierwszym wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-208">The <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</span></span> <span data-ttu-id="340b3-209">Gdy ostatni zsynchronizowany wątek roboczy zmniejsza licznik do zera, wskazując, że wszystkie zsynchronizowane wątki zakończyły uzyskiwanie dostępu do `SyncUpdateResource` zasobu, Metoda <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> wywołuje metodę, która sygnalizuje główny wątek, aby kontynuować działania.</span><span class="sxs-lookup"><span data-stu-id="340b3-209">When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the `SyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="340b3-210">Każde wywołanie `UnSyncUpdateResource` metody `numOps` wywołuje `UnSyncResource.Access` metodę wewnętrzną, a następnie wywołuje metodęwceluzmniejszenialicznika.<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="340b3-210">Each call to the `UnSyncUpdateResource` method calls the internal `UnSyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="340b3-211">Po ponownym <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> uruchomieniu Metoda jest używana do zmniejszenia licznika, aby upewnić się, że drugi wątek nie uzyskuje dostępu do wartości przed przypisaniem przez pierwszy wątek wartości do zmiennej.</span><span class="sxs-lookup"><span data-stu-id="340b3-211">Once again, the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</span></span> <span data-ttu-id="340b3-212">Kiedy ostatni niezsynchronizowany wątek roboczy zmniejsza licznik do zera, co oznacza, że nie ma więcej niezsynchronizowanych wątków potrzebnych do uzyskania dostępu do zasobu `UnSyncUpdateResource` , Metoda <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> wywołuje metodę, która sygnalizuje główny wątek, aby kontynuować wykonywanie .</span><span class="sxs-lookup"><span data-stu-id="340b3-212">When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the `UnSyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="340b3-213">Jak wynika z przykładu, zsynchronizowany dostęp gwarantuje, że wątek wywołujący opuszcza chroniony zasób, zanim inny wątek będzie mógł uzyskać do niego dostęp. Każdy wątek czeka na jego poprzednika.</span><span class="sxs-lookup"><span data-stu-id="340b3-213">As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</span></span> <span data-ttu-id="340b3-214">Z drugiej strony, bez blokady, `UnSyncResource.Access` Metoda jest wywoływana w kolejności, w której wątki docierają do niego.</span><span class="sxs-lookup"><span data-stu-id="340b3-214">On the other hand, without the lock, the `UnSyncResource.Access` method is called in the order in which threads reach it.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="340b3-215">Ten typ jest bezpieczny wątkowo.</span><span class="sxs-lookup"><span data-stu-id="340b3-215">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-216">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-216">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="340b3-217">Wątkowość obiektów i funkcji</span><span class="sxs-lookup"><span data-stu-id="340b3-217">Threading Objects and Features</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="340b3-218">Uzyskuje blokadę na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-218">Acquires an exclusive lock on a specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-219">Obiekt, na którym należy uzyskać blokadę monitora.</span><span class="sxs-lookup"><span data-stu-id="340b3-219">The object on which to acquire the monitor lock.</span></span></param>
        <summary><span data-ttu-id="340b3-220">Uzyskuje blokadę na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-220">Acquires an exclusive lock on the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-221">Użyj `Enter` , aby <xref:System.Threading.Monitor> uzyskać obiekt dla obiektu przesyłanego jako parametr.</span><span class="sxs-lookup"><span data-stu-id="340b3-221">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter.</span></span> <span data-ttu-id="340b3-222">Jeśli inny wątek `Enter` wykonał obiekt, ale nie wykonał jeszcze odpowiadającego <xref:System.Threading.Monitor.Exit%2A>, bieżący wątek zostanie zablokowany do momentu, gdy inny wątek zwolni obiekt.</span><span class="sxs-lookup"><span data-stu-id="340b3-222">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="340b3-223">Jest to dozwolone dla tego samego wątku, który `Enter` jest wywoływany więcej niż jeden raz bez blokowania, jednak taka `Exit` liczba wywołań musi być wywoływana, zanim inne wątki oczekujące na obiekt zostaną odblokowane.</span><span class="sxs-lookup"><span data-stu-id="340b3-223">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="340b3-224">Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-224">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="340b3-225">Gdy przekazujesz zmienną typu wartości do `Enter`, jest ona opakowana jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="340b3-225">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="340b3-226">Jeśli ta sama zmienna `Enter` zostanie przekazana ponownie, jest opakowana jako oddzielny obiekt, a wątek nie blokuje.</span><span class="sxs-lookup"><span data-stu-id="340b3-226">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="340b3-227">W takim przypadku kod `Monitor` supposedly ochronę nie jest chroniony.</span><span class="sxs-lookup"><span data-stu-id="340b3-227">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="340b3-228">Ponadto po przekazaniem zmiennej do `Exit`, nadal tworzony jest inny oddzielny obiekt.</span><span class="sxs-lookup"><span data-stu-id="340b3-228">Furthermore, when you pass the variable to `Exit`, still another separate object is created.</span></span> <span data-ttu-id="340b3-229">Ponieważ obiekt przeszedł do `Exit` jest inny niż obiekt przeszedł do `Enter`, `Monitor` zgłasza <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="340b3-229">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="340b3-230">Aby uzyskać więcej informacji, zobacz [Monitory](xref:System.Threading.Monitor)tematu koncepcyjnego.</span><span class="sxs-lookup"><span data-stu-id="340b3-230">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="340b3-231"><xref:System.Threading.Thread.Interrupt%2A>może przerywać wątki, które oczekują na `Monitor` wprowadzenie do obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-231"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="340b3-232"><xref:System.Threading.ThreadInterruptedException> Zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="340b3-232">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
 <span data-ttu-id="340b3-233">C# Użyj...`try``finally`</span><span class="sxs-lookup"><span data-stu-id="340b3-233">Use a C# `try`…`finally`</span></span> <span data-ttu-id="340b3-234">Blokuj (`Try`...`Finally`</span><span class="sxs-lookup"><span data-stu-id="340b3-234">block (`Try`…`Finally`</span></span> <span data-ttu-id="340b3-235">w Visual Basic), aby upewnić się, że monitor zostanie zwolniony lub C# `lock` Użyj instrukcji`SyncLock` (instrukcja w <xref:System.Threading.Monitor.Enter%2A> Visual Basic), która `try`zawija metody i <xref:System.Threading.Monitor.Exit%2A> w...`finally`</span><span class="sxs-lookup"><span data-stu-id="340b3-235">in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`…`finally`</span></span> <span data-ttu-id="340b3-236">odblokowan.</span><span class="sxs-lookup"><span data-stu-id="340b3-236">block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="340b3-237">Poniższy przykład ilustruje sposób używania `Enter` metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-237">The following example demonstrates how to use the `Enter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-238">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-238">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-239">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-239">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-240">Obiekt, na którym należy czekać.</span><span class="sxs-lookup"><span data-stu-id="340b3-240">The object on which to wait.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="340b3-241">Wynik próby uzyskania blokady, która została przeniesiona przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="340b3-241">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="340b3-242">Wartość wejściowa musi <see langword="false" />być.</span><span class="sxs-lookup"><span data-stu-id="340b3-242">The input must be <see langword="false" />.</span></span> <span data-ttu-id="340b3-243">Dane wyjściowe są <see langword="true" /> w przypadku pozyskania blokady; w przeciwnym razie dane <see langword="false" />wyjściowe to.</span><span class="sxs-lookup"><span data-stu-id="340b3-243">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="340b3-244">Dane wyjściowe są ustawiane nawet wtedy, gdy wystąpi wyjątek podczas próby uzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-244">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span>  
  
<span data-ttu-id="340b3-245">Zwróć uwagę, jeśli nie wystąpi żaden wyjątek, dane wyjściowe tej metody <see langword="true" />są zawsze.</span><span class="sxs-lookup"><span data-stu-id="340b3-245">Note   If no exception occurs, the output of this method is always <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="340b3-246">Uzyskuje blokadę na wyłączność dla określonego obiektu i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</span><span class="sxs-lookup"><span data-stu-id="340b3-246">Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-247">Użyj `Enter` , aby <xref:System.Threading.Monitor> uzyskać obiekt dla obiektu przesyłanego jako `obj` parametr.</span><span class="sxs-lookup"><span data-stu-id="340b3-247">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter.</span></span> <span data-ttu-id="340b3-248">Jeśli inny wątek `Enter` wykonał obiekt, ale nie wykonał jeszcze odpowiadającego <xref:System.Threading.Monitor.Exit%2A>, bieżący wątek zostanie zablokowany do momentu, gdy inny wątek zwolni obiekt.</span><span class="sxs-lookup"><span data-stu-id="340b3-248">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="340b3-249">Jest to dozwolone dla tego samego wątku, który `Enter` jest wywoływany więcej niż jeden raz bez blokowania, jednak taka `Exit` liczba wywołań musi być wywoływana, zanim inne wątki oczekujące na obiekt zostaną odblokowane.</span><span class="sxs-lookup"><span data-stu-id="340b3-249">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="340b3-250">Jeśli blokada nie została wykonana, ponieważ został zgłoszony wyjątek, zmienna określona dla `lockTaken` parametru jest `false` po zakończeniu tej metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-250">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="340b3-251">Dzięki temu program może określić, we wszystkich przypadkach, czy konieczne jest zwolnienie blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-251">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span> <span data-ttu-id="340b3-252">Jeśli ta metoda zwróci wartość bez zgłaszania wyjątku, zmienna określona dla `lockTaken` parametru jest zawsze `true`i nie ma potrzeby jej przetestowania.</span><span class="sxs-lookup"><span data-stu-id="340b3-252">If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.</span></span>  
  
 <span data-ttu-id="340b3-253">Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-253">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="340b3-254">Gdy przekazujesz zmienną typu wartości do `Enter`, jest ona opakowana jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="340b3-254">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="340b3-255">Jeśli ta sama zmienna `Enter` zostanie przekazana ponownie, jest opakowana jako oddzielny obiekt, a wątek nie blokuje.</span><span class="sxs-lookup"><span data-stu-id="340b3-255">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="340b3-256">W takim przypadku kod `Monitor` supposedly ochronę nie jest chroniony.</span><span class="sxs-lookup"><span data-stu-id="340b3-256">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="340b3-257">Ponadto podczas przekazywania zmiennej do `Exit`, tworzony jest inny oddzielny obiekt.</span><span class="sxs-lookup"><span data-stu-id="340b3-257">Furthermore, when you pass the variable to `Exit`, another separate object is created.</span></span> <span data-ttu-id="340b3-258">Ponieważ obiekt przeszedł do `Exit` jest inny niż obiekt przeszedł do `Enter`, `Monitor` zgłasza <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="340b3-258">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="340b3-259">Aby uzyskać więcej informacji, zobacz [Monitory](xref:System.Threading.Monitor)tematu koncepcyjnego.</span><span class="sxs-lookup"><span data-stu-id="340b3-259">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="340b3-260"><xref:System.Threading.Thread.Interrupt%2A>może przerywać wątki, które oczekują na `Monitor` wprowadzenie do obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-260"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="340b3-261"><xref:System.Threading.ThreadInterruptedException> Zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="340b3-261">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="340b3-262">Poniższy kod przedstawia podstawowy wzorzec używania <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-262">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="340b3-263">To Przeciążenie zawsze ustawia wartość zmiennej, która jest przenoszona do `ref` parametru (`ByRef` w Visual Basic) `lockTaken`, nawet jeśli metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodnym sposobem sprawdzenia, czy blokada musi być zwolni.</span><span class="sxs-lookup"><span data-stu-id="340b3-263">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="340b3-264">Dane wejściowe <paramref name="lockTaken" /> to <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="340b3-264">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-265">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-265">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-266">Obiekt, na którym ma zostać wydaną blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-266">The object on which to release the lock.</span></span></param>
        <summary><span data-ttu-id="340b3-267">Zwalnia blokadę na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-267">Releases an exclusive lock on the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-268">Wątek wywołujący musi być własnym blokadą dla `obj` parametru.</span><span class="sxs-lookup"><span data-stu-id="340b3-268">The calling thread must own the lock on the `obj` parameter.</span></span> <span data-ttu-id="340b3-269">Jeśli wątek wywołujący jest właścicielem blokady określonego obiektu i ma taką samą liczbę `Exit` wywołań i <xref:System.Threading.Monitor.Enter%2A> jest wywoływany dla tego obiektu, blokada zostanie wydana.</span><span class="sxs-lookup"><span data-stu-id="340b3-269">If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released.</span></span> <span data-ttu-id="340b3-270">Jeśli wątek wywołujący nie został wywołany `Exit` tyle razy jak `Enter`, blokada nie zostanie wydana.</span><span class="sxs-lookup"><span data-stu-id="340b3-270">If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.</span></span>  
  
 <span data-ttu-id="340b3-271">Jeśli blokada jest wydana i inne wątki znajdują się w kolejce gotowości dla obiektu, jeden z wątków uzyskuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-271">If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</span></span> <span data-ttu-id="340b3-272">Jeśli inne wątki znajdują się w oczekującej kolejce oczekiwania na uzyskanie blokady, nie są automatycznie przenoszone do kolejki gotowości, gdy właściciel wywołań `Exit`blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-272">If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`.</span></span> <span data-ttu-id="340b3-273">Aby przenieść jeden lub więcej oczekujących wątków do kolejki gotowości, <xref:System.Threading.Monitor.Pulse%2A> Wywołaj lub <xref:System.Threading.Monitor.PulseAll%2A> przed `Exit`wywołaniem.</span><span class="sxs-lookup"><span data-stu-id="340b3-273">To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="340b3-274">Poniższy przykład ilustruje sposób używania `Exit` metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-274">The following example demonstrates how to use the `Exit` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-275">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-275">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="340b3-276">Bieżący wątek nie jest obiektem blokady określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-276">The current thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-277">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-277">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-278">Obiekt do przetestowania.</span><span class="sxs-lookup"><span data-stu-id="340b3-278">The object to test.</span></span></param>
        <summary><span data-ttu-id="340b3-279">Określa, czy bieżący wątek przechowuje blokadę określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-279">Determines whether the current thread holds the lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="340b3-280"><see langword="true" />Jeśli bieżący wątek utrzymuje blokadę <paramref name="obj" />; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="340b3-280"><see langword="true" /> if the current thread holds the lock on <paramref name="obj" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-281">Ta metoda działa tylko w przypadku blokad, które są uzyskiwane przy użyciu metod <xref:System.Threading.Monitor> klasy lub C# `lock` instrukcji lub instrukcji Visual Basic `SyncLock` , które są implementowane z <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="340b3-281">This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="340b3-282">Użyj tej metody z narzędziami diagnostycznymi, takimi jak <xref:System.Diagnostics.Debug.Assert%2A> Metoda <xref:System.Diagnostics.Contracts.Contract> i Klasa, do debugowania problemów z <xref:System.Threading.Monitor> blokowaniem, które obejmują klasę.</span><span class="sxs-lookup"><span data-stu-id="340b3-282">Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-283"><paramref name="obj" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="340b3-283"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="340b3-284">Pobiera informacje o tym, ile razy wystąpił rywalizacja podczas próby przeprowadzenia blokady monitora.</span><span class="sxs-lookup"><span data-stu-id="340b3-284">Gets the number of times there was contention when trying to take the monitor's lock.</span></span></summary>
        <value><span data-ttu-id="340b3-285">Liczba przypadków rywalizacji podczas próby przeprowadzenia blokady monitora.</span><span class="sxs-lookup"><span data-stu-id="340b3-285">The number of times there was contention when trying to take the monitor's lock.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-286">Obiekt, dla którego jest oczekiwany wątek.</span><span class="sxs-lookup"><span data-stu-id="340b3-286">The object a thread is waiting for.</span></span></param>
        <summary><span data-ttu-id="340b3-287">Powiadamia wątek w kolejce oczekujące zmiany stanu zablokowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-287">Notifies a thread in the waiting queue of a change in the locked object's state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-288">Tylko bieżący właściciel blokady może sygnalizować obiekt oczekujący przy użyciu `Pulse`.</span><span class="sxs-lookup"><span data-stu-id="340b3-288">Only the current owner of the lock can signal a waiting object using `Pulse`.</span></span>  
  
 <span data-ttu-id="340b3-289">Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę, aby sygnalizować Następny wątek w wierszu dla blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-289">The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</span></span> <span data-ttu-id="340b3-290">Po odebraniu pulsu oczekujący wątek zostanie przeniesiony do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-290">Upon receiving the pulse, the waiting thread is moved to the ready queue.</span></span> <span data-ttu-id="340b3-291">Gdy wątek, który wywołał `Pulse` , zwalnia blokadę, Następny wątek w kolejce gotowości (który nie jest konieczny do wątku, który został impulsowo) uzyskuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-291">When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="340b3-292">Klasa nie utrzymuje stanu wskazującego <xref:System.Threading.Monitor.Pulse%2A> , że metoda została wywołana. <xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="340b3-292">The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called.</span></span> <span data-ttu-id="340b3-293">W tym przypadku, jeśli <xref:System.Threading.Monitor.Pulse%2A> wywołasz, gdy żaden wątek nie oczekuje, następnym wątku <xref:System.Threading.Monitor.Wait%2A> , który wywołuje <xref:System.Threading.Monitor.Pulse%2A> bloki, tak jakby nigdy nie został wywołany.</span><span class="sxs-lookup"><span data-stu-id="340b3-293">Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called.</span></span> <span data-ttu-id="340b3-294">Jeśli dwa wątki używają <xref:System.Threading.Monitor.Pulse%2A> i <xref:System.Threading.Monitor.Wait%2A> do działania, może to spowodować zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="340b3-294">If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock.</span></span> <span data-ttu-id="340b3-295">W przeciwieństwie do zachowania <xref:System.Threading.AutoResetEvent> klasy: W przypadku sygnalizowania <xref:System.Threading.AutoResetEvent> przez <xref:System.Threading.EventWaitHandle.Set%2A> wywołanie metody, gdy <xref:System.Threading.AutoResetEvent> nie ma żadnych wątków oczekujących, pozostaje w stanie zasygnalizowania do momentu wywołania <xref:System.Threading.WaitHandle.WaitOne%2A>wątku, <xref:System.Threading.WaitHandle.WaitAny%2A>, lub <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="340b3-295">Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="340b3-296"><xref:System.Threading.AutoResetEvent> Zwalnia ten wątek i powraca do stanu niesygnalizowanego.</span><span class="sxs-lookup"><span data-stu-id="340b3-296">The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.</span></span>  
  
 <span data-ttu-id="340b3-297">Należy zauważyć, że zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości zawierającej wątki, które są gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki czekające na powiadomienie zmiany stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-297">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="340b3-298">Metody `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A> i<xref:System.Threading.Monitor.Wait%2A> muszą być wywoływane z poziomu synchronizowanego bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="340b3-298">The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="340b3-299">Aby sygnalizować wiele wątków, użyj <xref:System.Threading.Monitor.PulseAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-299">To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-300">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-300">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="340b3-301">Wątek wywołujący nie jest obiektem blokady określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-301">The calling thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-302">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-302">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-303">Obiekt, który wysyła impuls.</span><span class="sxs-lookup"><span data-stu-id="340b3-303">The object that sends the pulse.</span></span></param>
        <summary><span data-ttu-id="340b3-304">Powiadamia wszystkie oczekujące wątki zmiany stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-304">Notifies all waiting threads of a change in the object's state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-305">Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę, aby sygnalizować wszystkie wątki oczekujące na uzyskanie blokady obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-305">The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</span></span> <span data-ttu-id="340b3-306">Po wysłaniu sygnału oczekujące wątki są przenoszone do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-306">After the signal is sent, the waiting threads are moved to the ready queue.</span></span> <span data-ttu-id="340b3-307">Gdy wątek wywoływany `PulseAll` przez program zwalnia blokadę, Następny wątek w kolejce gotowej uzyskuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-307">When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.</span></span>  
  
 <span data-ttu-id="340b3-308">Należy zauważyć, że zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości zawierającej wątki, które są gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki czekające na powiadomienie zmiany stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-308">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="340b3-309">Metody <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll` i<xref:System.Threading.Monitor.Wait%2A> muszą być wywoływane z poziomu synchronizowanego bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="340b3-309">The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="340b3-310">Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.</span><span class="sxs-lookup"><span data-stu-id="340b3-310">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 <span data-ttu-id="340b3-311">Aby sygnalizować pojedynczy wątek, użyj `Pulse` metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-311">To signal a single thread, use the `Pulse` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-312">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-312">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="340b3-313">Wątek wywołujący nie jest obiektem blokady określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-313">The calling thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-314">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-314">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="340b3-315">Próbuje uzyskać blokadę na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-315">Attempts to acquire an exclusive lock on the specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-316">Obiekt, na którym należy uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-316">The object on which to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="340b3-317">Próbuje uzyskać blokadę na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-317">Attempts to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="340b3-318"><see langword="true" />Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="340b3-318"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-319">Jeśli to się powiedzie, ta metoda uzyskuje blokadę `obj` na wyłączność dla parametru.</span><span class="sxs-lookup"><span data-stu-id="340b3-319">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="340b3-320">Ta metoda wraca natychmiast, niezależnie od tego, czy blokada jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="340b3-320">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="340b3-321">Ta metoda jest podobna do <xref:System.Threading.Monitor.Enter%2A>, ale nigdy nie blokuje bieżącego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-321">This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread.</span></span> <span data-ttu-id="340b3-322">Jeśli wątek nie może wejść bez blokowania, metoda zwraca `false,`.</span><span class="sxs-lookup"><span data-stu-id="340b3-322">If the thread cannot enter without blocking, the method returns `false,`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-323">Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-323">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="340b3-324">Aby uzyskać szczegółowe informacje, <xref:System.Threading.Monitor> Zobacz artykuł.</span><span class="sxs-lookup"><span data-stu-id="340b3-324">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="340b3-325">Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość zwracana `true`to.</span><span class="sxs-lookup"><span data-stu-id="340b3-325">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="340b3-326">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-326">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="340b3-327">Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="340b3-327">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="340b3-328">Poniższy przykład kodu demonstruje sposób używania `TryEnter` metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-328">The following code example demonstrates how to use the `TryEnter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-329">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-329">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-330">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-330">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-331">Obiekt, na którym należy uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-331">The object on which to acquire the lock.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="340b3-332">Wynik próby uzyskania blokady, która została przeniesiona przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="340b3-332">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="340b3-333">Wartość wejściowa musi <see langword="false" />być.</span><span class="sxs-lookup"><span data-stu-id="340b3-333">The input must be <see langword="false" />.</span></span> <span data-ttu-id="340b3-334">Dane wyjściowe są <see langword="true" /> w przypadku pozyskania blokady; w przeciwnym razie dane <see langword="false" />wyjściowe to.</span><span class="sxs-lookup"><span data-stu-id="340b3-334">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="340b3-335">Dane wyjściowe są ustawiane nawet wtedy, gdy wystąpi wyjątek podczas próby uzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-335">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="340b3-336">Próbuje uzyskać wyłączną blokadę określonego obiektu i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</span><span class="sxs-lookup"><span data-stu-id="340b3-336">Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-337">Jeśli to się powiedzie, ta metoda uzyskuje blokadę `obj` na wyłączność dla parametru.</span><span class="sxs-lookup"><span data-stu-id="340b3-337">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="340b3-338">Ta metoda wraca natychmiast, niezależnie od tego, czy blokada jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="340b3-338">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="340b3-339">Jeśli blokada nie została wykonana, ponieważ został zgłoszony wyjątek, zmienna określona dla `lockTaken` parametru jest `false` po zakończeniu tej metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-339">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="340b3-340">Dzięki temu program może określić, we wszystkich przypadkach, czy konieczne jest zwolnienie blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-340">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
 <span data-ttu-id="340b3-341">Ta metoda jest podobna do <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, ale nigdy nie blokuje bieżącego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-341">This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread.</span></span> <span data-ttu-id="340b3-342">Jeśli wątek nie może wejść bez blokowania, `lockTaken` argument jest ustawiany na `false` , gdy metoda zwraca.</span><span class="sxs-lookup"><span data-stu-id="340b3-342">If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-343">Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-343">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="340b3-344">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> artykuł.</span><span class="sxs-lookup"><span data-stu-id="340b3-344">For more information, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="340b3-345">Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość `lockTaken` i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość to. `true`</span><span class="sxs-lookup"><span data-stu-id="340b3-345">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="340b3-346">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-346">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="340b3-347">Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="340b3-347">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="340b3-348">Poniższy kod przedstawia podstawowy wzorzec używania <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-348">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="340b3-349">To Przeciążenie zawsze ustawia wartość zmiennej, która jest przenoszona do `ref` parametru (`ByRef` w Visual Basic) `lockTaken`, nawet jeśli metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodnym sposobem sprawdzenia, czy blokada musi być zwolni.</span><span class="sxs-lookup"><span data-stu-id="340b3-349">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="340b3-350">Dane wejściowe <paramref name="lockTaken" /> to <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="340b3-350">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-351">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-351">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-352">Obiekt, na którym należy uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-352">The object on which to acquire the lock.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="340b3-353">Liczba milisekund oczekiwania na blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-353">The number of milliseconds to wait for the lock.</span></span></param>
        <summary><span data-ttu-id="340b3-354">Próby dla określonej liczby milisekund w celu uzyskania blokady na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-354">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="340b3-355"><see langword="true" />Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="340b3-355"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-356">Jeśli parametr ma wartość <xref:System.Threading.Timeout.Infinite>, ta metoda jest równoważna <xref:System.Threading.Monitor.Enter%2A>z. `millisecondsTimeout`</span><span class="sxs-lookup"><span data-stu-id="340b3-356">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="340b3-357">Jeśli `millisecondsTimeout` jest równa 0, ta metoda jest <xref:System.Threading.Monitor.TryEnter%2A>równoważna z.</span><span class="sxs-lookup"><span data-stu-id="340b3-357">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-358">Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-358">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="340b3-359">Aby uzyskać szczegółowe informacje, <xref:System.Threading.Monitor> Zobacz artykuł.</span><span class="sxs-lookup"><span data-stu-id="340b3-359">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="340b3-360">Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość zwracana `true`to.</span><span class="sxs-lookup"><span data-stu-id="340b3-360">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="340b3-361">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-361">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="340b3-362">Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="340b3-362">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-363">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-363">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="340b3-364"><paramref name="millisecondsTimeout" />jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="340b3-364"><paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-365">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-365">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-366">Obiekt, na którym należy uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-366">The object on which to acquire the lock.</span></span></param>
        <param name="timeout"><span data-ttu-id="340b3-367"><see cref="T:System.TimeSpan" /> Reprezentująca ilość czasu oczekiwania na blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-367">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock.</span></span> <span data-ttu-id="340b3-368">Wartość-1 milisekunda określa nieskończony czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="340b3-368">A value of -1 millisecond specifies an infinite wait.</span></span></param>
        <summary><span data-ttu-id="340b3-369">Próby, przez określony czas, uzyskania blokady wyłącznej dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-369">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="340b3-370"><see langword="true" />Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="340b3-370"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-371">Jeśli wartość `timeout` parametru konwertowana na milisekundy jest równa-1, ta metoda jest równoważna <xref:System.Threading.Monitor.Enter%2A>z.</span><span class="sxs-lookup"><span data-stu-id="340b3-371">If the value of the `timeout` parameter converted to milliseconds equals -1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="340b3-372">Jeśli wartość `timeout` jest równa 0, ta metoda jest równoważna <xref:System.Threading.Monitor.TryEnter%2A>z.</span><span class="sxs-lookup"><span data-stu-id="340b3-372">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-373">Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-373">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="340b3-374">Aby uzyskać szczegółowe informacje, <xref:System.Threading.Monitor> Zobacz temat Klasa.</span><span class="sxs-lookup"><span data-stu-id="340b3-374">For details, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="340b3-375">Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość zwracana `true`to.</span><span class="sxs-lookup"><span data-stu-id="340b3-375">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="340b3-376">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-376">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="340b3-377">Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="340b3-377">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-378">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-378">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="340b3-379">Wartość <paramref name="timeout" /> w milisekundach jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa (-1 milisekund) lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="340b3-379">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-380">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-380">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-381">Obiekt, na którym należy uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-381">The object on which to acquire the lock.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="340b3-382">Liczba milisekund oczekiwania na blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-382">The number of milliseconds to wait for the lock.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="340b3-383">Wynik próby uzyskania blokady, która została przeniesiona przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="340b3-383">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="340b3-384">Wartość wejściowa musi <see langword="false" />być.</span><span class="sxs-lookup"><span data-stu-id="340b3-384">The input must be <see langword="false" />.</span></span> <span data-ttu-id="340b3-385">Dane wyjściowe są <see langword="true" /> w przypadku pozyskania blokady; w przeciwnym razie dane <see langword="false" />wyjściowe to.</span><span class="sxs-lookup"><span data-stu-id="340b3-385">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="340b3-386">Dane wyjściowe są ustawiane nawet wtedy, gdy wystąpi wyjątek podczas próby uzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-386">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="340b3-387">Próby, przez określoną liczbę milisekund, do uzyskania blokady na wyłączność określonego obiektu i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</span><span class="sxs-lookup"><span data-stu-id="340b3-387">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-388">Jeśli parametr ma wartość <xref:System.Threading.Timeout.Infinite>, ta metoda jest równoważna <xref:System.Threading.Monitor.Enter%28System.Object%29>z. `millisecondsTimeout`</span><span class="sxs-lookup"><span data-stu-id="340b3-388">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="340b3-389">Jeśli `millisecondsTimeout` jest równa 0, ta metoda jest <xref:System.Threading.Monitor.TryEnter%28System.Object%29>równoważna z.</span><span class="sxs-lookup"><span data-stu-id="340b3-389">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="340b3-390">Jeśli blokada nie została wykonana, ponieważ został zgłoszony wyjątek, zmienna określona dla `lockTaken` parametru jest `false` po zakończeniu tej metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-390">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="340b3-391">Dzięki temu program może określić, we wszystkich przypadkach, czy konieczne jest zwolnienie blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-391">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-392">Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-392">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="340b3-393">Aby uzyskać więcej informacji, zapoznaj się z <xref:System.Threading.Monitor> tematem klasy.</span><span class="sxs-lookup"><span data-stu-id="340b3-393">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="340b3-394">Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość `lockTaken` i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość to. `true`</span><span class="sxs-lookup"><span data-stu-id="340b3-394">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="340b3-395">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-395">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="340b3-396">Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="340b3-396">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="340b3-397">Poniższy kod przedstawia podstawowy wzorzec używania <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> przeciążenia metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-397">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="340b3-398">To Przeciążenie zawsze ustawia wartość zmiennej, która jest przenoszona do `ref` parametru (`ByRef` w Visual Basic) `lockTaken`, nawet jeśli metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodnym sposobem sprawdzenia, czy blokada musi być zwolni.</span><span class="sxs-lookup"><span data-stu-id="340b3-398">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="340b3-399">Dane wejściowe <paramref name="lockTaken" /> to <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="340b3-399">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-400">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-400">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="340b3-401"><paramref name="millisecondsTimeout" />jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="340b3-401"><paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-402">Obiekt, na którym należy uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-402">The object on which to acquire the lock.</span></span></param>
        <param name="timeout"><span data-ttu-id="340b3-403">Czas oczekiwania na blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-403">The amount of time to wait for the lock.</span></span> <span data-ttu-id="340b3-404">Wartość-1 milisekunda określa nieskończony czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="340b3-404">A value of -1 millisecond specifies an infinite wait.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="340b3-405">Wynik próby uzyskania blokady, która została przeniesiona przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="340b3-405">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="340b3-406">Wartość wejściowa musi <see langword="false" />być.</span><span class="sxs-lookup"><span data-stu-id="340b3-406">The input must be <see langword="false" />.</span></span> <span data-ttu-id="340b3-407">Dane wyjściowe są <see langword="true" /> w przypadku pozyskania blokady; w przeciwnym razie dane <see langword="false" />wyjściowe to.</span><span class="sxs-lookup"><span data-stu-id="340b3-407">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="340b3-408">Dane wyjściowe są ustawiane nawet wtedy, gdy wystąpi wyjątek podczas próby uzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-408">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="340b3-409">Próbuje, przez określony czas, uzyskać blokadę na wyłączność określonego obiektu i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</span><span class="sxs-lookup"><span data-stu-id="340b3-409">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-410">Jeśli wartość `timeout` parametru konwertowana na milisekundy jest równa-1, ta metoda jest równoważna <xref:System.Threading.Monitor.Enter%28System.Object%29>z.</span><span class="sxs-lookup"><span data-stu-id="340b3-410">If the value of the `timeout` parameter converted to milliseconds equals -1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="340b3-411">Jeśli wartość `timeout` jest równa 0, ta metoda jest równoważna <xref:System.Threading.Monitor.TryEnter%28System.Object%29>z.</span><span class="sxs-lookup"><span data-stu-id="340b3-411">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="340b3-412">Jeśli blokada nie została wykonana, ponieważ został zgłoszony wyjątek, zmienna określona dla `lockTaken` parametru jest `false` po zakończeniu tej metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-412">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="340b3-413">Dzięki temu program może określić, we wszystkich przypadkach, czy konieczne jest zwolnienie blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-413">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-414">Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="340b3-414">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="340b3-415">Aby uzyskać więcej informacji, zapoznaj się z <xref:System.Threading.Monitor> tematem klasy.</span><span class="sxs-lookup"><span data-stu-id="340b3-415">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="340b3-416">Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość `lockTaken` i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość to. `true`</span><span class="sxs-lookup"><span data-stu-id="340b3-416">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="340b3-417">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-417">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="340b3-418">Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="340b3-418">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="340b3-419">Dane wejściowe <paramref name="lockTaken" /> to <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="340b3-419">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-420">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-420">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="340b3-421">Wartość <paramref name="timeout" /> w milisekundach jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa (-1 milisekund) lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="340b3-421">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-422">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-422">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="340b3-423">Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-423">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-424">Obiekt, na którym należy czekać.</span><span class="sxs-lookup"><span data-stu-id="340b3-424">The object on which to wait.</span></span></param>
        <summary><span data-ttu-id="340b3-425">Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-425">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span></summary>
        <returns><span data-ttu-id="340b3-426"><see langword="true" />Jeśli wywołanie zostało zwrócone, ponieważ obiekt wywołujący odzyskuje blokadę dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-426"><see langword="true" /> if the call returned because the caller reacquired the lock for the specified object.</span></span> <span data-ttu-id="340b3-427">Ta metoda nie zwraca, jeśli blokada nie zostanie odbrana.</span><span class="sxs-lookup"><span data-stu-id="340b3-427">This method does not return if the lock is not reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-428">Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę w celu zwolnienia obiektu, tak aby inny wątek mógł uzyskać do niego dostęp.</span><span class="sxs-lookup"><span data-stu-id="340b3-428">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="340b3-429">Obiekt wywołujący jest zablokowany podczas oczekiwania na odzyskanie blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-429">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="340b3-430">Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmianę stanu, która zostanie wykonana w wyniku operacji innego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-430">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="340b3-431">Gdy wątek wywołuje `Wait`, zwalnia blokadę obiektu i przechodzi do oczekującej kolejki obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-431">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="340b3-432">Następny wątek w kolejce gotowości obiektu (jeśli istnieje) uzyskuje blokadę i ma wyłączny dostęp do obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-432">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="340b3-433">Wszystkie wątki, które `Wait` wywołują, pozostaną w kolejce oczekiwania do momentu <xref:System.Threading.Monitor.Pulse%2A> otrzymania <xref:System.Threading.Monitor.PulseAll%2A>sygnału z lub, wysyłane przez właściciela blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-433">All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock.</span></span> <span data-ttu-id="340b3-434">W `Pulse` przypadku wysłania tej zmiany dotyczy tylko wątku w kolejce oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="340b3-434">If `Pulse` is sent, only the thread at the head of the waiting queue is affected.</span></span> <span data-ttu-id="340b3-435">Jeśli `PulseAll` jest wysyłana, wpłynie to na wszystkie wątki, które oczekują na obiekt.</span><span class="sxs-lookup"><span data-stu-id="340b3-435">If `PulseAll` is sent, all threads that are waiting for the object are affected.</span></span> <span data-ttu-id="340b3-436">Po odebraniu sygnału co najmniej jeden wątek opuszcza oczekującą kolejkę i wprowadza gotową kolejkę.</span><span class="sxs-lookup"><span data-stu-id="340b3-436">When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</span></span> <span data-ttu-id="340b3-437">Wątek w kolejce gotowości jest dozwolony do odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-437">A thread in the ready queue is permitted to reacquire the lock.</span></span>  
  
 <span data-ttu-id="340b3-438">Ta metoda zwraca, gdy wątek wywołujący ponownie uzyskuje blokadę obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-438">This method returns when the calling thread reacquires the lock on the object.</span></span> <span data-ttu-id="340b3-439">Należy zauważyć, że ta metoda blokuje się w nieskończoność, jeśli posiadacz blokady nie `Pulse` wywołuje `PulseAll`lub.</span><span class="sxs-lookup"><span data-stu-id="340b3-439">Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.</span></span>  
  
 <span data-ttu-id="340b3-440">Obiekt wywołujący `Wait` jest wykonywany jednokrotnie, niezależnie od tego <xref:System.Threading.Monitor.Enter%2A> , ile razy został wywołany dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-440">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="340b3-441">Koncepcyjnie `Enter` `Exit` metoda przechowuje liczbę wywołanych przez obiekt wywołujący w obiekcie i wywołuje tyle razy, ile jest to konieczne, aby w pełni zwolnić zablokowany obiekt. `Wait`</span><span class="sxs-lookup"><span data-stu-id="340b3-441">Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="340b3-442">Obiekt wywołujący jest następnie blokowany podczas oczekiwania na ponowne uzyskanie obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-442">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="340b3-443">Gdy obiekt wywołujący ponownie uzyska blokadę, system wywoła `Enter` tyle razy, ile jest to konieczne, aby przywrócić zapisaną `Enter` liczbę dla obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="340b3-443">When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller.</span></span> <span data-ttu-id="340b3-444">Wywoływanie `Wait` zwalnia blokadę tylko dla określonego obiektu; Jeśli obiekt wywołujący jest właścicielem blokad dla innych obiektów, te blokady nie są zwalniane.</span><span class="sxs-lookup"><span data-stu-id="340b3-444">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
 <span data-ttu-id="340b3-445">Należy zauważyć, że zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości zawierającej wątki, które są gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki czekające na powiadomienie zmiany stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-445">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="340b3-446">Metody <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A> i`Wait` muszą być wywoływane z poziomu synchronizowanego bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="340b3-446">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="340b3-447">Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.</span><span class="sxs-lookup"><span data-stu-id="340b3-447">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-448">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-448">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="340b3-449">Wątek wywołujący nie jest obiektem blokady określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-449">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="340b3-450">Wątek, który wywołuje <see langword="Wait" /> , został później przerwany ze stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="340b3-450">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="340b3-451">Dzieje się tak, gdy inny wątek wywołuje <see cref="M:System.Threading.Thread.Interrupt" /> metodę tego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-451">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-452">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-452">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-453">Obiekt, na którym należy czekać.</span><span class="sxs-lookup"><span data-stu-id="340b3-453">The object on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="340b3-454">Liczba milisekund oczekiwania przed przejściem wątku do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-454">The number of milliseconds to wait before the thread enters the ready queue.</span></span></param>
        <summary><span data-ttu-id="340b3-455">Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-455">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="340b3-456">Jeśli upłynie określony interwał limitu czasu, wątek przechodzi do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-456">If the specified time-out interval elapses, the thread enters the ready queue.</span></span></summary>
        <returns><span data-ttu-id="340b3-457"><see langword="true" />Jeśli blokada została odbrana przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została odzyskania po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="340b3-457"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="340b3-458">Metoda nie zwraca do momentu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-458">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-459">Ta metoda nie zwraca do momentu odzyskania blokady wyłącznej na `obj` parametrze.</span><span class="sxs-lookup"><span data-stu-id="340b3-459">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="340b3-460">Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę w celu zwolnienia obiektu, tak aby inny wątek mógł uzyskać do niego dostęp.</span><span class="sxs-lookup"><span data-stu-id="340b3-460">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="340b3-461">Obiekt wywołujący jest zablokowany podczas oczekiwania na odzyskanie blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-461">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="340b3-462">Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmianę stanu, która zostanie wykonana w wyniku operacji innego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-462">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="340b3-463">Limit czasu zapewnia, że bieżący wątek nie blokuje się w nieskończoność, jeśli inny wątek zwolni blokadę bez uprzedniego wywołania <xref:System.Threading.Monitor.Pulse%2A> metody <xref:System.Threading.Monitor.PulseAll%2A> lub.</span><span class="sxs-lookup"><span data-stu-id="340b3-463">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="340b3-464">Przenosi również wątek do kolejki gotowości, pomijając inne wątki przed nim w kolejce oczekiwania, dzięki czemu może on ponownie uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-464">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="340b3-465">Wątek może testować wartość <xref:System.Threading.Monitor.Wait%2A> zwracaną metody, aby określić, czy odzyskuje blokadę przed upływem limitu czasu. Wątek może oszacować warunki, które spowodowały wprowadzenie oczekiwania, i w razie potrzeby ponownie wywołać <xref:System.Threading.Monitor.Wait%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="340b3-465">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="340b3-466">Gdy wątek wywołuje `Wait`, zwalnia blokadę obiektu i przechodzi do oczekującej kolejki obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-466">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="340b3-467">Następny wątek w kolejce gotowości obiektu (jeśli istnieje) uzyskuje blokadę i ma wyłączny dostęp do obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-467">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="340b3-468">Wywoływany `Wait` wątek pozostaje w kolejce oczekiwania do momentu, aż wątek, który przechowuje <xref:System.Threading.Monitor.PulseAll%2A>blokadę, lub jest następnym w kolejce i wątek <xref:System.Threading.Monitor.Pulse%2A>, który przechowuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-468">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="340b3-469">Jeśli `millisecondsTimeout` jednak upłynie, zanim inny wątek wywoła ten <xref:System.Threading.Monitor.Pulse%2A> obiekt lub <xref:System.Threading.Monitor.PulseAll%2A> metodę, oryginalny wątek zostanie przeniesiony do kolejki gotowości w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-469">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-470">Jeśli <xref:System.Threading.Timeout.Infinite> jest określony `millisecondsTimeout` dla parametru, ta metoda blokuje się w nieskończoność, chyba że posiadacz wywołań <xref:System.Threading.Monitor.Pulse%2A> Lock lub <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="340b3-470">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="340b3-471">Jeśli `millisecondsTimeout` wartość jest równa 0, wątek `Wait` , który wywołuje zwalnia blokadę, a następnie natychmiast wprowadza gotową kolejkę do odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-471">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="340b3-472">Obiekt wywołujący `Wait` jest wykonywany jednokrotnie, niezależnie od tego <xref:System.Threading.Monitor.Enter%2A> , ile razy został wywołany dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-472">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="340b3-473">Koncepcyjnie <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.Exit%2A> metoda przechowuje liczbę wywołanych przez obiekt wywołujący w obiekcie i wywołuje tyle razy, ile jest to konieczne, aby w pełni zwolnić zablokowany obiekt. `Wait`</span><span class="sxs-lookup"><span data-stu-id="340b3-473">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="340b3-474">Obiekt wywołujący jest następnie blokowany podczas oczekiwania na ponowne uzyskanie obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-474">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="340b3-475">Gdy obiekt wywołujący ponownie uzyska blokadę, system wywoła <xref:System.Threading.Monitor.Enter%2A> tyle razy, ile jest to konieczne, aby przywrócić zapisaną <xref:System.Threading.Monitor.Enter%2A> liczbę dla obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="340b3-475">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="340b3-476">Wywoływanie `Wait` zwalnia blokadę tylko dla określonego obiektu; Jeśli obiekt wywołujący jest właścicielem blokad dla innych obiektów, te blokady nie są zwalniane.</span><span class="sxs-lookup"><span data-stu-id="340b3-476">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-477">Zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości, która zawiera wątki gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki, które oczekują na powiadomienie o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-477">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="340b3-478">Metody <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A> i`Wait` muszą być wywoływane z poziomu synchronizowanego bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="340b3-478">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="340b3-479">Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.</span><span class="sxs-lookup"><span data-stu-id="340b3-479">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-480">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-480">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="340b3-481">Wątek wywołujący nie jest obiektem blokady określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-481">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="340b3-482">Wątek, który wywołuje <see langword="Wait" /> , został później przerwany ze stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="340b3-482">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="340b3-483">Dzieje się tak, gdy inny wątek wywołuje <see cref="M:System.Threading.Thread.Interrupt" /> metodę tego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-483">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="340b3-484">Wartość <paramref name="millisecondsTimeout" /> parametru jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" />równa.</span><span class="sxs-lookup"><span data-stu-id="340b3-484">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-485">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-485">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-486">Obiekt, na którym należy czekać.</span><span class="sxs-lookup"><span data-stu-id="340b3-486">The object on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="340b3-487"><see cref="T:System.TimeSpan" /> Reprezentująca ilość czasu oczekiwania przed przejściem wątku do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-487">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span></span></param>
        <summary><span data-ttu-id="340b3-488">Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-488">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="340b3-489">Jeśli upłynie określony interwał limitu czasu, wątek przechodzi do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-489">If the specified time-out interval elapses, the thread enters the ready queue.</span></span></summary>
        <returns><span data-ttu-id="340b3-490"><see langword="true" />Jeśli blokada została odbrana przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została odzyskania po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="340b3-490"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="340b3-491">Metoda nie zwraca do momentu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-491">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-492">Ta metoda nie zwraca do momentu odzyskania blokady wyłącznej na `obj` parametrze.</span><span class="sxs-lookup"><span data-stu-id="340b3-492">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="340b3-493">Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę w celu zwolnienia obiektu, tak aby inny wątek mógł uzyskać do niego dostęp.</span><span class="sxs-lookup"><span data-stu-id="340b3-493">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="340b3-494">Obiekt wywołujący jest zablokowany podczas oczekiwania na odzyskanie blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-494">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="340b3-495">Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmianę stanu, która zostanie wykonana w wyniku operacji innego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-495">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="340b3-496">Limit czasu zapewnia, że bieżący wątek nie blokuje się w nieskończoność, jeśli inny wątek zwolni blokadę bez uprzedniego wywołania <xref:System.Threading.Monitor.Pulse%2A> metody <xref:System.Threading.Monitor.PulseAll%2A> lub.</span><span class="sxs-lookup"><span data-stu-id="340b3-496">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="340b3-497">Przenosi również wątek do kolejki gotowości, pomijając inne wątki przed nim w kolejce oczekiwania, dzięki czemu może on ponownie uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-497">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="340b3-498">Wątek może testować wartość <xref:System.Threading.Monitor.Wait%2A> zwracaną metody, aby określić, czy odzyskuje blokadę przed upływem limitu czasu. Wątek może oszacować warunki, które spowodowały wprowadzenie oczekiwania, i w razie potrzeby ponownie wywołać <xref:System.Threading.Monitor.Wait%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="340b3-498">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="340b3-499">Gdy wątek wywołuje `Wait`, zwalnia blokadę obiektu i przechodzi do oczekującej kolejki obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-499">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="340b3-500">Następny wątek w kolejce gotowości obiektu (jeśli istnieje) uzyskuje blokadę i ma wyłączny dostęp do obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-500">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="340b3-501">Wywoływany `Wait` wątek pozostaje w kolejce oczekiwania do momentu, aż wątek, który przechowuje <xref:System.Threading.Monitor.PulseAll%2A>blokadę, lub jest następnym w kolejce i wątek <xref:System.Threading.Monitor.Pulse%2A>, który przechowuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-501">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="340b3-502">Jeśli `timeout` jednak upłynie, zanim inny wątek wywoła ten <xref:System.Threading.Monitor.Pulse%2A> obiekt lub <xref:System.Threading.Monitor.PulseAll%2A> metodę, oryginalny wątek zostanie przeniesiony do kolejki gotowości w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-502">However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-503">Jeśli <xref:System.TimeSpan> <xref:System.Threading.Monitor.Pulse%2A> dla parametru określono wartość-1 milisekunda, ta metoda blokuje się w nieskończoność, chyba że jest on posiadaczem wywołań <xref:System.Threading.Monitor.PulseAll%2A>blokady lub. `timeout`</span><span class="sxs-lookup"><span data-stu-id="340b3-503">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="340b3-504">Jeśli `timeout` wartość wynosi 0 milisekund, wątek wywołujący `Wait` uwalnianie blokady, a następnie natychmiast wprowadza gotową kolejkę do odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-504">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="340b3-505">Obiekt wywołujący `Wait` jest wykonywany jednokrotnie, niezależnie od tego <xref:System.Threading.Monitor.Enter%2A> , ile razy został wywołany dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-505">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="340b3-506">Koncepcyjnie <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.Exit%2A> metoda przechowuje liczbę wywołanych przez obiekt wywołujący w obiekcie i wywołuje tyle razy, ile jest to konieczne, aby w pełni zwolnić zablokowany obiekt. `Wait`</span><span class="sxs-lookup"><span data-stu-id="340b3-506">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="340b3-507">Obiekt wywołujący jest następnie blokowany podczas oczekiwania na ponowne uzyskanie obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-507">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="340b3-508">Gdy obiekt wywołujący ponownie uzyska blokadę, system wywoła <xref:System.Threading.Monitor.Enter%2A> tyle razy, ile jest to konieczne, aby przywrócić zapisaną <xref:System.Threading.Monitor.Enter%2A> liczbę dla obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="340b3-508">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="340b3-509">Wywoływanie `Wait` zwalnia blokadę tylko dla określonego obiektu; Jeśli obiekt wywołujący jest właścicielem blokad dla innych obiektów, te blokady nie są zwalniane.</span><span class="sxs-lookup"><span data-stu-id="340b3-509">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-510">Zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości, która zawiera wątki gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki, które oczekują na powiadomienie o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-510">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="340b3-511">Metody <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A> i`Wait` muszą być wywoływane z poziomu synchronizowanego bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="340b3-511">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="340b3-512">Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.</span><span class="sxs-lookup"><span data-stu-id="340b3-512">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-513">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-513">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="340b3-514">Wątek wywołujący nie jest obiektem blokady określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-514">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="340b3-515">Wątek, który wywołuje <see langword="Wait" /> , został później przerwany ze stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="340b3-515">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="340b3-516">Dzieje się tak, gdy inny wątek wywołuje <see cref="M:System.Threading.Thread.Interrupt" /> metodę tego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-516">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="340b3-517">Wartość <paramref name="timeout" /> parametru w milisekundach jest ujemna i nie reprezentuje <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekund) lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="340b3-517">The value of the <paramref name="timeout" /> parameter in milliseconds is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-518">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-518">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-519">Obiekt, na którym należy czekać.</span><span class="sxs-lookup"><span data-stu-id="340b3-519">The object on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="340b3-520">Liczba milisekund oczekiwania przed przejściem wątku do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-520">The number of milliseconds to wait before the thread enters the ready queue.</span></span></param>
        <param name="exitContext"><span data-ttu-id="340b3-521"><see langword="true" />Aby wyjść i ponownie uzyskać domenę synchronizacji dla kontekstu (jeśli znajduje się w synchronizowanym kontekście) przed oczekiwaniem; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="340b3-521"><see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="340b3-522">Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-522">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="340b3-523">Jeśli upłynie określony interwał limitu czasu, wątek przechodzi do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-523">If the specified time-out interval elapses, the thread enters the ready queue.</span></span> <span data-ttu-id="340b3-524">Ta metoda określa również, czy domena synchronizacji kontekstu (Jeśli w synchronizowanym kontekście) zostanie zakończona przed zaczekaniem i ponownym pozyskaniem.</span><span class="sxs-lookup"><span data-stu-id="340b3-524">This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</span></span></summary>
        <returns><span data-ttu-id="340b3-525"><see langword="true" />Jeśli blokada została odbrana przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została odzyskania po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="340b3-525"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="340b3-526">Metoda nie zwraca do momentu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-526">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-527">Ta metoda nie zwraca do momentu odzyskania blokady wyłącznej na `obj` parametrze.</span><span class="sxs-lookup"><span data-stu-id="340b3-527">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="340b3-528">Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę w celu zwolnienia obiektu, tak aby inny wątek mógł uzyskać do niego dostęp.</span><span class="sxs-lookup"><span data-stu-id="340b3-528">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="340b3-529">Obiekt wywołujący jest zablokowany podczas oczekiwania na odzyskanie blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-529">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="340b3-530">Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmianę stanu, która zostanie wykonana w wyniku operacji innego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-530">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="340b3-531">Limit czasu zapewnia, że bieżący wątek nie blokuje się w nieskończoność, jeśli inny wątek zwolni blokadę bez uprzedniego wywołania <xref:System.Threading.Monitor.Pulse%2A> metody <xref:System.Threading.Monitor.PulseAll%2A> lub.</span><span class="sxs-lookup"><span data-stu-id="340b3-531">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="340b3-532">Przenosi również wątek do kolejki gotowości, pomijając inne wątki przed nim w kolejce oczekiwania, dzięki czemu może on ponownie uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-532">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="340b3-533">Wątek może testować wartość <xref:System.Threading.Monitor.Wait%2A> zwracaną metody, aby określić, czy odzyskuje blokadę przed upływem limitu czasu. Wątek może oszacować warunki, które spowodowały wprowadzenie oczekiwania, i w razie potrzeby ponownie wywołać <xref:System.Threading.Monitor.Wait%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="340b3-533">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="340b3-534">Gdy wątek wywołuje `Wait`, zwalnia blokadę i przechodzi do oczekującej kolejki.</span><span class="sxs-lookup"><span data-stu-id="340b3-534">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="340b3-535">W tym momencie następnym wątkiem w kolejce gotowości (jeśli istnieje) można przejąć kontrolę nad blokadą.</span><span class="sxs-lookup"><span data-stu-id="340b3-535">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="340b3-536">Wywoływany `Wait` wątek pozostaje w kolejce oczekiwania do momentu, aż wątek, który przechowuje <xref:System.Threading.Monitor.PulseAll%2A>blokadę, lub jest następnym w kolejce i wątek <xref:System.Threading.Monitor.Pulse%2A>, który przechowuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-536">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="340b3-537">Jeśli `millisecondsTimeout` jednak upłynie, zanim inny wątek wywoła ten <xref:System.Threading.Monitor.Pulse%2A> obiekt lub <xref:System.Threading.Monitor.PulseAll%2A> metodę, oryginalny wątek zostanie przeniesiony do kolejki gotowości w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-537">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-538">Jeśli <xref:System.Threading.Timeout.Infinite> jest określony `millisecondsTimeout` dla parametru, ta metoda blokuje się w nieskończoność, chyba że posiadacz wywołań <xref:System.Threading.Monitor.Pulse%2A> Lock lub <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="340b3-538">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="340b3-539">Jeśli `millisecondsTimeout` wartość jest równa 0, wątek `Wait` , który wywołuje zwalnia blokadę, a następnie natychmiast wprowadza gotową kolejkę do odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-539">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="340b3-540">Obiekt wywołujący `Wait` jest wykonywany jednokrotnie, niezależnie od tego <xref:System.Threading.Monitor.Enter%2A> , ile razy został wywołany dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-540">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="340b3-541">Koncepcyjnie <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.Exit%2A> metoda przechowuje liczbę wywołanych przez obiekt wywołujący w obiekcie i wywołuje tyle razy, ile jest to konieczne, aby w pełni zwolnić zablokowany obiekt. `Wait`</span><span class="sxs-lookup"><span data-stu-id="340b3-541">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="340b3-542">Obiekt wywołujący jest następnie blokowany podczas oczekiwania na ponowne uzyskanie obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-542">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="340b3-543">Gdy obiekt wywołujący ponownie uzyska blokadę, system wywoła <xref:System.Threading.Monitor.Enter%2A> tyle razy, ile jest to konieczne, aby przywrócić zapisaną <xref:System.Threading.Monitor.Enter%2A> liczbę dla obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="340b3-543">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="340b3-544">Wywoływanie `Wait` zwalnia blokadę tylko dla określonego obiektu; Jeśli obiekt wywołujący jest właścicielem blokad dla innych obiektów, te blokady nie są zwalniane.</span><span class="sxs-lookup"><span data-stu-id="340b3-544">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-545">Zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości, która zawiera wątki gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki, które oczekują na powiadomienie o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-545">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="340b3-546">Metody <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A> i`Wait` muszą być wywoływane z poziomu synchronizowanego bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="340b3-546">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="340b3-547">Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.</span><span class="sxs-lookup"><span data-stu-id="340b3-547">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="340b3-548">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="340b3-548">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="340b3-549">Parametr nie działa, <xref:System.Threading.Monitor.Wait%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego.`exitContext`</span><span class="sxs-lookup"><span data-stu-id="340b3-549">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="340b3-550">Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="340b3-550">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="340b3-551">Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="340b3-551">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="340b3-552">Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.Monitor.Wait%2A> kontekstu) przed wykonaniem metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-552">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="340b3-553">Powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.Monitor.Wait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-553">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="340b3-554">Może to być przydatne, gdy klasa związana z kontekstem ma <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> zastosowany atrybut.</span><span class="sxs-lookup"><span data-stu-id="340b3-554">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="340b3-555">W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy.</span><span class="sxs-lookup"><span data-stu-id="340b3-555">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="340b3-556">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.Monitor.Wait%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="340b3-556">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="340b3-557"><xref:System.Threading.Monitor.Wait%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="340b3-557">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-558">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-558">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="340b3-559"><see langword="Wait" />nie jest wywoływany z poziomu synchronizowanego bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="340b3-559"><see langword="Wait" /> is not invoked from within a synchronized block of code.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="340b3-560">Wątek, który wywołuje <see langword="Wait" /> , został później przerwany ze stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="340b3-560">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="340b3-561">Dzieje się tak, gdy inny wątek wywołuje <see cref="M:System.Threading.Thread.Interrupt" /> metodę tego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-561">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="340b3-562">Wartość <paramref name="millisecondsTimeout" /> parametru jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" />równa.</span><span class="sxs-lookup"><span data-stu-id="340b3-562">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-563">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-563">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="340b3-564">Obiekt, na którym należy czekać.</span><span class="sxs-lookup"><span data-stu-id="340b3-564">The object on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="340b3-565"><see cref="T:System.TimeSpan" /> Reprezentująca ilość czasu oczekiwania przed przejściem wątku do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-565">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span></span></param>
        <param name="exitContext"><span data-ttu-id="340b3-566"><see langword="true" />Aby wyjść i ponownie uzyskać domenę synchronizacji dla kontekstu (jeśli znajduje się w synchronizowanym kontekście) przed oczekiwaniem; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="340b3-566"><see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="340b3-567">Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-567">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="340b3-568">Jeśli upłynie określony interwał limitu czasu, wątek przechodzi do kolejki gotowości.</span><span class="sxs-lookup"><span data-stu-id="340b3-568">If the specified time-out interval elapses, the thread enters the ready queue.</span></span> <span data-ttu-id="340b3-569">Opcjonalnie zamyka domenę synchronizacji dla kontekstu synchronizowanego przed oczekiwaniem i ponownie uzyskuje domenę.</span><span class="sxs-lookup"><span data-stu-id="340b3-569">Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</span></span></summary>
        <returns><span data-ttu-id="340b3-570"><see langword="true" />Jeśli blokada została odbrana przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została odzyskania po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="340b3-570"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="340b3-571">Metoda nie zwraca do momentu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-571">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="340b3-572">Ta metoda nie zwraca do momentu odzyskania blokady wyłącznej na `obj` parametrze.</span><span class="sxs-lookup"><span data-stu-id="340b3-572">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="340b3-573">Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę w celu zwolnienia obiektu, tak aby inny wątek mógł uzyskać do niego dostęp.</span><span class="sxs-lookup"><span data-stu-id="340b3-573">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="340b3-574">Obiekt wywołujący jest zablokowany podczas oczekiwania na odzyskanie blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-574">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="340b3-575">Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmianę stanu, która zostanie wykonana w wyniku operacji innego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-575">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="340b3-576">Limit czasu zapewnia, że bieżący wątek nie blokuje się w nieskończoność, jeśli inny wątek zwolni blokadę bez uprzedniego wywołania <xref:System.Threading.Monitor.Pulse%2A> metody <xref:System.Threading.Monitor.PulseAll%2A> lub.</span><span class="sxs-lookup"><span data-stu-id="340b3-576">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="340b3-577">Przenosi również wątek do kolejki gotowości, pomijając inne wątki przed nim w kolejce oczekiwania, dzięki czemu może on ponownie uzyskać blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-577">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="340b3-578">Wątek może testować wartość <xref:System.Threading.Monitor.Wait%2A> zwracaną metody, aby określić, czy odzyskuje blokadę przed upływem limitu czasu. Wątek może oszacować warunki, które spowodowały wprowadzenie oczekiwania, i w razie potrzeby ponownie wywołać <xref:System.Threading.Monitor.Wait%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="340b3-578">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="340b3-579">Gdy wątek wywołuje `Wait`, zwalnia blokadę i przechodzi do oczekującej kolejki.</span><span class="sxs-lookup"><span data-stu-id="340b3-579">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="340b3-580">W tym momencie następnym wątkiem w kolejce gotowości (jeśli istnieje) można przejąć kontrolę nad blokadą.</span><span class="sxs-lookup"><span data-stu-id="340b3-580">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="340b3-581">Wywoływany `Wait` wątek pozostaje w kolejce oczekiwania do momentu, aż wątek, który przechowuje <xref:System.Threading.Monitor.PulseAll%2A>blokadę, lub jest następnym w kolejce i wątek <xref:System.Threading.Monitor.Pulse%2A>, który przechowuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="340b3-581">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="340b3-582">Jeśli `timeout` jednak milisekundy upłynie, zanim inny wątek wywoła ten <xref:System.Threading.Monitor.Pulse%2A> obiekt lub <xref:System.Threading.Monitor.PulseAll%2A> metodę, oryginalny wątek zostanie przeniesiony do kolejki gotowości w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-582">However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-583">Jeśli <xref:System.TimeSpan> <xref:System.Threading.Monitor.Pulse%2A> dla parametru określono wartość-1 milisekunda, ta metoda blokuje się w nieskończoność, chyba że jest on posiadaczem wywołań <xref:System.Threading.Monitor.PulseAll%2A>blokady lub. `timeout`</span><span class="sxs-lookup"><span data-stu-id="340b3-583">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="340b3-584">Jeśli `timeout` wartość wynosi 0 milisekund, wątek wywołujący `Wait` uwalnianie blokady, a następnie natychmiast wprowadza gotową kolejkę do odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="340b3-584">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="340b3-585">Obiekt wywołujący `Wait` jest wykonywany jednokrotnie, niezależnie od tego <xref:System.Threading.Monitor.Enter%2A> , ile razy został wywołany dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-585">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="340b3-586">Koncepcyjnie <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.Exit%2A> metoda przechowuje liczbę wywołanych przez obiekt wywołujący w obiekcie i wywołuje tyle razy, ile jest to konieczne, aby w pełni zwolnić zablokowany obiekt. `Wait`</span><span class="sxs-lookup"><span data-stu-id="340b3-586">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="340b3-587">Obiekt wywołujący jest następnie blokowany podczas oczekiwania na ponowne uzyskanie obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-587">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="340b3-588">Gdy obiekt wywołujący ponownie uzyska blokadę, system wywoła <xref:System.Threading.Monitor.Enter%2A> tyle razy, ile jest to konieczne, aby przywrócić zapisaną <xref:System.Threading.Monitor.Enter%2A> liczbę dla obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="340b3-588">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="340b3-589">Wywoływanie `Wait` zwalnia blokadę tylko dla określonego obiektu; Jeśli obiekt wywołujący jest właścicielem blokad dla innych obiektów, te blokady nie są zwalniane.</span><span class="sxs-lookup"><span data-stu-id="340b3-589">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="340b3-590">Zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości, która zawiera wątki gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki, które oczekują na powiadomienie o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="340b3-590">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="340b3-591">Metody <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A> i`Wait` muszą być wywoływane z poziomu synchronizowanego bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="340b3-591">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="340b3-592">Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.</span><span class="sxs-lookup"><span data-stu-id="340b3-592">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="340b3-593">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="340b3-593">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="340b3-594">Parametr nie działa, <xref:System.Threading.Monitor.Wait%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego.`exitContext`</span><span class="sxs-lookup"><span data-stu-id="340b3-594">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="340b3-595">Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="340b3-595">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="340b3-596">Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="340b3-596">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="340b3-597">Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.Monitor.Wait%2A> kontekstu) przed wykonaniem metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-597">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="340b3-598">Powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.Monitor.Wait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="340b3-598">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="340b3-599">Może to być przydatne, gdy klasa związana z kontekstem ma <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> zastosowany atrybut.</span><span class="sxs-lookup"><span data-stu-id="340b3-599">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="340b3-600">W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy.</span><span class="sxs-lookup"><span data-stu-id="340b3-600">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="340b3-601">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.Monitor.Wait%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację.</span><span class="sxs-lookup"><span data-stu-id="340b3-601">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="340b3-602"><xref:System.Threading.Monitor.Wait%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="340b3-602">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="340b3-603">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="340b3-603">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="340b3-604"><see langword="Wait" />nie jest wywoływany z poziomu synchronizowanego bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="340b3-604"><see langword="Wait" /> is not invoked from within a synchronized block of code.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="340b3-605">Wątek wywołujący oczekiwania został później przerwany ze stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="340b3-605">The thread that invokes Wait is later interrupted from the waiting state.</span></span> <span data-ttu-id="340b3-606">Dzieje się tak, gdy inny wątek wywołuje <see cref="M:System.Threading.Thread.Interrupt" /> metodę tego wątku.</span><span class="sxs-lookup"><span data-stu-id="340b3-606">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="340b3-607">Parametr jest ujemny i nie reprezentuje <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekund) lub jest większy niż <see cref="F:System.Int32.MaxValue" />. <paramref name="timeout" /></span><span class="sxs-lookup"><span data-stu-id="340b3-607">The <paramref name="timeout" /> parameter is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="340b3-608">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="340b3-608">Managed Threading</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4fb10be5601161de84aea8fd8f2a00a50eba6966" /><Meta Name="ms.sourcegitcommit" Value="5c332e8417c001736f7e2f33a84791feebba2cd7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/30/2019" /><Meta Name="ms.locfileid" Value="68632369" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia mechanizm, który synchronizuje dostęp do obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pozwala synchronizować dostęp do regionu kodu przez pobranie i zwolnienie blokady dla określonego obiektu przez <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>wywołanie metod, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, i <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>. <xref:System.Threading.Monitor> Blokady obiektów zapewniają możliwość ograniczenia dostępu do bloku kodu, który jest często określany jako sekcja krytyczna. Gdy wątek jest właścicielem blokady obiektu, żaden inny wątek nie może uzyskać tej blokady. Można również użyć <xref:System.Threading.Monitor> klasy, aby upewnić się, że żaden inny wątek nie może uzyskać dostępu do sekcji kodu aplikacji wykonywanej przez właściciela blokady, chyba że inny wątek wykonuje kod przy użyciu innego zablokowanego obiektu.  
  
 W tym artykule:  
  
 [Klasa monitora: Przegląd](#Overview)   
 [Obiekt blokady](#Lock)   
 [Sekcja krytyczna](#CriticalSection)   
 [Puls, PulseAll i Wait](#Pulse)   
 [Monitory i uchwyty oczekiwania](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Klasa monitora: Przegląd  
 <xref:System.Threading.Monitor>ma następujące funkcje:  
  
-   Jest ona skojarzona z obiektem na żądanie.  
  
-   Jest on niepowiązany, co oznacza, że może być wywoływana bezpośrednio z dowolnego kontekstu.  
  
-   Nie można utworzyć wystąpienia <xref:System.Threading.Monitor> klasy; metody <xref:System.Threading.Monitor> klasy są statyczne. Każda metoda jest przenoszona do synchronizowanego obiektu, który kontroluje dostęp do sekcji krytycznej.  
  
> [!NOTE]
>  Użyj klasy <xref:System.Threading.Monitor> , aby zablokować obiekty inne niż ciągi (czyli typy odwołań inne niż <xref:System.String>), a nie typy wartości. Aby uzyskać szczegółowe informacje, zobacz przeciążenia <xref:System.Threading.Monitor.Enter%2A> metody i [blokady obiektu](#Lock) w dalszej części tego artykułu.  
  
 W poniższej tabeli opisano akcje, które mogą być podejmowane przez wątki, które uzyskują dostęp do synchronizowanych obiektów:  
  
|Akcja|Opis|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Uzyskuje blokadę dla obiektu. Ta akcja oznacza również początek sekcji krytycznej. Żaden inny wątek nie może wejść do sekcji krytycznej, chyba że wykonuje instrukcje w sekcji krytycznej przy użyciu innego zablokowanego obiektu.|  
|<xref:System.Threading.Monitor.Wait%2A>|Zwalnia blokadę obiektu w celu zezwolenia innym wątkom na zablokowanie i uzyskanie dostępu do obiektu. Wątek wywołujący czeka, gdy inny wątek uzyskuje dostęp do obiektu. Sygnały pulsu służą do powiadamiania oczekujących wątków o zmianach stanu obiektu.|  
|<xref:System.Threading.Monitor.Pulse%2A>(sygnał),<xref:System.Threading.Monitor.PulseAll%2A>|Wysyła sygnał do co najmniej jednego oczekującego wątku. Sygnał powiadamia wątek oczekujący, że stan zablokowanego obiektu został zmieniony, a właściciel blokady jest gotowy do zwolnienia blokady. Wątek oczekujący jest umieszczany w kolejce gotowości obiektu, tak aby mógł ostatecznie odebrać blokadę dla obiektu. Gdy wątek ma blokadę, może sprawdzić nowy stan obiektu, aby sprawdzić, czy wymagany stan został osiągnięty.|  
|<xref:System.Threading.Monitor.Exit%2A>|Zwalnia blokadę obiektu. Ta akcja oznacza również koniec sekcji krytycznej chronionej przez zablokowany obiekt.|  
  
 Począwszy od <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.TryEnter%2A> , istnieją dwa zestawy przeciążenia dla metod i. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Jeden zbiór przeciążeń ma `ref` parametr ( C#in) `ByRef` lub (w Visual Basic <xref:System.Boolean> ), który jest niepodzielnie `true` ustawiony na wartość, jeśli zaznaczono blokadę, nawet jeśli wystąpi wyjątek podczas uzyskiwania blokady. Użyj tych przeciążeń, jeśli ma krytyczne znaczenie dla zwolnienia blokady we wszystkich przypadkach, nawet jeśli zasoby, które są chronione przez blokadę, mogą nie być w spójnym stanie.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>Obiekt blokady  
 Klasa monitora składa się `static` z metod C#(in `Shared` ) lub (w Visual Basic), które działają na obiekcie, który kontroluje dostęp do sekcji krytycznej.  Dla każdego synchronizowanego obiektu są utrzymywane następujące informacje:  
  
-   Odwołanie do wątku, w którym aktualnie znajduje się blokada.  
  
-   Odwołanie do kolejki gotowości, która zawiera wątki gotowe do uzyskania blokady.  
  
-   Odwołanie do oczekującej kolejki, która zawiera wątki czekające na powiadomienie zmiany stanu zablokowanego obiektu.  
  
 <xref:System.Threading.Monitor>blokuje obiekty (czyli typy odwołań), a nie typy wartości. Można przekazać typ wartości do <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A>, jest on opakowany oddzielnie dla każdego wywołania. Ponieważ każde wywołanie tworzy oddzielny obiekt <xref:System.Threading.Monitor.Enter%2A> , nigdy nie bloki, a kod, który jest supposedly chroniący, nie jest w rzeczywistości synchronizowany. Ponadto obiekt przekazano do <xref:System.Threading.Monitor.Exit%2A> jest inny niż obiekt przekazano do <xref:System.Threading.Monitor.Enter%2A>, więc <xref:System.Threading.Monitor> zgłasza <xref:System.Threading.SynchronizationLockException> wyjątek z komunikatem "Metoda synchronizacji obiektów została wywołana z niezsynchronizowanego bloku kodu".  
  
 Poniższy przykład ilustruje ten problem. Uruchamia dziesięć zadań, z których każdy stanie się uśpiony przez 250 milisekund. Każde zadanie aktualizuje zmienną `nTasks`licznika, która jest przeznaczona do policzania liczby zadań, które faktycznie zostały uruchomione i wykonane. Ponieważ `nTasks` jest zmienną globalną, która może być aktualizowana jednocześnie przez wiele zadań, monitor służy do ochrony przed jednoczesnymi modyfikacjami przez wiele zadań. Jednak dane wyjściowe z przykładu pokazują, że każdy z zadań zgłasza <xref:System.Threading.SynchronizationLockException> wyjątek.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 Każde zadanie zgłasza <xref:System.Threading.SynchronizationLockException> wyjątek, `nTasks` ponieważ zmienna jest opakowana <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> przed wywołaniem metody w każdym zadaniu. Innymi słowy, każde wywołanie metody jest przekazanie oddzielnej zmiennej, która jest niezależna od innych. `nTasks`jest ponownie opakowany w wywołaniu <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metody. Ponownie spowoduje to utworzenie dziesięciu nowych zmiennych opakowanych, które są niezależne od siebie, `nTasks`oraz dziesięciu zmiennych opakowanych utworzonych w wywołaniu <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> metody. Wyjątek jest zgłaszany, a następnie, ponieważ nasz kod próbuje zwolnić blokadę dla nowo utworzonej zmiennej, która nie została wcześniej zablokowana.  
  
 Chociaż można wpisać zmienną typu wartości przed wywołaniem <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A>, jak pokazano w poniższym przykładzie, i przekazać ten sam obiekt opakowany do obu tych metod, nie ma to żadnego znaczenia. Zmiany w zmiennej nieopakowanej nie są uwzględniane w kopii w ramce i nie ma sposobu zmiany wartości kopii w ramce.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 Podczas wybierania obiektu do synchronizowania należy zablokować tylko w obiektach prywatnych i wewnętrznych. Zablokowanie obiektów zewnętrznych może spowodować zakleszczenie, ponieważ niezwiązany kod może wybrać te same obiekty do zablokowania w różnych celach.  
  
 Należy pamiętać, że można synchronizować obiekt w wielu domenach aplikacji, jeśli obiekt używany do blokowania pochodzi od <xref:System.MarshalByRefObject>.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>Sekcja krytyczna  
 Użyj metod <xref:System.Threading.Monitor.Exit%2A> i, aby oznaczyć początek i koniec sekcji krytycznej. <xref:System.Threading.Monitor.Enter%2A>  
  
> [!NOTE]
>  Funkcje zapewniane przez <xref:System.Threading.Monitor.Enter%2A> metody i <xref:System.Threading.Monitor.Exit%2A> są takie same jak podane przez instrukcję [Lock](~/docs/csharp/language-reference/keywords/lock-statement.md) w C# i instrukcji [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) w Visual Basic, z tą różnicą, że konstrukcja języka otacza <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType>Przeciążenie metody i <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> `try`metody w...`finally` Blokuj, aby upewnić się, że monitor został opublikowany.  
  
 Jeśli Sekcja krytyczna jest zbiorem instrukcji ciągłych, blokada uzyskana przez <xref:System.Threading.Monitor.Enter%2A> metodę gwarantuje, że tylko jeden wątek może wykonać załączony kod z zablokowanym obiektem. W tym przypadku zalecamy umieszczenie tego kodu w `try` bloku i umieszczenie wywołania <xref:System.Threading.Monitor.Exit%2A> metody w `finally` bloku. Gwarantuje to, że blokada zostanie wydana, nawet jeśli wystąpi wyjątek. Poniższy fragment kodu ilustruje ten wzorzec.  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 Ta funkcja jest zwykle używana do synchronizowania dostępu do statycznej metody lub klasy wystąpień.  
  
 Jeśli Sekcja krytyczna obejmuje całą metodę, funkcję blokowania można osiągnąć, umieszczając ją <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> na metodzie i <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> określając <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>wartość w konstruktorze. W przypadku korzystania z <xref:System.Threading.Monitor.Enter%2A> tego atrybutu wywołania metod i <xref:System.Threading.Monitor.Exit%2A> nie są potrzebne. Poniższy fragment kodu ilustruje ten wzorzec:  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 Należy zauważyć, że ten atrybut powoduje, że bieżący wątek utrzymuje blokadę do momentu, gdy metoda zwróci wartość; Jeśli blokada może być wydawana wcześniej, należy użyć <xref:System.Threading.Monitor> klasy, C# instrukcji [Lock](~/docs/csharp/language-reference/keywords/lock-statement.md) lub instrukcji Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) wewnątrz metody zamiast atrybutu.  
  
 Chociaż można <xref:System.Threading.Monitor.Enter%2A> wykonać instrukcje i <xref:System.Threading.Monitor.Exit%2A> , które zablokują i zwalniają dany obiekt do granic składowych lub klas, lub obie te metody nie są zalecane.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Puls, PulseAll i Wait  
 Gdy wątek jest właścicielem blokady i wprowadzono sekcję krytyczną, która jest chroniona przez blokadę, może wywołać <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>metody <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>,, <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> i.  
  
 Gdy wątek, który przechowuje wywołania <xref:System.Threading.Monitor.Wait%2A>blokady, blokada zostaje wydana i wątek zostanie dodany do oczekującej kolejki synchronizowanego obiektu. Pierwszy wątek w kolejce gotowości, jeśli istnieje, uzyskuje blokadę i wprowadza sekcję krytyczną. Wątek, który został <xref:System.Threading.Monitor.Wait%2A> wywołany, jest przenoszony z kolejki oczekujące do kolejki gotowości, <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> gdy <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> lub metoda jest wywoływana przez wątek, który przechowuje blokadę (do przeniesienia, wątek musi znajdować się na końcu kolejki oczekiwania). <xref:System.Threading.Monitor.Wait%2A> Metoda zwraca, gdy wątek wywołujący ponownie uzyskuje blokadę.  
  
 Gdy wątek, który przechowuje wywołania <xref:System.Threading.Monitor.Pulse%2A>blokady, wątek w nagłówku oczekującej kolejki zostanie przeniesiony do kolejki gotowości. Wywołanie <xref:System.Threading.Monitor.PulseAll%2A> metody przenosi wszystkie wątki z oczekującej kolejki do kolejki gotowości.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>Monitory i uchwyty oczekiwania  
 Ważne jest, aby zauważyć rozróżnienie między użyciem <xref:System.Threading.Monitor> klasy i <xref:System.Threading.WaitHandle> obiektów.  
  
-   <xref:System.Threading.Monitor> Klasa jest całkowicie zarządzana, w pełni przenośna i może być bardziej wydajna w zakresie wymagań dotyczących zasobów systemu operacyjnego.  
  
-   <xref:System.Threading.WaitHandle>obiekty reprezentują obiekty oczekiwane w systemie operacyjnym, są przydatne do synchronizowania kodu zarządzanego i niezarządzanego oraz uwidaczniają pewne zaawansowane funkcje systemu operacyjnego, takie jak możliwość oczekiwania na wiele obiektów jednocześnie.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Threading.Monitor> klasy do synchronizowania dostępu do jednego wystąpienia generatora liczb losowych reprezentowanego <xref:System.Random> przez klasę. Przykład tworzy dziesięć zadań, z których każdy jest wykonywany asynchronicznie w wątku puli wątków. Każde zadanie generuje liczbę losową 10 000, oblicza ich średnią i aktualizuje dwie zmienne na poziomie procedury, które utrzymują liczbę liczb losowych wygenerowanych i ich sumę. Po wykonaniu wszystkich zadań te dwie wartości są następnie używane do obliczania średniej.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 Ponieważ można uzyskać do nich dostęp z dowolnego zadania uruchomionego w wątku puli wątków, należy również zsynchronizować `total` dostęp `n` do zmiennych i. <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> Metoda jest używana do tego celu.  
  
 Poniższy przykład <xref:System.Threading.Monitor> demonstruje użycie klasy (zaimplementowane `lock` z lub `SyncLock` <xref:System.Threading.AutoResetEvent> konstrukcja języka), <xref:System.Threading.Interlocked> klasy i klasy. `internal` Definiuje dwie (w C#) lub `Friend` (w Visual Basic) klasy `SyncResource` i `UnSyncResource`, które odpowiednio zapewniają synchronizację i niezsynchronizowany dostęp do zasobu. Aby zapewnić, że przykład ilustruje różnicę między synchronizowanym i niezsynchronizowanym dostępem (może to być przypadek, jeśli każde wywołanie metody zostanie szybko zakończone), metoda obejmuje losowe opóźnienie: dla wątków, których <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> właściwość jest parzysta, wywołuje <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodę, aby wprowadzić opóźnienie 2 000 milisekund. Należy zauważyć, że ponieważ `SyncResource` Klasa nie jest publiczna, żaden kod klienta nie ma blokady w synchronizowanym zasobie; sama sama klasa przyjmuje blokadę. Zapobiega to zablokowaniu obiektu publicznego przez złośliwy kod.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 W przykładzie zdefiniowano zmienną, `numOps`która definiuje liczbę wątków, które będą próbować uzyskać dostęp do zasobu. Wątek aplikacji wywołuje metodę, <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> aby zsynchronizować i niezsynchronizowany dostęp pięć razy każdy. <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> Metoda ma jeden parametr, delegat, który nie akceptuje parametrów i nie zwraca żadnej wartości. W przypadku dostępu zsynchronizowanego `SyncUpdateResource` metoda wywołuje metodę; w przypadku niezsynchronizowanego dostępu `UnSyncUpdateResource` wywołuje metodę. Po każdym zestawie wywołań metod wątek aplikacji wywołuje metodę [AutoResetEvent. WaitOne](xref:System.Threading.WaitHandle.WaitOne*) , aby blokowała do momentu <xref:System.Threading.AutoResetEvent> zasygnalizowania wystąpienia.  
  
 Każde wywołanie `SyncUpdateResource` metody `numOps` wywołuje `SyncResource.Access` metodę wewnętrzną, a następnie wywołuje metodęwceluzmniejszenialicznika.<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Metoda jest używana do zmniejszania licznika, ponieważ w przeciwnym razie nie można mieć pewności, że drugi wątek będzie miał dostęp do wartości przed zapisaniem w zmiennej wartości w pierwszym wątku. Gdy ostatni zsynchronizowany wątek roboczy zmniejsza licznik do zera, wskazując, że wszystkie zsynchronizowane wątki zakończyły uzyskiwanie dostępu do `SyncUpdateResource` zasobu, Metoda <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> wywołuje metodę, która sygnalizuje główny wątek, aby kontynuować działania.  
  
 Każde wywołanie `UnSyncUpdateResource` metody `numOps` wywołuje `UnSyncResource.Access` metodę wewnętrzną, a następnie wywołuje metodęwceluzmniejszenialicznika.<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Po ponownym <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> uruchomieniu Metoda jest używana do zmniejszenia licznika, aby upewnić się, że drugi wątek nie uzyskuje dostępu do wartości przed przypisaniem przez pierwszy wątek wartości do zmiennej. Kiedy ostatni niezsynchronizowany wątek roboczy zmniejsza licznik do zera, co oznacza, że nie ma więcej niezsynchronizowanych wątków potrzebnych do uzyskania dostępu do zasobu `UnSyncUpdateResource` , Metoda <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> wywołuje metodę, która sygnalizuje główny wątek, aby kontynuować wykonywanie .  
  
 Jak wynika z przykładu, zsynchronizowany dostęp gwarantuje, że wątek wywołujący opuszcza chroniony zasób, zanim inny wątek będzie mógł uzyskać do niego dostęp. Każdy wątek czeka na jego poprzednika. Z drugiej strony, bez blokady, `UnSyncResource.Access` Metoda jest wywoływana w kolejności, w której wątki docierają do niego.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Wątkowość obiektów i funkcji</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje blokadę na wyłączność dla określonego obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy uzyskać blokadę monitora.</param>
        <summary>Uzyskuje blokadę na wyłączność dla określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Enter` , aby <xref:System.Threading.Monitor> uzyskać obiekt dla obiektu przesyłanego jako parametr. Jeśli inny wątek `Enter` wykonał obiekt, ale nie wykonał jeszcze odpowiadającego <xref:System.Threading.Monitor.Exit%2A>, bieżący wątek zostanie zablokowany do momentu, gdy inny wątek zwolni obiekt. Jest to dozwolone dla tego samego wątku, który `Enter` jest wywoływany więcej niż jeden raz bez blokowania, jednak taka `Exit` liczba wywołań musi być wywoływana, zanim inne wątki oczekujące na obiekt zostaną odblokowane.  
  
 Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości. Gdy przekazujesz zmienną typu wartości do `Enter`, jest ona opakowana jako obiekt. Jeśli ta sama zmienna `Enter` zostanie przekazana ponownie, jest opakowana jako oddzielny obiekt, a wątek nie blokuje. W takim przypadku kod `Monitor` supposedly ochronę nie jest chroniony. Ponadto po przekazaniem zmiennej do `Exit`, nadal tworzony jest inny oddzielny obiekt. Ponieważ obiekt przeszedł do `Exit` jest inny niż obiekt przeszedł do `Enter`, `Monitor` zgłasza <xref:System.Threading.SynchronizationLockException>. Aby uzyskać więcej informacji, zobacz [Monitory](xref:System.Threading.Monitor)tematu koncepcyjnego.  
  
 <xref:System.Threading.Thread.Interrupt%2A>może przerywać wątki, które oczekują na `Monitor` wprowadzenie do obiektu. <xref:System.Threading.ThreadInterruptedException> Zostanie zgłoszony.  
  
 C# Użyj...`try``finally` Blokuj (`Try`...`Finally` w Visual Basic), aby upewnić się, że monitor zostanie zwolniony lub C# `lock` Użyj instrukcji`SyncLock` (instrukcja w <xref:System.Threading.Monitor.Enter%2A> Visual Basic), która `try`zawija metody i <xref:System.Threading.Monitor.Exit%2A> w...`finally` odblokowan.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób używania `Enter` metody.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy czekać.</param>
        <param name="lockTaken">Wynik próby uzyskania blokady, która została przeniesiona przez odwołanie. Wartość wejściowa musi <see langword="false" />być. Dane wyjściowe są <see langword="true" /> w przypadku pozyskania blokady; w przeciwnym razie dane <see langword="false" />wyjściowe to. Dane wyjściowe są ustawiane nawet wtedy, gdy wystąpi wyjątek podczas próby uzyskania blokady.  
  
Zwróć uwagę, jeśli nie wystąpi żaden wyjątek, dane wyjściowe tej metody <see langword="true" />są zawsze.</param>
        <summary>Uzyskuje blokadę na wyłączność dla określonego obiektu i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Enter` , aby <xref:System.Threading.Monitor> uzyskać obiekt dla obiektu przesyłanego jako `obj` parametr. Jeśli inny wątek `Enter` wykonał obiekt, ale nie wykonał jeszcze odpowiadającego <xref:System.Threading.Monitor.Exit%2A>, bieżący wątek zostanie zablokowany do momentu, gdy inny wątek zwolni obiekt. Jest to dozwolone dla tego samego wątku, który `Enter` jest wywoływany więcej niż jeden raz bez blokowania, jednak taka `Exit` liczba wywołań musi być wywoływana, zanim inne wątki oczekujące na obiekt zostaną odblokowane.  
  
 Jeśli blokada nie została wykonana, ponieważ został zgłoszony wyjątek, zmienna określona dla `lockTaken` parametru jest `false` po zakończeniu tej metody. Dzięki temu program może określić, we wszystkich przypadkach, czy konieczne jest zwolnienie blokady. Jeśli ta metoda zwróci wartość bez zgłaszania wyjątku, zmienna określona dla `lockTaken` parametru jest zawsze `true`i nie ma potrzeby jej przetestowania.  
  
 Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości. Gdy przekazujesz zmienną typu wartości do `Enter`, jest ona opakowana jako obiekt. Jeśli ta sama zmienna `Enter` zostanie przekazana ponownie, jest opakowana jako oddzielny obiekt, a wątek nie blokuje. W takim przypadku kod `Monitor` supposedly ochronę nie jest chroniony. Ponadto podczas przekazywania zmiennej do `Exit`, tworzony jest inny oddzielny obiekt. Ponieważ obiekt przeszedł do `Exit` jest inny niż obiekt przeszedł do `Enter`, `Monitor` zgłasza <xref:System.Threading.SynchronizationLockException>. Aby uzyskać więcej informacji, zobacz [Monitory](xref:System.Threading.Monitor)tematu koncepcyjnego.  
  
 <xref:System.Threading.Thread.Interrupt%2A>może przerywać wątki, które oczekują na `Monitor` wprowadzenie do obiektu. <xref:System.Threading.ThreadInterruptedException> Zostanie zgłoszony.  
  
   
  
## Examples  
 Poniższy kod przedstawia podstawowy wzorzec używania <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> przeciążenia metody. To Przeciążenie zawsze ustawia wartość zmiennej, która jest przenoszona do `ref` parametru (`ByRef` w Visual Basic) `lockTaken`, nawet jeśli metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodnym sposobem sprawdzenia, czy blokada musi być zwolni.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dane wejściowe <paramref name="lockTaken" /> to <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym ma zostać wydaną blokadę.</param>
        <summary>Zwalnia blokadę na wyłączność dla określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek wywołujący musi być własnym blokadą dla `obj` parametru. Jeśli wątek wywołujący jest właścicielem blokady określonego obiektu i ma taką samą liczbę `Exit` wywołań i <xref:System.Threading.Monitor.Enter%2A> jest wywoływany dla tego obiektu, blokada zostanie wydana. Jeśli wątek wywołujący nie został wywołany `Exit` tyle razy jak `Enter`, blokada nie zostanie wydana.  
  
 Jeśli blokada jest wydana i inne wątki znajdują się w kolejce gotowości dla obiektu, jeden z wątków uzyskuje blokadę. Jeśli inne wątki znajdują się w oczekującej kolejce oczekiwania na uzyskanie blokady, nie są automatycznie przenoszone do kolejki gotowości, gdy właściciel wywołań `Exit`blokady. Aby przenieść jeden lub więcej oczekujących wątków do kolejki gotowości, <xref:System.Threading.Monitor.Pulse%2A> Wywołaj lub <xref:System.Threading.Monitor.PulseAll%2A> przed `Exit`wywołaniem.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób używania `Exit` metody.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie jest obiektem blokady określonego obiektu.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do przetestowania.</param>
        <summary>Określa, czy bieżący wątek przechowuje blokadę określonego obiektu.</summary>
        <returns><see langword="true" />Jeśli bieżący wątek utrzymuje blokadę <paramref name="obj" />; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa tylko w przypadku blokad, które są uzyskiwane przy użyciu metod <xref:System.Threading.Monitor> klasy lub C# `lock` instrukcji lub instrukcji Visual Basic `SyncLock` , które są implementowane z <xref:System.Threading.Monitor>.  
  
 Użyj tej metody z narzędziami diagnostycznymi, takimi jak <xref:System.Diagnostics.Debug.Assert%2A> Metoda <xref:System.Diagnostics.Contracts.Contract> i Klasa, do debugowania problemów z <xref:System.Threading.Monitor> blokowaniem, które obejmują klasę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o tym, ile razy wystąpił rywalizacja podczas próby przeprowadzenia blokady monitora.</summary>
        <value>Liczba przypadków rywalizacji podczas próby przeprowadzenia blokady monitora.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, dla którego jest oczekiwany wątek.</param>
        <summary>Powiadamia wątek w kolejce oczekujące zmiany stanu zablokowanego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko bieżący właściciel blokady może sygnalizować obiekt oczekujący przy użyciu `Pulse`.  
  
 Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę, aby sygnalizować Następny wątek w wierszu dla blokady. Po odebraniu pulsu oczekujący wątek zostanie przeniesiony do kolejki gotowości. Gdy wątek, który wywołał `Pulse` , zwalnia blokadę, Następny wątek w kolejce gotowości (który nie jest konieczny do wątku, który został impulsowo) uzyskuje blokadę.  
  
> [!IMPORTANT]
>  Klasa nie utrzymuje stanu wskazującego <xref:System.Threading.Monitor.Pulse%2A> , że metoda została wywołana. <xref:System.Threading.Monitor> W tym przypadku, jeśli <xref:System.Threading.Monitor.Pulse%2A> wywołasz, gdy żaden wątek nie oczekuje, następnym wątku <xref:System.Threading.Monitor.Wait%2A> , który wywołuje <xref:System.Threading.Monitor.Pulse%2A> bloki, tak jakby nigdy nie został wywołany. Jeśli dwa wątki używają <xref:System.Threading.Monitor.Pulse%2A> i <xref:System.Threading.Monitor.Wait%2A> do działania, może to spowodować zakleszczenie. W przeciwieństwie do zachowania <xref:System.Threading.AutoResetEvent> klasy: W przypadku sygnalizowania <xref:System.Threading.AutoResetEvent> przez <xref:System.Threading.EventWaitHandle.Set%2A> wywołanie metody, gdy <xref:System.Threading.AutoResetEvent> nie ma żadnych wątków oczekujących, pozostaje w stanie zasygnalizowania do momentu wywołania <xref:System.Threading.WaitHandle.WaitOne%2A>wątku, <xref:System.Threading.WaitHandle.WaitAny%2A>, lub <xref:System.Threading.WaitHandle.WaitAll%2A>. <xref:System.Threading.AutoResetEvent> Zwalnia ten wątek i powraca do stanu niesygnalizowanego.  
  
 Należy zauważyć, że zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości zawierającej wątki, które są gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki czekające na powiadomienie zmiany stanu obiektu.  
  
 Metody `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A> i<xref:System.Threading.Monitor.Wait%2A> muszą być wywoływane z poziomu synchronizowanego bloku kodu.  
  
 Aby sygnalizować wiele wątków, użyj <xref:System.Threading.Monitor.PulseAll%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Wątek wywołujący nie jest obiektem blokady określonego obiektu.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który wysyła impuls.</param>
        <summary>Powiadamia wszystkie oczekujące wątki zmiany stanu obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę, aby sygnalizować wszystkie wątki oczekujące na uzyskanie blokady obiektu. Po wysłaniu sygnału oczekujące wątki są przenoszone do kolejki gotowości. Gdy wątek wywoływany `PulseAll` przez program zwalnia blokadę, Następny wątek w kolejce gotowej uzyskuje blokadę.  
  
 Należy zauważyć, że zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości zawierającej wątki, które są gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki czekające na powiadomienie zmiany stanu obiektu.  
  
 Metody <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll` i<xref:System.Threading.Monitor.Wait%2A> muszą być wywoływane z poziomu synchronizowanego bloku kodu.  
  
 Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.  
  
 Aby sygnalizować pojedynczy wątek, użyj `Pulse` metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Wątek wywołujący nie jest obiektem blokady określonego obiektu.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje uzyskać blokadę na wyłączność dla określonego obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy uzyskać blokadę.</param>
        <summary>Próbuje uzyskać blokadę na wyłączność dla określonego obiektu.</summary>
        <returns><see langword="true" />Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to się powiedzie, ta metoda uzyskuje blokadę `obj` na wyłączność dla parametru. Ta metoda wraca natychmiast, niezależnie od tego, czy blokada jest dostępna.  
  
 Ta metoda jest podobna do <xref:System.Threading.Monitor.Enter%2A>, ale nigdy nie blokuje bieżącego wątku. Jeśli wątek nie może wejść bez blokowania, metoda zwraca `false,`.  
  
> [!NOTE]
>  Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości. Aby uzyskać szczegółowe informacje, <xref:System.Threading.Monitor> Zobacz artykuł.  
  
 Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość zwracana `true`to. Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania `TryEnter` metody.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy uzyskać blokadę.</param>
        <param name="lockTaken">Wynik próby uzyskania blokady, która została przeniesiona przez odwołanie. Wartość wejściowa musi <see langword="false" />być. Dane wyjściowe są <see langword="true" /> w przypadku pozyskania blokady; w przeciwnym razie dane <see langword="false" />wyjściowe to. Dane wyjściowe są ustawiane nawet wtedy, gdy wystąpi wyjątek podczas próby uzyskania blokady.</param>
        <summary>Próbuje uzyskać wyłączną blokadę określonego obiektu i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to się powiedzie, ta metoda uzyskuje blokadę `obj` na wyłączność dla parametru. Ta metoda wraca natychmiast, niezależnie od tego, czy blokada jest dostępna.  
  
 Jeśli blokada nie została wykonana, ponieważ został zgłoszony wyjątek, zmienna określona dla `lockTaken` parametru jest `false` po zakończeniu tej metody. Dzięki temu program może określić, we wszystkich przypadkach, czy konieczne jest zwolnienie blokady.  
  
 Ta metoda jest podobna do <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, ale nigdy nie blokuje bieżącego wątku. Jeśli wątek nie może wejść bez blokowania, `lockTaken` argument jest ustawiany na `false` , gdy metoda zwraca.  
  
> [!NOTE]
>  Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości. Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> artykuł.  
  
 Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość `lockTaken` i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość to. `true` Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 Poniższy kod przedstawia podstawowy wzorzec używania <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> przeciążenia metody. To Przeciążenie zawsze ustawia wartość zmiennej, która jest przenoszona do `ref` parametru (`ByRef` w Visual Basic) `lockTaken`, nawet jeśli metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodnym sposobem sprawdzenia, czy blokada musi być zwolni.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dane wejściowe <paramref name="lockTaken" /> to <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy uzyskać blokadę.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania na blokadę.</param>
        <summary>Próby dla określonej liczby milisekund w celu uzyskania blokady na wyłączność dla określonego obiektu.</summary>
        <returns><see langword="true" />Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli parametr ma wartość <xref:System.Threading.Timeout.Infinite>, ta metoda jest równoważna <xref:System.Threading.Monitor.Enter%2A>z. `millisecondsTimeout` Jeśli `millisecondsTimeout` jest równa 0, ta metoda jest <xref:System.Threading.Monitor.TryEnter%2A>równoważna z.  
  
> [!NOTE]
>  Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości. Aby uzyskać szczegółowe informacje, <xref:System.Threading.Monitor> Zobacz artykuł.  
  
 Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość zwracana `true`to. Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy uzyskać blokadę.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Reprezentująca ilość czasu oczekiwania na blokadę. Wartość-1 milisekunda określa nieskończony czas oczekiwania.</param>
        <summary>Próby, przez określony czas, uzyskania blokady wyłącznej dla określonego obiektu.</summary>
        <returns><see langword="true" />Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `timeout` parametru konwertowana na milisekundy jest równa-1, ta metoda jest równoważna <xref:System.Threading.Monitor.Enter%2A>z. Jeśli wartość `timeout` jest równa 0, ta metoda jest równoważna <xref:System.Threading.Monitor.TryEnter%2A>z.  
  
> [!NOTE]
>  Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości. Aby uzyskać szczegółowe informacje, <xref:System.Threading.Monitor> Zobacz temat Klasa.  
  
 Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość zwracana `true`to. Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> w milisekundach jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa (-1 milisekund) lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy uzyskać blokadę.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania na blokadę.</param>
        <param name="lockTaken">Wynik próby uzyskania blokady, która została przeniesiona przez odwołanie. Wartość wejściowa musi <see langword="false" />być. Dane wyjściowe są <see langword="true" /> w przypadku pozyskania blokady; w przeciwnym razie dane <see langword="false" />wyjściowe to. Dane wyjściowe są ustawiane nawet wtedy, gdy wystąpi wyjątek podczas próby uzyskania blokady.</param>
        <summary>Próby, przez określoną liczbę milisekund, do uzyskania blokady na wyłączność określonego obiektu i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli parametr ma wartość <xref:System.Threading.Timeout.Infinite>, ta metoda jest równoważna <xref:System.Threading.Monitor.Enter%28System.Object%29>z. `millisecondsTimeout` Jeśli `millisecondsTimeout` jest równa 0, ta metoda jest <xref:System.Threading.Monitor.TryEnter%28System.Object%29>równoważna z.  
  
 Jeśli blokada nie została wykonana, ponieważ został zgłoszony wyjątek, zmienna określona dla `lockTaken` parametru jest `false` po zakończeniu tej metody. Dzięki temu program może określić, we wszystkich przypadkach, czy konieczne jest zwolnienie blokady.  
  
> [!NOTE]
>  Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości. Aby uzyskać więcej informacji, zapoznaj się z <xref:System.Threading.Monitor> tematem klasy.  
  
 Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość `lockTaken` i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość to. `true` Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 Poniższy kod przedstawia podstawowy wzorzec używania <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> przeciążenia metody. To Przeciążenie zawsze ustawia wartość zmiennej, która jest przenoszona do `ref` parametru (`ByRef` w Visual Basic) `lockTaken`, nawet jeśli metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodnym sposobem sprawdzenia, czy blokada musi być zwolni.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dane wejściowe <paramref name="lockTaken" /> to <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy uzyskać blokadę.</param>
        <param name="timeout">Czas oczekiwania na blokadę. Wartość-1 milisekunda określa nieskończony czas oczekiwania.</param>
        <param name="lockTaken">Wynik próby uzyskania blokady, która została przeniesiona przez odwołanie. Wartość wejściowa musi <see langword="false" />być. Dane wyjściowe są <see langword="true" /> w przypadku pozyskania blokady; w przeciwnym razie dane <see langword="false" />wyjściowe to. Dane wyjściowe są ustawiane nawet wtedy, gdy wystąpi wyjątek podczas próby uzyskania blokady.</param>
        <summary>Próbuje, przez określony czas, uzyskać blokadę na wyłączność określonego obiektu i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `timeout` parametru konwertowana na milisekundy jest równa-1, ta metoda jest równoważna <xref:System.Threading.Monitor.Enter%28System.Object%29>z. Jeśli wartość `timeout` jest równa 0, ta metoda jest równoważna <xref:System.Threading.Monitor.TryEnter%28System.Object%29>z.  
  
 Jeśli blokada nie została wykonana, ponieważ został zgłoszony wyjątek, zmienna określona dla `lockTaken` parametru jest `false` po zakończeniu tej metody. Dzięki temu program może określić, we wszystkich przypadkach, czy konieczne jest zwolnienie blokady.  
  
> [!NOTE]
>  Służy <xref:System.Threading.Monitor> do blokowania obiektów (czyli typów referencyjnych), a nie typów wartości. Aby uzyskać więcej informacji, zapoznaj się z <xref:System.Threading.Monitor> tematem klasy.  
  
 Aby upewnić się, że wątek nie wprowadza sekcji krytycznej, należy sprawdzić wartość `lockTaken` i wykonać kod w sekcji krytycznej tylko wtedy, gdy jej wartość to. `true` Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy pamiętać, że należy <xref:System.Threading.Monitor.Exit%2A> wywołać `finally` w bloku, aby upewnić się, że wywoływany wątek zwalnia jego blokadę w sekcji krytycznej, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dane wejściowe <paramref name="lockTaken" /> to <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> w milisekundach jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa (-1 milisekund) lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy czekać.</param>
        <summary>Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady.</summary>
        <returns><see langword="true" />Jeśli wywołanie zostało zwrócone, ponieważ obiekt wywołujący odzyskuje blokadę dla określonego obiektu. Ta metoda nie zwraca, jeśli blokada nie zostanie odbrana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę w celu zwolnienia obiektu, tak aby inny wątek mógł uzyskać do niego dostęp. Obiekt wywołujący jest zablokowany podczas oczekiwania na odzyskanie blokady. Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmianę stanu, która zostanie wykonana w wyniku operacji innego wątku.  
  
 Gdy wątek wywołuje `Wait`, zwalnia blokadę obiektu i przechodzi do oczekującej kolejki obiektu. Następny wątek w kolejce gotowości obiektu (jeśli istnieje) uzyskuje blokadę i ma wyłączny dostęp do obiektu. Wszystkie wątki, które `Wait` wywołują, pozostaną w kolejce oczekiwania do momentu <xref:System.Threading.Monitor.Pulse%2A> otrzymania <xref:System.Threading.Monitor.PulseAll%2A>sygnału z lub, wysyłane przez właściciela blokady. W `Pulse` przypadku wysłania tej zmiany dotyczy tylko wątku w kolejce oczekiwania. Jeśli `PulseAll` jest wysyłana, wpłynie to na wszystkie wątki, które oczekują na obiekt. Po odebraniu sygnału co najmniej jeden wątek opuszcza oczekującą kolejkę i wprowadza gotową kolejkę. Wątek w kolejce gotowości jest dozwolony do odzyskania blokady.  
  
 Ta metoda zwraca, gdy wątek wywołujący ponownie uzyskuje blokadę obiektu. Należy zauważyć, że ta metoda blokuje się w nieskończoność, jeśli posiadacz blokady nie `Pulse` wywołuje `PulseAll`lub.  
  
 Obiekt wywołujący `Wait` jest wykonywany jednokrotnie, niezależnie od tego <xref:System.Threading.Monitor.Enter%2A> , ile razy został wywołany dla określonego obiektu. Koncepcyjnie `Enter` `Exit` metoda przechowuje liczbę wywołanych przez obiekt wywołujący w obiekcie i wywołuje tyle razy, ile jest to konieczne, aby w pełni zwolnić zablokowany obiekt. `Wait` Obiekt wywołujący jest następnie blokowany podczas oczekiwania na ponowne uzyskanie obiektu. Gdy obiekt wywołujący ponownie uzyska blokadę, system wywoła `Enter` tyle razy, ile jest to konieczne, aby przywrócić zapisaną `Enter` liczbę dla obiektu wywołującego. Wywoływanie `Wait` zwalnia blokadę tylko dla określonego obiektu; Jeśli obiekt wywołujący jest właścicielem blokad dla innych obiektów, te blokady nie są zwalniane.  
  
 Należy zauważyć, że zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości zawierającej wątki, które są gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki czekające na powiadomienie zmiany stanu obiektu.  
  
 Metody <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A> i`Wait` muszą być wywoływane z poziomu synchronizowanego bloku kodu.  
  
 Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Wątek wywołujący nie jest obiektem blokady określonego obiektu.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek, który wywołuje <see langword="Wait" /> , został później przerwany ze stanu oczekiwania. Dzieje się tak, gdy inny wątek wywołuje <see cref="M:System.Threading.Thread.Interrupt" /> metodę tego wątku.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy czekać.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania przed przejściem wątku do kolejki gotowości.</param>
        <summary>Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady. Jeśli upłynie określony interwał limitu czasu, wątek przechodzi do kolejki gotowości.</summary>
        <returns><see langword="true" />Jeśli blokada została odbrana przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została odzyskania po upływie określonego czasu. Metoda nie zwraca do momentu odzyskania blokady.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zwraca do momentu odzyskania blokady wyłącznej na `obj` parametrze.  
  
 Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę w celu zwolnienia obiektu, tak aby inny wątek mógł uzyskać do niego dostęp. Obiekt wywołujący jest zablokowany podczas oczekiwania na odzyskanie blokady. Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmianę stanu, która zostanie wykonana w wyniku operacji innego wątku.  
  
 Limit czasu zapewnia, że bieżący wątek nie blokuje się w nieskończoność, jeśli inny wątek zwolni blokadę bez uprzedniego wywołania <xref:System.Threading.Monitor.Pulse%2A> metody <xref:System.Threading.Monitor.PulseAll%2A> lub. Przenosi również wątek do kolejki gotowości, pomijając inne wątki przed nim w kolejce oczekiwania, dzięki czemu może on ponownie uzyskać blokadę. Wątek może testować wartość <xref:System.Threading.Monitor.Wait%2A> zwracaną metody, aby określić, czy odzyskuje blokadę przed upływem limitu czasu. Wątek może oszacować warunki, które spowodowały wprowadzenie oczekiwania, i w razie potrzeby ponownie wywołać <xref:System.Threading.Monitor.Wait%2A> metodę.  
  
 Gdy wątek wywołuje `Wait`, zwalnia blokadę obiektu i przechodzi do oczekującej kolejki obiektu. Następny wątek w kolejce gotowości obiektu (jeśli istnieje) uzyskuje blokadę i ma wyłączny dostęp do obiektu. Wywoływany `Wait` wątek pozostaje w kolejce oczekiwania do momentu, aż wątek, który przechowuje <xref:System.Threading.Monitor.PulseAll%2A>blokadę, lub jest następnym w kolejce i wątek <xref:System.Threading.Monitor.Pulse%2A>, który przechowuje blokadę. Jeśli `millisecondsTimeout` jednak upłynie, zanim inny wątek wywoła ten <xref:System.Threading.Monitor.Pulse%2A> obiekt lub <xref:System.Threading.Monitor.PulseAll%2A> metodę, oryginalny wątek zostanie przeniesiony do kolejki gotowości w celu odzyskania blokady.  
  
> [!NOTE]
>  Jeśli <xref:System.Threading.Timeout.Infinite> jest określony `millisecondsTimeout` dla parametru, ta metoda blokuje się w nieskończoność, chyba że posiadacz wywołań <xref:System.Threading.Monitor.Pulse%2A> Lock lub <xref:System.Threading.Monitor.PulseAll%2A>. Jeśli `millisecondsTimeout` wartość jest równa 0, wątek `Wait` , który wywołuje zwalnia blokadę, a następnie natychmiast wprowadza gotową kolejkę do odzyskania blokady.  
  
 Obiekt wywołujący `Wait` jest wykonywany jednokrotnie, niezależnie od tego <xref:System.Threading.Monitor.Enter%2A> , ile razy został wywołany dla określonego obiektu. Koncepcyjnie <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.Exit%2A> metoda przechowuje liczbę wywołanych przez obiekt wywołujący w obiekcie i wywołuje tyle razy, ile jest to konieczne, aby w pełni zwolnić zablokowany obiekt. `Wait` Obiekt wywołujący jest następnie blokowany podczas oczekiwania na ponowne uzyskanie obiektu. Gdy obiekt wywołujący ponownie uzyska blokadę, system wywoła <xref:System.Threading.Monitor.Enter%2A> tyle razy, ile jest to konieczne, aby przywrócić zapisaną <xref:System.Threading.Monitor.Enter%2A> liczbę dla obiektu wywołującego. Wywoływanie `Wait` zwalnia blokadę tylko dla określonego obiektu; Jeśli obiekt wywołujący jest właścicielem blokad dla innych obiektów, te blokady nie są zwalniane.  
  
> [!NOTE]
>  Zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości, która zawiera wątki gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki, które oczekują na powiadomienie o zmianie stanu obiektu.  
  
 Metody <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A> i`Wait` muszą być wywoływane z poziomu synchronizowanego bloku kodu.  
  
 Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Wątek wywołujący nie jest obiektem blokady określonego obiektu.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek, który wywołuje <see langword="Wait" /> , został później przerwany ze stanu oczekiwania. Dzieje się tak, gdy inny wątek wywołuje <see cref="M:System.Threading.Thread.Interrupt" /> metodę tego wątku.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> parametru jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" />równa.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy czekać.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Reprezentująca ilość czasu oczekiwania przed przejściem wątku do kolejki gotowości.</param>
        <summary>Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady. Jeśli upłynie określony interwał limitu czasu, wątek przechodzi do kolejki gotowości.</summary>
        <returns><see langword="true" />Jeśli blokada została odbrana przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została odzyskania po upływie określonego czasu. Metoda nie zwraca do momentu odzyskania blokady.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zwraca do momentu odzyskania blokady wyłącznej na `obj` parametrze.  
  
 Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę w celu zwolnienia obiektu, tak aby inny wątek mógł uzyskać do niego dostęp. Obiekt wywołujący jest zablokowany podczas oczekiwania na odzyskanie blokady. Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmianę stanu, która zostanie wykonana w wyniku operacji innego wątku.  
  
 Limit czasu zapewnia, że bieżący wątek nie blokuje się w nieskończoność, jeśli inny wątek zwolni blokadę bez uprzedniego wywołania <xref:System.Threading.Monitor.Pulse%2A> metody <xref:System.Threading.Monitor.PulseAll%2A> lub. Przenosi również wątek do kolejki gotowości, pomijając inne wątki przed nim w kolejce oczekiwania, dzięki czemu może on ponownie uzyskać blokadę. Wątek może testować wartość <xref:System.Threading.Monitor.Wait%2A> zwracaną metody, aby określić, czy odzyskuje blokadę przed upływem limitu czasu. Wątek może oszacować warunki, które spowodowały wprowadzenie oczekiwania, i w razie potrzeby ponownie wywołać <xref:System.Threading.Monitor.Wait%2A> metodę.  
  
 Gdy wątek wywołuje `Wait`, zwalnia blokadę obiektu i przechodzi do oczekującej kolejki obiektu. Następny wątek w kolejce gotowości obiektu (jeśli istnieje) uzyskuje blokadę i ma wyłączny dostęp do obiektu. Wywoływany `Wait` wątek pozostaje w kolejce oczekiwania do momentu, aż wątek, który przechowuje <xref:System.Threading.Monitor.PulseAll%2A>blokadę, lub jest następnym w kolejce i wątek <xref:System.Threading.Monitor.Pulse%2A>, który przechowuje blokadę. Jeśli `timeout` jednak upłynie, zanim inny wątek wywoła ten <xref:System.Threading.Monitor.Pulse%2A> obiekt lub <xref:System.Threading.Monitor.PulseAll%2A> metodę, oryginalny wątek zostanie przeniesiony do kolejki gotowości w celu odzyskania blokady.  
  
> [!NOTE]
>  Jeśli <xref:System.TimeSpan> <xref:System.Threading.Monitor.Pulse%2A> dla parametru określono wartość-1 milisekunda, ta metoda blokuje się w nieskończoność, chyba że jest on posiadaczem wywołań <xref:System.Threading.Monitor.PulseAll%2A>blokady lub. `timeout` Jeśli `timeout` wartość wynosi 0 milisekund, wątek wywołujący `Wait` uwalnianie blokady, a następnie natychmiast wprowadza gotową kolejkę do odzyskania blokady.  
  
 Obiekt wywołujący `Wait` jest wykonywany jednokrotnie, niezależnie od tego <xref:System.Threading.Monitor.Enter%2A> , ile razy został wywołany dla określonego obiektu. Koncepcyjnie <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.Exit%2A> metoda przechowuje liczbę wywołanych przez obiekt wywołujący w obiekcie i wywołuje tyle razy, ile jest to konieczne, aby w pełni zwolnić zablokowany obiekt. `Wait` Obiekt wywołujący jest następnie blokowany podczas oczekiwania na ponowne uzyskanie obiektu. Gdy obiekt wywołujący ponownie uzyska blokadę, system wywoła <xref:System.Threading.Monitor.Enter%2A> tyle razy, ile jest to konieczne, aby przywrócić zapisaną <xref:System.Threading.Monitor.Enter%2A> liczbę dla obiektu wywołującego. Wywoływanie `Wait` zwalnia blokadę tylko dla określonego obiektu; Jeśli obiekt wywołujący jest właścicielem blokad dla innych obiektów, te blokady nie są zwalniane.  
  
> [!NOTE]
>  Zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości, która zawiera wątki gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki, które oczekują na powiadomienie o zmianie stanu obiektu.  
  
 Metody <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A> i`Wait` muszą być wywoływane z poziomu synchronizowanego bloku kodu.  
  
 Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Wątek wywołujący nie jest obiektem blokady określonego obiektu.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek, który wywołuje <see langword="Wait" /> , został później przerwany ze stanu oczekiwania. Dzieje się tak, gdy inny wątek wywołuje <see cref="M:System.Threading.Thread.Interrupt" /> metodę tego wątku.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> parametru w milisekundach jest ujemna i nie reprezentuje <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekund) lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy czekać.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania przed przejściem wątku do kolejki gotowości.</param>
        <param name="exitContext"><see langword="true" />Aby wyjść i ponownie uzyskać domenę synchronizacji dla kontekstu (jeśli znajduje się w synchronizowanym kontekście) przed oczekiwaniem; w przeciwnym razie. <see langword="false" /></param>
        <summary>Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady. Jeśli upłynie określony interwał limitu czasu, wątek przechodzi do kolejki gotowości. Ta metoda określa również, czy domena synchronizacji kontekstu (Jeśli w synchronizowanym kontekście) zostanie zakończona przed zaczekaniem i ponownym pozyskaniem.</summary>
        <returns><see langword="true" />Jeśli blokada została odbrana przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została odzyskania po upływie określonego czasu. Metoda nie zwraca do momentu odzyskania blokady.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zwraca do momentu odzyskania blokady wyłącznej na `obj` parametrze.  
  
 Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę w celu zwolnienia obiektu, tak aby inny wątek mógł uzyskać do niego dostęp. Obiekt wywołujący jest zablokowany podczas oczekiwania na odzyskanie blokady. Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmianę stanu, która zostanie wykonana w wyniku operacji innego wątku.  
  
 Limit czasu zapewnia, że bieżący wątek nie blokuje się w nieskończoność, jeśli inny wątek zwolni blokadę bez uprzedniego wywołania <xref:System.Threading.Monitor.Pulse%2A> metody <xref:System.Threading.Monitor.PulseAll%2A> lub. Przenosi również wątek do kolejki gotowości, pomijając inne wątki przed nim w kolejce oczekiwania, dzięki czemu może on ponownie uzyskać blokadę. Wątek może testować wartość <xref:System.Threading.Monitor.Wait%2A> zwracaną metody, aby określić, czy odzyskuje blokadę przed upływem limitu czasu. Wątek może oszacować warunki, które spowodowały wprowadzenie oczekiwania, i w razie potrzeby ponownie wywołać <xref:System.Threading.Monitor.Wait%2A> metodę.  
  
 Gdy wątek wywołuje `Wait`, zwalnia blokadę i przechodzi do oczekującej kolejki. W tym momencie następnym wątkiem w kolejce gotowości (jeśli istnieje) można przejąć kontrolę nad blokadą. Wywoływany `Wait` wątek pozostaje w kolejce oczekiwania do momentu, aż wątek, który przechowuje <xref:System.Threading.Monitor.PulseAll%2A>blokadę, lub jest następnym w kolejce i wątek <xref:System.Threading.Monitor.Pulse%2A>, który przechowuje blokadę. Jeśli `millisecondsTimeout` jednak upłynie, zanim inny wątek wywoła ten <xref:System.Threading.Monitor.Pulse%2A> obiekt lub <xref:System.Threading.Monitor.PulseAll%2A> metodę, oryginalny wątek zostanie przeniesiony do kolejki gotowości w celu odzyskania blokady.  
  
> [!NOTE]
>  Jeśli <xref:System.Threading.Timeout.Infinite> jest określony `millisecondsTimeout` dla parametru, ta metoda blokuje się w nieskończoność, chyba że posiadacz wywołań <xref:System.Threading.Monitor.Pulse%2A> Lock lub <xref:System.Threading.Monitor.PulseAll%2A>. Jeśli `millisecondsTimeout` wartość jest równa 0, wątek `Wait` , który wywołuje zwalnia blokadę, a następnie natychmiast wprowadza gotową kolejkę do odzyskania blokady.  
  
 Obiekt wywołujący `Wait` jest wykonywany jednokrotnie, niezależnie od tego <xref:System.Threading.Monitor.Enter%2A> , ile razy został wywołany dla określonego obiektu. Koncepcyjnie <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.Exit%2A> metoda przechowuje liczbę wywołanych przez obiekt wywołujący w obiekcie i wywołuje tyle razy, ile jest to konieczne, aby w pełni zwolnić zablokowany obiekt. `Wait` Obiekt wywołujący jest następnie blokowany podczas oczekiwania na ponowne uzyskanie obiektu. Gdy obiekt wywołujący ponownie uzyska blokadę, system wywoła <xref:System.Threading.Monitor.Enter%2A> tyle razy, ile jest to konieczne, aby przywrócić zapisaną <xref:System.Threading.Monitor.Enter%2A> liczbę dla obiektu wywołującego. Wywoływanie `Wait` zwalnia blokadę tylko dla określonego obiektu; Jeśli obiekt wywołujący jest właścicielem blokad dla innych obiektów, te blokady nie są zwalniane.  
  
> [!NOTE]
>  Zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości, która zawiera wątki gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki, które oczekują na powiadomienie o zmianie stanu obiektu.  
  
 Metody <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A> i`Wait` muszą być wywoływane z poziomu synchronizowanego bloku kodu.  
  
 Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 Parametr nie działa, <xref:System.Threading.Monitor.Wait%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego.`exitContext` Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.Monitor.Wait%2A> kontekstu) przed wykonaniem metody. Powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.Monitor.Wait%2A> metody.  
  
 Może to być przydatne, gdy klasa związana z kontekstem ma <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> zastosowany atrybut. W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.Monitor.Wait%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację. <xref:System.Threading.Monitor.Wait%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" />nie jest wywoływany z poziomu synchronizowanego bloku kodu.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek, który wywołuje <see langword="Wait" /> , został później przerwany ze stanu oczekiwania. Dzieje się tak, gdy inny wątek wywołuje <see cref="M:System.Threading.Thread.Interrupt" /> metodę tego wątku.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> parametru jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" />równa.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym należy czekać.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Reprezentująca ilość czasu oczekiwania przed przejściem wątku do kolejki gotowości.</param>
        <param name="exitContext"><see langword="true" />Aby wyjść i ponownie uzyskać domenę synchronizacji dla kontekstu (jeśli znajduje się w synchronizowanym kontekście) przed oczekiwaniem; w przeciwnym razie. <see langword="false" /></param>
        <summary>Zwalnia blokadę obiektu i blokuje bieżący wątek do momentu odzyskania blokady. Jeśli upłynie określony interwał limitu czasu, wątek przechodzi do kolejki gotowości. Opcjonalnie zamyka domenę synchronizacji dla kontekstu synchronizowanego przed oczekiwaniem i ponownie uzyskuje domenę.</summary>
        <returns><see langword="true" />Jeśli blokada została odbrana przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została odzyskania po upływie określonego czasu. Metoda nie zwraca do momentu odzyskania blokady.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zwraca do momentu odzyskania blokady wyłącznej na `obj` parametrze.  
  
 Wątek, który jest aktualnie właścicielem blokady określonego obiektu wywołuje tę metodę w celu zwolnienia obiektu, tak aby inny wątek mógł uzyskać do niego dostęp. Obiekt wywołujący jest zablokowany podczas oczekiwania na odzyskanie blokady. Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmianę stanu, która zostanie wykonana w wyniku operacji innego wątku.  
  
 Limit czasu zapewnia, że bieżący wątek nie blokuje się w nieskończoność, jeśli inny wątek zwolni blokadę bez uprzedniego wywołania <xref:System.Threading.Monitor.Pulse%2A> metody <xref:System.Threading.Monitor.PulseAll%2A> lub. Przenosi również wątek do kolejki gotowości, pomijając inne wątki przed nim w kolejce oczekiwania, dzięki czemu może on ponownie uzyskać blokadę. Wątek może testować wartość <xref:System.Threading.Monitor.Wait%2A> zwracaną metody, aby określić, czy odzyskuje blokadę przed upływem limitu czasu. Wątek może oszacować warunki, które spowodowały wprowadzenie oczekiwania, i w razie potrzeby ponownie wywołać <xref:System.Threading.Monitor.Wait%2A> metodę.  
  
 Gdy wątek wywołuje `Wait`, zwalnia blokadę i przechodzi do oczekującej kolejki. W tym momencie następnym wątkiem w kolejce gotowości (jeśli istnieje) można przejąć kontrolę nad blokadą. Wywoływany `Wait` wątek pozostaje w kolejce oczekiwania do momentu, aż wątek, który przechowuje <xref:System.Threading.Monitor.PulseAll%2A>blokadę, lub jest następnym w kolejce i wątek <xref:System.Threading.Monitor.Pulse%2A>, który przechowuje blokadę. Jeśli `timeout` jednak milisekundy upłynie, zanim inny wątek wywoła ten <xref:System.Threading.Monitor.Pulse%2A> obiekt lub <xref:System.Threading.Monitor.PulseAll%2A> metodę, oryginalny wątek zostanie przeniesiony do kolejki gotowości w celu odzyskania blokady.  
  
> [!NOTE]
>  Jeśli <xref:System.TimeSpan> <xref:System.Threading.Monitor.Pulse%2A> dla parametru określono wartość-1 milisekunda, ta metoda blokuje się w nieskończoność, chyba że jest on posiadaczem wywołań <xref:System.Threading.Monitor.PulseAll%2A>blokady lub. `timeout` Jeśli `timeout` wartość wynosi 0 milisekund, wątek wywołujący `Wait` uwalnianie blokady, a następnie natychmiast wprowadza gotową kolejkę do odzyskania blokady.  
  
 Obiekt wywołujący `Wait` jest wykonywany jednokrotnie, niezależnie od tego <xref:System.Threading.Monitor.Enter%2A> , ile razy został wywołany dla określonego obiektu. Koncepcyjnie <xref:System.Threading.Monitor.Enter%2A> <xref:System.Threading.Monitor.Exit%2A> metoda przechowuje liczbę wywołanych przez obiekt wywołujący w obiekcie i wywołuje tyle razy, ile jest to konieczne, aby w pełni zwolnić zablokowany obiekt. `Wait` Obiekt wywołujący jest następnie blokowany podczas oczekiwania na ponowne uzyskanie obiektu. Gdy obiekt wywołujący ponownie uzyska blokadę, system wywoła <xref:System.Threading.Monitor.Enter%2A> tyle razy, ile jest to konieczne, aby przywrócić zapisaną <xref:System.Threading.Monitor.Enter%2A> liczbę dla obiektu wywołującego. Wywoływanie `Wait` zwalnia blokadę tylko dla określonego obiektu; Jeśli obiekt wywołujący jest właścicielem blokad dla innych obiektów, te blokady nie są zwalniane.  
  
> [!NOTE]
>  Zsynchronizowany obiekt zawiera kilka odwołań, w tym odwołanie do wątku, w którym aktualnie znajduje się blokada, odwołanie do kolejki gotowości, która zawiera wątki gotowe do uzyskania blokady, oraz odwołanie do oczekującej kolejki, która zawiera wątki, które oczekują na powiadomienie o zmianie stanu obiektu.  
  
 Metody <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A> i`Wait` muszą być wywoływane z poziomu synchronizowanego bloku kodu.  
  
 Uwagi dla metody wyjaśniają, co się dzieje <xref:System.Threading.Monitor.Pulse%2A> , <xref:System.Threading.Monitor.Pulse%2A> jeśli jest wywoływana, gdy nie oczekuje żadnych wątków.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 Parametr nie działa, <xref:System.Threading.Monitor.Wait%2A> chyba że metoda jest wywołana z wnętrza niedomyślnego kontekstu zarządzanego.`exitContext` Taka sytuacja może wystąpić, jeśli wątek jest wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet jeśli obecnie wykonujesz metodę na klasie, która nie pochodzi od <xref:System.ContextBoundObject>elementu <xref:System.String>, na przykład, możesz być w niedomyślnym kontekście, jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście niedomyślnym, określenie `true` dla `exitContext` powoduje, że wątek zamyka niedomyślny kontekst zarządzany (czyli przejście do domyślnego <xref:System.Threading.Monitor.Wait%2A> kontekstu) przed wykonaniem metody. Powraca do oryginalnego niedomyślnego kontekstu po zakończeniu wywołania <xref:System.Threading.Monitor.Wait%2A> metody.  
  
 Może to być przydatne, gdy klasa związana z kontekstem ma <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> zastosowany atrybut. W takim przypadku wszystkie wywołania elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji to cała treść kodu dla klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.Monitor.Wait%2A> metodę i określa `true` dla `exitContext`, wątek opuszcza domenę synchronizacji, zezwalając na wątek, który jest blokowany w wywołaniu dowolnego elementu członkowskiego obiektu, aby wykonać operację. <xref:System.Threading.Monitor.Wait%2A> Gdy metoda zwraca, wątek, który wykonał wywołanie, musi czekać na ponowne wprowadzenie domeny synchronizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" />nie jest wywoływany z poziomu synchronizowanego bloku kodu.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek wywołujący oczekiwania został później przerwany ze stanu oczekiwania. Dzieje się tak, gdy inny wątek wywołuje <see cref="M:System.Threading.Thread.Interrupt" /> metodę tego wątku.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametr jest ujemny i nie reprezentuje <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekund) lub jest większy niż <see cref="F:System.Int32.MaxValue" />. <paramref name="timeout" /></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
      </Docs>
    </Member>
  </Members>
</Type>

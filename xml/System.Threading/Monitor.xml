<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="954622f2462225c1791594afeb678ab93b5bb509" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39989891" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia mechanizm, który synchronizuje dostęp do obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Monitor> Klasy służy do synchronizowania dostępu do regionu kodu przez pobranie i zwalniania blokady dla określonego obiektu przez wywołanie metody <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, i <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metody. Blokady obiektu pozwalają ograniczyć dostęp do bloku kodu, często nazywane sekcję krytyczną. Podczas gdy wątek jest właścicielem blokady dla obiektu, nie z innego wątku można uzyskać tego blokady. Można również użyć <xref:System.Threading.Monitor> klasy, aby upewnić się, że nie inne wątek nie może być dostęp do części aplikacji kodu, wykonywane przez właściciela blokady, chyba że innego wątku jest wykonywany kod przy użyciu innego obiektu zablokowane.  
  
 W tym artykule:  
  
 [Klasa monitora: omówienie](#Overview)   
 [Obiekt blokady](#Lock)   
 [Sekcja krytycznego](#CriticalSection)   
 [Puls, PulseAll i oczekiwania](#Pulse)   
 [Monitory i uchwytami oczekiwania](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Klasa monitora: omówienie  
 <xref:System.Threading.Monitor> ma następujące cechy:  
  
-   Jest skojarzony z obiektem na żądanie.  
  
-   Jest ona niezwiązany, co oznacza, że mogą być wywoływane bezpośrednio z dowolnym kontekście.  
  
-   Wystąpienie <xref:System.Threading.Monitor> nie można utworzyć klasy; metody <xref:System.Threading.Monitor> klasy są wszystkie statyczne. Każda metoda jest przekazywana zsynchronizowane obiekt, który kontroluje dostęp do sekcji krytycznych.  
  
> [!NOTE]
>  Użyj <xref:System.Threading.Monitor> klasy obiektów blokady inne niż ciągi (czyli odwoływać się do typów innych niż <xref:System.String>), nie typów wartości. Aby uzyskać szczegółowe informacje, zobacz przeciążenia <xref:System.Threading.Monitor.Enter%2A> metody i [zablokować obiektu](#Lock) sekcję w dalszej części tego artykułu.  
  
 W poniższej tabeli opisano akcje, które mogą być podejmowane przez wątki, do których dostęp synchronizowane obiekty:  
  
|Akcja|Opis|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Uzyskuje blokadę dla obiektu. Ta akcja oznacza również początek sekcję krytyczną. Nie innego wątku można wprowadzić sekcję krytyczną, o ile nie wykonuje instrukcji w sekcji krytycznych, przy użyciu innego obiektu zablokowane.|  
|<xref:System.Threading.Monitor.Wait%2A>|Zwalnia blokadę na obiekcie, aby zezwolić na inne wątki, aby zablokować i uzyskać dostęp do obiektu. Wątek wywołujący czeka, podczas gdy inny wątek uzyskuje dostęp do obiektu. Sygnały Pulse są używane do powiadamiania wątków oczekujących o zmianach stanu obiektu.|  
|<xref:System.Threading.Monitor.Pulse%2A> (sygnał) <xref:System.Threading.Monitor.PulseAll%2A>|Wysyła sygnał do jednego lub więcej wątków oczekujących. Sygnał powiadamia wątku oczekiwania, który zmienił stan obiektu zablokowane, a właściciel blokady jest gotowy do zwolnienia blokady. Wątek oczekiwania jest umieszczana w kolejce gotowe obiektu, tak, aby otrzymać ostatecznie blokady dla obiektu. Gdy wątek ma blokadę, jego Sprawdź nowy stan obiektu, aby zobaczyć, jeśli osiągnięty wymaganego stanu.|  
|<xref:System.Threading.Monitor.Exit%2A>|Zwalnia blokadę na obiekcie. Ta akcja oznacza również końcu sekcję krytyczną, chronione przez zablokowany obiekt.|  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], istnieją dwa zestawy przeciążenia <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.TryEnter%2A> metody. Zawiera jeden zestaw przeciążenia `ref` (w języku C#) lub `ByRef` (w języku Visual Basic) <xref:System.Boolean> parametr, który niepodzielnie jest ustawiony na `true` Jeśli jest blokada, nawet wtedy, gdy wyjątek jest generowany podczas uzyskiwania blokady. Użyj te przeciążenia, jeśli jest niezwykle zwalnia blokadę we wszystkich przypadkach, nawet wtedy, gdy zasoby, które chroni blokady może nie być w stanie spójności.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>Obiekt blokady  
 Klasa monitora składa się z `static` (w języku C#) lub `Shared` (w języku Visual Basic) metody, które działają na obiekt, które kontroluje dostęp do krytycznych części.  Poniższe informacje są obsługiwane dla poszczególnych obiektów synchronizowanych:  
  
-   Odwołanie do wątku, który obecnie posiada blokadę.  
  
-   Odwołanie do kolejki gotowości, która zawiera wątki, które są gotowe do uzyskania blokady.  
  
-   Odwołanie do kolejki oczekujące, która zawiera wątków, które oczekują na powiadomienia o zmianie w stanie zablokowanym obiektu.  
  
 <xref:System.Threading.Monitor> blokuje obiektów (czyli typy referencyjne), nie typów wartości. Można przekazać typu wartości do <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A>, jest spakowany osobno dla każdego wywołania. Ponieważ każde wywołanie tworzy oddzielny obiekt <xref:System.Threading.Monitor.Enter%2A> nigdy nie bloków i kodu funkcji rzekomo chroni nie jest tak naprawdę zsynchronizowany. Ponadto przekazany obiekt <xref:System.Threading.Monitor.Exit%2A> jest inny niż obiekt przekazany do <xref:System.Threading.Monitor.Enter%2A>, więc <xref:System.Threading.Monitor> zgłasza <xref:System.Threading.SynchronizationLockException> wyjątek z komunikatem "Metoda synchronizacji obiektu została wywołana z niezsynchronizowanego bloku kodu."  
  
 Poniższy przykład ilustruje ten problem. Uruchamia ona dziesięciu zadań, z których każdy po prostu zostanie uśpiony 250 milisekund. Każde zadanie podrzędne następnie aktualizuje zmienną licznika `nTasks`, który jest przeznaczony do zliczania liczby zadań, które faktycznie uruchomić i wykonywane. Ponieważ `nTasks` jest zmienną globalną, które mogą być aktualizowane przez wiele zadań jednocześnie, monitor służy do ochrony przed jednoczesnych modyfikacji przez wiele zadań. Jednak jako dane wyjściowe w przykładzie pokazano, każde z zadań zgłasza <xref:System.Threading.SynchronizationLockException> wyjątku.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 Każde zadanie podrzędne zgłasza <xref:System.Threading.SynchronizationLockException> wyjątków ponieważ `nTasks` zmienna jest umieszczona przed wywołaniem do <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> metodę w każdym zadaniu. Innymi słowy każde wywołanie metody jest przekazywany oddzielna zmienna, która jest niezależna od innych. `nTasks` jest ponownie umieszczona w wywołaniu <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metody. Jeszcze raz, spowoduje to utworzenie dziesięć nowych zmiennych spakowany, które są niezależne od siebie nawzajem, `nTasks`, i spakowane dziesięciu zmiennych utworzonych w wywołaniu <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> metody. Wyjątek jest zgłaszany, następnie, ponieważ nasz kod próbuje zwolnić blokady na nowo utworzonej zmiennej, która wcześniej nie był zablokowany.  
  
 Mimo że można polu zmienną typu wartości przed wywołaniem <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A>, jak pokazano w następujących przykład i przekazać tego samego obiektu w ramce do obu tych metod, nie ma żadnych dodatkowych zalet w ten sposób. Zmiany do zmiennej rozpakowany nie są odzwierciedlane w ramce kopii i nie ma sposobu na zmianę wartości spakowanej kopiowania.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 Po wybraniu obiektu, na którym należy zsynchronizować, należy zablokować tylko w obiektach prywatne lub wewnętrzne. Blokowanie zewnętrznych obiektów może spowodować zakleszczenia, ponieważ niepowiązanych kod można wybrać te same obiekty do blokowania na do różnych celów.  
  
 Należy zauważyć, że można synchronizować na obiekcie w wielu domenach aplikacji, jeśli obiekt używany do blokowania pochodzi od klasy <xref:System.MarshalByRefObject>.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>Sekcja krytycznego  
 Użyj <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> metody służące do oznaczania początku i końcu sekcję krytyczną.  
  
> [!NOTE]
>  Funkcje udostępniane przez <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> metod jest taka sama jak dostarczony przez [blokady](~/docs/csharp/language-reference/keywords/lock-statement.md) instrukcji w języku C# i [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instrukcji w języku Visual Basic, chyba że Zawijanie konstrukcji językowych <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> przeciążenie metody i <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in Class metoda `try`...`finally` blok, aby upewnić się, jest zwolnienie monitora.  
  
 Jeśli sekcja krytycznego to zbiór instrukcji ciągły, a następnie blokadę uzyskaną przez <xref:System.Threading.Monitor.Enter%2A> metoda gwarantuje, że tylko jednego wątku można wykonać ujęty kod zablokowany obiekt. W tym przypadku zaleca się umieszczenie tego kodu w `try` blokowania i umieść wywołanie <xref:System.Threading.Monitor.Exit%2A> method in Class metoda `finally` bloku. Daje to gwarancję, że blokada jest zwalniana, nawet jeśli wystąpi wyjątek. Poniższy fragment kodu ilustruje ten wzorzec.  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 Tej funkcji jest zwykle używane do synchronizowania dostępu na statyczną lub metodę wystąpienia klasy.  
  
 Jeśli sekcja krytycznego obejmuje całą metodę, blokowanie funkcji można osiągnąć, umieszczając <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> na metodzie i podając <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> wartość w Konstruktorze typu <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>. Korzystając z tego atrybutu <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> wywołań metod nie są wymagane. Poniższy fragment kodu ilustruje tego wzorca:  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 Należy pamiętać, że atrybutu powoduje, że bieżący wątek posiada blokady, dopóki metoda zwraca; Jeśli blokada może być zwolnione szybciej, użyj <xref:System.Threading.Monitor> klasy C# [blokady](~/docs/csharp/language-reference/keywords/lock-statement.md) instrukcji lub Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instrukcji wewnątrz metody zamiast atrybutu.  
  
 Choć jest możliwe dla <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> instrukcji, blokowanie, które dany obiekt przetnie elementu członkowskiego klasy granice i/lub wersji tej praktyką nie jest zalecane.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Puls, PulseAll i oczekiwania  
 Gdy wątek jest właścicielem blokady i wprowadził sekcję krytyczną, który jest chroniony przez blokadę, może wywołać <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, i <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> metody.  
  
 <xref:System.Threading.Monitor.Wait%2A> zwalnia blokadę, jeśli są przechowywane, umożliwia wątku oczekiwania lub wątków, aby uzyskać blokadę, a następnie wprowadź sekcję krytyczną i czeka, aby otrzymywać powiadomienia za pomocą wywołania <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> lub <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> metody. Gdy <xref:System.Threading.Monitor.Wait%2A> zostanie powiadomiony, zwraca i ponownie uzyskuje blokadę.  
  
 Zarówno <xref:System.Threading.Monitor.Pulse%2A> i <xref:System.Threading.Monitor.PulseAll%2A> sygnale dla następnego wątku w kolejce oczekiwania, aby kontynuować.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>Monitory i uchwytami oczekiwania  
 Należy zauważyć różnicę między użytkowania jest <xref:System.Threading.Monitor> klasy i <xref:System.Threading.WaitHandle> obiektów.  
  
-   <xref:System.Threading.Monitor> Klasy jest całkowicie zarządzana i całkowicie przenośne i może być bardziej efektywne pod kątem wymagań dotyczących zasobów systemu operacyjnego.  
  
-   <xref:System.Threading.WaitHandle> obiekty reprezentowała obiekty oczekujący systemu operacyjnego, są przydatne podczas synchronizacji między kodem zarządzanym i niezarządzanym i ujawniać niektórych zaawansowanych funkcji systemu operacyjnego, takich jak możliwość czekać na wiele obiektów jednocześnie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Monitor> klasy do synchronizowania dostępu do pojedynczego wystąpienia generator liczb losowych reprezentowany przez <xref:System.Random> klasy. Ten przykład tworzy dziesięć zadań, z których każdy wykonuje asynchronicznie na wątku z puli wątków. Każde zadanie podrzędne generuje 10 000 liczb losowych, oblicza średnią ich i aktualizuje dwie zmienne na poziomie procedury zapewniające suma liczby liczb losowych, które są generowane, a ich suma. Po wykonaniu wszystkich zadań, te dwie wartości są następnie używane do obliczania średniej ogólnej.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 Ponieważ są one dostępne z dowolnego zadania podrzędnego uruchamiania w wątku z puli wątków, uzyskać dostęp do zmiennych `total` i `n` również muszą być synchronizowane. <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> Metoda jest używana w tym celu.  
  
 W poniższym przykładzie pokazano łącznego użycia <xref:System.Threading.Monitor> klasy (implementowane za pomocą `lock` lub `SyncLock` konstrukcją języka pierwszej klasy), <xref:System.Threading.Interlocked> klasy, a <xref:System.Threading.AutoResetEvent> klasy. Definiuje dwa `internal` (w języku C#) lub `Friend` (w języku Visual Basic) klas, `SyncResource` i `UnSyncResource`, które zapewniają odpowiednio zsynchronizowane i zsynchronizowany dostęp do zasobu. Aby upewnić się, że w przykładzie pokazano różnicę między dostępu zsynchronizowane i które nie są synchronizowane, (która może wystąpić w przypadku, jeśli każde wywołanie metody zakończy się szybko), metoda obejmuje losowe opóźnienie: dla wątków, którego <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> właściwość jest parzysta, metoda wywołuje metodę <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> do wprowadzania opóźnienia 2000 MS. Należy zauważyć, że ponieważ `SyncResource` klasy nie jest publiczna, żaden kod klienta ma blokadę zsynchronizowane zasobu; w samej klasy wewnętrznej przyjmuje blokady. Zapobiega to tworzenia blokady obiektu publicznego złośliwego kodu.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 W przykładzie zdefiniowano zmienną, `numOps`, który definiuje liczbę wątków, które próbują uzyskać dostęp do zasobu. Wywołania wątku aplikacji <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> metoda synchronizacji i/procent niezsynchronizowanych dostępu pięć razy każdego. <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> Metoda ma jeden parametr delegata, która przyjmuje żadnych parametrów i nie zwraca żadnej wartości. Zsynchronizowane dostępu wywołuje `SyncUpdateResource` metody; niezsynchronizowane dostępu wywołuje `UnSyncUpdateResource` metody. Po każdy zestaw wywołań metody wywołuje wątku aplikacji [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) metodę, tak że blokuje aż do <xref:System.Threading.AutoResetEvent> zasygnalizowania wystąpienia.  
  
 Każde wywołanie `SyncUpdateResource` metoda wywołuje wewnętrzny `SyncResource.Access` metody, a następnie wywołania <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodę, aby zmniejszyć `numOps` licznika. <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Metoda jest używana do dekrementacja licznika, ponieważ w przeciwnym razie nie będzie określone, że drugi wątek dostęp do wartości przed pierwszym wątku użytkownika wraz z przydzielaniem wartości zostały zapisane w zmiennej. Ostatni synchronizowane zmniejsza wątku roboczego licznika do zera, wskazujący, że wszystkie wątki synchronizowane została ukończona, dostęp do zasobu `SyncUpdateResource` wywołania metody <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> metody, które sygnalizują wątku głównego, aby kontynuować wykonanie.  
  
 Każde wywołanie `UnSyncUpdateResource` metoda wywołuje wewnętrzny `UnSyncResource.Access` metody, a następnie wywołania <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodę, aby zmniejszyć `numOps` licznika. Jeszcze raz <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metoda jest używana do dekrementacja licznika, aby upewnić się, że drugi wątek nie dostęp do wartości, zanim pierwszy wątek zmniejszona wartość przypisana do zmiennej. Podczas ostatniego/procent niezsynchronizowanych zmniejsza wątku roboczego licznika do zera, wskazujący, że kolejne niezsynchronizowane wątków muszą uzyskać dostęp do zasobu `UnSyncUpdateResource` wywołania metody <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> metody, które sygnalizują wątku głównego, aby kontynuować wykonywanie .  
  
 Dane wyjściowe z przykładu pokazują, zsynchronizowany dostęp zapewnia wątek wywołujący zamyka chronionego zasobu, zanim dostęp inny wątek. Każdy wątek czeka na jego poprzednika. Z drugiej strony, bez blokady `UnSyncResource.Access` metoda jest wywoływana w kolejności, w którym wątków przejść do niego.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje blokady na wyłączność dla określonego obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, w którym można uzyskać blokady monitora.</param>
        <summary>Uzyskuje blokady na wyłączność dla określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Enter` uzyskania <xref:System.Threading.Monitor> na obiekt przekazany jako parametr. Jeśli inny wątek został wykonany `Enter` obiektu, ale nie ma jeszcze wykonać odpowiednie <xref:System.Threading.Monitor.Exit%2A>, spowoduje zablokowanie bieżącego wątku, dopóki innego wątku zwalnia obiekt. Jest legalne, tym samym wątku wywołać `Enter` więcej niż jeden raz bez blokowania; jednak równej liczby `Exit` wywołania musi być wywoływany przed odblokowanie innych wątków oczekujących na obiekt.  
  
 Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości. Podczas przekazywania zmienną typu wartości `Enter`, jest spakowany jako obiekt. Jeśli przekażesz tę samą zmienną do `Enter` ponownie jest spakowany jako oddzielny obiekt i nie są blokowane w wątku. W tym przypadku kod, `Monitor` jest funkcji rzekomo ochrony nie jest chroniony. Ponadto, gdy możesz przekazać zmienną do `Exit`, inny oddzielny obiekt zostanie utworzony. Ponieważ przekazany obiekt `Exit` jest inny niż obiekt przekazany do `Enter`, `Monitor` zgłasza <xref:System.Threading.SynchronizationLockException>. Aby uzyskać więcej informacji, zobacz temat dotyczący pojęć [monitorów](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> można przerwać wątki, które oczekują na wprowadzanie `Monitor` na obiekcie. A <xref:System.Threading.ThreadInterruptedException> zostanie zgłoszony.  
  
 Używaj języka C# `try`...`finally` blok (`Try`...`Finally` w Visual Basic), aby upewnić się, monitor wersji lub używać języka C# `lock` — instrukcja (`SyncLock` instrukcji w języku Visual Basic), który opakowuje <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> metody `try`...`finally` blok.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia `Enter` metody.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym oczekiwania.</param>
        <param name="lockTaken">Wynik próba uzyskania blokady, przekazywany przez odwołanie. Wartość wejściowa musi być <see langword="false" />. Dane wyjściowe są <see langword="true" /> Jeśli jest blokada; w przeciwnym razie wynikiem jest <see langword="false" />. Dane wyjściowe jest ustawiona, nawet jeśli wystąpi wyjątek podczas próby uzyskania blokady.  
  
Należy zwrócić uwagę, jeśli nie wystąpi wyjątek, dane wyjściowe tej metody jest zawsze <see langword="true" />.</param>
        <summary>Uzyskuje blokady na wyłączność dla określonego obiektu i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Enter` uzyskania <xref:System.Threading.Monitor> na obiekt przekazany jako `obj` parametru. Jeśli inny wątek został wykonany `Enter` obiektu, ale nie ma jeszcze wykonać odpowiednie <xref:System.Threading.Monitor.Exit%2A>, spowoduje zablokowanie bieżącego wątku, dopóki innego wątku zwalnia obiekt. Jest legalne, tym samym wątku wywołać `Enter` więcej niż jeden raz bez blokowania; jednak równej liczby `Exit` wywołania musi być wywoływany przed odblokowanie innych wątków oczekujących na obiekt.  
  
 Jeśli blokada nie została wykonana, ponieważ wystąpił wyjątek, zmienna jest określona dla `lockTaken` parametr jest `false` po zakończeniu tej metody. Dzięki temu program określić, we wszystkich przypadkach, czy jest to konieczne zwolnić blokadę. Jeśli ta metoda zwraca bez zgłaszania wyjątku, zmienna jest określona dla `lockTaken` parametr jest zawsze `true`, i trzeba ją przetestować.  
  
 Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości. Podczas przekazywania zmienną typu wartości `Enter`, jest spakowany jako obiekt. Jeśli przekażesz tę samą zmienną do `Enter` ponownie jest spakowany jako oddzielny obiekt i nie są blokowane w wątku. W tym przypadku kod, `Monitor` jest funkcji rzekomo ochrony nie jest chroniony. Ponadto, gdy możesz przekazać zmienną do `Exit`, innej oddzielny obiekt zostanie utworzony. Ponieważ przekazany obiekt `Exit` jest inny niż obiekt przekazany do `Enter`, `Monitor` zgłasza <xref:System.Threading.SynchronizationLockException>. Aby uzyskać więcej informacji, zobacz temat dotyczący pojęć [monitorów](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> można przerwać wątki, które oczekują na wprowadzanie `Monitor` na obiekcie. A <xref:System.Threading.ThreadInterruptedException> zostanie zgłoszony.  
  
   
  
## Examples  
 Poniższy kod przedstawia podstawowy wzorzec przy użyciu <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> przeciążenie metody. To przeciążenie zawsze ustawia wartość zmiennej, która jest przekazywana do `ref` parametru (`ByRef` w języku Visual Basic) `lockTaken`nawet wtedy, gdy metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodny sposób, aby sprawdzić, czy blokada musi być wydana.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dane wejściowe <paramref name="lockTaken" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym chcesz zwolnić blokadę.</param>
        <summary>Zwalnia blokady na wyłączność dla określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek wywołujący musi być właścicielem blokady na `obj` parametru. Jeśli wątek wywołujący posiada blokadę określony obiekt i podejścia biznesowego uczyniło równej liczby `Exit` i <xref:System.Threading.Monitor.Enter%2A> wywołuje dla obiektu, a następnie blokada jest zwalniana. Jeśli wątek wywołujący nie zostało wywołane `Exit` tyle razy, ile `Enter`, blokada nie jest zwalniana.  
  
 Jeśli blokada jest zwalniana i inne wątki znajdują się w kolejce gotowe dla obiektu, jeden z wątków uzyskuje blokadę. W przypadku innych wątków w kolejce oczekiwania, oczekiwania na uzyskanie blokady, ich nie są automatycznie przenoszone do kolejki gotowe gdy właściciel blokady wywołuje `Exit`. Aby przenieść jeden lub więcej wątków oczekujących w kolejce gotowe, należy wywołać <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> przed wywołaniem `Exit`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia `Exit` metody.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Bieżący wątek nie posiada blokady dla określonego obiektu.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do przetestowania.</param>
        <summary>Określa, czy bieżący wątek posiada blokadę na określony obiekt.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący wątek nałoży blokadę <paramref name="obj" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa tylko w przypadku blokad, które są nabywane za pomocą metody <xref:System.Threading.Monitor> klasy lub przy użyciu języka C# `lock` instrukcji lub Visual Basic `SyncLock` instrukcji, które są implementowane za pomocą <xref:System.Threading.Monitor>.  
  
 Ta metoda za pomocą narzędzia diagnostyczne, takie jak <xref:System.Diagnostics.Debug.Assert%2A> metody i <xref:System.Diagnostics.Contracts.Contract> klasy, aby debugować problemy blokujące, obejmujące <xref:System.Threading.Monitor> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oczekiwanie obiektu wątku.</param>
        <summary>Powiadamia wątek w kolejce oczekiwania zmiany w stanie zablokowanym obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko bieżący właściciel blokady może zasygnalizowania obiektu oczekiwania przy użyciu `Pulse`.  
  
 Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę w celu zasygnalizowania następny wątek w wierszu blokady. Po odebraniu pulse, wątek oczekiwania została przeniesiona do kolejki gotowe. Kiedy wątek, wywołana `Pulse` zwalnia blokadę, następny wątek w kolejce gotowe, (które niekoniecznie jest wątek, który został impulsu) uzyskuje blokadę.  
  
> [!IMPORTANT]
>  <xref:System.Threading.Monitor> Klasy nie przechowuje stan wskazujący, że <xref:System.Threading.Monitor.Pulse%2A> została wywołana metoda. W związku z tym jeśli wywołasz <xref:System.Threading.Monitor.Pulse%2A> po żadnych wątków oczekujących, następny wątek, który wywołuje <xref:System.Threading.Monitor.Wait%2A> bloki tak, jakby <xref:System.Threading.Monitor.Pulse%2A> nigdy nie została wywołana. Jeśli z dwoma wątkami <xref:System.Threading.Monitor.Pulse%2A> i <xref:System.Threading.Monitor.Wait%2A> wchodzić w interakcje, może to spowodować zakleszczenia. Natomiast to zachowanie <xref:System.Threading.AutoResetEvent> klasy: Jeśli użytkownik sygnał <xref:System.Threading.AutoResetEvent> przez wywołanie jego <xref:System.Threading.EventWaitHandle.Set%2A> metody i nie istnieją wątki oczekujące, <xref:System.Threading.AutoResetEvent> pozostanie w zasygnalizowany stan do momentu wywołania wątku <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, lub <xref:System.Threading.WaitHandle.WaitAll%2A>. <xref:System.Threading.AutoResetEvent> Zwalnia wątek, a następnie wróci do stanu unsignaled.  
  
 Należy pamiętać, że synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątków, które oczekują na powiadomienia o zmianie stanu obiektu.  
  
 `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, I <xref:System.Threading.Monitor.Wait%2A> metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.  
  
 O wiele wątków, użyj <xref:System.Threading.Monitor.PulseAll%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Wątek wywołujący nie posiada blokady dla określonego obiektu.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który wysyła Puls.</param>
        <summary>Powiadamia wszystkie wątki oczekujące zmiany w stan obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę w celu zasygnalizowania wszystkie wątki, oczekiwania na uzyskanie blokady obiektu. Po wysłaniu sygnału wątków oczekujących są przenoszone do kolejki gotowe. Kiedy wątek, wywołana `PulseAll` zwalnia blokadę, następny wątek w kolejce gotowe uzyskuje blokadę.  
  
 Należy pamiętać, że synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątków, które oczekują na powiadomienia o zmianie stanu obiektu.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, I <xref:System.Threading.Monitor.Wait%2A> metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.  
  
 Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.  
  
 Aby zasygnalizować pojedynczego wątku, należy użyć `Pulse` metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Wątek wywołujący nie posiada blokady dla określonego obiektu.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje uzyskać wyłącznej blokady określony obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, w którym można uzyskać blokady.</param>
        <summary>Próbuje uzyskać wyłącznej blokady określony obiekt.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja się powiedzie, ta metoda uzyskuje blokady na wyłączność w `obj` parametru. Ta metoda zwraca natychmiast, czy blokada jest dostępna.  
  
 Ta metoda jest podobna do <xref:System.Threading.Monitor.Enter%2A>, ale nigdy nie blokuje bieżącego wątku. Jeśli wątek nie można wprowadzić bez blokowania, metoda zwraca `false,`.  
  
> [!NOTE]
>  Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości. Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> artykułu.  
  
 Aby upewnić się, że wątek nie wprowadził sekcję krytyczną, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcję krytyczną, tylko wtedy, gdy jego wartość zwracana jest `true`. Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania `TryEnter` metody.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, w którym można uzyskać blokady.</param>
        <param name="lockTaken">Wynik próba uzyskania blokady, przekazywany przez odwołanie. Wartość wejściowa musi być <see langword="false" />. Dane wyjściowe są <see langword="true" /> Jeśli jest blokada; w przeciwnym razie wynikiem jest <see langword="false" />. Dane wyjściowe jest ustawiona, nawet jeśli wystąpi wyjątek podczas próby uzyskania blokady.</param>
        <summary>Próbuje uzyskać wyłącznej blokady określony obiekt i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja się powiedzie, ta metoda uzyskuje blokady na wyłączność w `obj` parametru. Ta metoda zwraca natychmiast, czy blokada jest dostępna.  
  
 Jeśli blokada nie została wykonana, ponieważ wystąpił wyjątek, zmienna jest określona dla `lockTaken` parametr jest `false` po zakończeniu tej metody. Dzięki temu program określić, we wszystkich przypadkach, czy jest to konieczne zwolnić blokadę.  
  
 Ta metoda jest podobna do <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, ale nigdy nie blokuje bieżącego wątku. Jeśli wątek nie można wprowadzić bez blokowania, `lockTaken` argument ma wartość `false` gdy metoda ta zwraca.  
  
> [!NOTE]
>  Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości. Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> artykułu.  
  
 Aby upewnić się, że wątek wprowadzaj sekcję krytyczną, należy sprawdzić wartość `lockTaken` i wykonania kodu w sekcję krytyczną, tylko wtedy, gdy jej wartość jest `true`. Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 Poniższy kod przedstawia podstawowy wzorzec przy użyciu <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> przeciążenie metody. To przeciążenie zawsze ustawia wartość zmiennej, która jest przekazywana do `ref` parametru (`ByRef` w języku Visual Basic) `lockTaken`nawet wtedy, gdy metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodny sposób, aby sprawdzić, czy blokada musi być wydana.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dane wejściowe <paramref name="lockTaken" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, w którym można uzyskać blokady.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania na blokadę.</param>
        <summary>Próbuje określoną liczbę milisekund, można uzyskać blokady na wyłączność dla określonego obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` parametr ma wartość <xref:System.Threading.Timeout.Infinite>, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.Enter%2A>. Jeśli `millisecondsTimeout` jest równa 0, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości. Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> artykułu.  
  
 Aby upewnić się, że wątek nie wprowadził sekcję krytyczną, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcję krytyczną, tylko wtedy, gdy jego wartość zwracana jest `true`. Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest ujemny i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, w którym można uzyskać blokady.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący ilość czasu oczekiwania na blokadę. Wartość-1 milisekundy określa nieskończone oczekiwanie.</param>
        <summary>Prób, określoną ilość czasu, aby pozyskać blokady na wyłączność dla określonego obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `timeout` parametr przekonwertowane na milisekund jest równa -1, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.Enter%2A>. Jeśli wartość `timeout` jest równa 0, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości. Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> temat poświęcony klasie.  
  
 Aby upewnić się, że wątek nie wprowadził sekcję krytyczną, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcję krytyczną, tylko wtedy, gdy jego wartość zwracana jest `true`. Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> w milisekundach jest ujemna, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekundy), lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, w którym można uzyskać blokady.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania na blokadę.</param>
        <param name="lockTaken">Wynik próba uzyskania blokady, przekazywany przez odwołanie. Wartość wejściowa musi być <see langword="false" />. Dane wyjściowe są <see langword="true" /> Jeśli jest blokada; w przeciwnym razie wynikiem jest <see langword="false" />. Dane wyjściowe jest ustawiona, nawet jeśli wystąpi wyjątek podczas próby uzyskania blokady.</param>
        <summary>Próbuje, określoną liczbę milisekund, można uzyskać blokady na wyłączność dla określonego obiektu, dzięki czemu niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` parametr ma wartość <xref:System.Threading.Timeout.Infinite>, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.Enter%28System.Object%29>. Jeśli `millisecondsTimeout` jest równa 0, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Jeśli blokada nie została wykonana, ponieważ wystąpił wyjątek, zmienna jest określona dla `lockTaken` parametr jest `false` po zakończeniu tej metody. Dzięki temu program określić, we wszystkich przypadkach, czy jest to konieczne zwolnić blokadę.  
  
> [!NOTE]
>  Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości. Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> temat poświęcony klasie.  
  
 Aby upewnić się, że wątek wprowadzaj sekcję krytyczną, należy sprawdzić wartość `lockTaken` i wykonania kodu w sekcję krytyczną, tylko wtedy, gdy jej wartość jest `true`. Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 Poniższy kod przedstawia podstawowy wzorzec przy użyciu <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> przeciążenie metody. To przeciążenie zawsze ustawia wartość zmiennej, która jest przekazywana do `ref` parametru (`ByRef` w języku Visual Basic) `lockTaken`nawet wtedy, gdy metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodny sposób, aby sprawdzić, czy blokada musi być wydana.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dane wejściowe <paramref name="lockTaken" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest ujemny i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, w którym można uzyskać blokady.</param>
        <param name="timeout">Ilość czasu oczekiwania na blokadę. Wartość-1 milisekundy określa nieskończone oczekiwanie.</param>
        <param name="lockTaken">Wynik próba uzyskania blokady, przekazywany przez odwołanie. Wartość wejściowa musi być <see langword="false" />. Dane wyjściowe są <see langword="true" /> Jeśli jest blokada; w przeciwnym razie wynikiem jest <see langword="false" />. Dane wyjściowe jest ustawiona, nawet jeśli wystąpi wyjątek podczas próby uzyskania blokady.</param>
        <summary>Próbuje uzyskać określoną ilość czasu, aby pozyskać blokady na wyłączność dla określonego obiektu, a niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `timeout` parametr przekonwertowane na milisekund jest równa -1, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.Enter%28System.Object%29>. Jeśli wartość `timeout` jest równa 0, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Jeśli blokada nie została wykonana, ponieważ wystąpił wyjątek, zmienna jest określona dla `lockTaken` parametr jest `false` po zakończeniu tej metody. Dzięki temu program określić, we wszystkich przypadkach, czy jest to konieczne zwolnić blokadę.  
  
> [!NOTE]
>  Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości. Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> temat poświęcony klasie.  
  
 Aby upewnić się, że wątek wprowadzaj sekcję krytyczną, należy sprawdzić wartość `lockTaken` i wykonania kodu w sekcję krytyczną, tylko wtedy, gdy jej wartość jest `true`. Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody. Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dane wejściowe <paramref name="lockTaken" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> w milisekundach jest ujemna, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekundy), lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym oczekiwania.</param>
        <summary>Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady.</summary>
        <returns>
          <see langword="true" /> Jeśli wywołanie zwróciło, ponieważ obiekt wywołujący reacquired blokady dla określonego obiektu. Ta metoda nie zwraca, jeśli blokada nie jest reacquired.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę, aby zwolnić obiekt, dzięki czemu można do niego dostęp inny wątek. Obiekt wywołujący jest blokowane podczas oczekiwania na ponownie pobrać blokady. Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmiany stanu, które będzie wysyłane w wyniku operacji inny wątek.  
  
 Kiedy wątek wywołuje `Wait`, zwalnia blokadę na obiekcie i wprowadza kolejce oczekiwania obiektu. Następny wątek w kolejce gotowe obiektu (jeśli istnieje) uzyskuje blokadę, a ma wyłącznego użytku obiektu. Wszystkie wątki, które wywołują `Wait` pozostaną w kolejce oczekiwania, aż otrzyma sygnał od <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A>, wysłanych przez właściciela blokady. Jeśli `Pulse` wysłaniu dotyczy tylko wątku na czele kolejce oczekiwania. Jeśli `PulseAll` zostanie wysłany, wpływają na wszystkie wątki, które oczekują na obiekt. Po odebraniu sygnału jeden lub więcej wątków pozostaw kolejce oczekiwania i wprowadź kolejkę gotowe. Wątek w kolejce gotowe może ponownie pobrać blokady.  
  
 Ta metoda zwraca, jeśli wątek wywołujący reacquires blokadę na obiekcie. Należy zauważyć, że ta metoda blokuje, przez czas nieokreślony, jeśli właściciel blokady nie mogą wywoływać `Pulse` lub `PulseAll`.  
  
 Element wywołujący wykonuje `Wait` raz, niezależnie od tego, ile razy <xref:System.Threading.Monitor.Enter%2A> zostało wywołane dla określonego obiektu. Model `Wait` metoda przechowuje liczbę wywołany obiekt wywołujący `Enter` w obiekcie, a następnie wywołuje `Exit` tyle razy, aby całkowicie zwolnić zablokowany obiekt. Obiekt wywołujący blokuje wtedy dane podczas oczekiwania na ponownie pobrać obiekt. Gdy obiekt wywołujący reacquires blokady, system wywołuje `Enter` tyle razy, aby przywrócić zapisane `Enter` liczba do obiektu wywołującego. Wywoływanie `Wait` zwalnia blokadę dla określonego obiektu Jeśli element wywołujący jest właściciel blokady na inne obiekty, blokadami tymi nie zostaną zwolnione.  
  
 Należy pamiętać, że synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątków, które oczekują na powiadomienia o zmianie stanu obiektu.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, I `Wait` metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.  
  
 Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Wątek wywołujący nie posiada blokady dla określonego obiektu.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek, który wywołuje <see langword="Wait" /> później zostanie przerwany ze stanu oczekiwania. Tak się stanie, gdy inny wątek wywołuje ten wątek <see cref="M:System.Threading.Thread.Interrupt" /> metody.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym oczekiwania.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania przed wątku przechodzi gotowe kolejki.</param>
        <summary>Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady. Jeżeli określony limit czasu upłynie, wątku przechodzi gotowe kolejki.</summary>
        <returns>
          <see langword="true" /> Jeśli blokada została reacquired przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została reacquired po upływie określonego czasu. Metoda nie zwraca, dopóki blokada jest reacquired.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zwraca do momentu jej reacquires blokady na wyłączność w `obj` parametru.  
  
 Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę, aby zwolnić obiekt, dzięki czemu można do niego dostęp inny wątek. Obiekt wywołujący jest blokowane podczas oczekiwania na ponownie pobrać blokady. Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmiany stanu, które będzie wysyłane w wyniku operacji inny wątek.  
  
 Limit czasu zapewnia, że bieżący wątek nie blokuje przez czas nieokreślony Jeśli inny wątek zwalnia blokadę bez wywoływania pierwszy <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody. Przesuwa się również wątek do kolejki gotowe, tak, aby je można ponownie pobrać blokady wcześniej z pominięciem innych wątków w przód od jej w kolejce oczekiwania. Wątek można sprawdzić wartość zwracaną przez <xref:System.Threading.Monitor.Wait%2A> metodę pozwala ustalić, czy jego reacquired blokady przed limit czasu. Wątek może służyć do oceny warunków, które spowodowało wprowadzenie czas oczekiwania, czas i, jeśli konieczne wywołanie <xref:System.Threading.Monitor.Wait%2A> ponownie metodą.  
  
 Kiedy wątek wywołuje `Wait`, zwalnia blokadę na obiekcie i wprowadza kolejce oczekiwania obiektu. Następny wątek w kolejce gotowe obiektu (jeśli istnieje) uzyskuje blokadę, a ma wyłącznego użytku obiektu. Wątek, który jest wywoływany `Wait` pozostaje w kolejce oczekiwania, aż do wątku, który posiada blokadę wywołuje <xref:System.Threading.Monitor.PulseAll%2A>, lub jest dalej w kolejce, i wywołuje wątku, który posiada blokadę <xref:System.Threading.Monitor.Pulse%2A>. Jednak jeśli `millisecondsTimeout` musi upłynąć, zanim inny wątek wywołuje ten obiekt <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody, oryginalnym wątku została przeniesiona do kolejki gotowe w celu odzyskania blokady.  
  
> [!NOTE]
>  Jeśli <xref:System.Threading.Timeout.Infinite> jest określona dla `millisecondsTimeout` parametru tej metody na czas nieokreślony blokuje, chyba że właściciel blokady wywołuje <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A>. Jeśli `millisecondsTimeout` jest równa 0, wątek, który wywołuje `Wait` zwalnia blokadę, a następnie od razu wchodzi gotowe kolejki w celu odzyskania blokady.  
  
 Element wywołujący wykonuje `Wait` raz, niezależnie od tego, ile razy <xref:System.Threading.Monitor.Enter%2A> zostało wywołane dla określonego obiektu. Model `Wait` metoda przechowuje liczbę wywołany obiekt wywołujący <xref:System.Threading.Monitor.Enter%2A> w obiekcie, a następnie wywołuje <xref:System.Threading.Monitor.Exit%2A> tyle razy, aby całkowicie zwolnić zablokowany obiekt. Obiekt wywołujący blokuje wtedy dane podczas oczekiwania na ponownie pobrać obiekt. Gdy obiekt wywołujący reacquires blokady, system wywołuje <xref:System.Threading.Monitor.Enter%2A> tyle razy, aby przywrócić zapisane <xref:System.Threading.Monitor.Enter%2A> liczba do obiektu wywołującego. Wywoływanie `Wait` zwalnia blokadę dla określonego obiektu Jeśli element wywołujący jest właściciel blokady na inne obiekty, blokadami tymi nie zostaną zwolnione.  
  
> [!NOTE]
>  Synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątki, które oczekują na powiadomienia o zmianie stanu obiektu.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, I `Wait` metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.  
  
 Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Wątek wywołujący nie posiada blokady dla określonego obiektu.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek, który wywołuje <see langword="Wait" /> później zostanie przerwany ze stanu oczekiwania. Tak się stanie, gdy inny wątek wywołuje ten wątek <see cref="M:System.Threading.Thread.Interrupt" /> metody.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> parametr ma wartość ujemną, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym oczekiwania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący ilość czasu oczekiwania na wątku przechodzi gotowe kolejki.</param>
        <summary>Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady. Jeżeli określony limit czasu upłynie, wątku przechodzi gotowe kolejki.</summary>
        <returns>
          <see langword="true" /> Jeśli blokada została reacquired przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została reacquired po upływie określonego czasu. Metoda nie zwraca, dopóki blokada jest reacquired.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zwraca do momentu jej reacquires blokady na wyłączność w `obj` parametru.  
  
 Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę, aby zwolnić obiekt, dzięki czemu można do niego dostęp inny wątek. Obiekt wywołujący jest blokowane podczas oczekiwania na ponownie pobrać blokady. Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmiany stanu, które będzie wysyłane w wyniku operacji inny wątek.  
  
 Limit czasu zapewnia, że bieżący wątek nie blokuje przez czas nieokreślony Jeśli inny wątek zwalnia blokadę bez wywoływania pierwszy <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody. Przesuwa się również wątek do kolejki gotowe, tak, aby je można ponownie pobrać blokady wcześniej z pominięciem innych wątków w przód od jej w kolejce oczekiwania. Wątek można sprawdzić wartość zwracaną przez <xref:System.Threading.Monitor.Wait%2A> metodę pozwala ustalić, czy jego reacquired blokady przed limit czasu. Wątek może służyć do oceny warunków, które spowodowało wprowadzenie czas oczekiwania, czas i, jeśli konieczne wywołanie <xref:System.Threading.Monitor.Wait%2A> ponownie metodą.  
  
 Kiedy wątek wywołuje `Wait`, zwalnia blokadę na obiekcie i wprowadza kolejce oczekiwania obiektu. Następny wątek w kolejce gotowe obiektu (jeśli istnieje) uzyskuje blokadę, a ma wyłącznego użytku obiektu. Wątek, który jest wywoływany `Wait` pozostaje w kolejce oczekiwania, aż do wątku, który posiada blokadę wywołuje <xref:System.Threading.Monitor.PulseAll%2A>, lub jest dalej w kolejce, i wywołuje wątku, który posiada blokadę <xref:System.Threading.Monitor.Pulse%2A>. Jednak jeśli `timeout` musi upłynąć, zanim inny wątek wywołuje ten obiekt <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody, oryginalnym wątku została przeniesiona do kolejki gotowe w celu odzyskania blokady.  
  
> [!NOTE]
>  Jeśli <xref:System.TimeSpan> reprezentujący milisekund-1 jest określona dla `timeout` parametru tej metody na czas nieokreślony blokuje, chyba że właściciel blokady wywołuje <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A>. Jeśli `timeout` wynosi 0 milisekund, wątek, który wywołuje `Wait` zwalnia blokadę, a następnie od razu wchodzi gotowe kolejki w celu odzyskania blokady.  
  
 Element wywołujący wykonuje `Wait` raz, niezależnie od tego, ile razy <xref:System.Threading.Monitor.Enter%2A> zostało wywołane dla określonego obiektu. Model `Wait` metoda przechowuje liczbę wywołany obiekt wywołujący <xref:System.Threading.Monitor.Enter%2A> w obiekcie, a następnie wywołuje <xref:System.Threading.Monitor.Exit%2A> tyle razy, aby całkowicie zwolnić zablokowany obiekt. Obiekt wywołujący blokuje wtedy dane podczas oczekiwania na ponownie pobrać obiekt. Gdy obiekt wywołujący reacquires blokady, system wywołuje <xref:System.Threading.Monitor.Enter%2A> tyle razy, aby przywrócić zapisane <xref:System.Threading.Monitor.Enter%2A> liczba do obiektu wywołującego. Wywoływanie `Wait` zwalnia blokadę dla określonego obiektu Jeśli element wywołujący jest właściciel blokady na inne obiekty, blokadami tymi nie zostaną zwolnione.  
  
> [!NOTE]
>  Synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątki, które oczekują na powiadomienia o zmianie stanu obiektu.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, I `Wait` metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.  
  
 Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Wątek wywołujący nie posiada blokady dla określonego obiektu.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek, który wywołuje <see langword="Wait" /> później zostanie przerwany ze stanu oczekiwania. Tak się stanie, gdy inny wątek wywołuje ten wątek <see cref="M:System.Threading.Thread.Interrupt" /> metody.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> parametru w milisekundach jest ujemna, a nie reprezentuje <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekundy), lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym oczekiwania.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania przed wątku przechodzi gotowe kolejki.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zamknąć i ponownie pobrać domeny synchronizacji dla kontekstu (Jeśli w kontekście zsynchronizowane) przed oczekiwaniem; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady. Jeżeli określony limit czasu upłynie, wątku przechodzi gotowe kolejki. Ta metoda określa również, czy domeny synchronizacji dla kontekstu (jeśli są w synchronizowane context) jest zakończony przed czas oczekiwania i reacquired później.</summary>
        <returns>
          <see langword="true" /> Jeśli blokada została reacquired przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została reacquired po upływie określonego czasu. Metoda nie zwraca, dopóki blokada jest reacquired.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zwraca do momentu jej reacquires blokady na wyłączność w `obj` parametru.  
  
 Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę, aby zwolnić obiekt, dzięki czemu można do niego dostęp inny wątek. Obiekt wywołujący jest blokowane podczas oczekiwania na ponownie pobrać blokady. Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmiany stanu, które będzie wysyłane w wyniku operacji inny wątek.  
  
 Limit czasu zapewnia, że bieżący wątek nie blokuje przez czas nieokreślony Jeśli inny wątek zwalnia blokadę bez wywoływania pierwszy <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody. Przesuwa się również wątek do kolejki gotowe, tak, aby je można ponownie pobrać blokady wcześniej z pominięciem innych wątków w przód od jej w kolejce oczekiwania. Wątek można sprawdzić wartość zwracaną przez <xref:System.Threading.Monitor.Wait%2A> metodę pozwala ustalić, czy jego reacquired blokady przed limit czasu. Wątek może służyć do oceny warunków, które spowodowało wprowadzenie czas oczekiwania, czas i, jeśli konieczne wywołanie <xref:System.Threading.Monitor.Wait%2A> ponownie metodą.  
  
 Kiedy wątek wywołuje `Wait`, zwalnia blokadę, a przechodzi w kolejce oczekiwania. W tym momencie następny wątek w kolejce gotowy (jeśli istnieje) może przejąć kontrolę nad blokady. Wątek, który jest wywoływany `Wait` pozostaje w kolejce oczekiwania, aż do wątku, który posiada blokadę wywołuje <xref:System.Threading.Monitor.PulseAll%2A>, lub jest dalej w kolejce, i wywołuje wątku, który posiada blokadę <xref:System.Threading.Monitor.Pulse%2A>. Jednak jeśli `millisecondsTimeout` musi upłynąć, zanim inny wątek wywołuje ten obiekt <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody, oryginalnym wątku została przeniesiona do kolejki gotowe w celu odzyskania blokady.  
  
> [!NOTE]
>  Jeśli <xref:System.Threading.Timeout.Infinite> jest określona dla `millisecondsTimeout` parametru tej metody na czas nieokreślony blokuje, chyba że właściciel blokady wywołuje <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A>. Jeśli `millisecondsTimeout` jest równa 0, wątek, który wywołuje `Wait` zwalnia blokadę, a następnie od razu wchodzi gotowe kolejki w celu odzyskania blokady.  
  
 Element wywołujący wykonuje `Wait` raz, niezależnie od tego, ile razy <xref:System.Threading.Monitor.Enter%2A> zostało wywołane dla określonego obiektu. Model `Wait` metoda przechowuje liczbę wywołany obiekt wywołujący <xref:System.Threading.Monitor.Enter%2A> w obiekcie, a następnie wywołuje <xref:System.Threading.Monitor.Exit%2A> tyle razy, aby całkowicie zwolnić zablokowany obiekt. Obiekt wywołujący blokuje wtedy dane podczas oczekiwania na ponownie pobrać obiekt. Gdy obiekt wywołujący reacquires blokady, system wywołuje <xref:System.Threading.Monitor.Enter%2A> tyle razy, aby przywrócić zapisane <xref:System.Threading.Monitor.Enter%2A> liczba do obiektu wywołującego. Wywoływanie `Wait` zwalnia blokadę dla określonego obiektu Jeśli element wywołujący jest właściciel blokady na inne obiekty, blokadami tymi nie zostaną zwolnione.  
  
> [!NOTE]
>  Synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątki, które oczekują na powiadomienia o zmianie stanu obiektu.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, I `Wait` metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.  
  
 Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.Monitor.Wait%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych. Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.Monitor.Wait%2A> metody. Zwraca do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.Monitor.Wait%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> zastosowany. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.Monitor.Wait%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować. Gdy <xref:System.Threading.Monitor.Wait%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> w ramach zsynchronizowane bloku kodu nie jest wywoływany z.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek, który wywołuje <see langword="Wait" /> później zostanie przerwany ze stanu oczekiwania. Tak się stanie, gdy inny wątek wywołuje ten wątek <see cref="M:System.Threading.Thread.Interrupt" /> metody.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> parametr ma wartość ujemną, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, na którym oczekiwania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący ilość czasu oczekiwania na wątku przechodzi gotowe kolejki.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zamknąć i ponownie pobrać domeny synchronizacji dla kontekstu (Jeśli w kontekście zsynchronizowane) przed oczekiwaniem; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady. Jeżeli określony limit czasu upłynie, wątku przechodzi gotowe kolejki. Opcjonalnie zamyka domeny synchronizacji dla kontekstu zsynchronizowane przed czas oczekiwania i później reacquires domeny.</summary>
        <returns>
          <see langword="true" /> Jeśli blokada została reacquired przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została reacquired po upływie określonego czasu. Metoda nie zwraca, dopóki blokada jest reacquired.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zwraca do momentu jej reacquires blokady na wyłączność w `obj` parametru.  
  
 Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę, aby zwolnić obiekt, dzięki czemu można do niego dostęp inny wątek. Obiekt wywołujący jest blokowane podczas oczekiwania na ponownie pobrać blokady. Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmiany stanu, które będzie wysyłane w wyniku operacji inny wątek.  
  
 Limit czasu zapewnia, że bieżący wątek nie blokuje przez czas nieokreślony Jeśli inny wątek zwalnia blokadę bez wywoływania pierwszy <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody. Przesuwa się również wątek do kolejki gotowe, tak, aby je można ponownie pobrać blokady wcześniej z pominięciem innych wątków w przód od jej w kolejce oczekiwania. Wątek można sprawdzić wartość zwracaną przez <xref:System.Threading.Monitor.Wait%2A> metodę pozwala ustalić, czy jego reacquired blokady przed limit czasu. Wątek może służyć do oceny warunków, które spowodowało wprowadzenie czas oczekiwania, czas i, jeśli konieczne wywołanie <xref:System.Threading.Monitor.Wait%2A> ponownie metodą.  
  
 Kiedy wątek wywołuje `Wait`, zwalnia blokadę, a przechodzi w kolejce oczekiwania. W tym momencie następny wątek w kolejce gotowy (jeśli istnieje) może przejąć kontrolę nad blokady. Wątek, który jest wywoływany `Wait` pozostaje w kolejce oczekiwania, aż do wątku, który posiada blokadę wywołuje <xref:System.Threading.Monitor.PulseAll%2A>, lub jest dalej w kolejce, i wywołuje wątku, który posiada blokadę <xref:System.Threading.Monitor.Pulse%2A>. Jednak jeśli `timeout` milisekund oczekiwania przed inny wątek wywołuje ten obiekt <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody, oryginalnym wątku została przeniesiona do kolejki gotowe w celu odzyskania blokady.  
  
> [!NOTE]
>  Jeśli <xref:System.TimeSpan> reprezentujący milisekund wartości-1 jest określona dla `timeout` parametru tej metody na czas nieokreślony blokuje, chyba że właściciel blokady wywołuje <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A>. Jeśli `timeout` wynosi 0 milisekund, wątek, który wywołuje `Wait` zwalnia blokadę, a następnie od razu wchodzi gotowe kolejki w celu odzyskania blokady.  
  
 Element wywołujący wykonuje `Wait` raz, niezależnie od tego, ile razy <xref:System.Threading.Monitor.Enter%2A> zostało wywołane dla określonego obiektu. Model `Wait` metoda przechowuje liczbę wywołany obiekt wywołujący <xref:System.Threading.Monitor.Enter%2A> w obiekcie, a następnie wywołuje <xref:System.Threading.Monitor.Exit%2A> tyle razy, aby całkowicie zwolnić zablokowany obiekt. Obiekt wywołujący blokuje wtedy dane podczas oczekiwania na ponownie pobrać obiekt. Gdy obiekt wywołujący reacquires blokady, system wywołuje <xref:System.Threading.Monitor.Enter%2A> tyle razy, aby przywrócić zapisane <xref:System.Threading.Monitor.Enter%2A> liczba do obiektu wywołującego. Wywoływanie `Wait` zwalnia blokadę dla określonego obiektu Jeśli element wywołujący jest właściciel blokady na inne obiekty, blokadami tymi nie zostaną zwolnione.  
  
> [!NOTE]
>  Synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątki, które oczekują na powiadomienia o zmianie stanu obiektu.  
  
 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, I `Wait` metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.  
  
 Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.Monitor.Wait%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych. Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.Monitor.Wait%2A> metody. Zwraca do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.Monitor.Wait%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> zastosowany. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.Monitor.Wait%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować. Gdy <xref:System.Threading.Monitor.Wait%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> w ramach zsynchronizowane bloku kodu nie jest wywoływany z.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek, który wywołuje oczekiwania później zostało przerwane ze stanu oczekiwania. Tak się stanie, gdy inny wątek wywołuje ten wątek <see cref="M:System.Threading.Thread.Interrupt" /> metody.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> Parametru jest ujemna, a nie reprezentuje <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekundy), lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
  </Members>
</Type>
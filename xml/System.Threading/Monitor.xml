<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3bfaa4f0ca1c607a6d8ac9414307092efd5b281a" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67243378" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="e480b-101">Udostępnia mechanizm, który synchronizuje dostęp do obiektów.</span><span class="sxs-lookup"><span data-stu-id="e480b-101">Provides a mechanism that synchronizes access to objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-102"><xref:System.Threading.Monitor> Klasy służy do synchronizowania dostępu do regionu kodu przez pobranie i zwalniania blokady dla określonego obiektu przez wywołanie metody <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, i <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-102">The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="e480b-103">Blokady obiektu pozwalają ograniczyć dostęp do bloku kodu, często nazywane sekcję krytyczną.</span><span class="sxs-lookup"><span data-stu-id="e480b-103">Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</span></span> <span data-ttu-id="e480b-104">Podczas gdy wątek jest właścicielem blokady dla obiektu, nie z innego wątku można uzyskać tego blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-104">While a thread owns the lock for an object, no other thread can acquire that lock.</span></span> <span data-ttu-id="e480b-105">Można również użyć <xref:System.Threading.Monitor> klasy, aby upewnić się, że nie inne wątek nie może być dostęp do części aplikacji kodu, wykonywane przez właściciela blokady, chyba że innego wątku jest wykonywany kod przy użyciu innego obiektu zablokowane.</span><span class="sxs-lookup"><span data-stu-id="e480b-105">You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</span></span>  
  
 <span data-ttu-id="e480b-106">W tym artykule:</span><span class="sxs-lookup"><span data-stu-id="e480b-106">In this article:</span></span>  
  
 <span data-ttu-id="e480b-107">[Klasa monitora: Omówienie](#Overview) </span><span class="sxs-lookup"><span data-stu-id="e480b-107">[The Monitor class: An overview](#Overview) </span></span>  
 <span data-ttu-id="e480b-108">[Obiekt blokady](#Lock) </span><span class="sxs-lookup"><span data-stu-id="e480b-108">[The lock object](#Lock) </span></span>  
 <span data-ttu-id="e480b-109">[Sekcja krytycznego](#CriticalSection) </span><span class="sxs-lookup"><span data-stu-id="e480b-109">[The critical section](#CriticalSection) </span></span>  
 <span data-ttu-id="e480b-110">[Puls, PulseAll i oczekiwania](#Pulse) </span><span class="sxs-lookup"><span data-stu-id="e480b-110">[Pulse, PulseAll, and Wait](#Pulse) </span></span>  
 [<span data-ttu-id="e480b-111">Monitory i uchwytami oczekiwania</span><span class="sxs-lookup"><span data-stu-id="e480b-111">Monitors and wait handles</span></span>](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a><span data-ttu-id="e480b-112">Klasa monitora: Omówienie</span><span class="sxs-lookup"><span data-stu-id="e480b-112">The Monitor class: An overview</span></span>  
 <span data-ttu-id="e480b-113"><xref:System.Threading.Monitor> ma następujące cechy:</span><span class="sxs-lookup"><span data-stu-id="e480b-113"><xref:System.Threading.Monitor> has the following features:</span></span>  
  
-   <span data-ttu-id="e480b-114">Jest skojarzony z obiektem na żądanie.</span><span class="sxs-lookup"><span data-stu-id="e480b-114">It is associated with an object on demand.</span></span>  
  
-   <span data-ttu-id="e480b-115">Jest ona niezwiązany, co oznacza, że mogą być wywoływane bezpośrednio z dowolnym kontekście.</span><span class="sxs-lookup"><span data-stu-id="e480b-115">It is unbound, which means it can be called directly from any context.</span></span>  
  
-   <span data-ttu-id="e480b-116">Wystąpienie <xref:System.Threading.Monitor> nie można utworzyć klasy; metody <xref:System.Threading.Monitor> klasy są wszystkie statyczne.</span><span class="sxs-lookup"><span data-stu-id="e480b-116">An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static.</span></span> <span data-ttu-id="e480b-117">Każda metoda jest przekazywana zsynchronizowane obiekt, który kontroluje dostęp do sekcji krytycznych.</span><span class="sxs-lookup"><span data-stu-id="e480b-117">Each method is passed the synchronized object that controls access to the critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-118">Użyj <xref:System.Threading.Monitor> klasy obiektów blokady inne niż ciągi (czyli odwoływać się do typów innych niż <xref:System.String>), nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-118">Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types.</span></span> <span data-ttu-id="e480b-119">Aby uzyskać szczegółowe informacje, zobacz przeciążenia <xref:System.Threading.Monitor.Enter%2A> metody i [zablokować obiektu](#Lock) sekcję w dalszej części tego artykułu.</span><span class="sxs-lookup"><span data-stu-id="e480b-119">For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.</span></span>  
  
 <span data-ttu-id="e480b-120">W poniższej tabeli opisano akcje, które mogą być podejmowane przez wątki, do których dostęp synchronizowane obiekty:</span><span class="sxs-lookup"><span data-stu-id="e480b-120">The following table describes the actions that can be taken by threads that access synchronized objects:</span></span>  
  
|<span data-ttu-id="e480b-121">Akcja</span><span class="sxs-lookup"><span data-stu-id="e480b-121">Action</span></span>|<span data-ttu-id="e480b-122">Opis</span><span class="sxs-lookup"><span data-stu-id="e480b-122">Description</span></span>|  
|------------|-----------------|  
|<span data-ttu-id="e480b-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span><span class="sxs-lookup"><span data-stu-id="e480b-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span></span>|<span data-ttu-id="e480b-124">Uzyskuje blokadę dla obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-124">Acquires a lock for an object.</span></span> <span data-ttu-id="e480b-125">Ta akcja oznacza również początek sekcję krytyczną.</span><span class="sxs-lookup"><span data-stu-id="e480b-125">This action also marks the beginning of a critical section.</span></span> <span data-ttu-id="e480b-126">Nie innego wątku można wprowadzić sekcję krytyczną, o ile nie wykonuje instrukcji w sekcji krytycznych, przy użyciu innego obiektu zablokowane.</span><span class="sxs-lookup"><span data-stu-id="e480b-126">No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</span></span>|  
|<xref:System.Threading.Monitor.Wait%2A>|<span data-ttu-id="e480b-127">Zwalnia blokadę na obiekcie, aby zezwolić na inne wątki, aby zablokować i uzyskać dostęp do obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-127">Releases the lock on an object in order to permit other threads to lock and access the object.</span></span> <span data-ttu-id="e480b-128">Wątek wywołujący czeka, podczas gdy inny wątek uzyskuje dostęp do obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-128">The calling thread waits while another thread accesses the object.</span></span> <span data-ttu-id="e480b-129">Sygnały Pulse są używane do powiadamiania wątków oczekujących o zmianach stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-129">Pulse signals are used to notify waiting threads about changes to an object's state.</span></span>|  
|<span data-ttu-id="e480b-130"><xref:System.Threading.Monitor.Pulse%2A> (sygnał) <xref:System.Threading.Monitor.PulseAll%2A></span><span class="sxs-lookup"><span data-stu-id="e480b-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span></span>|<span data-ttu-id="e480b-131">Wysyła sygnał do jednego lub więcej wątków oczekujących.</span><span class="sxs-lookup"><span data-stu-id="e480b-131">Sends a signal to one or more waiting threads.</span></span> <span data-ttu-id="e480b-132">Sygnał powiadamia wątku oczekiwania, który zmienił stan obiektu zablokowane, a właściciel blokady jest gotowy do zwolnienia blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-132">The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</span></span> <span data-ttu-id="e480b-133">Wątek oczekiwania jest umieszczana w kolejce gotowe obiektu, tak, aby otrzymać ostatecznie blokady dla obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-133">The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</span></span> <span data-ttu-id="e480b-134">Gdy wątek ma blokadę, jego Sprawdź nowy stan obiektu, aby zobaczyć, jeśli osiągnięty wymaganego stanu.</span><span class="sxs-lookup"><span data-stu-id="e480b-134">Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</span></span>|  
|<xref:System.Threading.Monitor.Exit%2A>|<span data-ttu-id="e480b-135">Zwalnia blokadę na obiekcie.</span><span class="sxs-lookup"><span data-stu-id="e480b-135">Releases the lock on an object.</span></span> <span data-ttu-id="e480b-136">Ta akcja oznacza również końcu sekcję krytyczną, chronione przez zablokowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-136">This action also marks the end of a critical section protected by the locked object.</span></span>|  
  
 <span data-ttu-id="e480b-137">Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], istnieją dwa zestawy przeciążenia <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.TryEnter%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-137">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods.</span></span> <span data-ttu-id="e480b-138">Zawiera jeden zestaw przeciążenia `ref` (w języku C#) lub `ByRef` (w języku Visual Basic) <xref:System.Boolean> parametr, który niepodzielnie jest ustawiony na `true` Jeśli jest blokada, nawet wtedy, gdy wyjątek jest generowany podczas uzyskiwania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-138">One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock.</span></span> <span data-ttu-id="e480b-139">Użyj te przeciążenia, jeśli jest niezwykle zwalnia blokadę we wszystkich przypadkach, nawet wtedy, gdy zasoby, które chroni blokady może nie być w stanie spójności.</span><span class="sxs-lookup"><span data-stu-id="e480b-139">Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</span></span>  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a><span data-ttu-id="e480b-140">Obiekt blokady</span><span class="sxs-lookup"><span data-stu-id="e480b-140">The lock object</span></span>  
 <span data-ttu-id="e480b-141">Klasa monitora składa się z `static` (w języku C#) lub `Shared` (w języku Visual Basic) metody, które działają na obiekt, które kontroluje dostęp do krytycznych części.</span><span class="sxs-lookup"><span data-stu-id="e480b-141">The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.</span></span>  <span data-ttu-id="e480b-142">Poniższe informacje są obsługiwane dla poszczególnych obiektów synchronizowanych:</span><span class="sxs-lookup"><span data-stu-id="e480b-142">The following information is maintained for each synchronized object:</span></span>  
  
-   <span data-ttu-id="e480b-143">Odwołanie do wątku, który obecnie posiada blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-143">A reference to the thread that currently holds the lock.</span></span>  
  
-   <span data-ttu-id="e480b-144">Odwołanie do kolejki gotowości, która zawiera wątki, które są gotowe do uzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-144">A reference to a ready queue, which contains the threads that are ready to obtain the lock.</span></span>  
  
-   <span data-ttu-id="e480b-145">Odwołanie do kolejki oczekujące, która zawiera wątków, które oczekują na powiadomienia o zmianie w stanie zablokowanym obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-145">A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</span></span>  
  
 <span data-ttu-id="e480b-146"><xref:System.Threading.Monitor> blokuje obiektów (czyli typy referencyjne), nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-146"><xref:System.Threading.Monitor> locks objects (that is, reference types), not value types.</span></span> <span data-ttu-id="e480b-147">Można przekazać typu wartości do <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A>, jest spakowany osobno dla każdego wywołania.</span><span class="sxs-lookup"><span data-stu-id="e480b-147">While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call.</span></span> <span data-ttu-id="e480b-148">Ponieważ każde wywołanie tworzy oddzielny obiekt <xref:System.Threading.Monitor.Enter%2A> nigdy nie bloków i kodu funkcji rzekomo chroni nie jest tak naprawdę zsynchronizowany.</span><span class="sxs-lookup"><span data-stu-id="e480b-148">Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized.</span></span> <span data-ttu-id="e480b-149">Ponadto przekazany obiekt <xref:System.Threading.Monitor.Exit%2A> jest inny niż obiekt przekazany do <xref:System.Threading.Monitor.Enter%2A>, więc <xref:System.Threading.Monitor> zgłasza <xref:System.Threading.SynchronizationLockException> wyjątek z komunikatem "Metoda synchronizacji obiektu została wywołana z niezsynchronizowanego bloku kodu."</span><span class="sxs-lookup"><span data-stu-id="e480b-149">In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message "Object synchronization method was called from an unsynchronized block of code."</span></span>  
  
 <span data-ttu-id="e480b-150">Poniższy przykład ilustruje ten problem.</span><span class="sxs-lookup"><span data-stu-id="e480b-150">The following example illustrates this problem.</span></span> <span data-ttu-id="e480b-151">Uruchamia ona dziesięciu zadań, z których każdy po prostu zostanie uśpiony 250 milisekund.</span><span class="sxs-lookup"><span data-stu-id="e480b-151">It launches ten tasks, each of which just sleeps for 250 milliseconds.</span></span> <span data-ttu-id="e480b-152">Każde zadanie podrzędne następnie aktualizuje zmienną licznika `nTasks`, który jest przeznaczony do zliczania liczby zadań, które faktycznie uruchomić i wykonywane.</span><span class="sxs-lookup"><span data-stu-id="e480b-152">Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed.</span></span> <span data-ttu-id="e480b-153">Ponieważ `nTasks` jest zmienną globalną, które mogą być aktualizowane przez wiele zadań jednocześnie, monitor służy do ochrony przed jednoczesnych modyfikacji przez wiele zadań.</span><span class="sxs-lookup"><span data-stu-id="e480b-153">Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</span></span> <span data-ttu-id="e480b-154">Jednak jako dane wyjściowe w przykładzie pokazano, każde z zadań zgłasza <xref:System.Threading.SynchronizationLockException> wyjątku.</span><span class="sxs-lookup"><span data-stu-id="e480b-154">However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 <span data-ttu-id="e480b-155">Każde zadanie podrzędne zgłasza <xref:System.Threading.SynchronizationLockException> wyjątków ponieważ `nTasks` zmienna jest umieszczona przed wywołaniem do <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> metodę w każdym zadaniu.</span><span class="sxs-lookup"><span data-stu-id="e480b-155">Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method in each task.</span></span> <span data-ttu-id="e480b-156">Innymi słowy każde wywołanie metody jest przekazywany oddzielna zmienna, która jest niezależna od innych.</span><span class="sxs-lookup"><span data-stu-id="e480b-156">In other words, each method call is passed a separate variable that is independent of the others.</span></span> <span data-ttu-id="e480b-157">`nTasks` jest ponownie umieszczona w wywołaniu <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-157">`nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e480b-158">Jeszcze raz, spowoduje to utworzenie dziesięć nowych zmiennych spakowany, które są niezależne od siebie nawzajem, `nTasks`, i spakowane dziesięciu zmiennych utworzonych w wywołaniu <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-158">Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e480b-159">Wyjątek jest zgłaszany, następnie, ponieważ nasz kod próbuje zwolnić blokady na nowo utworzonej zmiennej, która wcześniej nie był zablokowany.</span><span class="sxs-lookup"><span data-stu-id="e480b-159">The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</span></span>  
  
 <span data-ttu-id="e480b-160">Mimo że można polu zmienną typu wartości przed wywołaniem <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A>, jak pokazano w następujących przykład i przekazać tego samego obiektu w ramce do obu tych metod, nie ma żadnych dodatkowych zalet w ten sposób.</span><span class="sxs-lookup"><span data-stu-id="e480b-160">Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</span></span> <span data-ttu-id="e480b-161">Zmiany do zmiennej rozpakowany nie są odzwierciedlane w ramce kopii i nie ma sposobu na zmianę wartości spakowanej kopiowania.</span><span class="sxs-lookup"><span data-stu-id="e480b-161">Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 <span data-ttu-id="e480b-162">Po wybraniu obiektu, na którym należy zsynchronizować, należy zablokować tylko w obiektach prywatne lub wewnętrzne.</span><span class="sxs-lookup"><span data-stu-id="e480b-162">When selecting an object on which to synchronize, you should lock only on private or internal objects.</span></span> <span data-ttu-id="e480b-163">Blokowanie zewnętrznych obiektów może spowodować zakleszczenia, ponieważ niepowiązanych kod można wybrać te same obiekty do blokowania na do różnych celów.</span><span class="sxs-lookup"><span data-stu-id="e480b-163">Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</span></span>  
  
 <span data-ttu-id="e480b-164">Należy zauważyć, że można synchronizować na obiekcie w wielu domenach aplikacji, jeśli obiekt używany do blokowania pochodzi od klasy <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="e480b-164">Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a><span data-ttu-id="e480b-165">Sekcja krytycznego</span><span class="sxs-lookup"><span data-stu-id="e480b-165">The critical section</span></span>  
 <span data-ttu-id="e480b-166">Użyj <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> metody służące do oznaczania początku i końcu sekcję krytyczną.</span><span class="sxs-lookup"><span data-stu-id="e480b-166">Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-167">Funkcje udostępniane przez <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> metod jest taka sama jak dostarczony przez [blokady](~/docs/csharp/language-reference/keywords/lock-statement.md) instrukcji w języku C# i [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instrukcji w języku Visual Basic, chyba że Zawijanie konstrukcji językowych <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> przeciążenie metody i <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in Class metoda `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="e480b-167">The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in a `try`…`finally`</span></span> <span data-ttu-id="e480b-168">blok, aby upewnić się, jest zwolnienie monitora.</span><span class="sxs-lookup"><span data-stu-id="e480b-168">block to ensure that the monitor is released.</span></span>  
  
 <span data-ttu-id="e480b-169">Jeśli sekcja krytycznego to zbiór instrukcji ciągły, a następnie blokadę uzyskaną przez <xref:System.Threading.Monitor.Enter%2A> metoda gwarantuje, że tylko jednego wątku można wykonać ujęty kod zablokowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-169">If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object.</span></span> <span data-ttu-id="e480b-170">W tym przypadku zaleca się umieszczenie tego kodu w `try` blokowania i umieść wywołanie <xref:System.Threading.Monitor.Exit%2A> method in Class metoda `finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="e480b-170">In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block.</span></span> <span data-ttu-id="e480b-171">Daje to gwarancję, że blokada jest zwalniana, nawet jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-171">This ensures that the lock is released even if an exception occurs.</span></span> <span data-ttu-id="e480b-172">Poniższy fragment kodu ilustruje ten wzorzec.</span><span class="sxs-lookup"><span data-stu-id="e480b-172">The following code fragment illustrates this pattern.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 <span data-ttu-id="e480b-173">Tej funkcji jest zwykle używane do synchronizowania dostępu na statyczną lub metodę wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="e480b-173">This facility is typically used to synchronize access to a static or instance method of a class.</span></span>  
  
 <span data-ttu-id="e480b-174">Jeśli sekcja krytycznego obejmuje całą metodę, blokowanie funkcji można osiągnąć, umieszczając <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> na metodzie i podając <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> wartość w Konstruktorze typu <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e480b-174">If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e480b-175">Korzystając z tego atrybutu <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> wywołań metod nie są wymagane.</span><span class="sxs-lookup"><span data-stu-id="e480b-175">When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed.</span></span> <span data-ttu-id="e480b-176">Poniższy fragment kodu ilustruje tego wzorca:</span><span class="sxs-lookup"><span data-stu-id="e480b-176">The following code fragment illustrates this pattern:</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 <span data-ttu-id="e480b-177">Należy pamiętać, że atrybutu powoduje, że bieżący wątek posiada blokady, dopóki metoda zwraca; Jeśli blokada może być zwolnione szybciej, użyj <xref:System.Threading.Monitor> klasy C# [blokady](~/docs/csharp/language-reference/keywords/lock-statement.md) instrukcji lub Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instrukcji wewnątrz metody zamiast atrybutu.</span><span class="sxs-lookup"><span data-stu-id="e480b-177">Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement, or the Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement inside of the method instead of the attribute.</span></span>  
  
 <span data-ttu-id="e480b-178">Choć jest możliwe dla <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> instrukcji, blokowanie, które dany obiekt przetnie elementu członkowskiego klasy granice i/lub wersji tej praktyką nie jest zalecane.</span><span class="sxs-lookup"><span data-stu-id="e480b-178">While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</span></span>  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a><span data-ttu-id="e480b-179">Puls, PulseAll i oczekiwania</span><span class="sxs-lookup"><span data-stu-id="e480b-179">Pulse, PulseAll, and Wait</span></span>  
 <span data-ttu-id="e480b-180">Gdy wątek jest właścicielem blokady i wprowadził sekcję krytyczną, który jest chroniony przez blokadę, może wywołać <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, i <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-180">Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="e480b-181">Kiedy wątek przechowuje wywołania blokady <xref:System.Threading.Monitor.Wait%2A>, blokada jest zwalniana i wątku jest dodawane do kolejki oczekiwania obiektu zsynchronizowane.</span><span class="sxs-lookup"><span data-stu-id="e480b-181">When the thread that holds the lock calls <xref:System.Threading.Monitor.Wait%2A>, the lock is released and the thread is added to the waiting queue of the synchronized object.</span></span> <span data-ttu-id="e480b-182">Pierwszym wątkiem w kolejce gotowe, uzyskuje blokadę i wprowadza sekcję krytyczną.</span><span class="sxs-lookup"><span data-stu-id="e480b-182">The first thread in the ready queue, if any, acquires the lock and enters the critical section.</span></span> <span data-ttu-id="e480b-183">Wątek został przeniesiony z kolejce oczekiwania w kolejce gotowy po albo <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> (do przeniesienia, wątek to na czele kolejce oczekiwania) lub <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> metoda jest wywoływana przez wątek, który posiada blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-183">The thread is moved from the waiting queue to the ready queue when either the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> (to be moved, the thread must be at the head of the waiting queue) or the <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> method is called by the thread that holds the lock.</span></span> <span data-ttu-id="e480b-184"><xref:System.Threading.Monitor.Wait%2A> Metoda zwraca wartość, gdy wątek wywołujący reacquires blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-184">The <xref:System.Threading.Monitor.Wait%2A> method returns when the calling thread reacquires the lock.</span></span>  
  
 <span data-ttu-id="e480b-185">Kiedy wątek przechowuje wywołania blokady <xref:System.Threading.Monitor.Pulse%2A>, wątek na czele kolejce oczekiwania zostanie przeniesiona do kolejki gotowe.</span><span class="sxs-lookup"><span data-stu-id="e480b-185">When the thread that holds the lock calls <xref:System.Threading.Monitor.Pulse%2A>, the thread at the head of the waiting queue is moved to the ready queue.</span></span> <span data-ttu-id="e480b-186">Wywołanie <xref:System.Threading.Monitor.PulseAll%2A> metoda przenosi wszystkie wątki z kolejce oczekiwania w kolejce gotowe.</span><span class="sxs-lookup"><span data-stu-id="e480b-186">The call to the <xref:System.Threading.Monitor.PulseAll%2A> method moves all the threads from the waiting queue to the ready queue.</span></span>  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a><span data-ttu-id="e480b-187">Monitory i uchwytami oczekiwania</span><span class="sxs-lookup"><span data-stu-id="e480b-187">Monitors and wait handles</span></span>  
 <span data-ttu-id="e480b-188">Należy zauważyć różnicę między użytkowania jest <xref:System.Threading.Monitor> klasy i <xref:System.Threading.WaitHandle> obiektów.</span><span class="sxs-lookup"><span data-stu-id="e480b-188">It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.</span></span>  
  
-   <span data-ttu-id="e480b-189"><xref:System.Threading.Monitor> Klasy jest całkowicie zarządzana i całkowicie przenośne i może być bardziej efektywne pod kątem wymagań dotyczących zasobów systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="e480b-189">The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</span></span>  
  
-   <span data-ttu-id="e480b-190"><xref:System.Threading.WaitHandle> obiekty reprezentowała obiekty oczekujący systemu operacyjnego, są przydatne podczas synchronizacji między kodem zarządzanym i niezarządzanym i ujawniać niektórych zaawansowanych funkcji systemu operacyjnego, takich jak możliwość czekać na wiele obiektów jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="e480b-190"><xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e480b-191">W poniższym przykładzie użyto <xref:System.Threading.Monitor> klasy do synchronizowania dostępu do pojedynczego wystąpienia generator liczb losowych reprezentowany przez <xref:System.Random> klasy.</span><span class="sxs-lookup"><span data-stu-id="e480b-191">The following example uses the <xref:System.Threading.Monitor> class to synchronize access to a single instance of a random number generator represented by the <xref:System.Random> class.</span></span> <span data-ttu-id="e480b-192">Ten przykład tworzy dziesięć zadań, z których każdy wykonuje asynchronicznie na wątku z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="e480b-192">The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</span></span> <span data-ttu-id="e480b-193">Każde zadanie podrzędne generuje 10 000 liczb losowych, oblicza średnią ich i aktualizuje dwie zmienne na poziomie procedury zapewniające suma liczby liczb losowych, które są generowane, a ich suma.</span><span class="sxs-lookup"><span data-stu-id="e480b-193">Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</span></span> <span data-ttu-id="e480b-194">Po wykonaniu wszystkich zadań, te dwie wartości są następnie używane do obliczania średniej ogólnej.</span><span class="sxs-lookup"><span data-stu-id="e480b-194">After all tasks have executed, these two values are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="e480b-195">Ponieważ są one dostępne z dowolnego zadania podrzędnego uruchamiania w wątku z puli wątków, uzyskać dostęp do zmiennych `total` i `n` również muszą być synchronizowane.</span><span class="sxs-lookup"><span data-stu-id="e480b-195">Because they can be accessed from any task running on a thread pool thread, access to the variables `total` and `n` must also be synchronized.</span></span> <span data-ttu-id="e480b-196"><xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> Metoda jest używana w tym celu.</span><span class="sxs-lookup"><span data-stu-id="e480b-196">The <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method is used for this purpose.</span></span>  
  
 <span data-ttu-id="e480b-197">W poniższym przykładzie pokazano łącznego użycia <xref:System.Threading.Monitor> klasy (implementowane za pomocą `lock` lub `SyncLock` konstrukcją języka pierwszej klasy), <xref:System.Threading.Interlocked> klasy, a <xref:System.Threading.AutoResetEvent> klasy.</span><span class="sxs-lookup"><span data-stu-id="e480b-197">The following example demonstrates the combined use of the <xref:System.Threading.Monitor> class (implemented with the `lock` or `SyncLock` language construct), the <xref:System.Threading.Interlocked> class, and the <xref:System.Threading.AutoResetEvent> class.</span></span> <span data-ttu-id="e480b-198">Definiuje dwa `internal` (w języku C#) lub `Friend` (w języku Visual Basic) klas, `SyncResource` i `UnSyncResource`, które zapewniają odpowiednio zsynchronizowane i zsynchronizowany dostęp do zasobu.</span><span class="sxs-lookup"><span data-stu-id="e480b-198">It defines two `internal` (in C#) or `Friend` (in Visual Basic) classes, `SyncResource` and `UnSyncResource`, that respectively provide synchronized and unsynchronized access to a resource.</span></span> <span data-ttu-id="e480b-199">Aby upewnić się, że w przykładzie pokazano różnicę między dostępu zsynchronizowane i które nie są synchronizowane, (która może wystąpić w przypadku, jeśli każde wywołanie metody zakończy się szybko), metoda obejmuje losowe opóźnienie: dla wątków, którego <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> właściwość jest parzysta, metoda wywołuje metodę <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> do wprowadzania opóźnienia 2000 MS.</span><span class="sxs-lookup"><span data-stu-id="e480b-199">To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property is even, the method calls <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> to introduce a delay of 2,000 milliseconds.</span></span> <span data-ttu-id="e480b-200">Należy zauważyć, że ponieważ `SyncResource` klasy nie jest publiczna, żaden kod klienta ma blokadę zsynchronizowane zasobu; w samej klasy wewnętrznej przyjmuje blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-200">Note that, because the `SyncResource` class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</span></span> <span data-ttu-id="e480b-201">Zapobiega to tworzenia blokady obiektu publicznego złośliwego kodu.</span><span class="sxs-lookup"><span data-stu-id="e480b-201">This prevents malicious code from taking a lock on a public object.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 <span data-ttu-id="e480b-202">W przykładzie zdefiniowano zmienną, `numOps`, który definiuje liczbę wątków, które próbują uzyskać dostęp do zasobu.</span><span class="sxs-lookup"><span data-stu-id="e480b-202">The example defines a variable, `numOps`, that defines the number of threads that will attempt to access the resource.</span></span> <span data-ttu-id="e480b-203">Wywołania wątku aplikacji <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> metoda synchronizacji i/procent niezsynchronizowanych dostępu pięć razy każdego.</span><span class="sxs-lookup"><span data-stu-id="e480b-203">The application thread calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method for synchronized and unsynchronized access five times each.</span></span> <span data-ttu-id="e480b-204"><xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> Metoda ma jeden parametr delegata, która przyjmuje żadnych parametrów i nie zwraca żadnej wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-204">The <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method has a single parameter, a delegate that accepts no parameters and returns no value.</span></span> <span data-ttu-id="e480b-205">Zsynchronizowane dostępu wywołuje `SyncUpdateResource` metody; niezsynchronizowane dostępu wywołuje `UnSyncUpdateResource` metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-205">For synchronized access, it invokes the `SyncUpdateResource` method; for unsynchronized access, it invokes the `UnSyncUpdateResource` method.</span></span> <span data-ttu-id="e480b-206">Po każdy zestaw wywołań metody wywołuje wątku aplikacji [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) metodę, tak że blokuje aż do <xref:System.Threading.AutoResetEvent> zasygnalizowania wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="e480b-206">After each set of method calls, the application thread calls the [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) method so that it blocks until the <xref:System.Threading.AutoResetEvent> instance is signaled.</span></span>  
  
 <span data-ttu-id="e480b-207">Każde wywołanie `SyncUpdateResource` metoda wywołuje wewnętrzny `SyncResource.Access` metody, a następnie wywołania <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodę, aby zmniejszyć `numOps` licznika.</span><span class="sxs-lookup"><span data-stu-id="e480b-207">Each call to the `SyncUpdateResource` method calls the internal `SyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="e480b-208"><xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Metoda jest używana do dekrementacja licznika, ponieważ w przeciwnym razie nie będzie określone, że drugi wątek dostęp do wartości przed pierwszym wątku użytkownika wraz z przydzielaniem wartości zostały zapisane w zmiennej.</span><span class="sxs-lookup"><span data-stu-id="e480b-208">The <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</span></span> <span data-ttu-id="e480b-209">Ostatni synchronizowane zmniejsza wątku roboczego licznika do zera, wskazujący, że wszystkie wątki synchronizowane została ukończona, dostęp do zasobu `SyncUpdateResource` wywołania metody <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> metody, które sygnalizują wątku głównego, aby kontynuować wykonanie.</span><span class="sxs-lookup"><span data-stu-id="e480b-209">When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the `SyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="e480b-210">Każde wywołanie `UnSyncUpdateResource` metoda wywołuje wewnętrzny `UnSyncResource.Access` metody, a następnie wywołania <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodę, aby zmniejszyć `numOps` licznika.</span><span class="sxs-lookup"><span data-stu-id="e480b-210">Each call to the `UnSyncUpdateResource` method calls the internal `UnSyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="e480b-211">Jeszcze raz <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metoda jest używana do dekrementacja licznika, aby upewnić się, że drugi wątek nie dostęp do wartości, zanim pierwszy wątek zmniejszona wartość przypisana do zmiennej.</span><span class="sxs-lookup"><span data-stu-id="e480b-211">Once again, the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</span></span> <span data-ttu-id="e480b-212">Podczas ostatniego/procent niezsynchronizowanych zmniejsza wątku roboczego licznika do zera, wskazujący, że kolejne niezsynchronizowane wątków muszą uzyskać dostęp do zasobu `UnSyncUpdateResource` wywołania metody <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> metody, które sygnalizują wątku głównego, aby kontynuować wykonywanie .</span><span class="sxs-lookup"><span data-stu-id="e480b-212">When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the `UnSyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="e480b-213">Dane wyjściowe z przykładu pokazują, zsynchronizowany dostęp zapewnia wątek wywołujący zamyka chronionego zasobu, zanim dostęp inny wątek. Każdy wątek czeka na jego poprzednika.</span><span class="sxs-lookup"><span data-stu-id="e480b-213">As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</span></span> <span data-ttu-id="e480b-214">Z drugiej strony, bez blokady `UnSyncResource.Access` metoda jest wywoływana w kolejności, w którym wątków przejść do niego.</span><span class="sxs-lookup"><span data-stu-id="e480b-214">On the other hand, without the lock, the `UnSyncResource.Access` method is called in the order in which threads reach it.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="e480b-215">Ten typ jest bezpieczny wątkowo.</span><span class="sxs-lookup"><span data-stu-id="e480b-215">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-216">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-216">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="e480b-217">Wątkowość obiektów i funkcji</span><span class="sxs-lookup"><span data-stu-id="e480b-217">Threading Objects and Features</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e480b-218">Uzyskuje blokady na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-218">Acquires an exclusive lock on a specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-219">Obiekt, w którym można uzyskać blokady monitora.</span><span class="sxs-lookup"><span data-stu-id="e480b-219">The object on which to acquire the monitor lock.</span></span></param>
        <summary><span data-ttu-id="e480b-220">Uzyskuje blokady na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-220">Acquires an exclusive lock on the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-221">Użyj `Enter` uzyskania <xref:System.Threading.Monitor> na obiekt przekazany jako parametr.</span><span class="sxs-lookup"><span data-stu-id="e480b-221">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter.</span></span> <span data-ttu-id="e480b-222">Jeśli inny wątek został wykonany `Enter` obiektu, ale nie ma jeszcze wykonać odpowiednie <xref:System.Threading.Monitor.Exit%2A>, spowoduje zablokowanie bieżącego wątku, dopóki innego wątku zwalnia obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-222">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="e480b-223">Jest legalne, tym samym wątku wywołać `Enter` więcej niż jeden raz bez blokowania; jednak równej liczby `Exit` wywołania musi być wywoływany przed odblokowanie innych wątków oczekujących na obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-223">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="e480b-224">Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-224">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="e480b-225">Podczas przekazywania zmienną typu wartości `Enter`, jest spakowany jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-225">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="e480b-226">Jeśli przekażesz tę samą zmienną do `Enter` ponownie jest spakowany jako oddzielny obiekt i nie są blokowane w wątku.</span><span class="sxs-lookup"><span data-stu-id="e480b-226">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="e480b-227">W tym przypadku kod, `Monitor` jest funkcji rzekomo ochrony nie jest chroniony.</span><span class="sxs-lookup"><span data-stu-id="e480b-227">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="e480b-228">Ponadto, gdy możesz przekazać zmienną do `Exit`, inny oddzielny obiekt zostanie utworzony.</span><span class="sxs-lookup"><span data-stu-id="e480b-228">Furthermore, when you pass the variable to `Exit`, still another separate object is created.</span></span> <span data-ttu-id="e480b-229">Ponieważ przekazany obiekt `Exit` jest inny niż obiekt przekazany do `Enter`, `Monitor` zgłasza <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="e480b-229">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="e480b-230">Aby uzyskać więcej informacji, zobacz temat dotyczący pojęć [monitorów](xref:System.Threading.Monitor).</span><span class="sxs-lookup"><span data-stu-id="e480b-230">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="e480b-231"><xref:System.Threading.Thread.Interrupt%2A> można przerwać wątki, które oczekują na wprowadzanie `Monitor` na obiekcie.</span><span class="sxs-lookup"><span data-stu-id="e480b-231"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="e480b-232">A <xref:System.Threading.ThreadInterruptedException> zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="e480b-232">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
 <span data-ttu-id="e480b-233">Używaj języka C# `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="e480b-233">Use a C# `try`…`finally`</span></span> <span data-ttu-id="e480b-234">blok (`Try`...`Finally`</span><span class="sxs-lookup"><span data-stu-id="e480b-234">block (`Try`…`Finally`</span></span> <span data-ttu-id="e480b-235">w Visual Basic), aby upewnić się, monitor wersji lub używać języka C# `lock` — instrukcja (`SyncLock` instrukcji w języku Visual Basic), który opakowuje <xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> metody `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="e480b-235">in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`…`finally`</span></span> <span data-ttu-id="e480b-236">blok.</span><span class="sxs-lookup"><span data-stu-id="e480b-236">block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e480b-237">Poniższy przykład pokazuje sposób użycia `Enter` metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-237">The following example demonstrates how to use the `Enter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-238"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-238">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-239">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-239">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-240">Obiekt, na którym oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-240">The object on which to wait.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="e480b-241">Wynik próba uzyskania blokady, przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="e480b-241">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="e480b-242">Wartość wejściowa musi być <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-242">The input must be <see langword="false" />.</span></span> <span data-ttu-id="e480b-243">Dane wyjściowe są <see langword="true" /> Jeśli jest blokada; w przeciwnym razie wynikiem jest <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-243">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="e480b-244">Dane wyjściowe jest ustawiona, nawet jeśli wystąpi wyjątek podczas próby uzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-244">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span>  
  
<span data-ttu-id="e480b-245">Należy zwrócić uwagę, jeśli nie wystąpi wyjątek, dane wyjściowe tej metody jest zawsze <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-245">Note   If no exception occurs, the output of this method is always <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="e480b-246">Uzyskuje blokady na wyłączność dla określonego obiektu i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</span><span class="sxs-lookup"><span data-stu-id="e480b-246">Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-247">Użyj `Enter` uzyskania <xref:System.Threading.Monitor> na obiekt przekazany jako `obj` parametru.</span><span class="sxs-lookup"><span data-stu-id="e480b-247">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter.</span></span> <span data-ttu-id="e480b-248">Jeśli inny wątek został wykonany `Enter` obiektu, ale nie ma jeszcze wykonać odpowiednie <xref:System.Threading.Monitor.Exit%2A>, spowoduje zablokowanie bieżącego wątku, dopóki innego wątku zwalnia obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-248">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="e480b-249">Jest legalne, tym samym wątku wywołać `Enter` więcej niż jeden raz bez blokowania; jednak równej liczby `Exit` wywołania musi być wywoływany przed odblokowanie innych wątków oczekujących na obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-249">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="e480b-250">Jeśli blokada nie została wykonana, ponieważ wystąpił wyjątek, zmienna jest określona dla `lockTaken` parametr jest `false` po zakończeniu tej metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-250">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="e480b-251">Dzięki temu program określić, we wszystkich przypadkach, czy jest to konieczne zwolnić blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-251">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span> <span data-ttu-id="e480b-252">Jeśli ta metoda zwraca bez zgłaszania wyjątku, zmienna jest określona dla `lockTaken` parametr jest zawsze `true`, i trzeba ją przetestować.</span><span class="sxs-lookup"><span data-stu-id="e480b-252">If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.</span></span>  
  
 <span data-ttu-id="e480b-253">Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-253">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="e480b-254">Podczas przekazywania zmienną typu wartości `Enter`, jest spakowany jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-254">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="e480b-255">Jeśli przekażesz tę samą zmienną do `Enter` ponownie jest spakowany jako oddzielny obiekt i nie są blokowane w wątku.</span><span class="sxs-lookup"><span data-stu-id="e480b-255">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="e480b-256">W tym przypadku kod, `Monitor` jest funkcji rzekomo ochrony nie jest chroniony.</span><span class="sxs-lookup"><span data-stu-id="e480b-256">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="e480b-257">Ponadto, gdy możesz przekazać zmienną do `Exit`, innej oddzielny obiekt zostanie utworzony.</span><span class="sxs-lookup"><span data-stu-id="e480b-257">Furthermore, when you pass the variable to `Exit`, another separate object is created.</span></span> <span data-ttu-id="e480b-258">Ponieważ przekazany obiekt `Exit` jest inny niż obiekt przekazany do `Enter`, `Monitor` zgłasza <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="e480b-258">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="e480b-259">Aby uzyskać więcej informacji, zobacz temat dotyczący pojęć [monitorów](xref:System.Threading.Monitor).</span><span class="sxs-lookup"><span data-stu-id="e480b-259">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="e480b-260"><xref:System.Threading.Thread.Interrupt%2A> można przerwać wątki, które oczekują na wprowadzanie `Monitor` na obiekcie.</span><span class="sxs-lookup"><span data-stu-id="e480b-260"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="e480b-261">A <xref:System.Threading.ThreadInterruptedException> zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="e480b-261">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e480b-262">Poniższy kod przedstawia podstawowy wzorzec przy użyciu <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-262">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="e480b-263">To przeciążenie zawsze ustawia wartość zmiennej, która jest przekazywana do `ref` parametru (`ByRef` w języku Visual Basic) `lockTaken`nawet wtedy, gdy metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodny sposób, aby sprawdzić, czy blokada musi być wydana.</span><span class="sxs-lookup"><span data-stu-id="e480b-263">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e480b-264">Dane wejściowe <paramref name="lockTaken" /> jest <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-264">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-265"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-265">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-266">Obiekt, na którym chcesz zwolnić blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-266">The object on which to release the lock.</span></span></param>
        <summary><span data-ttu-id="e480b-267">Zwalnia blokady na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-267">Releases an exclusive lock on the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-268">Wątek wywołujący musi być właścicielem blokady na `obj` parametru.</span><span class="sxs-lookup"><span data-stu-id="e480b-268">The calling thread must own the lock on the `obj` parameter.</span></span> <span data-ttu-id="e480b-269">Jeśli wątek wywołujący posiada blokadę określony obiekt i podejścia biznesowego uczyniło równej liczby `Exit` i <xref:System.Threading.Monitor.Enter%2A> wywołuje dla obiektu, a następnie blokada jest zwalniana.</span><span class="sxs-lookup"><span data-stu-id="e480b-269">If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released.</span></span> <span data-ttu-id="e480b-270">Jeśli wątek wywołujący nie zostało wywołane `Exit` tyle razy, ile `Enter`, blokada nie jest zwalniana.</span><span class="sxs-lookup"><span data-stu-id="e480b-270">If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.</span></span>  
  
 <span data-ttu-id="e480b-271">Jeśli blokada jest zwalniana i inne wątki znajdują się w kolejce gotowe dla obiektu, jeden z wątków uzyskuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-271">If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</span></span> <span data-ttu-id="e480b-272">W przypadku innych wątków w kolejce oczekiwania, oczekiwania na uzyskanie blokady, ich nie są automatycznie przenoszone do kolejki gotowe gdy właściciel blokady wywołuje `Exit`.</span><span class="sxs-lookup"><span data-stu-id="e480b-272">If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`.</span></span> <span data-ttu-id="e480b-273">Aby przenieść jeden lub więcej wątków oczekujących w kolejce gotowe, należy wywołać <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> przed wywołaniem `Exit`.</span><span class="sxs-lookup"><span data-stu-id="e480b-273">To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e480b-274">Poniższy przykład pokazuje sposób użycia `Exit` metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-274">The following example demonstrates how to use the `Exit` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-275"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-275">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="e480b-276">Bieżący wątek nie posiada blokady dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-276">The current thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-277">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-277">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-278">Obiekt do przetestowania.</span><span class="sxs-lookup"><span data-stu-id="e480b-278">The object to test.</span></span></param>
        <summary><span data-ttu-id="e480b-279">Określa, czy bieżący wątek posiada blokadę na określony obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-279">Determines whether the current thread holds the lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="e480b-280"><see langword="true" /> Jeśli bieżący wątek nałoży blokadę <paramref name="obj" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-280"><see langword="true" /> if the current thread holds the lock on <paramref name="obj" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-281">Ta metoda działa tylko w przypadku blokad, które są nabywane za pomocą metody <xref:System.Threading.Monitor> klasy lub przy użyciu języka C# `lock` instrukcji lub Visual Basic `SyncLock` instrukcji, które są implementowane za pomocą <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="e480b-281">This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="e480b-282">Ta metoda za pomocą narzędzia diagnostyczne, takie jak <xref:System.Diagnostics.Debug.Assert%2A> metody i <xref:System.Diagnostics.Contracts.Contract> klasy, aby debugować problemy blokujące, obejmujące <xref:System.Threading.Monitor> klasy.</span><span class="sxs-lookup"><span data-stu-id="e480b-282">Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-283"><paramref name="obj" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-283"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-284">Oczekiwanie obiektu wątku.</span><span class="sxs-lookup"><span data-stu-id="e480b-284">The object a thread is waiting for.</span></span></param>
        <summary><span data-ttu-id="e480b-285">Powiadamia wątek w kolejce oczekiwania zmiany w stanie zablokowanym obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-285">Notifies a thread in the waiting queue of a change in the locked object's state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-286">Tylko bieżący właściciel blokady może zasygnalizowania obiektu oczekiwania przy użyciu `Pulse`.</span><span class="sxs-lookup"><span data-stu-id="e480b-286">Only the current owner of the lock can signal a waiting object using `Pulse`.</span></span>  
  
 <span data-ttu-id="e480b-287">Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę w celu zasygnalizowania następny wątek w wierszu blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-287">The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</span></span> <span data-ttu-id="e480b-288">Po odebraniu pulse, wątek oczekiwania została przeniesiona do kolejki gotowe.</span><span class="sxs-lookup"><span data-stu-id="e480b-288">Upon receiving the pulse, the waiting thread is moved to the ready queue.</span></span> <span data-ttu-id="e480b-289">Kiedy wątek, wywołana `Pulse` zwalnia blokadę, następny wątek w kolejce gotowe, (które niekoniecznie jest wątek, który został impulsu) uzyskuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-289">When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e480b-290"><xref:System.Threading.Monitor> Klasy nie przechowuje stan wskazujący, że <xref:System.Threading.Monitor.Pulse%2A> została wywołana metoda.</span><span class="sxs-lookup"><span data-stu-id="e480b-290">The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called.</span></span> <span data-ttu-id="e480b-291">W związku z tym jeśli wywołasz <xref:System.Threading.Monitor.Pulse%2A> po żadnych wątków oczekujących, następny wątek, który wywołuje <xref:System.Threading.Monitor.Wait%2A> bloki tak, jakby <xref:System.Threading.Monitor.Pulse%2A> nigdy nie została wywołana.</span><span class="sxs-lookup"><span data-stu-id="e480b-291">Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called.</span></span> <span data-ttu-id="e480b-292">Jeśli z dwoma wątkami <xref:System.Threading.Monitor.Pulse%2A> i <xref:System.Threading.Monitor.Wait%2A> wchodzić w interakcje, może to spowodować zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="e480b-292">If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock.</span></span> <span data-ttu-id="e480b-293">Natomiast to zachowanie <xref:System.Threading.AutoResetEvent> klasy: Jeśli użytkownik sygnał <xref:System.Threading.AutoResetEvent> przez wywołanie jego <xref:System.Threading.EventWaitHandle.Set%2A> metody i nie istnieją wątki oczekujące, <xref:System.Threading.AutoResetEvent> pozostanie w zasygnalizowany stan do momentu wywołania wątku <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, lub <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-293">Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="e480b-294"><xref:System.Threading.AutoResetEvent> Zwalnia wątek, a następnie wróci do stanu unsignaled.</span><span class="sxs-lookup"><span data-stu-id="e480b-294">The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.</span></span>  
  
 <span data-ttu-id="e480b-295">Należy pamiętać, że synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątków, które oczekują na powiadomienia o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-295">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="e480b-296">`Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, I <xref:System.Threading.Monitor.Wait%2A> metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="e480b-296">The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="e480b-297">O wiele wątków, użyj <xref:System.Threading.Monitor.PulseAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-297">To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-298"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-298">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="e480b-299">Wątek wywołujący nie posiada blokady dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-299">The calling thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-300">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-300">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-301">Obiekt, który wysyła Puls.</span><span class="sxs-lookup"><span data-stu-id="e480b-301">The object that sends the pulse.</span></span></param>
        <summary><span data-ttu-id="e480b-302">Powiadamia wszystkie wątki oczekujące zmiany w stan obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-302">Notifies all waiting threads of a change in the object's state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-303">Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę w celu zasygnalizowania wszystkie wątki, oczekiwania na uzyskanie blokady obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-303">The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</span></span> <span data-ttu-id="e480b-304">Po wysłaniu sygnału wątków oczekujących są przenoszone do kolejki gotowe.</span><span class="sxs-lookup"><span data-stu-id="e480b-304">After the signal is sent, the waiting threads are moved to the ready queue.</span></span> <span data-ttu-id="e480b-305">Kiedy wątek, wywołana `PulseAll` zwalnia blokadę, następny wątek w kolejce gotowe uzyskuje blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-305">When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.</span></span>  
  
 <span data-ttu-id="e480b-306">Należy pamiętać, że synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątków, które oczekują na powiadomienia o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-306">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="e480b-307"><xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, I <xref:System.Threading.Monitor.Wait%2A> metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="e480b-307">The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="e480b-308">Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.</span><span class="sxs-lookup"><span data-stu-id="e480b-308">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 <span data-ttu-id="e480b-309">Aby zasygnalizować pojedynczego wątku, należy użyć `Pulse` metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-309">To signal a single thread, use the `Pulse` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-310"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-310">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="e480b-311">Wątek wywołujący nie posiada blokady dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-311">The calling thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-312">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-312">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e480b-313">Próbuje uzyskać wyłącznej blokady określony obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-313">Attempts to acquire an exclusive lock on the specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-314">Obiekt, w którym można uzyskać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-314">The object on which to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="e480b-315">Próbuje uzyskać wyłącznej blokady określony obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-315">Attempts to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="e480b-316"><see langword="true" /> Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-316"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-317">Jeśli operacja się powiedzie, ta metoda uzyskuje blokady na wyłączność w `obj` parametru.</span><span class="sxs-lookup"><span data-stu-id="e480b-317">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="e480b-318">Ta metoda zwraca natychmiast, czy blokada jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="e480b-318">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="e480b-319">Ta metoda jest podobna do <xref:System.Threading.Monitor.Enter%2A>, ale nigdy nie blokuje bieżącego wątku.</span><span class="sxs-lookup"><span data-stu-id="e480b-319">This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread.</span></span> <span data-ttu-id="e480b-320">Jeśli wątek nie można wprowadzić bez blokowania, metoda zwraca `false,`.</span><span class="sxs-lookup"><span data-stu-id="e480b-320">If the thread cannot enter without blocking, the method returns `false,`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-321">Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-321">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="e480b-322">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> artykułu.</span><span class="sxs-lookup"><span data-stu-id="e480b-322">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="e480b-323">Aby upewnić się, że wątek nie wprowadził sekcję krytyczną, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcję krytyczną, tylko wtedy, gdy jego wartość zwracana jest `true`.</span><span class="sxs-lookup"><span data-stu-id="e480b-323">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="e480b-324">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-324">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="e480b-325">Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-325">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="e480b-326">Poniższy przykład kodu demonstruje sposób używania `TryEnter` metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-326">The following code example demonstrates how to use the `TryEnter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-327"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-327">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-328">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-328">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-329">Obiekt, w którym można uzyskać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-329">The object on which to acquire the lock.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="e480b-330">Wynik próba uzyskania blokady, przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="e480b-330">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="e480b-331">Wartość wejściowa musi być <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-331">The input must be <see langword="false" />.</span></span> <span data-ttu-id="e480b-332">Dane wyjściowe są <see langword="true" /> Jeśli jest blokada; w przeciwnym razie wynikiem jest <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-332">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="e480b-333">Dane wyjściowe jest ustawiona, nawet jeśli wystąpi wyjątek podczas próby uzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-333">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="e480b-334">Próbuje uzyskać wyłącznej blokady określony obiekt i niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</span><span class="sxs-lookup"><span data-stu-id="e480b-334">Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-335">Jeśli operacja się powiedzie, ta metoda uzyskuje blokady na wyłączność w `obj` parametru.</span><span class="sxs-lookup"><span data-stu-id="e480b-335">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="e480b-336">Ta metoda zwraca natychmiast, czy blokada jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="e480b-336">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="e480b-337">Jeśli blokada nie została wykonana, ponieważ wystąpił wyjątek, zmienna jest określona dla `lockTaken` parametr jest `false` po zakończeniu tej metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-337">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="e480b-338">Dzięki temu program określić, we wszystkich przypadkach, czy jest to konieczne zwolnić blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-338">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
 <span data-ttu-id="e480b-339">Ta metoda jest podobna do <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, ale nigdy nie blokuje bieżącego wątku.</span><span class="sxs-lookup"><span data-stu-id="e480b-339">This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread.</span></span> <span data-ttu-id="e480b-340">Jeśli wątek nie można wprowadzić bez blokowania, `lockTaken` argument ma wartość `false` gdy metoda ta zwraca.</span><span class="sxs-lookup"><span data-stu-id="e480b-340">If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-341">Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-341">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="e480b-342">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> artykułu.</span><span class="sxs-lookup"><span data-stu-id="e480b-342">For more information, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="e480b-343">Aby upewnić się, że wątek wprowadzaj sekcję krytyczną, należy sprawdzić wartość `lockTaken` i wykonania kodu w sekcję krytyczną, tylko wtedy, gdy jej wartość jest `true`.</span><span class="sxs-lookup"><span data-stu-id="e480b-343">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="e480b-344">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-344">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="e480b-345">Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-345">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="e480b-346">Poniższy kod przedstawia podstawowy wzorzec przy użyciu <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-346">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="e480b-347">To przeciążenie zawsze ustawia wartość zmiennej, która jest przekazywana do `ref` parametru (`ByRef` w języku Visual Basic) `lockTaken`nawet wtedy, gdy metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodny sposób, aby sprawdzić, czy blokada musi być wydana.</span><span class="sxs-lookup"><span data-stu-id="e480b-347">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e480b-348">Dane wejściowe <paramref name="lockTaken" /> jest <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-348">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-349"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-349">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-350">Obiekt, w którym można uzyskać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-350">The object on which to acquire the lock.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="e480b-351">Liczba milisekund oczekiwania na blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-351">The number of milliseconds to wait for the lock.</span></span></param>
        <summary><span data-ttu-id="e480b-352">Próbuje określoną liczbę milisekund, można uzyskać blokady na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-352">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="e480b-353"><see langword="true" /> Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-353"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-354">Jeśli `millisecondsTimeout` parametr ma wartość <xref:System.Threading.Timeout.Infinite>, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.Enter%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-354">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="e480b-355">Jeśli `millisecondsTimeout` jest równa 0, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.TryEnter%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-355">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-356">Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-356">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="e480b-357">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> artykułu.</span><span class="sxs-lookup"><span data-stu-id="e480b-357">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="e480b-358">Aby upewnić się, że wątek nie wprowadził sekcję krytyczną, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcję krytyczną, tylko wtedy, gdy jego wartość zwracana jest `true`.</span><span class="sxs-lookup"><span data-stu-id="e480b-358">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="e480b-359">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-359">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="e480b-360">Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-360">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-361"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-361">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e480b-362"><paramref name="millisecondsTimeout" /> jest ujemny i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-362"><paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-363">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-363">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-364">Obiekt, w którym można uzyskać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-364">The object on which to acquire the lock.</span></span></param>
        <param name="timeout"><span data-ttu-id="e480b-365">A <see cref="T:System.TimeSpan" /> reprezentujący ilość czasu oczekiwania na blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-365">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock.</span></span> <span data-ttu-id="e480b-366">Wartość-1 milisekundy określa nieskończone oczekiwanie.</span><span class="sxs-lookup"><span data-stu-id="e480b-366">A value of -1 millisecond specifies an infinite wait.</span></span></param>
        <summary><span data-ttu-id="e480b-367">Prób, określoną ilość czasu, aby pozyskać blokady na wyłączność dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-367">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="e480b-368"><see langword="true" /> Jeśli bieżący wątek uzyskuje blokadę; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-368"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-369">Jeśli wartość `timeout` parametr przekonwertowane na milisekund jest równa -1, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.Enter%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-369">If the value of the `timeout` parameter converted to milliseconds equals -1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="e480b-370">Jeśli wartość `timeout` jest równa 0, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.TryEnter%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-370">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-371">Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-371">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="e480b-372">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> temat poświęcony klasie.</span><span class="sxs-lookup"><span data-stu-id="e480b-372">For details, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="e480b-373">Aby upewnić się, że wątek nie wprowadził sekcję krytyczną, należy sprawdzić wartość zwracaną metody i wykonać kod w sekcję krytyczną, tylko wtedy, gdy jego wartość zwracana jest `true`.</span><span class="sxs-lookup"><span data-stu-id="e480b-373">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="e480b-374">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-374">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="e480b-375">Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-375">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-376"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-376">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e480b-377">Wartość <paramref name="timeout" /> w milisekundach jest ujemna, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekundy), lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-377">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-378">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-378">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-379">Obiekt, w którym można uzyskać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-379">The object on which to acquire the lock.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="e480b-380">Liczba milisekund oczekiwania na blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-380">The number of milliseconds to wait for the lock.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="e480b-381">Wynik próba uzyskania blokady, przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="e480b-381">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="e480b-382">Wartość wejściowa musi być <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-382">The input must be <see langword="false" />.</span></span> <span data-ttu-id="e480b-383">Dane wyjściowe są <see langword="true" /> Jeśli jest blokada; w przeciwnym razie wynikiem jest <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-383">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="e480b-384">Dane wyjściowe jest ustawiona, nawet jeśli wystąpi wyjątek podczas próby uzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-384">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="e480b-385">Próbuje, określoną liczbę milisekund, można uzyskać blokady na wyłączność dla określonego obiektu, dzięki czemu niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</span><span class="sxs-lookup"><span data-stu-id="e480b-385">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-386">Jeśli `millisecondsTimeout` parametr ma wartość <xref:System.Threading.Timeout.Infinite>, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="e480b-386">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="e480b-387">Jeśli `millisecondsTimeout` jest równa 0, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="e480b-387">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="e480b-388">Jeśli blokada nie została wykonana, ponieważ wystąpił wyjątek, zmienna jest określona dla `lockTaken` parametr jest `false` po zakończeniu tej metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-388">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="e480b-389">Dzięki temu program określić, we wszystkich przypadkach, czy jest to konieczne zwolnić blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-389">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-390">Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-390">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="e480b-391">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> temat poświęcony klasie.</span><span class="sxs-lookup"><span data-stu-id="e480b-391">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="e480b-392">Aby upewnić się, że wątek wprowadzaj sekcję krytyczną, należy sprawdzić wartość `lockTaken` i wykonania kodu w sekcję krytyczną, tylko wtedy, gdy jej wartość jest `true`.</span><span class="sxs-lookup"><span data-stu-id="e480b-392">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="e480b-393">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-393">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="e480b-394">Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-394">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="e480b-395">Poniższy kod przedstawia podstawowy wzorzec przy użyciu <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-395">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="e480b-396">To przeciążenie zawsze ustawia wartość zmiennej, która jest przekazywana do `ref` parametru (`ByRef` w języku Visual Basic) `lockTaken`nawet wtedy, gdy metoda zgłasza wyjątek, więc wartość zmiennej jest niezawodny sposób, aby sprawdzić, czy blokada musi być wydana.</span><span class="sxs-lookup"><span data-stu-id="e480b-396">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e480b-397">Dane wejściowe <paramref name="lockTaken" /> jest <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-397">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-398"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-398">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e480b-399"><paramref name="millisecondsTimeout" /> jest ujemny i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-399"><paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-400">Obiekt, w którym można uzyskać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-400">The object on which to acquire the lock.</span></span></param>
        <param name="timeout"><span data-ttu-id="e480b-401">Ilość czasu oczekiwania na blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-401">The amount of time to wait for the lock.</span></span> <span data-ttu-id="e480b-402">Wartość-1 milisekundy określa nieskończone oczekiwanie.</span><span class="sxs-lookup"><span data-stu-id="e480b-402">A value of -1 millisecond specifies an infinite wait.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="e480b-403">Wynik próba uzyskania blokady, przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="e480b-403">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="e480b-404">Wartość wejściowa musi być <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-404">The input must be <see langword="false" />.</span></span> <span data-ttu-id="e480b-405">Dane wyjściowe są <see langword="true" /> Jeśli jest blokada; w przeciwnym razie wynikiem jest <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-405">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="e480b-406">Dane wyjściowe jest ustawiona, nawet jeśli wystąpi wyjątek podczas próby uzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-406">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="e480b-407">Próbuje uzyskać określoną ilość czasu, aby pozyskać blokady na wyłączność dla określonego obiektu, a niepodzielnie ustawia wartość wskazującą, czy blokada została wykonana.</span><span class="sxs-lookup"><span data-stu-id="e480b-407">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-408">Jeśli wartość `timeout` parametr przekonwertowane na milisekund jest równa -1, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="e480b-408">If the value of the `timeout` parameter converted to milliseconds equals -1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="e480b-409">Jeśli wartość `timeout` jest równa 0, ta metoda jest odpowiednikiem <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="e480b-409">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="e480b-410">Jeśli blokada nie została wykonana, ponieważ wystąpił wyjątek, zmienna jest określona dla `lockTaken` parametr jest `false` po zakończeniu tej metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-410">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="e480b-411">Dzięki temu program określić, we wszystkich przypadkach, czy jest to konieczne zwolnić blokadę.</span><span class="sxs-lookup"><span data-stu-id="e480b-411">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-412">Użyj <xref:System.Threading.Monitor> blokowanie obiektów (czyli typy referencyjne), nie typów wartości.</span><span class="sxs-lookup"><span data-stu-id="e480b-412">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="e480b-413">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Monitor> temat poświęcony klasie.</span><span class="sxs-lookup"><span data-stu-id="e480b-413">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="e480b-414">Aby upewnić się, że wątek wprowadzaj sekcję krytyczną, należy sprawdzić wartość `lockTaken` i wykonania kodu w sekcję krytyczną, tylko wtedy, gdy jej wartość jest `true`.</span><span class="sxs-lookup"><span data-stu-id="e480b-414">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="e480b-415">Poniższy fragment kodu przedstawia wzorzec używany do wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-415">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="e480b-416">Należy zauważyć, że należy wywołać <xref:System.Threading.Monitor.Exit%2A> w `finally` bloku, aby upewnić się, czy wątek wywołujący zwalnia jego blokadę sekcję krytyczną, jeśli wystąpi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-416">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e480b-417">Dane wejściowe <paramref name="lockTaken" /> jest <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-417">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-418"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-418">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e480b-419">Wartość <paramref name="timeout" /> w milisekundach jest ujemna, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekundy), lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-419">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-420">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-420">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e480b-421">Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-421">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-422">Obiekt, na którym oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-422">The object on which to wait.</span></span></param>
        <summary><span data-ttu-id="e480b-423">Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-423">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span></summary>
        <returns><span data-ttu-id="e480b-424"><see langword="true" /> Jeśli wywołanie zwróciło, ponieważ obiekt wywołujący reacquired blokady dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-424"><see langword="true" /> if the call returned because the caller reacquired the lock for the specified object.</span></span> <span data-ttu-id="e480b-425">Ta metoda nie zwraca, jeśli blokada nie jest reacquired.</span><span class="sxs-lookup"><span data-stu-id="e480b-425">This method does not return if the lock is not reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-426">Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę, aby zwolnić obiekt, dzięki czemu można do niego dostęp inny wątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-426">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="e480b-427">Obiekt wywołujący jest blokowane podczas oczekiwania na ponownie pobrać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-427">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="e480b-428">Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmiany stanu, które będzie wysyłane w wyniku operacji inny wątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-428">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="e480b-429">Kiedy wątek wywołuje `Wait`, zwalnia blokadę na obiekcie i wprowadza kolejce oczekiwania obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-429">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="e480b-430">Następny wątek w kolejce gotowe obiektu (jeśli istnieje) uzyskuje blokadę, a ma wyłącznego użytku obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-430">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="e480b-431">Wszystkie wątki, które wywołują `Wait` pozostaną w kolejce oczekiwania, aż otrzyma sygnał od <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A>, wysłanych przez właściciela blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-431">All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock.</span></span> <span data-ttu-id="e480b-432">Jeśli `Pulse` wysłaniu dotyczy tylko wątku na czele kolejce oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-432">If `Pulse` is sent, only the thread at the head of the waiting queue is affected.</span></span> <span data-ttu-id="e480b-433">Jeśli `PulseAll` zostanie wysłany, wpływają na wszystkie wątki, które oczekują na obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-433">If `PulseAll` is sent, all threads that are waiting for the object are affected.</span></span> <span data-ttu-id="e480b-434">Po odebraniu sygnału jeden lub więcej wątków pozostaw kolejce oczekiwania i wprowadź kolejkę gotowe.</span><span class="sxs-lookup"><span data-stu-id="e480b-434">When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</span></span> <span data-ttu-id="e480b-435">Wątek w kolejce gotowe może ponownie pobrać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-435">A thread in the ready queue is permitted to reacquire the lock.</span></span>  
  
 <span data-ttu-id="e480b-436">Ta metoda zwraca, jeśli wątek wywołujący reacquires blokadę na obiekcie.</span><span class="sxs-lookup"><span data-stu-id="e480b-436">This method returns when the calling thread reacquires the lock on the object.</span></span> <span data-ttu-id="e480b-437">Należy zauważyć, że ta metoda blokuje, przez czas nieokreślony, jeśli właściciel blokady nie mogą wywoływać `Pulse` lub `PulseAll`.</span><span class="sxs-lookup"><span data-stu-id="e480b-437">Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.</span></span>  
  
 <span data-ttu-id="e480b-438">Element wywołujący wykonuje `Wait` raz, niezależnie od tego, ile razy <xref:System.Threading.Monitor.Enter%2A> zostało wywołane dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-438">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="e480b-439">Model `Wait` metoda przechowuje liczbę wywołany obiekt wywołujący `Enter` w obiekcie, a następnie wywołuje `Exit` tyle razy, aby całkowicie zwolnić zablokowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-439">Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="e480b-440">Obiekt wywołujący blokuje wtedy dane podczas oczekiwania na ponownie pobrać obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-440">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="e480b-441">Gdy obiekt wywołujący reacquires blokady, system wywołuje `Enter` tyle razy, aby przywrócić zapisane `Enter` liczba do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e480b-441">When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller.</span></span> <span data-ttu-id="e480b-442">Wywoływanie `Wait` zwalnia blokadę dla określonego obiektu Jeśli element wywołujący jest właściciel blokady na inne obiekty, blokadami tymi nie zostaną zwolnione.</span><span class="sxs-lookup"><span data-stu-id="e480b-442">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
 <span data-ttu-id="e480b-443">Należy pamiętać, że synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątków, które oczekują na powiadomienia o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-443">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="e480b-444"><xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, I `Wait` metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="e480b-444">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="e480b-445">Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.</span><span class="sxs-lookup"><span data-stu-id="e480b-445">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-446"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-446">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="e480b-447">Wątek wywołujący nie posiada blokady dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-447">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="e480b-448">Wątek, który wywołuje <see langword="Wait" /> później zostanie przerwany ze stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-448">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="e480b-449">Tak się stanie, gdy inny wątek wywołuje ten wątek <see cref="M:System.Threading.Thread.Interrupt" /> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-449">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-450">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-450">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-451">Obiekt, na którym oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-451">The object on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="e480b-452">Liczba milisekund oczekiwania przed wątku przechodzi gotowe kolejki.</span><span class="sxs-lookup"><span data-stu-id="e480b-452">The number of milliseconds to wait before the thread enters the ready queue.</span></span></param>
        <summary><span data-ttu-id="e480b-453">Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-453">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="e480b-454">Jeżeli określony limit czasu upłynie, wątku przechodzi gotowe kolejki.</span><span class="sxs-lookup"><span data-stu-id="e480b-454">If the specified time-out interval elapses, the thread enters the ready queue.</span></span></summary>
        <returns><span data-ttu-id="e480b-455"><see langword="true" /> Jeśli blokada została reacquired przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została reacquired po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="e480b-455"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="e480b-456">Metoda nie zwraca, dopóki blokada jest reacquired.</span><span class="sxs-lookup"><span data-stu-id="e480b-456">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-457">Ta metoda nie zwraca do momentu jej reacquires blokady na wyłączność w `obj` parametru.</span><span class="sxs-lookup"><span data-stu-id="e480b-457">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="e480b-458">Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę, aby zwolnić obiekt, dzięki czemu można do niego dostęp inny wątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-458">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="e480b-459">Obiekt wywołujący jest blokowane podczas oczekiwania na ponownie pobrać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-459">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="e480b-460">Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmiany stanu, które będzie wysyłane w wyniku operacji inny wątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-460">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="e480b-461">Limit czasu zapewnia, że bieżący wątek nie blokuje przez czas nieokreślony Jeśli inny wątek zwalnia blokadę bez wywoływania pierwszy <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-461">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="e480b-462">Przesuwa się również wątek do kolejki gotowe, tak, aby je można ponownie pobrać blokady wcześniej z pominięciem innych wątków w przód od jej w kolejce oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-462">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="e480b-463">Wątek można sprawdzić wartość zwracaną przez <xref:System.Threading.Monitor.Wait%2A> metodę pozwala ustalić, czy jego reacquired blokady przed limit czasu. Wątek może służyć do oceny warunków, które spowodowało wprowadzenie czas oczekiwania, czas i, jeśli konieczne wywołanie <xref:System.Threading.Monitor.Wait%2A> ponownie metodą.</span><span class="sxs-lookup"><span data-stu-id="e480b-463">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="e480b-464">Kiedy wątek wywołuje `Wait`, zwalnia blokadę na obiekcie i wprowadza kolejce oczekiwania obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-464">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="e480b-465">Następny wątek w kolejce gotowe obiektu (jeśli istnieje) uzyskuje blokadę, a ma wyłącznego użytku obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-465">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="e480b-466">Wątek, który jest wywoływany `Wait` pozostaje w kolejce oczekiwania, aż do wątku, który posiada blokadę wywołuje <xref:System.Threading.Monitor.PulseAll%2A>, lub jest dalej w kolejce, i wywołuje wątku, który posiada blokadę <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-466">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="e480b-467">Jednak jeśli `millisecondsTimeout` musi upłynąć, zanim inny wątek wywołuje ten obiekt <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody, oryginalnym wątku została przeniesiona do kolejki gotowe w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-467">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-468">Jeśli <xref:System.Threading.Timeout.Infinite> jest określona dla `millisecondsTimeout` parametru tej metody na czas nieokreślony blokuje, chyba że właściciel blokady wywołuje <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-468">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="e480b-469">Jeśli `millisecondsTimeout` jest równa 0, wątek, który wywołuje `Wait` zwalnia blokadę, a następnie od razu wchodzi gotowe kolejki w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-469">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="e480b-470">Element wywołujący wykonuje `Wait` raz, niezależnie od tego, ile razy <xref:System.Threading.Monitor.Enter%2A> zostało wywołane dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-470">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="e480b-471">Model `Wait` metoda przechowuje liczbę wywołany obiekt wywołujący <xref:System.Threading.Monitor.Enter%2A> w obiekcie, a następnie wywołuje <xref:System.Threading.Monitor.Exit%2A> tyle razy, aby całkowicie zwolnić zablokowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-471">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="e480b-472">Obiekt wywołujący blokuje wtedy dane podczas oczekiwania na ponownie pobrać obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-472">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="e480b-473">Gdy obiekt wywołujący reacquires blokady, system wywołuje <xref:System.Threading.Monitor.Enter%2A> tyle razy, aby przywrócić zapisane <xref:System.Threading.Monitor.Enter%2A> liczba do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e480b-473">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="e480b-474">Wywoływanie `Wait` zwalnia blokadę dla określonego obiektu Jeśli element wywołujący jest właściciel blokady na inne obiekty, blokadami tymi nie zostaną zwolnione.</span><span class="sxs-lookup"><span data-stu-id="e480b-474">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-475">Synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątki, które oczekują na powiadomienia o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-475">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="e480b-476"><xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, I `Wait` metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="e480b-476">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="e480b-477">Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.</span><span class="sxs-lookup"><span data-stu-id="e480b-477">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-478"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-478">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="e480b-479">Wątek wywołujący nie posiada blokady dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-479">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="e480b-480">Wątek, który wywołuje <see langword="Wait" /> później zostanie przerwany ze stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-480">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="e480b-481">Tak się stanie, gdy inny wątek wywołuje ten wątek <see cref="M:System.Threading.Thread.Interrupt" /> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-481">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e480b-482">Wartość <paramref name="millisecondsTimeout" /> parametr ma wartość ujemną, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-482">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-483">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-483">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-484">Obiekt, na którym oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-484">The object on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="e480b-485">A <see cref="T:System.TimeSpan" /> reprezentujący ilość czasu oczekiwania na wątku przechodzi gotowe kolejki.</span><span class="sxs-lookup"><span data-stu-id="e480b-485">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span></span></param>
        <summary><span data-ttu-id="e480b-486">Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-486">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="e480b-487">Jeżeli określony limit czasu upłynie, wątku przechodzi gotowe kolejki.</span><span class="sxs-lookup"><span data-stu-id="e480b-487">If the specified time-out interval elapses, the thread enters the ready queue.</span></span></summary>
        <returns><span data-ttu-id="e480b-488"><see langword="true" /> Jeśli blokada została reacquired przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została reacquired po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="e480b-488"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="e480b-489">Metoda nie zwraca, dopóki blokada jest reacquired.</span><span class="sxs-lookup"><span data-stu-id="e480b-489">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-490">Ta metoda nie zwraca do momentu jej reacquires blokady na wyłączność w `obj` parametru.</span><span class="sxs-lookup"><span data-stu-id="e480b-490">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="e480b-491">Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę, aby zwolnić obiekt, dzięki czemu można do niego dostęp inny wątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-491">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="e480b-492">Obiekt wywołujący jest blokowane podczas oczekiwania na ponownie pobrać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-492">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="e480b-493">Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmiany stanu, które będzie wysyłane w wyniku operacji inny wątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-493">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="e480b-494">Limit czasu zapewnia, że bieżący wątek nie blokuje przez czas nieokreślony Jeśli inny wątek zwalnia blokadę bez wywoływania pierwszy <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-494">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="e480b-495">Przesuwa się również wątek do kolejki gotowe, tak, aby je można ponownie pobrać blokady wcześniej z pominięciem innych wątków w przód od jej w kolejce oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-495">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="e480b-496">Wątek można sprawdzić wartość zwracaną przez <xref:System.Threading.Monitor.Wait%2A> metodę pozwala ustalić, czy jego reacquired blokady przed limit czasu. Wątek może służyć do oceny warunków, które spowodowało wprowadzenie czas oczekiwania, czas i, jeśli konieczne wywołanie <xref:System.Threading.Monitor.Wait%2A> ponownie metodą.</span><span class="sxs-lookup"><span data-stu-id="e480b-496">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="e480b-497">Kiedy wątek wywołuje `Wait`, zwalnia blokadę na obiekcie i wprowadza kolejce oczekiwania obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-497">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="e480b-498">Następny wątek w kolejce gotowe obiektu (jeśli istnieje) uzyskuje blokadę, a ma wyłącznego użytku obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-498">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="e480b-499">Wątek, który jest wywoływany `Wait` pozostaje w kolejce oczekiwania, aż do wątku, który posiada blokadę wywołuje <xref:System.Threading.Monitor.PulseAll%2A>, lub jest dalej w kolejce, i wywołuje wątku, który posiada blokadę <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-499">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="e480b-500">Jednak jeśli `timeout` musi upłynąć, zanim inny wątek wywołuje ten obiekt <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody, oryginalnym wątku została przeniesiona do kolejki gotowe w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-500">However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-501">Jeśli <xref:System.TimeSpan> reprezentujący milisekund wartości-1 jest określona dla `timeout` parametru tej metody na czas nieokreślony blokuje, chyba że właściciel blokady wywołuje <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-501">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="e480b-502">Jeśli `timeout` wynosi 0 milisekund, wątek, który wywołuje `Wait` zwalnia blokadę, a następnie od razu wchodzi gotowe kolejki w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-502">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="e480b-503">Element wywołujący wykonuje `Wait` raz, niezależnie od tego, ile razy <xref:System.Threading.Monitor.Enter%2A> zostało wywołane dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-503">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="e480b-504">Model `Wait` metoda przechowuje liczbę wywołany obiekt wywołujący <xref:System.Threading.Monitor.Enter%2A> w obiekcie, a następnie wywołuje <xref:System.Threading.Monitor.Exit%2A> tyle razy, aby całkowicie zwolnić zablokowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-504">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="e480b-505">Obiekt wywołujący blokuje wtedy dane podczas oczekiwania na ponownie pobrać obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-505">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="e480b-506">Gdy obiekt wywołujący reacquires blokady, system wywołuje <xref:System.Threading.Monitor.Enter%2A> tyle razy, aby przywrócić zapisane <xref:System.Threading.Monitor.Enter%2A> liczba do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e480b-506">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="e480b-507">Wywoływanie `Wait` zwalnia blokadę dla określonego obiektu Jeśli element wywołujący jest właściciel blokady na inne obiekty, blokadami tymi nie zostaną zwolnione.</span><span class="sxs-lookup"><span data-stu-id="e480b-507">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-508">Synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątki, które oczekują na powiadomienia o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-508">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="e480b-509"><xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, I `Wait` metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="e480b-509">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="e480b-510">Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.</span><span class="sxs-lookup"><span data-stu-id="e480b-510">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-511"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-511">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="e480b-512">Wątek wywołujący nie posiada blokady dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-512">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="e480b-513">Wątek, który wywołuje <see langword="Wait" /> później zostanie przerwany ze stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-513">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="e480b-514">Tak się stanie, gdy inny wątek wywołuje ten wątek <see cref="M:System.Threading.Thread.Interrupt" /> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-514">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e480b-515">Wartość <paramref name="timeout" /> parametru w milisekundach jest ujemna, a nie reprezentuje <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekundy), lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-515">The value of the <paramref name="timeout" /> parameter in milliseconds is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-516">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-516">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-517">Obiekt, na którym oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-517">The object on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="e480b-518">Liczba milisekund oczekiwania przed wątku przechodzi gotowe kolejki.</span><span class="sxs-lookup"><span data-stu-id="e480b-518">The number of milliseconds to wait before the thread enters the ready queue.</span></span></param>
        <param name="exitContext"><span data-ttu-id="e480b-519"><see langword="true" /> Aby zamknąć i ponownie pobrać domeny synchronizacji dla kontekstu (Jeśli w kontekście zsynchronizowane) przed oczekiwaniem; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-519"><see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="e480b-520">Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-520">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="e480b-521">Jeżeli określony limit czasu upłynie, wątku przechodzi gotowe kolejki.</span><span class="sxs-lookup"><span data-stu-id="e480b-521">If the specified time-out interval elapses, the thread enters the ready queue.</span></span> <span data-ttu-id="e480b-522">Ta metoda określa również, czy domeny synchronizacji dla kontekstu (jeśli są w synchronizowane context) jest zakończony przed czas oczekiwania i reacquired później.</span><span class="sxs-lookup"><span data-stu-id="e480b-522">This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</span></span></summary>
        <returns><span data-ttu-id="e480b-523"><see langword="true" /> Jeśli blokada została reacquired przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została reacquired po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="e480b-523"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="e480b-524">Metoda nie zwraca, dopóki blokada jest reacquired.</span><span class="sxs-lookup"><span data-stu-id="e480b-524">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-525">Ta metoda nie zwraca do momentu jej reacquires blokady na wyłączność w `obj` parametru.</span><span class="sxs-lookup"><span data-stu-id="e480b-525">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="e480b-526">Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę, aby zwolnić obiekt, dzięki czemu można do niego dostęp inny wątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-526">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="e480b-527">Obiekt wywołujący jest blokowane podczas oczekiwania na ponownie pobrać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-527">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="e480b-528">Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmiany stanu, które będzie wysyłane w wyniku operacji inny wątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-528">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="e480b-529">Limit czasu zapewnia, że bieżący wątek nie blokuje przez czas nieokreślony Jeśli inny wątek zwalnia blokadę bez wywoływania pierwszy <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-529">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="e480b-530">Przesuwa się również wątek do kolejki gotowe, tak, aby je można ponownie pobrać blokady wcześniej z pominięciem innych wątków w przód od jej w kolejce oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-530">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="e480b-531">Wątek można sprawdzić wartość zwracaną przez <xref:System.Threading.Monitor.Wait%2A> metodę pozwala ustalić, czy jego reacquired blokady przed limit czasu. Wątek może służyć do oceny warunków, które spowodowało wprowadzenie czas oczekiwania, czas i, jeśli konieczne wywołanie <xref:System.Threading.Monitor.Wait%2A> ponownie metodą.</span><span class="sxs-lookup"><span data-stu-id="e480b-531">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="e480b-532">Kiedy wątek wywołuje `Wait`, zwalnia blokadę, a przechodzi w kolejce oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-532">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="e480b-533">W tym momencie następny wątek w kolejce gotowy (jeśli istnieje) może przejąć kontrolę nad blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-533">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="e480b-534">Wątek, który jest wywoływany `Wait` pozostaje w kolejce oczekiwania, aż do wątku, który posiada blokadę wywołuje <xref:System.Threading.Monitor.PulseAll%2A>, lub jest dalej w kolejce, i wywołuje wątku, który posiada blokadę <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-534">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="e480b-535">Jednak jeśli `millisecondsTimeout` musi upłynąć, zanim inny wątek wywołuje ten obiekt <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody, oryginalnym wątku została przeniesiona do kolejki gotowe w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-535">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-536">Jeśli <xref:System.Threading.Timeout.Infinite> jest określona dla `millisecondsTimeout` parametru tej metody na czas nieokreślony blokuje, chyba że właściciel blokady wywołuje <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-536">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="e480b-537">Jeśli `millisecondsTimeout` jest równa 0, wątek, który wywołuje `Wait` zwalnia blokadę, a następnie od razu wchodzi gotowe kolejki w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-537">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="e480b-538">Element wywołujący wykonuje `Wait` raz, niezależnie od tego, ile razy <xref:System.Threading.Monitor.Enter%2A> zostało wywołane dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-538">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="e480b-539">Model `Wait` metoda przechowuje liczbę wywołany obiekt wywołujący <xref:System.Threading.Monitor.Enter%2A> w obiekcie, a następnie wywołuje <xref:System.Threading.Monitor.Exit%2A> tyle razy, aby całkowicie zwolnić zablokowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-539">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="e480b-540">Obiekt wywołujący blokuje wtedy dane podczas oczekiwania na ponownie pobrać obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-540">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="e480b-541">Gdy obiekt wywołujący reacquires blokady, system wywołuje <xref:System.Threading.Monitor.Enter%2A> tyle razy, aby przywrócić zapisane <xref:System.Threading.Monitor.Enter%2A> liczba do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e480b-541">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="e480b-542">Wywoływanie `Wait` zwalnia blokadę dla określonego obiektu Jeśli element wywołujący jest właściciel blokady na inne obiekty, blokadami tymi nie zostaną zwolnione.</span><span class="sxs-lookup"><span data-stu-id="e480b-542">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-543">Synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątki, które oczekują na powiadomienia o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-543">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="e480b-544"><xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, I `Wait` metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="e480b-544">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="e480b-545">Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.</span><span class="sxs-lookup"><span data-stu-id="e480b-545">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="e480b-546">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="e480b-546">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="e480b-547">`exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.Monitor.Wait%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="e480b-547">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="e480b-548">Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="e480b-548">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="e480b-549">Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e480b-549">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="e480b-550">Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.Monitor.Wait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-550">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="e480b-551">Zwraca do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.Monitor.Wait%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-551">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="e480b-552">Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> zastosowany.</span><span class="sxs-lookup"><span data-stu-id="e480b-552">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="e480b-553">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy.</span><span class="sxs-lookup"><span data-stu-id="e480b-553">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="e480b-554">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.Monitor.Wait%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="e480b-554">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="e480b-555">Gdy <xref:System.Threading.Monitor.Wait%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="e480b-555">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-556"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-556">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="e480b-557"><see langword="Wait" /> w ramach zsynchronizowane bloku kodu nie jest wywoływany z.</span><span class="sxs-lookup"><span data-stu-id="e480b-557"><see langword="Wait" /> is not invoked from within a synchronized block of code.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="e480b-558">Wątek, który wywołuje <see langword="Wait" /> później zostanie przerwany ze stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-558">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="e480b-559">Tak się stanie, gdy inny wątek wywołuje ten wątek <see cref="M:System.Threading.Thread.Interrupt" /> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-559">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e480b-560">Wartość <paramref name="millisecondsTimeout" /> parametr ma wartość ujemną, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-560">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-561">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-561">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e480b-562">Obiekt, na którym oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-562">The object on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="e480b-563">A <see cref="T:System.TimeSpan" /> reprezentujący ilość czasu oczekiwania na wątku przechodzi gotowe kolejki.</span><span class="sxs-lookup"><span data-stu-id="e480b-563">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span></span></param>
        <param name="exitContext"><span data-ttu-id="e480b-564"><see langword="true" /> Aby zamknąć i ponownie pobrać domeny synchronizacji dla kontekstu (Jeśli w kontekście zsynchronizowane) przed oczekiwaniem; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-564"><see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="e480b-565">Zwalnia blokadę na obiekcie i blokują bieżący wątek, do momentu jej reacquires blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-565">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="e480b-566">Jeżeli określony limit czasu upłynie, wątku przechodzi gotowe kolejki.</span><span class="sxs-lookup"><span data-stu-id="e480b-566">If the specified time-out interval elapses, the thread enters the ready queue.</span></span> <span data-ttu-id="e480b-567">Opcjonalnie zamyka domeny synchronizacji dla kontekstu zsynchronizowane przed czas oczekiwania i później reacquires domeny.</span><span class="sxs-lookup"><span data-stu-id="e480b-567">Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</span></span></summary>
        <returns><span data-ttu-id="e480b-568"><see langword="true" /> Jeśli blokada została reacquired przed upływem określonego czasu; <see langword="false" /> Jeśli blokada została reacquired po upływie określonego czasu.</span><span class="sxs-lookup"><span data-stu-id="e480b-568"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="e480b-569">Metoda nie zwraca, dopóki blokada jest reacquired.</span><span class="sxs-lookup"><span data-stu-id="e480b-569">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e480b-570">Ta metoda nie zwraca do momentu jej reacquires blokady na wyłączność w `obj` parametru.</span><span class="sxs-lookup"><span data-stu-id="e480b-570">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="e480b-571">Wątek, który jest bieżącym właścicielem blokady na określony obiekt wywołuje tę metodę, aby zwolnić obiekt, dzięki czemu można do niego dostęp inny wątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-571">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="e480b-572">Obiekt wywołujący jest blokowane podczas oczekiwania na ponownie pobrać blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-572">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="e480b-573">Ta metoda jest wywoływana, gdy obiekt wywołujący musi czekać na zmiany stanu, które będzie wysyłane w wyniku operacji inny wątek.</span><span class="sxs-lookup"><span data-stu-id="e480b-573">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="e480b-574">Limit czasu zapewnia, że bieżący wątek nie blokuje przez czas nieokreślony Jeśli inny wątek zwalnia blokadę bez wywoływania pierwszy <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-574">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="e480b-575">Przesuwa się również wątek do kolejki gotowe, tak, aby je można ponownie pobrać blokady wcześniej z pominięciem innych wątków w przód od jej w kolejce oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-575">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="e480b-576">Wątek można sprawdzić wartość zwracaną przez <xref:System.Threading.Monitor.Wait%2A> metodę pozwala ustalić, czy jego reacquired blokady przed limit czasu. Wątek może służyć do oceny warunków, które spowodowało wprowadzenie czas oczekiwania, czas i, jeśli konieczne wywołanie <xref:System.Threading.Monitor.Wait%2A> ponownie metodą.</span><span class="sxs-lookup"><span data-stu-id="e480b-576">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="e480b-577">Kiedy wątek wywołuje `Wait`, zwalnia blokadę, a przechodzi w kolejce oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-577">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="e480b-578">W tym momencie następny wątek w kolejce gotowy (jeśli istnieje) może przejąć kontrolę nad blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-578">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="e480b-579">Wątek, który jest wywoływany `Wait` pozostaje w kolejce oczekiwania, aż do wątku, który posiada blokadę wywołuje <xref:System.Threading.Monitor.PulseAll%2A>, lub jest dalej w kolejce, i wywołuje wątku, który posiada blokadę <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-579">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="e480b-580">Jednak jeśli `timeout` milisekund oczekiwania przed inny wątek wywołuje ten obiekt <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A> metody, oryginalnym wątku została przeniesiona do kolejki gotowe w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-580">However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-581">Jeśli <xref:System.TimeSpan> reprezentujący milisekund wartości-1 jest określona dla `timeout` parametru tej metody na czas nieokreślony blokuje, chyba że właściciel blokady wywołuje <xref:System.Threading.Monitor.Pulse%2A> lub <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="e480b-581">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="e480b-582">Jeśli `timeout` wynosi 0 milisekund, wątek, który wywołuje `Wait` zwalnia blokadę, a następnie od razu wchodzi gotowe kolejki w celu odzyskania blokady.</span><span class="sxs-lookup"><span data-stu-id="e480b-582">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="e480b-583">Element wywołujący wykonuje `Wait` raz, niezależnie od tego, ile razy <xref:System.Threading.Monitor.Enter%2A> zostało wywołane dla określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-583">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="e480b-584">Model `Wait` metoda przechowuje liczbę wywołany obiekt wywołujący <xref:System.Threading.Monitor.Enter%2A> w obiekcie, a następnie wywołuje <xref:System.Threading.Monitor.Exit%2A> tyle razy, aby całkowicie zwolnić zablokowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-584">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="e480b-585">Obiekt wywołujący blokuje wtedy dane podczas oczekiwania na ponownie pobrać obiekt.</span><span class="sxs-lookup"><span data-stu-id="e480b-585">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="e480b-586">Gdy obiekt wywołujący reacquires blokady, system wywołuje <xref:System.Threading.Monitor.Enter%2A> tyle razy, aby przywrócić zapisane <xref:System.Threading.Monitor.Enter%2A> liczba do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="e480b-586">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="e480b-587">Wywoływanie `Wait` zwalnia blokadę dla określonego obiektu Jeśli element wywołujący jest właściciel blokady na inne obiekty, blokadami tymi nie zostaną zwolnione.</span><span class="sxs-lookup"><span data-stu-id="e480b-587">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e480b-588">Synchronizowany obiekt posiada kilka odwołań, łącznie z odwołaniem do wątku, który obecnie posiada blokadę, odwołanie do kolejki gotowe, zawierającą wątki, które są gotowe do uzyskania blokady i odwołania do kolejki oczekiwania, który zawiera wątki, które oczekują na powiadomienia o zmianie stanu obiektu.</span><span class="sxs-lookup"><span data-stu-id="e480b-588">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="e480b-589"><xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, I `Wait` metody musi być wywoływane z w ramach zsynchronizowane bloku kodu.</span><span class="sxs-lookup"><span data-stu-id="e480b-589">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="e480b-590">Uwagi dla <xref:System.Threading.Monitor.Pulse%2A> metoda wyjaśnić, co się stanie, jeśli <xref:System.Threading.Monitor.Pulse%2A> jest wywoływana, gdy nie ma wątków oczekujących.</span><span class="sxs-lookup"><span data-stu-id="e480b-590">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="e480b-591">Uwagi dotyczące zamykania kontekstu</span><span class="sxs-lookup"><span data-stu-id="e480b-591">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="e480b-592">`exitContext` Parametr jest ignorowany, chyba że <xref:System.Threading.Monitor.Wait%2A> metoda jest wywoływana z wewnątrz inny niż domyślny kontekst zarządzanych.</span><span class="sxs-lookup"><span data-stu-id="e480b-592">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="e480b-593">Może się to zdarzyć, jeśli wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="e480b-593">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="e480b-594">Nawet wtedy, gdy są aktualnie wykonuje metodę w klasie, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innej niż domyślna Jeśli <xref:System.ContextBoundObject> znajduje się na stosie w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e480b-594">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="e480b-595">Gdy kod jest wykonywany w kontekście innej niż domyślna, określając `true` dla `exitContext` powoduje, że wątku zamknąć kontekstu zarządzanych inną niż domyślna (oznacza to, do którego nastąpi przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.Monitor.Wait%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-595">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="e480b-596">Zwraca do oryginalnego kontekstu niedomyślną po wywołaniu <xref:System.Threading.Monitor.Wait%2A> ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-596">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="e480b-597">Może to być przydatne, gdy zawiera klasy powiązane z kontekstu <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> zastosowany.</span><span class="sxs-lookup"><span data-stu-id="e480b-597">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="e480b-598">W takim przypadku wszystkie wywołania do elementów członkowskich klasy są automatycznie synchronizowane i domena synchronizacji jest cały kod dla tej klasy.</span><span class="sxs-lookup"><span data-stu-id="e480b-598">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="e480b-599">Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.Monitor.Wait%2A> metody i określa `true` dla `exitContext`, wątek kończy działanie synchronizacji domeny, dzięki czemu wątek, który jest zablokowany w wywołaniu do wszystkich elementów członkowskich obiektu, aby kontynuować.</span><span class="sxs-lookup"><span data-stu-id="e480b-599">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="e480b-600">Gdy <xref:System.Threading.Monitor.Wait%2A> metoda zwróci wartość, wątku, który zgłosił wywołanie musi czekać ponownie domeny synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="e480b-600">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e480b-601"><paramref name="obj" /> Parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-601">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="e480b-602"><see langword="Wait" /> w ramach zsynchronizowane bloku kodu nie jest wywoływany z.</span><span class="sxs-lookup"><span data-stu-id="e480b-602"><see langword="Wait" /> is not invoked from within a synchronized block of code.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="e480b-603">Wątek, który wywołuje oczekiwania później zostało przerwane ze stanu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="e480b-603">The thread that invokes Wait is later interrupted from the waiting state.</span></span> <span data-ttu-id="e480b-604">Tak się stanie, gdy inny wątek wywołuje ten wątek <see cref="M:System.Threading.Thread.Interrupt" /> metody.</span><span class="sxs-lookup"><span data-stu-id="e480b-604">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e480b-605"><paramref name="timeout" /> Parametru jest ujemna, a nie reprezentuje <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisekundy), lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="e480b-605">The <paramref name="timeout" /> parameter is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e480b-606">Zarządzana wątkowość</span><span class="sxs-lookup"><span data-stu-id="e480b-606">Managed Threading</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
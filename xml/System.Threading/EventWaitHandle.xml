<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a78f45e800db6ea099f816c0d991970357e9300e" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49152359" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="8ecb3-101">Reprezentuje zdarzenie synchronizacji wątków.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8ecb3-101">Represents a thread synchronization event.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-102"><xref:System.Threading.EventWaitHandle> Klasa umożliwia wątków do komunikowania się ze sobą za sygnalizowanie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-102">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="8ecb3-103">Zazwyczaj jeden lub więcej wątków zablokowane na <xref:System.Threading.EventWaitHandle> do momentu odblokowania wątek wywołuje <xref:System.Threading.EventWaitHandle.Set%2A> metody, zwalniając co najmniej jednym z zablokowanych wątków.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-103">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads.</span></span> <span data-ttu-id="8ecb3-104">Wątek może sygnał <xref:System.Threading.EventWaitHandle> a następnie zablokować na ich temat, wywołując `static` (`Shared` w języku Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-104">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8ecb3-105"><xref:System.Threading.EventWaitHandle> Klasy zapewnia dostęp do systemu o nazwie zdarzenia synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-105">The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
 <span data-ttu-id="8ecb3-106">Zachowanie <xref:System.Threading.EventWaitHandle> , zostały zasygnalizują, zależy od jej tryb resetowania.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-106">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode.</span></span> <span data-ttu-id="8ecb3-107"><xref:System.Threading.EventWaitHandle> Utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flaga Resetuje automatycznie, gdy sygnalizowane po przy zwalnianiu pojedynczego wątku oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-107">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="8ecb3-108"><xref:System.Threading.EventWaitHandle> Utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi pozostaje sygnałowego aż do jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-108">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="8ecb3-109">Automatyczne resetowanie zdarzenia udostępniają wyłącznego dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-109">Automatic reset events provide exclusive access to a resource.</span></span> <span data-ttu-id="8ecb3-110">Jeśli zdarzenie resetu automatycznego jest sygnalizowane, gdy nie ma wątków oczekujących, pozostaje sygnałowego aż wątek próby poczekaj na nim.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-110">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="8ecb3-111">Zdarzenie zwalnia wątku, a od razu resetuje, blokuje kolejnych wątków.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-111">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
 <span data-ttu-id="8ecb3-112">Zdarzenia są podobne do bramy resetowania ręcznego.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-112">Manual reset events are like gates.</span></span> <span data-ttu-id="8ecb3-113">Gdy zdarzenie nie jest sygnalizowane, wątki, które czekać na nim będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-113">When the event is not signaled, threads that wait on it will block.</span></span> <span data-ttu-id="8ecb3-114">Zdarzenie jest sygnalizowane, wszystkie wątki oczekiwania są wydawane, gdy zdarzenie pozostaje sygnałowego (oznacza to, w tym czasie czeka kolejnych nie blokują) do momentu jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-114">When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="8ecb3-115">Resetowanie ręczne zdarzenia są przydatne, gdy jeden wątek musi ukończyć działania, przed kontynuowaniem inne wątki.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-115">Manual reset events are useful when one thread must complete an activity before other threads can proceed.</span></span>  
  
 <span data-ttu-id="8ecb3-116"><xref:System.Threading.EventWaitHandle> obiekty mogą być używane z `static`(`Shared` w języku Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> i <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-116"><xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="8ecb3-117">Aby uzyskać więcej informacji na temat mechanizmów synchronizacji wątków, zobacz [EventWaitHandle, autoresetevent —, CountdownEvent ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="8ecb3-117">For more information about thread synchronization mechanisms, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb3-118">Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenia metody, aby zezwolić na wątek główny sygnał zablokowany wątek i poczekać, aż wątek kończy zadanie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-118">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="8ecb3-119">W przykładzie rozpoczyna się pięć wątków i umożliwia ich blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flaga, a następnie czas jeden wątek wersjach użytkownik naciśnie klawisz ENTER.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-119">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="8ecb3-120">Przykład następnie kolejkuje innego pięć wątków i zwalnia je za pomocą <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-120">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="8ecb3-121">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8ecb3-121">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="8ecb3-122">Zarządzana wątkowość</span>
      <span class="sxs-lookup">
        <span data-stu-id="8ecb3-122">Managed Threading</span>
      </span>
    </related>
    <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
      <span data-ttu-id="8ecb3-123">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
      <span class="sxs-lookup">
        <span data-stu-id="8ecb3-123">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8ecb3-124">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-124">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="8ecb3-125">
            <see langword="true" /> Aby ustawić stan początkowy sygnałowego; <see langword="false" /> ustawić ją na nonsignaled.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-125">
              <see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="8ecb3-126">Jedną z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-126">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ecb3-127">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając czy początkowo jest sygnalizowane dojście oczekiwania i czy Resetuje automatycznie lub ręcznie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-127">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-128">W przypadku nonsignaled początkowy stan zdarzenia spowoduje zablokowanie wątków, oczekiwania na zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-128">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="8ecb3-129">Jeśli stan początkowy jest sygnalizowane i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, wątki, które oczekiwania na zdarzenie nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-129">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="8ecb3-130">Jeśli stan początkowy jest sygnalizowane, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>, pierwszy wątek, który czeka na zdarzenie zostanie wydana natychmiast, po upływie którego zdarzenie spowoduje zresetowanie i spowoduje zablokowanie kolejnych wątków.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-130">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb3-131">Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenia metody, aby zezwolić na wątek główny sygnał zablokowany wątek i poczekać, aż wątek kończy zadanie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-131">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="8ecb3-132">W przykładzie rozpoczyna się pięć wątków i umożliwia ich blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flaga, a następnie czas jeden wątek wersjach użytkownik naciśnie klawisz ENTER.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-132">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses ENTER key.</span></span> <span data-ttu-id="8ecb3-133">Przykład następnie kolejkuje innego pięć wątków i zwalnia je za pomocą <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-133">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
          <span data-ttu-id="8ecb3-134">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-134">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="8ecb3-135">
            <see langword="true" /> Aby ustawić stan początkowy sygnalizowane, jeśli zdarzenie o nazwie zostanie utworzony w wyniku tego wywołania; <see langword="false" /> ustawić ją na nonsignaled.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-135">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="8ecb3-136">Jedną z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-136">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="8ecb3-137">Nazwa zdarzenia synchronizacji całego systemu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-137">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ecb3-138">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając, czy dojście oczekiwania początkowym zasygnalizowania Jeśli utworzone w wyniku tego wywołania czy Resetuje automatycznie lub ręcznie oraz nazwę zdarzenia synchronizacji systemu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-138">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-139">Jeśli `name` jest `null` lub pustym ciągiem, a lokalnym <xref:System.Threading.EventWaitHandle> zostanie utworzony.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-139">If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.</span></span>  
  
 <span data-ttu-id="8ecb3-140">Jeśli zdarzenie systemowe o podanej nazwie dla `name` parametr już istnieje, `initialState` parametr jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-140">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8ecb3-141">W przypadku używania tego konstruktora dla zdarzenia systemowe nazwanych, określ `false` dla `initialState`.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-141">When using this constructor for named system events, specify `false` for `initialState`.</span></span> <span data-ttu-id="8ecb3-142">Ten konstruktor zapewnia sposób określić, czy zdarzenie systemowe nazwane został utworzony, dlatego nie może wprowadzać żadnych założeń dotyczących stanu zdarzenia nazwanego.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-142">This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</span></span> <span data-ttu-id="8ecb3-143">Aby określić, czy zdarzenia nazwanego został utworzony, użyj <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> konstruktora lub <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-143">To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span></span>  
  
 <span data-ttu-id="8ecb3-144">W przypadku nonsignaled początkowy stan zdarzenia spowoduje zablokowanie wątków, oczekiwania na zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-144">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="8ecb3-145">Jeśli stan początkowy jest sygnalizowane i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, wątki, które oczekiwania na zdarzenie nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-145">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="8ecb3-146">Jeśli stan początkowy jest sygnalizowane, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>, pierwszy wątek, który czeka na zdarzenie zostanie wydana natychmiast, po upływie którego zdarzenie spowoduje zresetowanie i spowoduje zablokowanie kolejnych wątków.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-146">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="8ecb3-147">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-147">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="8ecb3-148">Zdarzenia nazwanego istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-148">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="8ecb3-149">Zdarzenia nazwanego nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-149">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8ecb3-150">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-150">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ecb3-151">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-151">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ecb3-152">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-152">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
          <span data-ttu-id="8ecb3-153">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-153">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="8ecb3-154">
            <see langword="true" /> Aby ustawić stan początkowy sygnalizowane, jeśli zdarzenie o nazwie zostanie utworzony w wyniku tego wywołania; <see langword="false" /> ustawić ją na nonsignaled.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-154">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="8ecb3-155">Jedną z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-155">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="8ecb3-156">Nazwa zdarzenia synchronizacji całego systemu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-156">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="8ecb3-157">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono zdarzenie lokalnego (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> ani być pustym ciągiem) lub jeśli utworzono zdarzenie określonego nazwanego systemu; <see langword="false" /> Jeśli zdarzenia określonego systemu o nazwie już istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-157">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          </span>
          <span data-ttu-id="8ecb3-158">Ten parametr jest przekazywany niezainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-158">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ecb3-159">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy, określania, czy dojście oczekiwania początkowym zasygnalizowania Jeśli utworzone w wyniku tego wywołania czy Resetuje automatycznie lub ręcznie, nazwę zdarzenia synchronizacji systemu i zmienną wartości logicznej którego wartość po wywołaniu wskazuje, czy zdarzenie systemowe nazwane został utworzony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-159">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-160">Jeśli zdarzenie systemowe o podanej nazwie dla `name` parametr już istnieje, `initialState` parametr jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-160">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="8ecb3-161">Po wywołaniu tego konstruktora, użyj wartości w zmiennej, określony dla `ref` parametru (`ByRef` parametru w języku Visual Basic)`createdNew` ustalenie, czy zdarzenie systemowe nazwane już istniało, czy też zostało utworzone.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-161">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="8ecb3-162">W przypadku nonsignaled początkowy stan zdarzenia spowoduje zablokowanie wątków, oczekiwania na zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-162">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="8ecb3-163">Jeśli stan początkowy jest sygnalizowane i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, wątki, które oczekiwania na zdarzenie nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-163">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="8ecb3-164">Jeśli stan początkowy jest sygnalizowane, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>, pierwszy wątek, który czeka na zdarzenie zostanie wydana natychmiast, po upływie którego zdarzenie spowoduje zresetowanie i spowoduje zablokowanie kolejnych wątków.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-164">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="8ecb3-165">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-165">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="8ecb3-166">Zdarzenia nazwanego istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-166">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="8ecb3-167">Zdarzenia nazwanego nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-167">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8ecb3-168">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-168">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ecb3-169">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-169">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ecb3-170">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-170">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
          <span data-ttu-id="8ecb3-171">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-171">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="8ecb3-172">
            <see langword="true" /> Aby ustawić stan początkowy sygnalizowane, jeśli zdarzenie o nazwie zostanie utworzony w wyniku tego wywołania; <see langword="false" /> ustawić ją na nonsignaled.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-172">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="8ecb3-173">Jedną z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-173">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="8ecb3-174">Nazwa zdarzenia synchronizacji całego systemu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-174">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="8ecb3-175">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono zdarzenie lokalnego (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> ani być pustym ciągiem) lub jeśli utworzono zdarzenie określonego nazwanego systemu; <see langword="false" /> Jeśli zdarzenia określonego systemu o nazwie już istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-175">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          </span>
          <span data-ttu-id="8ecb3-176">Ten parametr jest przekazywany niezainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-176">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="eventSecurity">
          <span data-ttu-id="8ecb3-177">
            <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt, który reprezentuje kontrolę dostępu mają być stosowane do zdarzeń o nazwie systemu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-177">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ecb3-178">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając, czy dojście oczekiwania początkowym zasygnalizowania Jeśli utworzone w wyniku tego wywołania czy Resetuje automatycznie lub ręcznie, Nazwa zdarzenia synchronizacji systemu, wartość logiczna którego wartość po wywołaniu wskazuje, czy utworzono zdarzenie o nazwie system i kontrolę dostępu, ma zostać zastosowany do zdarzenia nazwanego, jeśli jest on tworzony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-178">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-179">Aby zastosować kontrolę dostępu do zdarzeń o nazwie system, podczas jego tworzenia, uniemożliwiając innym kodem przejmowaniu zdarzenia, należy użyć tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-179">Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</span></span>  
  
 <span data-ttu-id="8ecb3-180">Ten konstruktor inicjuje <xref:System.Threading.EventWaitHandle> obiekt, który reprezentuje zdarzenie systemowe.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-180">This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event.</span></span> <span data-ttu-id="8ecb3-181">Możesz tworzyć wiele <xref:System.Threading.EventWaitHandle> obiektami, które reprezentują te same zdarzenia systemu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-181">You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.</span></span>  
  
 <span data-ttu-id="8ecb3-182">Zdarzenie systemowe nie istnieje, zostanie utworzony przy użyciu określonego kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-182">If the system event does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="8ecb3-183">Jeśli zdarzenie występuje, określony kontrolę dostępu jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-183">If the event exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8ecb3-184">Obiekt wywołujący ma pełną kontrolę nad nowo utworzony <xref:System.Threading.EventWaitHandle> nawet wtedy, gdy obiekt `eventSecurity` nie zezwala lub nie powiedzie się pewne prawa dostępu do bieżącego użytkownika.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-184">The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="8ecb3-185">Jednak jeśli bieżący użytkownik próbuje pobrać inny <xref:System.Threading.EventWaitHandle> obiektu, do reprezentowania takie same nazwanego zdarzenia, za pomocą konstruktora lub <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metody Windows zastosowano kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-185">However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="8ecb3-186">Jeśli zdarzenie systemowe o podanej nazwie dla `name` parametr już istnieje, `initialState` parametr jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-186">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="8ecb3-187">Po wywołaniu tego konstruktora, użyj wartości w zmiennej, określony dla `ref` parametru (`ByRef` parametru w języku Visual Basic) `createdNew` ustalenie, czy zdarzenie systemowe nazwane już istniało, czy też zostało utworzone.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-187">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="8ecb3-188">W przypadku nonsignaled początkowy stan zdarzenia spowoduje zablokowanie wątków, oczekiwania na zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-188">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="8ecb3-189">Jeśli stan początkowy jest sygnalizowane i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, wątki, które oczekiwania na zdarzenie nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-189">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="8ecb3-190">Jeśli stan początkowy jest sygnalizowane, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>, pierwszy wątek, który czeka na zdarzenie zostanie wydana natychmiast, po upływie którego zdarzenie spowoduje zresetowanie i spowoduje zablokowanie kolejnych wątków.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-190">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb3-191">Poniższy przykład kodu pokazuje zachowanie między procesami zdarzeń o nazwie system z kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-191">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="8ecb3-192">W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia zdarzeń o nazwie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-192">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="8ecb3-193">Jeśli zdarzenie nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, nie zezwala na bieżącemu użytkownikowi prawa do używania zdarzenia, ale daje prawo do odczytu, a zmiana uprawnień do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-193">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="8ecb3-194">Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-194">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="8ecb3-195">Wyjątek, a w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, aby czekać na zdarzenia przy użyciu uprawnień wymaganych do odczytywania i zmienić uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-195">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="8ecb3-196">Po zmianie uprawnienia zdarzenie zostanie otwarty z prawami musieli czekać na nim i wyda sygnał.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-196">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="8ecb3-197">Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci przykład działa przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-197">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="8ecb3-198">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-198">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="8ecb3-199">Zdarzenia nazwanego istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-199">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="8ecb3-200">Zdarzenia nazwanego nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-200">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8ecb3-201">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-201">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ecb3-202">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-202">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ecb3-203">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-203">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
          <span data-ttu-id="8ecb3-204">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-204">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8ecb3-205">Pobiera <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> obiekt, który reprezentuje kontrolę dostępu dla zdarzenia o nazwie system reprezentowany przez bieżącą <see cref="T:System.Threading.EventWaitHandle" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-205">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ecb3-206">
            <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt, który reprezentuje kontrolę dostępu dla zdarzeń o nazwie systemu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-206">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-207"><xref:System.Threading.EventWaitHandle.GetAccessControl%2A> Metoda używa następujących kombinacji flag (połączone za pomocą bitowej operacji OR) do wyszukania uprawnienia: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-207">The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8ecb3-208">Użytkownik musi mieć <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> praw do wywołania tej metody i zdarzenia muszą została otwarta z <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-208">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb3-209">Poniższy przykład kodu pokazuje zachowanie między procesami zdarzeń o nazwie system z kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-209">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="8ecb3-210">W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia zdarzeń o nazwie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-210">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="8ecb3-211">Jeśli zdarzenie nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, nie zezwala na bieżącemu użytkownikowi prawa do używania zdarzenia, ale daje prawo do odczytu, a zmiana uprawnień do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-211">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="8ecb3-212">Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-212">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="8ecb3-213">Wyjątek, a w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, aby czekać na zdarzenia przy użyciu uprawnień wymaganych do odczytywania i zmienić uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-213">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="8ecb3-214">Po przeczytaniu uprawnienia, za pomocą <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> metody i zmianie, zdarzenie jest otwierany z prawami musieli czekać na nim i wyda sygnał.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-214">After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="8ecb3-215">Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci przykład działa przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-215">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="8ecb3-216">Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt reprezentuje zdarzenie o nazwie system, a użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-216">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          </span>
          <span data-ttu-id="8ecb3-217">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-217">-or-</span>
          </span>
          <span data-ttu-id="8ecb3-218">Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt reprezentuje zdarzenie o nazwie system i nie została otwarta z <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-218">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8ecb3-219">Nie jest obsługiwane dla Windows 98 lub Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-219">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8ecb3-220">
            <see cref="M:System.Threading.WaitHandle.Close" /> Wcześniej wywołano metodę w tym <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-220">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
          <span data-ttu-id="8ecb3-221">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-221">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8ecb3-222">Otwiera to zdarzenie określonego nazwanego synchronizacji, jeśli już istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-222">Opens a specified named synchronization event, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8ecb3-223">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-223">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ecb3-224">Zostanie otwarte zdarzenie określonego nazwanego synchronizacji, jeśli już istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-224">Opens the specified named synchronization event, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ecb3-225">Obiekt, który reprezentuje zdarzenie o nazwie system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-225">An  object that represents the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-226"><xref:System.Threading.EventWaitHandle.OpenExisting%2A> Metoda podejmuje próbę otwarcia zdarzenia określonego nazwanego systemu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-226">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event.</span></span> <span data-ttu-id="8ecb3-227">Jeśli zdarzenie systemowe nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia zdarzeń systemu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-227">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="8ecb3-228">Aby utworzyć zdarzenie systemowe, gdy już nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które ma `name` parametru.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-228">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="8ecb3-229">Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.EventWaitHandle> obiektów, nawet jeśli obiekty, które są zwracane reprezentują te same zdarzenia o nazwie system.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-229">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 <span data-ttu-id="8ecb3-230">Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenie metody i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> praw, połączone za pomocą bitowej operacji OR.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-230">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="8ecb3-231">Określanie <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku w celu oczekiwania na zdarzenie o nazwie system i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątków do wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-231">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb3-232">Poniższy przykład kodu pokazuje zachowanie między procesami zdarzeń o nazwie system z kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-232">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="8ecb3-233">W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia zdarzeń o nazwie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-233">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="8ecb3-234">Jeśli zdarzenie nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, nie zezwala na bieżącemu użytkownikowi prawa do używania zdarzenia, ale daje prawo do odczytu, a zmiana uprawnień do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-234">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="8ecb3-235">Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-235">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="8ecb3-236">Wyjątek, a w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, aby czekać na zdarzenia przy użyciu uprawnień wymaganych do odczytywania i zmienić uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-236">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="8ecb3-237">Po zmianie uprawnienia zdarzenie zostanie otwarty z prawami musieli czekać na nim i wyda sygnał.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-237">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="8ecb3-238">Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci przykład działa przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-238">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8ecb3-239">
            <paramref name="name" /> jest ciągiem pustym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-239">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="8ecb3-240">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-240">-or-</span>
          </span>
          <span data-ttu-id="8ecb3-241">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-241">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8ecb3-242">
            <paramref name="name" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-242">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="8ecb3-243">Zdarzenie systemowe o nazwie nie istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-243">The named system event does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="8ecb3-244">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-244">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="8ecb3-245">Zdarzenie o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-245">The named event exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ecb3-246">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-246">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ecb3-247">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-247">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
          <span data-ttu-id="8ecb3-248">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-248">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8ecb3-249">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-249">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="8ecb3-250">Bitowa kombinacja wartości wyliczenia, które reprezentują dostęp pożądanych zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-250">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ecb3-251">Otwiera określony o nazwie zdarzenia synchronizacji, jeśli już istnieje, z dostępem do pożądanych zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-251">Opens the specified named synchronization event, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ecb3-252">Obiekt, który reprezentuje zdarzenie o nazwie system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-252">An object that represents the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-253">`rights` Parametr musi zawierać <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flagi, aby zezwolić wątków oczekiwania na zdarzenie, a <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flagi, aby zezwolić wątków do wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-253">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="8ecb3-254"><xref:System.Threading.EventWaitHandle.OpenExisting%2A> Metoda podejmuje próbę otwarcia istniejących zdarzeń o nazwie system.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-254">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event.</span></span> <span data-ttu-id="8ecb3-255">Jeśli zdarzenie systemowe nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia zdarzeń systemu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-255">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="8ecb3-256">Aby utworzyć zdarzenie systemowe, gdy już nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które ma `name` parametru.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-256">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="8ecb3-257">Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.EventWaitHandle> obiektów, nawet jeśli obiekty, które są zwracane reprezentują te same zdarzenia o nazwie system.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-257">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb3-258">Poniższy przykład kodu pokazuje zachowanie między procesami zdarzeń o nazwie system z kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-258">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="8ecb3-259">W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia zdarzeń o nazwie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-259">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="8ecb3-260">Jeśli zdarzenie nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, nie zezwala na bieżącemu użytkownikowi prawa do używania zdarzenia, ale daje prawo do odczytu, a zmiana uprawnień do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-260">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="8ecb3-261">Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-261">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="8ecb3-262">Wyjątek, a w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, aby czekać na zdarzenia przy użyciu uprawnień wymaganych do odczytywania i zmienić uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-262">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="8ecb3-263">Po zmianie uprawnienia zdarzenie zostanie otwarty z prawami musieli czekać na nim i wyda sygnał.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-263">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="8ecb3-264">Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci przykład działa przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-264">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8ecb3-265">
            <paramref name="name" /> jest ciągiem pustym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-265">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="8ecb3-266">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-266">-or-</span>
          </span>
          <span data-ttu-id="8ecb3-267">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-267">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8ecb3-268">
            <paramref name="name" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-268">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="8ecb3-269">Zdarzenie systemowe o nazwie nie istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-269">The named system event does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="8ecb3-270">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-270">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="8ecb3-271">Zdarzenie o nazwie istnieje, ale użytkownik nie ma dostępu pożądanych zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-271">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ecb3-272">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-272">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ecb3-273">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-273">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
          <span data-ttu-id="8ecb3-274">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-274">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8ecb3-275">Ustawia stan zdarzenia w celu nonsignaled, powodując wątków zablokować.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-275">Sets the state of the event to nonsignaled, causing threads to block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ecb3-276">
            <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-276">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8ecb3-277">
            <see cref="M:System.Threading.WaitHandle.Close" /> Wcześniej wywołano metodę w tym <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-277">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
          <span data-ttu-id="8ecb3-278">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-278">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8ecb3-279">Ustawia stan zdarzenia w celu sygnalizowane, dzięki czemu jeden lub więcej wątków oczekujących kontynuować.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-279">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ecb3-280">
            <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-280">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-281">Dla <xref:System.Threading.EventWaitHandle> z <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (w tym <xref:System.Threading.AutoResetEvent>), <xref:System.Threading.EventWaitHandle.Set%2A> metoda zwalnia jednego wątku.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-281">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread.</span></span> <span data-ttu-id="8ecb3-282">Jeśli nie istnieją wątki oczekujące, dojście oczekiwania pozostaje sygnałowego, aż wątek próby poczekaj na nim lub do momentu jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-282">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8ecb3-283">Nie ma żadnej gwarancji, każde wywołanie <xref:System.Threading.EventWaitHandle.Set%2A> metoda zwolni wątku z <xref:System.Threading.EventWaitHandle> której tryb resetowania jest <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-283">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8ecb3-284">Jeśli dwa wywołania są zbyt blisko siebie, tak, aby drugie wywołanie występuje przed wydano wątku, tylko jeden wątek jest zwalniana.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-284">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="8ecb3-285">Jest tak, jakby nie nastąpiły drugie wywołanie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-285">It is as if the second call did not happen.</span></span> <span data-ttu-id="8ecb3-286">Ponadto jeśli <xref:System.Threading.EventWaitHandle.Set%2A> jest wywoływana, gdy nie istnieją wątki oczekujące i <xref:System.Threading.EventWaitHandle> już jest sygnalizowane, wywołanie nie ma wpływu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-286">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="8ecb3-287">Dla <xref:System.Threading.EventWaitHandle> z <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (w tym <xref:System.Threading.ManualResetEvent>), wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> metoda pozostawia dojście oczekiwania w zasygnalizowany stan do momentu jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-287">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb3-288">Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenia metody, aby zezwolić na wątek główny sygnał zablokowany wątek i poczekać, aż wątek kończy zadanie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-288">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="8ecb3-289">W przykładzie rozpoczyna się pięć wątków i umożliwia ich blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flaga, a następnie czas jeden wątek wersjach użytkownik naciśnie klawisz ENTER.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-289">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="8ecb3-290">Przykład następnie kolejkuje innego pięć wątków i zwalnia je za pomocą <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-290">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8ecb3-291">
            <see cref="M:System.Threading.WaitHandle.Close" /> Wcześniej wywołano metodę w tym <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-291">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
          <span data-ttu-id="8ecb3-292">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-292">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">
          <span data-ttu-id="8ecb3-293">
            <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt, który reprezentuje kontrolę dostępu mają być stosowane do zdarzeń o nazwie systemu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-293">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ecb3-294">Ustawia kontrolę dostępu dla zdarzenia o nazwie system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-294">Sets the access control security for a named system event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-295">Użytkownik musi mieć <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> praw do wywołania tej metody i zdarzenia muszą została otwarta z <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-295">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ecb3-296">Poniższy przykład kodu pokazuje zachowanie między procesami zdarzeń o nazwie system z kontrolę dostępu.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-296">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="8ecb3-297">W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia zdarzeń o nazwie.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-297">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="8ecb3-298">Jeśli zdarzenie nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, nie zezwala na bieżącemu użytkownikowi prawa do używania zdarzenia, ale daje prawo do odczytu, a zmiana uprawnień do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-298">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="8ecb3-299">Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-299">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="8ecb3-300">Wyjątek, a w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, aby czekać na zdarzenia przy użyciu uprawnień wymaganych do odczytywania i zmienić uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-300">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="8ecb3-301">Po zmianie uprawnienia, za pomocą <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> metody i zdarzenia jest otwierany z prawami musieli czekać na nim i wyda sygnał.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-301">After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="8ecb3-302">Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci przykład działa przy użyciu nowych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-302">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8ecb3-303">
            <paramref name="eventSecurity" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-303">
              <paramref name="eventSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="8ecb3-304">Użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-304">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          </span>
          <span data-ttu-id="8ecb3-305">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-305">-or-</span>
          </span>
          <span data-ttu-id="8ecb3-306">Zdarzenie nie zostało otwarte z <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-306">The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="8ecb3-307">Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt nie reprezentuje zdarzenia systemowe nazwanych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-307">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8ecb3-308">
            <see cref="M:System.Threading.WaitHandle.Close" /> Wcześniej wywołano metodę w tym <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-308">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
          <span data-ttu-id="8ecb3-309">EventWaitHandle, autoresetevent — i ManualResetEvent</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-309">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8ecb3-310">Otwiera to zdarzenie określonego nazwanego synchronizacji, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-310">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8ecb3-311">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-311">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="8ecb3-312">Po powrocie z tej metody zawiera <see cref="T:System.Threading.EventWaitHandle" /> obiekt, który reprezentuje zdarzenie o nazwie synchronizacji, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie nie powiodło się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-312">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="8ecb3-313">Ten parametr jest traktowany jako niezainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-313">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ecb3-314">Zostanie otwarte zdarzenie określonego nazwanego synchronizacji, jeśli już istnieje i zwraca wartość wskazującą, czy operacja się powiedzie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-314">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ecb3-315">
            <see langword="true" /> Jeśli zdarzenie o nazwie synchronizacji został otwarty pomyślnie; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-315">
              <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-316">Jeśli zdarzenia synchronizacji o nazwie nie istnieje, ta metoda nie powoduje utworzenia go.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-316">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="8ecb3-317">Aby utworzyć zdarzenie systemowe, gdy już nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które ma `name` parametru.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-317">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="8ecb3-318">Jeśli masz pewności, czy zdarzenia synchronizacji o nazwie istnieje, użyj tego przeciążenia metody, zamiast <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody, która zgłasza wyjątek, jeśli zdarzenie synchronizacji nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-318">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="8ecb3-319">Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> przeciążenie metody i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> praw, połączone za pomocą bitowej operacji OR.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-319">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="8ecb3-320">Określanie <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku w celu oczekiwania na zdarzenie o nazwie system i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątków do wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-320">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="8ecb3-321">Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.EventWaitHandle> obiektów, nawet jeśli obiekty, które są zwracane reprezentują te same zdarzenia o nazwie system.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-321">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8ecb3-322">
            <paramref name="name" /> jest ciągiem pustym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-322">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="8ecb3-323">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-323">-or-</span>
          </span>
          <span data-ttu-id="8ecb3-324">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-324">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8ecb3-325">
            <paramref name="name" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-325">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="8ecb3-326">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-326">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="8ecb3-327">Zdarzenie o nazwie istnieje, ale użytkownik nie ma dostępu pożądanych zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-327">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ecb3-328">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-328">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ecb3-329">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-329">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8ecb3-330">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-330">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="8ecb3-331">Bitowa kombinacja wartości wyliczenia, które reprezentują dostęp pożądanych zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-331">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="8ecb3-332">Po powrocie z tej metody zawiera <see cref="T:System.Threading.EventWaitHandle" /> obiekt, który reprezentuje zdarzenie o nazwie synchronizacji, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie nie powiodło się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-332">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="8ecb3-333">Ten parametr jest traktowany jako niezainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-333">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ecb3-334">Otwiera zdarzenie określonego nazwanego synchronizacji, jeśli już istnieje z dostępem do pożądanych zabezpieczeń i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-334">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ecb3-335">
            <see langword="true" /> Jeśli zdarzenie o nazwie synchronizacji został otwarty pomyślnie; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-335">
              <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ecb3-336">Jeśli zdarzenia synchronizacji o nazwie nie istnieje, ta metoda nie powoduje utworzenia go.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-336">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="8ecb3-337">Aby utworzyć zdarzenie systemowe, gdy już nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które ma `name` parametru.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-337">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="8ecb3-338">Jeśli masz pewności, czy zdarzenia synchronizacji o nazwie istnieje, użyj tego przeciążenia metody, zamiast <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, która zgłasza wyjątek, jeśli zdarzenie synchronizacji nie istnieje.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-338">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="8ecb3-339">`rights` Parametr musi zawierać <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flagi, aby zezwolić wątków oczekiwania na zdarzenie, a <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flagi, aby zezwolić wątków do wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-339">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="8ecb3-340">Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.EventWaitHandle> obiektów, nawet jeśli obiekty, które są zwracane reprezentują te same zdarzenia o nazwie system.</span><span class="sxs-lookup"><span data-stu-id="8ecb3-340">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8ecb3-341">
            <paramref name="name" /> jest ciągiem pustym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-341">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="8ecb3-342">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-342">-or-</span>
          </span>
          <span data-ttu-id="8ecb3-343">
            <paramref name="name" /> jest dłuższa niż 260 znaków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-343">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8ecb3-344">
            <paramref name="name" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-344">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="8ecb3-345">Wystąpił błąd systemu Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-345">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="8ecb3-346">Zdarzenie o nazwie istnieje, ale użytkownik nie ma dostępu pożądanych zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-346">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ecb3-347">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-347">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ecb3-348">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ecb3-348">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>
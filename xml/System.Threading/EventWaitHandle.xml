<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="04ca1c444cfd772670659b4609b267628b38c728" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30579880" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje zdarzenia synchronizacji wątku.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle> Klasa umożliwia wątków do komunikowania się ze sobą za sygnalizowania. Zazwyczaj zablokować co najmniej jeden wątek na <xref:System.Threading.EventWaitHandle> do momentu wywołania wątku odblokowany <xref:System.Threading.EventWaitHandle.Set%2A> metoda zwalniania co najmniej jeden zablokowanych wątków. Wątek może sygnalizować <xref:System.Threading.EventWaitHandle> , a następnie zablokować, wywołując `static` (`Shared` w języku Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  <xref:System.Threading.EventWaitHandle> Klasy zapewnia dostęp do systemu o nazwie zdarzenia synchronizacji.  
  
 Zachowanie <xref:System.Threading.EventWaitHandle> który został zasygnalizują, zależy od jego trybu resetowania. <xref:System.Threading.EventWaitHandle> Utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flagi automatycznie po resetuje sygnalizowane po zwalniania pojedynczego wątku oczekiwania. <xref:System.Threading.EventWaitHandle> Utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi pozostaje sygnałowego aż do jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.  
  
 Automatyczne resetowanie zdarzenia udostępniają wyłącznego dostępu do zasobu. W przypadku automatycznego resetowania zdarzenie jest sygnalizowane, gdy nie ma wątków oczekujących, pozostaje sygnałowego dopóki wątku próbuje czekać na nim. Zdarzenie zwalnia wątku i resetuje natychmiast, blokowanie kolejnych wątków.  
  
 Zdarzenia są takie jak bramy resetowania ręcznego. Gdy zdarzenie nie zostanie zasygnalizowane, blokuje wątków oczekiwania na nim. Gdy zdarzenie jest sygnalizowane, wszystkich wątków oczekujących są wydawane i zdarzenie pozostaje sygnałowego (to znaczy kolejnych czeka nie blokują) do momentu jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana. Zdarzenia z resetowaniem ręcznym są przydatne, gdy jeden wątek musi ukończyć działania, przed kontynuowaniem pracy innych wątków.  
  
 <xref:System.Threading.EventWaitHandle> obiekty mogą być używane z `static`(`Shared` w języku Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> i <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat mechanizmów synchronizacji wątku, zobacz [EventWaitHandle, autoresetevent —, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenie metody, aby zezwolić na sygnał zablokowanych wątków, a następnie poczekaj zakończenie wątku zadania głównego wątku.  
  
 Przykład rozpoczyna się pięć wątków i można je zablokować na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flagi, a następnie czasu jeden wątek wersjach użytkownik naciśnie klawisz ENTER. W przykładzie następnie kolejki innego pięć wątków i zwalnia wszystkie przy użyciu <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> Aby ustawić stanu początkowego sygnalizuje; <see langword="false" /> ustawić ją na nonsignaled.</param>
        <param name="mode">Jeden z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy określenie, czy początkowo zostanie zasygnalizowane dojście oczekiwania, oraz czy Resetuje automatycznie lub ręcznie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli początkowy stan zdarzenia jest nonsignaled, blokuje wątków oczekiwania na zdarzenie. Jeśli zostanie zasygnalizowane początkowy stan i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, nie blokuje wątków oczekiwania na zdarzenie. Jeśli zostanie zasygnalizowane początkowy stan, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>pierwszym wątkiem oczekiwania na zdarzenie zostanie wydana natychmiast, po którym spowoduje zresetowanie zdarzenia i blokuje kolejnych wątków.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenie metody, aby zezwolić na sygnał zablokowanych wątków, a następnie poczekaj zakończenie wątku zadania głównego wątku.  
  
 Przykład rozpoczyna się pięć wątków i można je zablokować na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flagi, a następnie czasu jeden wątek wersjach użytkownik naciśnie klawisz ENTER. W przykładzie następnie kolejki innego pięć wątków i zwalnia wszystkie przy użyciu <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> Aby ustawić stanu początkowego sygnalizuje, jeśli zdarzenie o nazwie zostanie utworzony w wyniku tego wywołania; <see langword="false" /> ustawić ją na nonsignaled.</param>
        <param name="mode">Jeden z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</param>
        <param name="name">Nazwa zdarzenia synchronizacji całego systemu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając, czy dojście oczekiwania jest początkowo sygnalizowane Jeśli utworzony w wyniku tego wywołania, czy następuje zresetowanie automatycznie lub ręcznie oraz nazwę zdarzenia synchronizacji systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` jest `null` lub ciąg pusty lokalnym <xref:System.Threading.EventWaitHandle> jest tworzony.  
  
 Jeśli zdarzenie systemowe o podanej nazwie dla `name` parametr już istnieje, `initialState` parametru jest ignorowana.  
  
> [!IMPORTANT]
>  W przypadku używania tego konstruktora dla zdarzeń systemowych nazwanego, określ `false` dla `initialState`. Ten konstruktor zapewnia nie można określić, czy zdarzenie systemowe nazwanego został utworzony, więc nie można wprowadzić żadnych założenia dotyczące stanu zdarzenia o nazwie. Aby określić, czy nazwany zdarzeń został utworzony, użyj <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> konstruktora lub <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> konstruktora.  
  
 Jeśli początkowy stan zdarzenia jest nonsignaled, blokuje wątków oczekiwania na zdarzenie. Jeśli zostanie zasygnalizowane początkowy stan i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, nie blokuje wątków oczekiwania na zdarzenie. Jeśli zostanie zasygnalizowane początkowy stan, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>pierwszym wątkiem oczekiwania na zdarzenie zostanie wydana natychmiast, po którym spowoduje zresetowanie zdarzenia i blokuje kolejnych wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenia o nazwie istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwane zdarzenie nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> Aby ustawić stanu początkowego sygnalizuje, jeśli zdarzenie o nazwie zostanie utworzony w wyniku tego wywołania; <see langword="false" /> ustawić ją na nonsignaled.</param>
        <param name="mode">Jeden z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</param>
        <param name="name">Nazwa zdarzenia synchronizacji całego systemu.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono zdarzenie lokalnego (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> lub ciąg pusty) lub jeśli utworzono zdarzenie określonego systemu o nazwie; <see langword="false" /> Jeśli zdarzenie określonego systemu o nazwie już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy określenie, czy dojście oczekiwania jest początkowo sygnalizowane Jeśli utworzony w wyniku tego wywołania, czy następuje zresetowanie automatycznie lub ręcznie, nazwę zdarzenia synchronizacji systemu i wartość logiczna której wartość po wywołaniu metody wskazuje, czy zdarzenie systemowe nazwanego został utworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zdarzenie systemowe o podanej nazwie dla `name` parametr już istnieje, `initialState` parametru jest ignorowana. Po wywołaniu tego konstruktora, użyj wartości w zmiennej określonej dla `ref` parametr (`ByRef` parametru w języku Visual Basic)`createdNew` ustalenie, czy zdarzeń systemu o nazwie już istnieje lub została utworzona.  
  
 Jeśli początkowy stan zdarzenia jest nonsignaled, blokuje wątków oczekiwania na zdarzenie. Jeśli zostanie zasygnalizowane początkowy stan i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, nie blokuje wątków oczekiwania na zdarzenie. Jeśli zostanie zasygnalizowane początkowy stan, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>pierwszym wątkiem oczekiwania na zdarzenie zostanie wydana natychmiast, po którym spowoduje zresetowanie zdarzenia i blokuje kolejnych wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenia o nazwie istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwane zdarzenie nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> Aby ustawić stanu początkowego sygnalizuje, jeśli zdarzenie o nazwie zostanie utworzony w wyniku tego wywołania; <see langword="false" /> ustawić ją na nonsignaled.</param>
        <param name="mode">Jeden z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</param>
        <param name="name">Nazwa zdarzenia synchronizacji całego systemu.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono zdarzenie lokalnego (to znaczy, jeśli <c>nazwa</c> jest <see langword="null" /> lub ciąg pusty) lub jeśli utworzono zdarzenie określonego systemu o nazwie; <see langword="false" /> Jeśli zdarzenie określonego systemu o nazwie już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="eventSecurity">
          <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt, który reprezentuje kontrolę dostępu do zastosowania dla zdarzeń o nazwie systemu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając, czy dojście oczekiwania jest początkowo sygnalizowane Jeśli utworzony w wyniku tego wywołania, czy następuje zresetowanie automatycznie lub ręcznie, nazwę zdarzenia synchronizacji systemu, wartość logiczna którego wartość po wywołaniu wskazuje, czy zdarzenie systemowe nazwanego został utworzony i kontrolę dostępu ma zostać zastosowany do nazwanego zdarzenia, jeśli jest tworzona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, aby zastosować kontrolę dostępu do zdarzenia systemowe nazwane podczas jego tworzenia, uniemożliwia pobieranie formantu zdarzenia innego kodu.  
  
 Ten konstruktor inicjuje <xref:System.Threading.EventWaitHandle> obiekt, który reprezentuje zdarzeń systemu. Możesz utworzyć wiele <xref:System.Threading.EventWaitHandle> obiektów, które reprezentują tego samego zdarzenia systemu.  
  
 Jeśli zdarzenie systemowe nie istnieje, jest tworzony z określonym kontrolę dostępu. Jeśli zdarzenie istnieje, określony kontrolę dostępu jest ignorowane.  
  
> [!NOTE]
>  Obiekt wywołujący ma pełną kontrolę nad nowo utworzony <xref:System.Threading.EventWaitHandle> nawet wtedy, gdy obiekt `eventSecurity` nie zezwala lub nie powiedzie się pewne prawa dostępu do bieżącego użytkownika. Jednak jeśli bieżący użytkownik próbuje pobrać inny <xref:System.Threading.EventWaitHandle> obiekt, do reprezentowania takie same o nazwie zdarzenia za pomocą konstruktora lub <xref:System.Threading.EventWaitHandle.OpenExisting%2A> zastosowano kontrolę dostępu w systemie Windows metody.  
  
 Jeśli zdarzenie systemowe o podanej nazwie dla `name` parametr już istnieje, `initialState` parametru jest ignorowana. Po wywołaniu tego konstruktora, użyj wartości w zmiennej określonej dla `ref` parametr (`ByRef` parametru w języku Visual Basic) `createdNew` ustalenie, czy zdarzeń systemu o nazwie już istnieje lub została utworzona.  
  
 Jeśli początkowy stan zdarzenia jest nonsignaled, blokuje wątków oczekiwania na zdarzenie. Jeśli zostanie zasygnalizowane początkowy stan i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, nie blokuje wątków oczekiwania na zdarzenie. Jeśli zostanie zasygnalizowane początkowy stan, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>pierwszym wątkiem oczekiwania na zdarzenie zostanie wydana natychmiast, po którym spowoduje zresetowanie zdarzenia i blokuje kolejnych wątków.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie międzyprocesowa zdarzenia o nazwie system z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenie metody do sprawdzenia istnienia zdarzeń o nazwie.  
  
 Jeśli zdarzenie nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania zdarzenia, które daje prawo do odczytu, a zmiana uprawnień do zdarzenia.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenie metody oczekiwania na zdarzenie z uprawnień niezbędnych do odczytu i zmienić uprawnienia.  
  
 Po zmianie uprawnienia, zdarzenie jest otwarty z prawami musi czekać na nim i sygnału go. Po uruchomieniu przykład skompilowanych z okna polecenia trzeci w przykładzie są wykonywane przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenia o nazwie istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwane zdarzenie nie można utworzyć, prawdopodobnie ponieważ dojścia oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> obiekt, który reprezentuje kontrolę dostępu dla zdarzenia o nazwie system reprezentowany przez bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiektu.</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt, który reprezentuje kontrolę dostępu dla zdarzenia o nazwie system.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> Metoda używa następujących kombinacji flag (połączone, przy użyciu operacji bitowej OR) do wyszukania uprawnienia: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> praw, aby wywołać tę metodę i zdarzenia musi została otwarta z <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flagi.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie międzyprocesowa zdarzenia o nazwie system z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenie metody do sprawdzenia istnienia zdarzeń o nazwie.  
  
 Jeśli zdarzenie nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania zdarzenia, które daje prawo do odczytu, a zmiana uprawnień do zdarzenia.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenie metody oczekiwania na zdarzenie z uprawnień niezbędnych do odczytu i zmienić uprawnienia.  
  
 Po przeczytaniu uprawnienia, przy użyciu <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> metody, i zmianie, zdarzenie jest otwierany z prawami musi czekać na nim i sygnału go. Po uruchomieniu przykład skompilowanych z okna polecenia trzeci w przykładzie są wykonywane przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt reprezentuje zdarzenia o nazwie system, a użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
 —lub—  
  
 Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt reprezentuje zdarzenie o nazwie system i nie została otwarta z <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Nie jest obsługiwane dla systemu Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> Na tym wcześniej wywołano metodę <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera zdarzenia określonego nazwanego synchronizacji, jeśli już istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</param>
        <summary>Otwiera zdarzeń określony nazwany synchronizacji, jeśli już istnieje.</summary>
        <returns>Obiekt, który reprezentuje zdarzenia o nazwie system.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Metody spróbuje otworzyć zdarzenia określonego nazwanego systemu. Jeśli zdarzenie systemowe nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia zdarzeń systemowych. Aby utworzyć zdarzenie systemowe, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Wiele wywołań do tej metody, używanego przez tę samą wartość `name` nie musi zwracać taki sam <xref:System.Threading.EventWaitHandle> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego zdarzenia o nazwie system.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenie metody i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> praw, połączone przy użyciu operacji lub.  
  
 Określanie <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku oczekiwania na zdarzenie o nazwie system i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątku w celu wywołania <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie międzyprocesowa zdarzenia o nazwie system z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenie metody do sprawdzenia istnienia zdarzeń o nazwie.  
  
 Jeśli zdarzenie nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania zdarzenia, które daje prawo do odczytu, a zmiana uprawnień do zdarzenia.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenie metody oczekiwania na zdarzenie z uprawnień niezbędnych do odczytu i zmienić uprawnienia.  
  
 Po zmianie uprawnienia, zdarzenie jest otwarty z prawami musi czekać na nim i sygnału go. Po uruchomieniu przykład skompilowanych z okna polecenia trzeci w przykładzie są wykonywane przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Zdarzenia systemu o nazwie nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenia o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń, trzeba go używać.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</param>
        <param name="rights">Bitowe połączenie wartości wyliczenia, które reprezentują dostęp wymaganymi.</param>
        <summary>Otwiera określony o nazwie zdarzenia synchronizacji, jeśli już istnieje, z wymaganymi dostępu.</summary>
        <returns>Obiekt, który reprezentuje zdarzenia o nazwie system.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Musi zawierać parametr <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flaga wątki oczekiwania na zdarzenie i <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flagę wątków, aby wywołać <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.  
  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Metody spróbuje otworzyć zdarzenia o nazwie system istniejącego. Jeśli zdarzenie systemowe nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia zdarzeń systemowych. Aby utworzyć zdarzenie systemowe, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Wiele wywołań do tej metody, używanego przez tę samą wartość `name` nie musi zwracać taki sam <xref:System.Threading.EventWaitHandle> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego zdarzenia o nazwie system.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie międzyprocesowa zdarzenia o nazwie system z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenie metody do sprawdzenia istnienia zdarzeń o nazwie.  
  
 Jeśli zdarzenie nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania zdarzenia, które daje prawo do odczytu, a zmiana uprawnień do zdarzenia.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenie metody oczekiwania na zdarzenie z uprawnień niezbędnych do odczytu i zmienić uprawnienia.  
  
 Po zmianie uprawnienia, zdarzenie jest otwarty z prawami musi czekać na nim i sygnału go. Po uruchomieniu przykład skompilowanych z okna polecenia trzeci w przykładzie są wykonywane przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Zdarzenia systemu o nazwie nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenia o nazwie istnieje, ale użytkownik nie ma dostępu do żądanego zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia stan zdarzenia do nonsignaled, powodując wątków, aby zablokować.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> Na tym wcześniej wywołano metodę <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia stan zdarzenia sygnalizuje, dzięki czemu jeden lub więcej wątków oczekujących kontynuować.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla <xref:System.Threading.EventWaitHandle> z <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (łącznie z <xref:System.Threading.AutoResetEvent>), <xref:System.Threading.EventWaitHandle.Set%2A> metoda zwalnia jednego wątku. Jeśli nie ma żadnych wątków oczekujących, dojście oczekiwania pozostaje sygnałowego, dopóki wątku próbuje czekać na niej, lub do czasu jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.  
  
> [!IMPORTANT]
>  Nie ma żadnej gwarancji który każdego wywołania <xref:System.Threading.EventWaitHandle.Set%2A> metody opublikuje wątku z <xref:System.Threading.EventWaitHandle> której tryb resetowania jest <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Jeśli dwa wywołania są zbyt blisko siebie tak, aby drugie wywołanie występuje przed wątek został zwolniony, tylko jeden wątek jest zwalniany. Jest tak, jakby nie nastąpiły drugie wywołanie. Ponadto jeśli <xref:System.Threading.EventWaitHandle.Set%2A> jest wywoływane, gdy nie ma żadnych wątków oczekujących i <xref:System.Threading.EventWaitHandle> zostało już zasygnalizowane, połączenie nie ma wpływu.  
  
 Dla <xref:System.Threading.EventWaitHandle> z <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (łącznie z <xref:System.Threading.ManualResetEvent>), wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> metody pozostawia dojście oczekiwania w sygnałowego stanu do jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenie metody, aby zezwolić na sygnał zablokowanych wątków, a następnie poczekaj zakończenie wątku zadania głównego wątku.  
  
 Przykład rozpoczyna się pięć wątków i można je zablokować na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flagi, a następnie czasu jeden wątek wersjach użytkownik naciśnie klawisz ENTER. W przykładzie następnie kolejki innego pięć wątków i zwalnia wszystkie przy użyciu <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> Na tym wcześniej wywołano metodę <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">
          <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt, który reprezentuje kontrolę dostępu do zastosowania dla zdarzeń o nazwie systemu.</param>
        <summary>Ustawia kontrolę dostępu dla zdarzenia o nazwie system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi mieć <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> praw, aby wywołać tę metodę i zdarzenia musi została otwarta z <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flagi.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie międzyprocesowa zdarzenia o nazwie system z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenie metody do sprawdzenia istnienia zdarzeń o nazwie.  
  
 Jeśli zdarzenie nie istnieje, jest tworzony z początkowej własności i kontrolę dostępu, nie zezwala na bieżący użytkownik prawa do używania zdarzenia, które daje prawo do odczytu, a zmiana uprawnień do zdarzenia.  
  
 Jeśli uruchamiane skompilowany przykład dwa okna polecenia, druga kopia spowoduje zgłoszenie wyjątku naruszenie dostępu w wywołaniu <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Wyjątek zostanie przechwycony i w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenie metody oczekiwania na zdarzenie z uprawnień niezbędnych do odczytu i zmienić uprawnienia.  
  
 Po zmianie uprawnienia, przy użyciu <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> metody, zdarzenie zostanie otwarty z uprawnienia wymagane do Zaczekaj na jej i jej sygnału. Po uruchomieniu przykład skompilowanych z okna polecenia trzeci w przykładzie są wykonywane przy użyciu nowe uprawnienia.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
 —lub—  
  
 Zdarzenie nie została otwarta z <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt nie reprezentuje zdarzenia o nazwie system.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> Na tym wcześniej wywołano metodę <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera zdarzenia określonego nazwanego synchronizacji, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.EventWaitHandle" /> obiekt, który reprezentuje zdarzenia synchronizacji o nazwie, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie zakończyło się niepowodzeniem. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera zdarzeń określony nazwany synchronizacji, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns>
          <see langword="true" /> Jeśli zdarzenia synchronizacji o nazwie została otwarta pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zdarzenia synchronizacji o nazwie nie istnieje, ta metoda nie utworzy go. Aby utworzyć zdarzenie systemowe, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Jeśli masz pewności, czy istnieje zdarzenia o nazwie synchronizacji, użyj tego przeciążenia metody zamiast <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenie metody, która zgłasza wyjątek, jeśli zdarzenia synchronizacji nie istnieje.  
  
 Przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> przeciążenie metody i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> praw, połączone przy użyciu operacji lub. Określanie <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku oczekiwania na zdarzenie o nazwie system i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątku w celu wywołania <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.  
  
 Wiele wywołań do tej metody, używanego przez tę samą wartość `name` nie musi zwracać taki sam <xref:System.Threading.EventWaitHandle> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego zdarzenia o nazwie system.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenia o nazwie istnieje, ale użytkownik nie ma dostępu do żądanego zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</param>
        <param name="rights">Bitowe połączenie wartości wyliczenia, które reprezentują dostęp wymaganymi.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.EventWaitHandle" /> obiekt, który reprezentuje zdarzenia synchronizacji o nazwie, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie zakończyło się niepowodzeniem. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera zdarzeń określony nazwany synchronizacji, jeśli już istnieje z wymaganymi dostęp i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns>
          <see langword="true" /> Jeśli zdarzenia synchronizacji o nazwie została otwarta pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zdarzenia synchronizacji o nazwie nie istnieje, ta metoda nie utworzy go. Aby utworzyć zdarzenie systemowe, gdy jeszcze nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> ma konstruktorów `name` parametru.  
  
 Jeśli masz pewności, czy istnieje zdarzenia o nazwie synchronizacji, użyj tego przeciążenia metody zamiast <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenie metody, która zgłasza wyjątek, jeśli zdarzenia synchronizacji nie istnieje.  
  
 `rights` Musi zawierać parametr <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flaga wątki oczekiwania na zdarzenie i <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flagę wątków, aby wywołać <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.  
  
 Wiele wywołań do tej metody, używanego przez tę samą wartość `name` nie musi zwracać taki sam <xref:System.Threading.EventWaitHandle> obiektu, nawet jeśli obiekty, które są zwracane reprezentują tego samego zdarzenia o nazwie system.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest pustym ciągiem.  
  
 —lub—  
  
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenia o nazwie istnieje, ale użytkownik nie ma dostępu do żądanego zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
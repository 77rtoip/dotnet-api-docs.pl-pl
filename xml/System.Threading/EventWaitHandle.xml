<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fc1d0f39e32f0e1f04f469845918aa4cdb230b30" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69229528" /></Metadata><TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje zdarzenie synchronizacji wątku.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle> Klasa pozwala wątkom komunikować się ze sobą przez sygnalizowanie. Zwykle co najmniej jeden wątek jest <xref:System.Threading.EventWaitHandle> blokowany na bloku, dopóki nie zostanie odblokowany wątku <xref:System.Threading.EventWaitHandle.Set%2A> , zwalniając jeden lub więcej zablokowanych wątków. Wątek może sygnalizować <xref:System.Threading.EventWaitHandle> , a następnie blokować na nim, `static` wywołując metodę (`Shared` w Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> .  
  
> [!NOTE]
>  <xref:System.Threading.EventWaitHandle> Klasa zapewnia dostęp do nazwanych zdarzeń synchronizacji systemu.  
  
 Zachowanie <xref:System.Threading.EventWaitHandle> , które zostało zasygnalizowane, zależy od jego trybu resetowania. <xref:System.Threading.EventWaitHandle> Utworzony<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> z flagą resetuje się automatycznie po zasygnalizowaniu, po zwolnieniu pojedynczego wątku oczekującego. Element <xref:System.Threading.EventWaitHandle> utworzony <xref:System.Threading.EventWaitHandle.Reset%2A> przy użyciu flagi pozostaje zasygnalizowani do momentu wywołania metody. <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>  
  
 Zdarzenia automatycznego resetowania zapewniają wyłączny dostęp do zasobu. Jeśli automatyczne resetowanie zostanie sygnalizowane, gdy żaden wątek nie oczekuje, pozostaje zasygnalizowani do momentu, gdy wątki spróbuje go zaczekać. Zdarzenie zwalnia wątek i natychmiast resetuje, blokując kolejne wątki.  
  
 Zdarzenia resetowania ręcznego są takie same jak bramy. Gdy zdarzenie nie jest sygnalizowane, wątki, które czekają na niego, zostaną zablokowane. Po zasygnalizowaniu zdarzenia wszystkie oczekujące wątki są wyłączane, a zdarzenie pozostaje sygnalizowane (to oznacza, że kolejne oczekiwania nie będą blokowane) do momentu <xref:System.Threading.EventWaitHandle.Reset%2A> wywołania metody. Zdarzenia resetowania ręcznego są przydatne, gdy jeden wątek musi wykonać działanie, aby można było przejść do innych wątków.  
  
 <xref:System.Threading.EventWaitHandle>obiekty mogą być używane `static`z (`Shared` w Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> i <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metodami.  
  
 Aby uzyskać więcej informacji, zobacz [interakcja wątku lub](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) sekcja Sygnalizowanie w artykule [Omówienie elementów pierwotnych synchronizacji](~/docs/standard/threading/overview-of-synchronization-primitives.md) .  
  
   
  
## Examples  
 Poniższy przykład kodu używa przeciążenia metody <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> , aby umożliwić głównemu wątkowi sygnalizowanie zablokowanego wątku, a następnie zaczekać, aż wątek zakończy zadanie.  
  
 Przykład rozpoczyna pięć wątków i umożliwia ich zablokowanie przy <xref:System.Threading.EventWaitHandle> <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> użyciu flagi, a następnie zwalnia jeden wątek za każdym razem, gdy użytkownik naciśnie klawisz ENTER. W tym przykładzie kolejka będzie kolejkować kolejne pięć wątków i zwalnia <xref:System.Threading.EventWaitHandle> je wszystkie przy <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> użyciu flagi utworzony z flagą.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" />Aby ustawić stan początkowy na zasygnalizowanie; <see langword="false" /> , aby ustawić na Niesygnalizowane.</param>
        <param name="mode">Jedna z <see cref="T:System.Threading.EventResetMode" /> wartości, która określa, czy zdarzenie jest resetowane automatycznie czy ręcznie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając, czy dojście oczekiwania jest początkowo sygnalizowane i czy jest resetowane automatycznie czy ręcznie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli początkowy stan zdarzenia jest Niesygnalizowane, wątki oczekujące na zdarzenie zostaną zablokowane. Jeśli stan początkowy jest sygnalizowane, a <xref:System.Threading.EventResetMode.ManualReset> flaga jest określona dla `mode`, wątki oczekujące na zdarzenie nie będą blokowane. Jeśli początkowy stan jest sygnałowy, a `mode` to <xref:System.Threading.EventResetMode.AutoReset>pierwszy wątek, który czeka na zdarzenie, zostanie natychmiast ogłoszony, po upływie którego zdarzenie zostanie zresetowane, a kolejne wątki zostaną zablokowane.  
  
   
  
## Examples  
 Poniższy przykład kodu używa przeciążenia metody <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> , aby umożliwić głównemu wątkowi sygnalizowanie zablokowanego wątku, a następnie zaczekać, aż wątek zakończy zadanie.  
  
 Przykład rozpoczyna pięć wątków i umożliwia ich zablokowanie przy <xref:System.Threading.EventWaitHandle> <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> użyciu flagi, a następnie zwalnia jeden wątek za każdym razem, gdy użytkownik naciśnie klawisz ENTER. W tym przykładzie kolejka będzie kolejkować kolejne pięć wątków i zwalnia <xref:System.Threading.EventWaitHandle> je wszystkie przy <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> użyciu flagi utworzony z flagą.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" />Aby ustawić stan początkowy na sygnalizowanie w przypadku utworzenia nazwanego zdarzenia w wyniku tego wywołania; <see langword="false" /> , aby ustawić na Niesygnalizowane.</param>
        <param name="mode">Jedna z <see cref="T:System.Threading.EventResetMode" /> wartości, która określa, czy zdarzenie jest resetowane automatycznie czy ręcznie.</param>
        <param name="name">Nazwa zdarzenia synchronizacji całego systemu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając, czy dojście oczekiwania jest początkowo sygnalizowane, jeśli zostało utworzone w wyniku tego wywołania, niezależnie od tego, czy resetuje się automatycznie, czy ręcznie, oraz nazwę zdarzenia synchronizacji systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` jest `null` lub jest pustym ciągiem, zostanie <xref:System.Threading.EventWaitHandle> utworzony element lokalny.  
  
 Jeśli zdarzenie systemowe o nazwie określonej dla `name` parametru już istnieje `initialState` , parametr jest ignorowany.  
  
> [!IMPORTANT]
>  Gdy ten konstruktor jest używany dla nazwanych zdarzeń systemowych `false` , `initialState`Określ dla. Ten konstruktor nie pozwala określić, czy nazwane zdarzenie systemowe zostało utworzone, dlatego nie można wykonać żadnych założeń dotyczących stanu nazwanego zdarzenia. Aby określić, czy nazwane zdarzenie zostało utworzone, użyj <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> konstruktora <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> lub konstruktora.  
  
 Jeśli początkowy stan zdarzenia jest Niesygnalizowane, wątki oczekujące na zdarzenie zostaną zablokowane. Jeśli stan początkowy jest sygnalizowane, a <xref:System.Threading.EventResetMode.ManualReset> flaga jest określona dla `mode`, wątki oczekujące na zdarzenie nie będą blokowane. Jeśli początkowy stan jest sygnałowy, a `mode` to <xref:System.Threading.EventResetMode.AutoReset>pierwszy wątek, który czeka na zdarzenie, zostanie natychmiast ogłoszony, po upływie którego zdarzenie zostanie zresetowane, a kolejne wątki zostaną zablokowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwane zdarzenie istnieje i ma zabezpieczenia kontroli dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nie można utworzyć nazwanego zdarzenia, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" />Aby ustawić stan początkowy na sygnalizowanie w przypadku utworzenia nazwanego zdarzenia w wyniku tego wywołania; <see langword="false" /> , aby ustawić na Niesygnalizowane.</param>
        <param name="mode">Jedna z <see cref="T:System.Threading.EventResetMode" /> wartości, która określa, czy zdarzenie jest resetowane automatycznie czy ręcznie.</param>
        <param name="name">Nazwa zdarzenia synchronizacji całego systemu.</param>
        <param name="createdNew">Gdy ta metoda zostanie zwrócona <see langword="true" /> , program zawiera wartość, jeśli zostało utworzone zdarzenie lokalne ( <paramref name="name" /> czyli <see langword="null" /> jeśli jest lub pusty ciąg) lub jeśli zostało utworzone określone nazwane zdarzenie systemowe; <see langword="false" /> Jeśli określone nazwane zdarzenie systemowe już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając, czy dojście oczekiwania jest początkowo sygnalizowane, jeśli zostało utworzone w wyniku tego wywołania, niezależnie od tego, czy resetuje się automatycznie, czy ręcznie, nazwę zdarzenia synchronizacji systemu i zmienną logiczną którego wartość po wywołaniu wskazuje, czy nazwane zdarzenie systemowe zostało utworzone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zdarzenie systemowe o nazwie określonej dla `name` parametru już istnieje `initialState` , parametr jest ignorowany. Po wywołaniu tego konstruktora Użyj wartości ze zmiennej określonej dla `ref` parametru (`ByRef` parametr w Visual Basic)`createdNew` , aby określić, czy nazwane zdarzenie systemowe już istnieje, czy też zostało utworzone.  
  
 Jeśli początkowy stan zdarzenia jest Niesygnalizowane, wątki oczekujące na zdarzenie zostaną zablokowane. Jeśli stan początkowy jest sygnalizowane, a <xref:System.Threading.EventResetMode.ManualReset> flaga jest określona dla `mode`, wątki oczekujące na zdarzenie nie będą blokowane. Jeśli początkowy stan jest sygnałowy, a `mode` to <xref:System.Threading.EventResetMode.AutoReset>pierwszy wątek, który czeka na zdarzenie, zostanie natychmiast ogłoszony, po upływie którego zdarzenie zostanie zresetowane, a kolejne wątki zostaną zablokowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwane zdarzenie istnieje i ma zabezpieczenia kontroli dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nie można utworzyć nazwanego zdarzenia, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialState"><see langword="true" />Aby ustawić stan początkowy na sygnalizowanie w przypadku utworzenia nazwanego zdarzenia w wyniku tego wywołania; <see langword="false" /> , aby ustawić na Niesygnalizowane.</param>
        <param name="mode">Jedna z <see cref="T:System.Threading.EventResetMode" /> wartości, która określa, czy zdarzenie jest resetowane automatycznie czy ręcznie.</param>
        <param name="name">Nazwa zdarzenia synchronizacji całego systemu.</param>
        <param name="createdNew">Gdy ta metoda zostanie zwrócona <see langword="true" /> , program zawiera wartość, jeśli zostało utworzone zdarzenie lokalne ( <paramref name="name" /> czyli <see langword="null" /> jeśli jest lub pusty ciąg) lub jeśli zostało utworzone określone nazwane zdarzenie systemowe; <see langword="false" /> Jeśli określone nazwane zdarzenie systemowe już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="eventSecurity"><see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu, który ma zostać zastosowany do nazwanego zdarzenia systemowego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając, czy dojście oczekiwania jest początkowo sygnalizowane, jeśli zostało utworzone w wyniku tego wywołania, niezależnie od tego, czy jest resetowany automatycznie, czy ręcznie, nazwa zdarzenia synchronizacji systemu, zmienna logiczna, której wartość po wywołaniu wskazuje, czy nazwane zdarzenie systemowe zostało utworzone, a zabezpieczenia kontroli dostępu mają być stosowane do nazwanego zdarzenia, jeśli zostało utworzone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, aby zastosować zabezpieczenia kontroli dostępu do nazwanego zdarzenia systemowego podczas jego tworzenia, uniemożliwiając innemu kodowi przejęcie kontroli nad zdarzeniem.  
  
 Ten konstruktor inicjuje <xref:System.Threading.EventWaitHandle> obiekt, który reprezentuje zdarzenie systemowe. Można utworzyć wiele <xref:System.Threading.EventWaitHandle> obiektów, które reprezentują to samo zdarzenie systemowe.  
  
 Jeśli zdarzenie systemowe nie istnieje, jest tworzone z określonym zabezpieczeniami kontroli dostępu. Jeśli zdarzenie istnieje, określone zabezpieczenia kontroli dostępu zostaną zignorowane.  
  
> [!NOTE]
>  Obiekt wywołujący ma pełną kontrolę nad nowo utworzonym <xref:System.Threading.EventWaitHandle> obiektem, nawet w przypadku `eventSecurity` odmowy lub niepowodzenia udzielenia pewnych praw dostępu bieżącemu użytkownikowi. Jeśli jednak bieżący użytkownik próbuje uzyskać inny <xref:System.Threading.EventWaitHandle> obiekt, aby reprezentować to samo nazwane zdarzenie, używając konstruktora <xref:System.Threading.EventWaitHandle.OpenExisting%2A> lub metody zabezpieczenia kontroli dostępu systemu Windows jest stosowane.  
  
 Jeśli zdarzenie systemowe o nazwie określonej dla `name` parametru już istnieje `initialState` , parametr jest ignorowany. Po wywołaniu tego konstruktora Użyj wartości ze zmiennej określonej dla `ref` parametru (`ByRef` parametr w Visual Basic) `createdNew` , aby określić, czy nazwane zdarzenie systemowe już istnieje, czy też zostało utworzone.  
  
 Jeśli początkowy stan zdarzenia jest Niesygnalizowane, wątki oczekujące na zdarzenie zostaną zablokowane. Jeśli stan początkowy jest sygnalizowane, a <xref:System.Threading.EventResetMode.ManualReset> flaga jest określona dla `mode`, wątki oczekujące na zdarzenie nie będą blokowane. Jeśli początkowy stan jest sygnałowy, a `mode` to <xref:System.Threading.EventResetMode.AutoReset>pierwszy wątek, który czeka na zdarzenie, zostanie natychmiast ogłoszony, po upływie którego zdarzenie zostanie zresetowane, a kolejne wątki zostaną zablokowane.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe nazwanego zdarzenia systemowego z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego zdarzenia.  
  
 Jeśli zdarzenie nie istnieje, jest tworzone z zastosowaniem początkowego prawa własności i zabezpieczenia kontroli dostępu, które odmówi bieżącego użytkownika prawo do użycia zdarzenia, ale przyznaje prawo do odczytu i zmiany uprawnień do tego zdarzenia.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> Przeciążenie metody do oczekiwania na zdarzenie z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień zdarzenie zostanie otwarte z prawami wymaganymi do jego zaczekania i zasygnalizowaniem. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń, przykład zostanie uruchomiony przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwane zdarzenie istnieje i ma zabezpieczenia kontroli dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nie można utworzyć nazwanego zdarzenia, prawdopodobnie dlatego, że dojście oczekiwania o innym typie ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt reprezentujący zabezpieczenia kontroli dostępu dla nazwanego zdarzenia systemowego reprezentowanego przez bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt. <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /></summary>
        <returns><see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu dla nazwanego zdarzenia systemowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda używa następującej kombinacji flag (połączonych przy użyciu wartości bitowej lub operacji) do wyszukiwania uprawnień: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. <xref:System.Threading.EventWaitHandle.GetAccessControl%2A>  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> uprawnienia do wywołania tej metody, a zdarzenie musi być otwarte <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> z flagą.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe nazwanego zdarzenia systemowego z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego zdarzenia.  
  
 Jeśli zdarzenie nie istnieje, jest tworzone z zastosowaniem początkowego prawa własności i zabezpieczenia kontroli dostępu, które odmówi bieżącego użytkownika prawo do użycia zdarzenia, ale przyznaje prawo do odczytu i zmiany uprawnień do tego zdarzenia.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> Przeciążenie metody do oczekiwania na zdarzenie z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po odczytaniu uprawnień przy użyciu <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> metody i zmianie zdarzenie jest otwierane z prawami wymaganymi do jego zaczekania i zasygnalizowaniem. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń, przykład zostanie uruchomiony przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt reprezentuje nazwane zdarzenie systemowe, a użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
—lub— 
Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt reprezentuje nazwane zdarzenie systemowe i nie został otwarty przy użyciu <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Nieobsługiwane dla systemu Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wcześniej wywołana na tym <see cref="T:System.Threading.EventWaitHandle" />. <see cref="M:System.Threading.WaitHandle.Close" /></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określone nazwane zdarzenie synchronizacji, jeśli już istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu do otwarcia.</param>
        <summary>Otwiera określone nazwane zdarzenie synchronizacji, jeśli już istnieje.</summary>
        <returns>Obiekt reprezentujący nazwane zdarzenie systemowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Metoda próbuje otworzyć określone nazwane zdarzenie systemowe. Jeśli zdarzenie systemowe nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia zdarzenia systemowego. Aby utworzyć zdarzenie systemowe, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.EventWaitHandle> obiekt, nawet jeśli zwracane obiekty reprezentują to samo nazwane zdarzenie systemowe.  
  
 To Przeciążenie metody jest równoważne wywołaniem <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody i określaniem <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> prawami, połączonymi przy użyciu bitowej lub operacji.  
  
 Określenie flagi pozwala wątek czekać na nazwane zdarzenie systemowe, a <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> określenie flagi umożliwia wątek wywoływanie <xref:System.Threading.EventWaitHandle.Set%2A> metod i <xref:System.Threading.EventWaitHandle.Reset%2A>. <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe nazwanego zdarzenia systemowego z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego zdarzenia.  
  
 Jeśli zdarzenie nie istnieje, jest tworzone z zastosowaniem początkowego prawa własności i zabezpieczenia kontroli dostępu, które odmówi bieżącego użytkownika prawo do użycia zdarzenia, ale przyznaje prawo do odczytu i zmiany uprawnień do tego zdarzenia.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> Przeciążenie metody do oczekiwania na zdarzenie z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień zdarzenie zostanie otwarte z prawami wymaganymi do jego zaczekania i zasygnalizowaniem. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń, przykład zostanie uruchomiony przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwane zdarzenie systemowe nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwane zdarzenie istnieje, ale użytkownik nie ma dostępu do niego wymaganego przez zabezpieczenia.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu do otwarcia.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują żądany dostęp do zabezpieczeń.</param>
        <summary>Otwiera określone nazwane zdarzenie synchronizacji, jeśli już istnieje, z żądanym dostępem zabezpieczeń.</summary>
        <returns>Obiekt reprezentujący nazwane zdarzenie systemowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.Reset%2A> <xref:System.Threading.EventWaitHandle.Set%2A> <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Parametr musi <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> zawierać flagę, aby umożliwić wątkom oczekiwanie na zdarzenie, oraz flagę umożliwiającą wątkom wywoływanie metod i. `rights`  
  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Metoda próbuje otworzyć istniejące nazwane zdarzenie systemowe. Jeśli zdarzenie systemowe nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia zdarzenia systemowego. Aby utworzyć zdarzenie systemowe, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.EventWaitHandle> obiekt, nawet jeśli zwracane obiekty reprezentują to samo nazwane zdarzenie systemowe.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe nazwanego zdarzenia systemowego z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego zdarzenia.  
  
 Jeśli zdarzenie nie istnieje, jest tworzone z zastosowaniem początkowego prawa własności i zabezpieczenia kontroli dostępu, które odmówi bieżącego użytkownika prawo do użycia zdarzenia, ale przyznaje prawo do odczytu i zmiany uprawnień do tego zdarzenia.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> Przeciążenie metody do oczekiwania na zdarzenie z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień zdarzenie zostanie otwarte z prawami wymaganymi do jego zaczekania i zasygnalizowaniem. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń, przykład zostanie uruchomiony przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Nazwane zdarzenie systemowe nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwane zdarzenie istnieje, ale użytkownik nie ma żądanego dostępu do zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia stan zdarzenia na Niesygnalizowane, powodując zablokowanie wątków.</summary>
        <returns><see langword="true" />Jeśli operacja się powiedzie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wcześniej wywołana na tym <see cref="T:System.Threading.EventWaitHandle" />. <see cref="M:System.Threading.WaitHandle.Close" /></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia stan zdarzenia, które ma być sygnalizowane przez co najmniej jeden oczekujący wątek.</summary>
        <returns><see langword="true" />Jeśli operacja się powiedzie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku <xref:System.Threading.EventWaitHandle> elementu <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> <xref:System.Threading.AutoResetEvent> with<xref:System.Threading.EventWaitHandle.Set%2A> (łącznie) metoda zwalnia pojedynczy wątek. Jeśli nie ma oczekujących wątków, dojście oczekiwania zostanie sygnalizowane do momentu, aż wątek podejmie próbę oczekiwania na niego lub <xref:System.Threading.EventWaitHandle.Reset%2A> do momentu wywołania metody.  
  
> [!IMPORTANT]
>  Nie ma gwarancji, że każde wywołanie <xref:System.Threading.EventWaitHandle.Set%2A> metody zwolni wątek z, <xref:System.Threading.EventWaitHandle> którego tryb resetowania to <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Jeśli dwa wywołania są zbyt blisko siebie, więc drugie wywołanie następuje przed zwolnieniem wątku, zostanie wydane tylko jeden wątek. Jest tak, jakby drugie wywołanie nie było wykonywane. Ponadto, jeśli <xref:System.Threading.EventWaitHandle.Set%2A> jest wywoływana, gdy nie ma żadnych wątków oczekujących <xref:System.Threading.EventWaitHandle> i jest już sygnalizowane, wywołanie nie ma żadnego wpływu.  
  
 W przypadku <xref:System.Threading.EventWaitHandle> elementu <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> with ( <xref:System.Threading.ManualResetEvent> łącznie)<xref:System.Threading.EventWaitHandle.Reset%2A> wywoływanie metodypozostawiadojścieoczekiwaniawstaniezasygnalizowaniadomomentuwywołaniametody.<xref:System.Threading.EventWaitHandle.Set%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu używa przeciążenia metody <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> , aby umożliwić głównemu wątkowi sygnalizowanie zablokowanego wątku, a następnie zaczekać, aż wątek zakończy zadanie.  
  
 Przykład rozpoczyna pięć wątków i umożliwia ich zablokowanie przy <xref:System.Threading.EventWaitHandle> <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> użyciu flagi, a następnie zwalnia jeden wątek za każdym razem, gdy użytkownik naciśnie klawisz ENTER. W tym przykładzie kolejka będzie kolejkować kolejne pięć wątków i zwalnia <xref:System.Threading.EventWaitHandle> je wszystkie przy <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> użyciu flagi utworzony z flagą.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Metoda została wcześniej wywołana na tym <see cref="T:System.Threading.EventWaitHandle" />. <see cref="M:System.Threading.WaitHandle.Close" /></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="eventSecurity"><see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt reprezentujący zabezpieczenia kontroli dostępu, który ma zostać zastosowany do nazwanego zdarzenia systemowego.</param>
        <summary>Ustawia zabezpieczenia kontroli dostępu dla nazwanego zdarzenia systemowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi mieć <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> uprawnienia do wywołania tej metody, a zdarzenie musi być otwarte <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> z flagą.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zachowanie międzyprocesowe nazwanego zdarzenia systemowego z zabezpieczeniami kontroli dostępu. W przykładzie zastosowano <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> Przeciążenie metody do testowania pod kątem istnienia nazwanego zdarzenia.  
  
 Jeśli zdarzenie nie istnieje, jest tworzone z zastosowaniem początkowego prawa własności i zabezpieczenia kontroli dostępu, które odmówi bieżącego użytkownika prawo do użycia zdarzenia, ale przyznaje prawo do odczytu i zmiany uprawnień do tego zdarzenia.  
  
 W przypadku uruchomienia skompilowanego przykładu z dwóch poleceń systemu Windows druga kopia spowoduje zgłoszenie wyjątku naruszenia zasad dostępu w wywołaniu <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Przechwycono wyjątek, a w przykładzie zastosowano <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> Przeciążenie metody do oczekiwania na zdarzenie z prawami wymaganymi do odczytu i zmiany uprawnień.  
  
 Po zmianie uprawnień przy użyciu <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> metody zdarzenie jest otwierane z prawami wymaganymi do jego zaczekania i zasygnalizowaniem. W przypadku uruchomienia skompilowanego przykładu z trzeciego okna poleceń, przykład zostanie uruchomiony przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="eventSecurity" />jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
—lub— 
Zdarzenie nie zostało otwarte przy użyciu <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt nie reprezentuje nazwanego zdarzenia systemowego.</exception>
        <exception cref="T:System.ObjectDisposedException">Metoda została wcześniej wywołana na tym <see cref="T:System.Threading.EventWaitHandle" />. <see cref="M:System.Threading.WaitHandle.Close" /></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">Przegląd elementów podstawowych synchronizacji</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera określone nazwane zdarzenie synchronizacji, jeśli już istnieje, i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu do otwarcia.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera <see cref="T:System.Threading.EventWaitHandle" /> obiekt, który reprezentuje nazwane zdarzenie synchronizacji, jeśli wywołanie zakończyło się powodzeniem lub <see langword="null" /> wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określone nazwane zdarzenie synchronizacji, jeśli już istnieje, i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli nazwane zdarzenie synchronizacji zostało pomyślnie otwarte; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwane zdarzenie synchronizacji nie istnieje, ta metoda nie zostanie utworzona. Aby utworzyć zdarzenie systemowe, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Jeśli nie masz pewności, czy nazwane zdarzenie synchronizacji istnieje, użyj tego przeciążenia metody zamiast <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody, które zgłasza wyjątek, jeśli zdarzenie synchronizacji nie istnieje.  
  
 To Przeciążenie metody jest równoważne wywołaniem <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> przeciążenia metody i określaniem <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> prawami, połączonymi przy użyciu bitowej lub operacji. Określenie flagi pozwala wątek czekać na nazwane zdarzenie systemowe, a <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> określenie flagi umożliwia wątek wywoływanie <xref:System.Threading.EventWaitHandle.Set%2A> metod i <xref:System.Threading.EventWaitHandle.Reset%2A>. <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>  
  
 Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.EventWaitHandle> obiekt, nawet jeśli zwracane obiekty reprezentują to samo nazwane zdarzenie systemowe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwane zdarzenie istnieje, ale użytkownik nie ma żądanego dostępu do zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu do otwarcia.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują żądany dostęp do zabezpieczeń.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera <see cref="T:System.Threading.EventWaitHandle" /> obiekt, który reprezentuje nazwane zdarzenie synchronizacji, jeśli wywołanie zakończyło się powodzeniem lub <see langword="null" /> wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera określone nazwane zdarzenie synchronizacji, jeśli już istnieje, z żądanym dostępem zabezpieczeń i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli nazwane zdarzenie synchronizacji zostało pomyślnie otwarte; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwane zdarzenie synchronizacji nie istnieje, ta metoda nie zostanie utworzona. Aby utworzyć zdarzenie systemowe, gdy jeszcze nie istnieje, użyj jednego z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które `name` mają parametr.  
  
 Jeśli nie masz pewności, czy nazwane zdarzenie synchronizacji istnieje, użyj tego przeciążenia metody zamiast <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, które zgłasza wyjątek, jeśli zdarzenie synchronizacji nie istnieje.  
  
 <xref:System.Threading.EventWaitHandle.Reset%2A> <xref:System.Threading.EventWaitHandle.Set%2A> <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Parametr musi <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> zawierać flagę, aby umożliwić wątkom oczekiwanie na zdarzenie, oraz flagę umożliwiającą wątkom wywoływanie metod i. `rights`  
  
 Wiele wywołań tej metody, które używają tej samej wartości dla `name` niekoniecznie zwraca ten sam <xref:System.Threading.EventWaitHandle> obiekt, nawet jeśli zwracane obiekty reprezentują to samo nazwane zdarzenie systemowe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest pustym ciągiem.  
  
—lub— 
 <paramref name="name" />jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nazwane zdarzenie istnieje, ale użytkownik nie ma żądanego dostępu do zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>

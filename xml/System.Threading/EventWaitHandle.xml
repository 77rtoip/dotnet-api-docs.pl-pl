<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5e1c6b7d42730ddf0c4a4b6bc78696c68758dbab" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52193607" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje zdarzenie synchronizacji wątków.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle> Klasa umożliwia wątków do komunikowania się ze sobą za sygnalizowanie. Zazwyczaj jeden lub więcej wątków zablokowane na <xref:System.Threading.EventWaitHandle> do momentu odblokowania wątek wywołuje <xref:System.Threading.EventWaitHandle.Set%2A> metody, zwalniając co najmniej jednym z zablokowanych wątków. Wątek może sygnał <xref:System.Threading.EventWaitHandle> a następnie zablokować na ich temat, wywołując `static` (`Shared` w języku Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  <xref:System.Threading.EventWaitHandle> Klasy zapewnia dostęp do systemu o nazwie zdarzenia synchronizacji.  
  
 Zachowanie <xref:System.Threading.EventWaitHandle> , zostały zasygnalizują, zależy od jej tryb resetowania. <xref:System.Threading.EventWaitHandle> Utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flaga Resetuje automatycznie, gdy sygnalizowane po przy zwalnianiu pojedynczego wątku oczekiwania. <xref:System.Threading.EventWaitHandle> Utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi pozostaje sygnałowego aż do jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.  
  
 Automatyczne resetowanie zdarzenia udostępniają wyłącznego dostępu do zasobu. Jeśli zdarzenie resetu automatycznego jest sygnalizowane, gdy nie ma wątków oczekujących, pozostaje sygnałowego aż wątek próby poczekaj na nim. Zdarzenie zwalnia wątku, a od razu resetuje, blokuje kolejnych wątków.  
  
 Zdarzenia są podobne do bramy resetowania ręcznego. Gdy zdarzenie nie jest sygnalizowane, wątki, które czekać na nim będzie blokować. Zdarzenie jest sygnalizowane, wszystkie wątki oczekiwania są wydawane, gdy zdarzenie pozostaje sygnałowego (oznacza to, w tym czasie czeka kolejnych nie blokują) do momentu jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana. Resetowanie ręczne zdarzenia są przydatne, gdy jeden wątek musi ukończyć działania, przed kontynuowaniem inne wątki.  
  
 <xref:System.Threading.EventWaitHandle> obiekty mogą być używane z `static`(`Shared` w języku Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> i <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji na temat mechanizmów synchronizacji wątków, zobacz [EventWaitHandle, autoresetevent —, CountdownEvent ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenia metody, aby zezwolić na wątek główny sygnał zablokowany wątek i poczekać, aż wątek kończy zadanie.  
  
 W przykładzie rozpoczyna się pięć wątków i umożliwia ich blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flaga, a następnie czas jeden wątek wersjach użytkownik naciśnie klawisz ENTER. Przykład następnie kolejkuje innego pięć wątków i zwalnia je za pomocą <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md">Zarządzana wątkowość</related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> Aby ustawić stan początkowy sygnałowego; <see langword="false" /> ustawić ją na nonsignaled.</param>
        <param name="mode">Jedną z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając czy początkowo jest sygnalizowane dojście oczekiwania i czy Resetuje automatycznie lub ręcznie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku nonsignaled początkowy stan zdarzenia spowoduje zablokowanie wątków, oczekiwania na zdarzenie. Jeśli stan początkowy jest sygnalizowane i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, wątki, które oczekiwania na zdarzenie nie będzie blokować. Jeśli stan początkowy jest sygnalizowane, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>, pierwszy wątek, który czeka na zdarzenie zostanie wydana natychmiast, po upływie którego zdarzenie spowoduje zresetowanie i spowoduje zablokowanie kolejnych wątków.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenia metody, aby zezwolić na wątek główny sygnał zablokowany wątek i poczekać, aż wątek kończy zadanie.  
  
 W przykładzie rozpoczyna się pięć wątków i umożliwia ich blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flaga, a następnie czas jeden wątek wersjach użytkownik naciśnie klawisz ENTER. Przykład następnie kolejkuje innego pięć wątków i zwalnia je za pomocą <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> Aby ustawić stan początkowy sygnalizowane, jeśli zdarzenie o nazwie zostanie utworzony w wyniku tego wywołania; <see langword="false" /> ustawić ją na nonsignaled.</param>
        <param name="mode">Jedną z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</param>
        <param name="name">Nazwa zdarzenia synchronizacji całego systemu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając, czy dojście oczekiwania początkowym zasygnalizowania Jeśli utworzone w wyniku tego wywołania czy Resetuje automatycznie lub ręcznie oraz nazwę zdarzenia synchronizacji systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` jest `null` lub pustym ciągiem, a lokalnym <xref:System.Threading.EventWaitHandle> zostanie utworzony.  
  
 Jeśli zdarzenie systemowe o podanej nazwie dla `name` parametr już istnieje, `initialState` parametr jest ignorowany.  
  
> [!IMPORTANT]
>  W przypadku używania tego konstruktora dla zdarzenia systemowe nazwanych, określ `false` dla `initialState`. Ten konstruktor zapewnia sposób określić, czy zdarzenie systemowe nazwane został utworzony, dlatego nie może wprowadzać żadnych założeń dotyczących stanu zdarzenia nazwanego. Aby określić, czy zdarzenia nazwanego został utworzony, użyj <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> konstruktora lub <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> konstruktora.  
  
 W przypadku nonsignaled początkowy stan zdarzenia spowoduje zablokowanie wątków, oczekiwania na zdarzenie. Jeśli stan początkowy jest sygnalizowane i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, wątki, które oczekiwania na zdarzenie nie będzie blokować. Jeśli stan początkowy jest sygnalizowane, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>, pierwszy wątek, który czeka na zdarzenie zostanie wydana natychmiast, po upływie którego zdarzenie spowoduje zresetowanie i spowoduje zablokowanie kolejnych wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenia nazwanego istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Zdarzenia nazwanego nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> Aby ustawić stan początkowy sygnalizowane, jeśli zdarzenie o nazwie zostanie utworzony w wyniku tego wywołania; <see langword="false" /> ustawić ją na nonsignaled.</param>
        <param name="mode">Jedną z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</param>
        <param name="name">Nazwa zdarzenia synchronizacji całego systemu.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono zdarzenie lokalnego (to znaczy, jeśli <paramref name="name" /> jest <see langword="null" /> ani być pustym ciągiem) lub jeśli utworzono zdarzenie określonego nazwanego systemu; <see langword="false" /> Jeśli zdarzenia określonego systemu o nazwie już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy, określania, czy dojście oczekiwania początkowym zasygnalizowania Jeśli utworzone w wyniku tego wywołania czy Resetuje automatycznie lub ręcznie, nazwę zdarzenia synchronizacji systemu i zmienną wartości logicznej którego wartość po wywołaniu wskazuje, czy zdarzenie systemowe nazwane został utworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zdarzenie systemowe o podanej nazwie dla `name` parametr już istnieje, `initialState` parametr jest ignorowany. Po wywołaniu tego konstruktora, użyj wartości w zmiennej, określony dla `ref` parametru (`ByRef` parametru w języku Visual Basic)`createdNew` ustalenie, czy zdarzenie systemowe nazwane już istniało, czy też zostało utworzone.  
  
 W przypadku nonsignaled początkowy stan zdarzenia spowoduje zablokowanie wątków, oczekiwania na zdarzenie. Jeśli stan początkowy jest sygnalizowane i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, wątki, które oczekiwania na zdarzenie nie będzie blokować. Jeśli stan początkowy jest sygnalizowane, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>, pierwszy wątek, który czeka na zdarzenie zostanie wydana natychmiast, po upływie którego zdarzenie spowoduje zresetowanie i spowoduje zablokowanie kolejnych wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenia nazwanego istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Zdarzenia nazwanego nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> Aby ustawić stan początkowy sygnalizowane, jeśli zdarzenie o nazwie zostanie utworzony w wyniku tego wywołania; <see langword="false" /> ustawić ją na nonsignaled.</param>
        <param name="mode">Jedną z <see cref="T:System.Threading.EventResetMode" /> wartości, które określa, czy zdarzenie Resetuje automatycznie lub ręcznie.</param>
        <param name="name">Nazwa zdarzenia synchronizacji całego systemu.</param>
        <param name="createdNew">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli utworzono zdarzenie lokalnego (to znaczy, jeśli <paramref name="name" /> jest <see langword="null" /> ani być pustym ciągiem) lub jeśli utworzono zdarzenie określonego nazwanego systemu; <see langword="false" /> Jeśli zdarzenia określonego systemu o nazwie już istnieje. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="eventSecurity">
          <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt, który reprezentuje kontrolę dostępu mają być stosowane do zdarzeń o nazwie systemu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.EventWaitHandle" /> klasy, określając, czy dojście oczekiwania początkowym zasygnalizowania Jeśli utworzone w wyniku tego wywołania czy Resetuje automatycznie lub ręcznie, Nazwa zdarzenia synchronizacji systemu, wartość logiczna którego wartość po wywołaniu wskazuje, czy utworzono zdarzenie o nazwie system i kontrolę dostępu, ma zostać zastosowany do zdarzenia nazwanego, jeśli jest on tworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zastosować kontrolę dostępu do zdarzeń o nazwie system, podczas jego tworzenia, uniemożliwiając innym kodem przejmowaniu zdarzenia, należy użyć tego konstruktora.  
  
 Ten konstruktor inicjuje <xref:System.Threading.EventWaitHandle> obiekt, który reprezentuje zdarzenie systemowe. Możesz tworzyć wiele <xref:System.Threading.EventWaitHandle> obiektami, które reprezentują te same zdarzenia systemu.  
  
 Zdarzenie systemowe nie istnieje, zostanie utworzony przy użyciu określonego kontrolę dostępu. Jeśli zdarzenie występuje, określony kontrolę dostępu jest ignorowany.  
  
> [!NOTE]
>  Obiekt wywołujący ma pełną kontrolę nad nowo utworzony <xref:System.Threading.EventWaitHandle> nawet wtedy, gdy obiekt `eventSecurity` nie zezwala lub nie powiedzie się pewne prawa dostępu do bieżącego użytkownika. Jednak jeśli bieżący użytkownik próbuje pobrać inny <xref:System.Threading.EventWaitHandle> obiektu, do reprezentowania takie same nazwanego zdarzenia, za pomocą konstruktora lub <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metody Windows zastosowano kontrolę dostępu.  
  
 Jeśli zdarzenie systemowe o podanej nazwie dla `name` parametr już istnieje, `initialState` parametr jest ignorowany. Po wywołaniu tego konstruktora, użyj wartości w zmiennej, określony dla `ref` parametru (`ByRef` parametru w języku Visual Basic) `createdNew` ustalenie, czy zdarzenie systemowe nazwane już istniało, czy też zostało utworzone.  
  
 W przypadku nonsignaled początkowy stan zdarzenia spowoduje zablokowanie wątków, oczekiwania na zdarzenie. Jeśli stan początkowy jest sygnalizowane i <xref:System.Threading.EventResetMode.ManualReset> określono flagę `mode`, wątki, które oczekiwania na zdarzenie nie będzie blokować. Jeśli stan początkowy jest sygnalizowane, i `mode` jest <xref:System.Threading.EventResetMode.AutoReset>, pierwszy wątek, który czeka na zdarzenie zostanie wydana natychmiast, po upływie którego zdarzenie spowoduje zresetowanie i spowoduje zablokowanie kolejnych wątków.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami zdarzeń o nazwie system z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia zdarzeń o nazwie.  
  
 Jeśli zdarzenie nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, nie zezwala na bieżącemu użytkownikowi prawa do używania zdarzenia, ale daje prawo do odczytu, a zmiana uprawnień do zdarzenia.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Wyjątek, a w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, aby czekać na zdarzenia przy użyciu uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia zdarzenie zostanie otwarty z prawami musieli czekać na nim i wyda sygnał. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci przykład działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenia nazwanego istnieje i ma kontrolę dostępu, ale użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Zdarzenia nazwanego nie można utworzyć, prawdopodobnie ponieważ dojście oczekiwania innego typu ma taką samą nazwę.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> obiekt, który reprezentuje kontrolę dostępu dla zdarzenia o nazwie system reprezentowany przez bieżącą <see cref="T:System.Threading.EventWaitHandle" /> obiektu.</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt, który reprezentuje kontrolę dostępu dla zdarzeń o nazwie systemu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> Metoda używa następujących kombinacji flag (połączone za pomocą bitowej operacji OR) do wyszukania uprawnienia: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, i <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Użytkownik musi mieć <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> praw do wywołania tej metody i zdarzenia muszą została otwarta z <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flagi.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami zdarzeń o nazwie system z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia zdarzeń o nazwie.  
  
 Jeśli zdarzenie nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, nie zezwala na bieżącemu użytkownikowi prawa do używania zdarzenia, ale daje prawo do odczytu, a zmiana uprawnień do zdarzenia.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Wyjątek, a w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, aby czekać na zdarzenia przy użyciu uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po przeczytaniu uprawnienia, za pomocą <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> metody i zmianie, zdarzenie jest otwierany z prawami musieli czekać na nim i wyda sygnał. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci przykład działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt reprezentuje zdarzenie o nazwie system, a użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
—lub— 
Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt reprezentuje zdarzenie o nazwie system i nie została otwarta z <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Nie jest obsługiwane dla Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> Wcześniej wywołano metodę w tym <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera to zdarzenie określonego nazwanego synchronizacji, jeśli już istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</param>
        <summary>Zostanie otwarte zdarzenie określonego nazwanego synchronizacji, jeśli już istnieje.</summary>
        <returns>Obiekt, który reprezentuje zdarzenie o nazwie system.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Metoda podejmuje próbę otwarcia zdarzenia określonego nazwanego systemu. Jeśli zdarzenie systemowe nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia zdarzeń systemu. Aby utworzyć zdarzenie systemowe, gdy już nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.EventWaitHandle> obiektów, nawet jeśli obiekty, które są zwracane reprezentują te same zdarzenia o nazwie system.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenie metody i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> praw, połączone za pomocą bitowej operacji OR.  
  
 Określanie <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku w celu oczekiwania na zdarzenie o nazwie system i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątków do wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami zdarzeń o nazwie system z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia zdarzeń o nazwie.  
  
 Jeśli zdarzenie nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, nie zezwala na bieżącemu użytkownikowi prawa do używania zdarzenia, ale daje prawo do odczytu, a zmiana uprawnień do zdarzenia.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Wyjątek, a w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, aby czekać na zdarzenia przy użyciu uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia zdarzenie zostanie otwarty z prawami musieli czekać na nim i wyda sygnał. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci przykład działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Zdarzenie systemowe o nazwie nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenie o nazwie istnieje, ale użytkownik nie ma dostępu zabezpieczeń wymagane do jej używać.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują dostęp pożądanych zabezpieczeń.</param>
        <summary>Otwiera określony o nazwie zdarzenia synchronizacji, jeśli już istnieje, z dostępem do pożądanych zabezpieczeń.</summary>
        <returns>Obiekt, który reprezentuje zdarzenie o nazwie system.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` Parametr musi zawierać <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flagi, aby zezwolić wątków oczekiwania na zdarzenie, a <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flagi, aby zezwolić wątków do wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.  
  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Metoda podejmuje próbę otwarcia istniejących zdarzeń o nazwie system. Jeśli zdarzenie systemowe nie istnieje, ta metoda zgłasza wyjątek zamiast tworzenia zdarzeń systemu. Aby utworzyć zdarzenie systemowe, gdy już nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.EventWaitHandle> obiektów, nawet jeśli obiekty, które są zwracane reprezentują te same zdarzenia o nazwie system.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami zdarzeń o nazwie system z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia zdarzeń o nazwie.  
  
 Jeśli zdarzenie nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, nie zezwala na bieżącemu użytkownikowi prawa do używania zdarzenia, ale daje prawo do odczytu, a zmiana uprawnień do zdarzenia.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Wyjątek, a w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, aby czekać na zdarzenia przy użyciu uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia zdarzenie zostanie otwarty z prawami musieli czekać na nim i wyda sygnał. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci przykład działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Zdarzenie systemowe o nazwie nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenie o nazwie istnieje, ale użytkownik nie ma dostępu pożądanych zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia stan zdarzenia w celu nonsignaled, powodując wątków zablokować.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> Wcześniej wywołano metodę w tym <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia stan zdarzenia w celu sygnalizowane, dzięki czemu jeden lub więcej wątków oczekujących kontynuować.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla <xref:System.Threading.EventWaitHandle> z <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (w tym <xref:System.Threading.AutoResetEvent>), <xref:System.Threading.EventWaitHandle.Set%2A> metoda zwalnia jednego wątku. Jeśli nie istnieją wątki oczekujące, dojście oczekiwania pozostaje sygnałowego, aż wątek próby poczekaj na nim lub do momentu jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.  
  
> [!IMPORTANT]
>  Nie ma żadnej gwarancji, każde wywołanie <xref:System.Threading.EventWaitHandle.Set%2A> metoda zwolni wątku z <xref:System.Threading.EventWaitHandle> której tryb resetowania jest <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Jeśli dwa wywołania są zbyt blisko siebie, tak, aby drugie wywołanie występuje przed wydano wątku, tylko jeden wątek jest zwalniana. Jest tak, jakby nie nastąpiły drugie wywołanie. Ponadto jeśli <xref:System.Threading.EventWaitHandle.Set%2A> jest wywoływana, gdy nie istnieją wątki oczekujące i <xref:System.Threading.EventWaitHandle> już jest sygnalizowane, wywołanie nie ma wpływu.  
  
 Dla <xref:System.Threading.EventWaitHandle> z <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (w tym <xref:System.Threading.ManualResetEvent>), wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> metoda pozostawia dojście oczekiwania w zasygnalizowany stan do momentu jego <xref:System.Threading.EventWaitHandle.Reset%2A> metoda jest wywoływana.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenia metody, aby zezwolić na wątek główny sygnał zablokowany wątek i poczekać, aż wątek kończy zadanie.  
  
 W przykładzie rozpoczyna się pięć wątków i umożliwia ich blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> Flaga, a następnie czas jeden wątek wersjach użytkownik naciśnie klawisz ENTER. Przykład następnie kolejkuje innego pięć wątków i zwalnia je za pomocą <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> Wcześniej wywołano metodę w tym <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">
          <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> Obiekt, który reprezentuje kontrolę dostępu mają być stosowane do zdarzeń o nazwie systemu.</param>
        <summary>Ustawia kontrolę dostępu dla zdarzenia o nazwie system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi mieć <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> praw do wywołania tej metody i zdarzenia muszą została otwarta z <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flagi.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie między procesami zdarzeń o nazwie system z kontrolę dostępu. W przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody do sprawdzania istnienia zdarzeń o nazwie.  
  
 Jeśli zdarzenie nie istnieje, zostanie utworzony przy użyciu początkowego, własności i kontrolę dostępu, nie zezwala na bieżącemu użytkownikowi prawa do używania zdarzenia, ale daje prawo do odczytu, a zmiana uprawnień do zdarzenia.  
  
 Po uruchomieniu przykładzie skompilowane z dwóch poleceń systemu windows, drugą kopię spowoduje zgłoszenie wyjątku naruszenie zasad dostępu na wywołanie <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Wyjątek, a w przykładzie użyto <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, aby czekać na zdarzenia przy użyciu uprawnień wymaganych do odczytywania i zmienić uprawnienia.  
  
 Po zmianie uprawnienia, za pomocą <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> metody i zdarzenia jest otwierany z prawami musieli czekać na nim i wyda sygnał. Po uruchomieniu przykładzie skompilowane z okna poleceń, trzeci przykład działa przy użyciu nowych uprawnień.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Użytkownik nie ma <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
—lub— 
Zdarzenie nie zostało otwarte z <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">Bieżący <see cref="T:System.Threading.EventWaitHandle" /> obiekt nie reprezentuje zdarzenia systemowe nazwanych.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> Wcześniej wywołano metodę w tym <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, autoresetevent — i ManualResetEvent</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera to zdarzenie określonego nazwanego synchronizacji, jeśli już istnieje i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.EventWaitHandle" /> obiekt, który reprezentuje zdarzenie o nazwie synchronizacji, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Zostanie otwarte zdarzenie określonego nazwanego synchronizacji, jeśli już istnieje i zwraca wartość wskazującą, czy operacja się powiedzie.</summary>
        <returns>
          <see langword="true" /> Jeśli zdarzenie o nazwie synchronizacji został otwarty pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zdarzenia synchronizacji o nazwie nie istnieje, ta metoda nie powoduje utworzenia go. Aby utworzyć zdarzenie systemowe, gdy już nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Jeśli masz pewności, czy zdarzenia synchronizacji o nazwie istnieje, użyj tego przeciążenia metody, zamiast <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> przeciążenia metody, która zgłasza wyjątek, jeśli zdarzenie synchronizacji nie istnieje.  
  
 Tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> przeciążenie metody i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> i <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> praw, połączone za pomocą bitowej operacji OR. Określanie <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> Flaga umożliwia wątku w celu oczekiwania na zdarzenie o nazwie system i określając <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> Flaga umożliwia wątków do wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.EventWaitHandle> obiektów, nawet jeśli obiekty, które są zwracane reprezentują te same zdarzenia o nazwie system.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenie o nazwie istnieje, ale użytkownik nie ma dostępu pożądanych zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia synchronizacji systemu, aby otworzyć.</param>
        <param name="rights">Bitowa kombinacja wartości wyliczenia, które reprezentują dostęp pożądanych zabezpieczeń.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Threading.EventWaitHandle" /> obiekt, który reprezentuje zdarzenie o nazwie synchronizacji, jeśli wywołanie zakończyło się pomyślnie, lub <see langword="null" /> Jeśli wywołanie nie powiodło się. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Otwiera zdarzenie określonego nazwanego synchronizacji, jeśli już istnieje z dostępem do pożądanych zabezpieczeń i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns>
          <see langword="true" /> Jeśli zdarzenie o nazwie synchronizacji został otwarty pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zdarzenia synchronizacji o nazwie nie istnieje, ta metoda nie powoduje utworzenia go. Aby utworzyć zdarzenie systemowe, gdy już nie istnieje, użyj jednej z <xref:System.Threading.EventWaitHandle.%23ctor%2A> konstruktorów, które ma `name` parametru.  
  
 Jeśli masz pewności, czy zdarzenia synchronizacji o nazwie istnieje, użyj tego przeciążenia metody, zamiast <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> przeciążenia metody, która zgłasza wyjątek, jeśli zdarzenie synchronizacji nie istnieje.  
  
 `rights` Parametr musi zawierać <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flagi, aby zezwolić wątków oczekiwania na zdarzenie, a <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flagi, aby zezwolić wątków do wywoływania <xref:System.Threading.EventWaitHandle.Set%2A> i <xref:System.Threading.EventWaitHandle.Reset%2A> metody.  
  
 Wiele wywołań tej metody, używanego przez tę samą wartość `name` nie zawsze zwracają takie same <xref:System.Threading.EventWaitHandle> obiektów, nawet jeśli obiekty, które są zwracane reprezentują te same zdarzenia o nazwie system.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="name" /> jest dłuższa niż 260 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd systemu Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Zdarzenie o nazwie istnieje, ale użytkownik nie ma dostępu pożądanych zabezpieczeń.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="CancellationToken" FullName="System.Threading.CancellationToken">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="19b22c264e9da195fc5b91af5de567dc3b839021" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061446" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct CancellationToken" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit CancellationToken extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Threading.CancellationToken" />
  <TypeSignature Language="VB.NET" Value="Public Structure CancellationToken" />
  <TypeSignature Language="C++ CLI" Value="public value class CancellationToken" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("IsCancellationRequested = {IsCancellationRequested}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Propaguje powiadomienie, że operacje powinny być anulowane.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Threading.CancellationToken> umożliwia anulowanie współpracy między wątkami, elementy robocze puli wątków, lub <xref:System.Threading.Tasks.Task> obiektów. Utwórz token anulowania przez utworzenie wystąpienia <xref:System.Threading.CancellationTokenSource> obiektu, który zarządza anulowanie tokenów pobierane z jego <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> właściwości. Token anulowania można następnie przekazać do dowolną liczbę wątków, zadania lub operacje, które powinny być przesyłane powiadomienia o anulowaniu. Token nie można zainicjować anulowania. Gdy wywołuje obiekt będący właścicielem <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>, <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> ma ustawioną właściwość w każdej kopii token anulowania `true`. Obiekty, które odbierają powiadomienia mogą odpowiadać w jakikolwiek sposób jest odpowiedni.  
  
 Więcej informacji i kod przykłady można znaleźć [anulowanie w zarządzanych wątkach](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto generator liczb losowych, co pozwoliłoby na emulowanie aplikacji zbierania danych, która odczytuje 10 wartości całkowitej z 11 instrumencie. Wartość zerowa wskazuje, że pomiar ma nie dla jednego dokumentu, obliczane w takim przypadku można anulować operację i nie oznacza ogólne.  
  
 Aby obsłużyć możliwe anulowanie operacji, tworzy przykładzie <xref:System.Threading.CancellationTokenSource> obiekt, który generuje token anulowania, który jest przekazywany do <xref:System.Threading.Tasks.TaskFactory> obiektu. <xref:System.Threading.Tasks.TaskFactory> Obiektu z kolei przekazuje token anulowania do poszczególnych zadań odpowiedzialne za zbieranie odczyty dla określonego dokumentu. <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%60%602%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2CSystem.Func%7BSystem.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2C%60%601%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Metoda jest wywoływana, aby upewnić się, że średnia jest obliczana tylko wtedy, gdy wszystkie odczyty zebrano zostały pomyślnie. Jeśli zadanie ma nie, ponieważ zostało anulowane, wywołanie <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> metoda zgłasza wyjątek.  
  
 [!code-csharp[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/cs/cancel1.cs#1)]
 [!code-vb[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/vb/cancel1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne i chronione elementy członkowskie <see cref="T:System.Threading.CancellationToken" /> są wątkowo i mogą być używane jednocześnie wiele wątków.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationToken (bool canceled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool canceled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (canceled As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationToken(bool canceled);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="canceled" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="canceled">Stan anulowane dla tokenu.</param>
        <summary>Inicjuje <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tokeny utworzone za pomocą tego konstruktora pozostanie w stanie Anulowane określony przez `canceled` parametru. Jeśli `canceled` jest `false`, oba <xref:System.Threading.CancellationToken.CanBeCanceled%2A> i <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> będzie `false`.  
  
 Jeśli `canceled` jest `true`, oba <xref:System.Threading.CancellationToken.CanBeCanceled%2A> i <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> będzie `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBeCanceled">
      <MemberSignature Language="C#" Value="public bool CanBeCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanBeCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.CanBeCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanBeCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanBeCanceled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację, czy token ten może być w stanie anulowane.</summary>
        <value>
          <see langword="true" /> Jeśli ten token jest może być w stanie anulowane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Threading.CancellationToken.CanBeCanceled%2A> zwraca `false`, to zagwarantować, że token nigdy nie przechodzi w stan Anulowane, oznacza to, że <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> nigdy nie zwróci `true`. Zwraca token anulowania, którego nie można anulować statycznych <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType> właściwości.  
  
 Ta właściwość opcjonalnie służy do określenia, czy token anulowania może być anulowana przed badania wartość <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> właściwości w celu określenia, czy zostało anulowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy bieżący <see cref="T:System.Threading.CancellationToken" /> wystąpienie jest równe określonej tokenu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (other As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="other">Drugi obiekt do porównania z tym wystąpieniem.</param>
        <summary>Określa, czy bieżący <see cref="T:System.Threading.CancellationToken" /> wystąpienie jest równe określonej <see cref="T:System.Object" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="other" /> jest <see cref="T:System.Threading.CancellationToken" /> i dwa wystąpienia są takie same; w przeciwnym razie <see langword="false" />. Zobacz sekcję Spostrzeżenia, aby uzyskać więcej informacji. </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Dwa anulowanie tokenów są takie same, jeśli spełniony jest jeden z następujących warunków: 

- Są one powiązane z tym samym <xref:System.Threading.CancellationTokenSource>.

- Ich obu skonstruowane z publicznego <xref:System.Threading.CancellationToken> konstruktorów i ich <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> wartości są równe.

- Wartość oba tokeny anulowania jest <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.

       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Skojarzony <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Threading.CancellationToken other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Threading.CancellationToken other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Threading::CancellationToken other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="other">Druga <see cref="T:System.Threading.CancellationToken" /> do porównania z tym wystąpieniem.</param>
        <summary>Określa, czy bieżący <see cref="T:System.Threading.CancellationToken" /> wystąpienie jest równe określonej tokenu.</summary>
        <returns>
          <see langword="true" /> Jeśli wystąpienia są równe; w przeciwnym razie <see langword="false" />. Zobacz sekcję Spostrzeżenia, aby uzyskać więcej informacji. </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Dwa anulowanie tokenów są takie same, jeśli spełniony jest jeden z następujących warunków: 

- Są one powiązane z tym samym <xref:System.Threading.CancellationTokenSource>.

- Ich obu skonstruowane z publicznego <xref:System.Threading.CancellationToken> konstruktorów i ich <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> wartości są równe.

- Wartość oba tokeny anulowania jest <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pełni rolę funkcji skrótu dla <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Threading.CancellationToken" /> wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCancellationRequested">
      <MemberSignature Language="C#" Value="public bool IsCancellationRequested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCancellationRequested" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.IsCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCancellationRequested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCancellationRequested { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy zażądano anulowania tego tokenu.</summary>
        <value>
          <see langword="true" /> Jeśli ma anulowania żądanie dla tego tokena; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość wskazuje, czy ten token, za pomocą tokenu początkowo tworzona w stanie anulowane lub za pośrednictwem wywołania zażądano anulowania <xref:System.Threading.CancellationTokenSource.Cancel%2A> na skojarzonym token <xref:System.Threading.CancellationTokenSource>.  
  
 Jeśli ta właściwość jest `true`, tylko gwarantuje, że zażądano anulowania. Nie gwarantuje co zarejestrowaną usługę programu obsługi zakończenie wykonywania ani anulowania żądania zostało ukończone, propagowania na wszystkich zarejestrowanych programów obsługi. Dodatkowe synchronizacji mogą być wymagane, szczególnie w sytuacjach, w którym powiązane obiekty zostały anulowane jednocześnie.  
  
   
  
## Examples  
 Poniżej przedstawiono prosty przykład, która wykonuje proces serwera do <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> zwraca właściwość `true`.  
  
 [!code-csharp[System.Threading.Tasks.CancellationToken.IsCancellationRequested#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.CancellationToken.IsCancellationRequested/cs/cancellation.cs#12)]
 [!code-vb[System.Threading.Tasks.CancellationToken.IsCancellationRequested#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.CancellationToken.IsCancellationRequested/vb/cancelthreads.vb#12)]  
  
 Przykład tworzy <xref:System.Threading.CancellationTokenSource> obiektu, który kontroluje dostęp do tokena anulowania. Definiuje dwie procedury wątku. Pierwszy jest zdefiniowany jako wyrażenie lambda, pul klawiatury, a następnie wywołuje po naciśnięciu klawisza "C", <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> można ustawić token anulowania do anulowania stanu. Drugim jest metodą sparametryzowane `ServerClass.StaticMethod`, który wykonuje pętli do <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> właściwość jest `true`.  
  
 Wątku głównego następnie uruchamia dwoma wątkami i bloków do wątku, który wykonuje `ServerClass.StaticMethod` kończy metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationToken None { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Threading.CancellationToken None" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property None As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::CancellationToken None { System::Threading::CancellationToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca pustą <see cref="T:System.Threading.CancellationToken" /> wartość.</summary>
        <value>Token anulowania puste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można anulować token anulowania zwracane przez tę właściwość; oznacza to, że jego <xref:System.Threading.CancellationToken.CanBeCanceled%2A> jest właściwość `false`.  
  
 Można również użyć języka C# [default(CancellationToken)](~/docs/csharp/language-reference/keywords/default.md) instrukcji, aby utworzyć token anulowania puste. 

 Dwa puste anulowanie tokenów zawsze są takie same.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Threading.CancellationToken left, System.Threading.CancellationToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Threading.CancellationToken left, valuetype System.Threading.CancellationToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As CancellationToken, right As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Threading::CancellationToken left, System::Threading::CancellationToken right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Threading.CancellationToken" />
        <Parameter Name="right" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsze wystąpienie.</param>
        <param name="right">Drugie wystąpienie.</param>
        <summary>Określa, czy dwa <see cref="T:System.Threading.CancellationToken" /> wystąpienia są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli wystąpienia są równe; w przeciwnym razie <see langword="false" /> sekcji uwag, aby uzyskać więcej informacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Dwa anulowanie tokenów są takie same, jeśli spełniony jest jeden z następujących warunków: 

- Są one powiązane z tym samym <xref:System.Threading.CancellationTokenSource>.

- Ich obu skonstruowane z publicznego <xref:System.Threading.CancellationToken> konstruktorów i ich <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> wartości są równe.

- Wartość oba tokeny anulowania jest <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.
       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Skojarzony <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Threading.CancellationToken left, System.Threading.CancellationToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Threading.CancellationToken left, valuetype System.Threading.CancellationToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As CancellationToken, right As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Threading::CancellationToken left, System::Threading::CancellationToken right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Threading.CancellationToken" />
        <Parameter Name="right" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsze wystąpienie.</param>
        <param name="right">Drugie wystąpienie.</param>
        <summary>Określa, czy dwa <see cref="T:System.Threading.CancellationToken" /> wystąpień nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli wystąpienia nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Definicję równości <xref:System.Threading.CancellationToken.Equals%2A> metody. 
       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Skojarzony <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje delegata, który zostanie wywołana podczas to <see cref="T:System.Threading.CancellationToken" /> zostało anulowane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Delegowaną, która ma zostać wykonana po <see cref="T:System.Threading.CancellationToken" /> zostało anulowane.</param>
        <summary>Rejestruje delegata, który zostanie wywołana podczas to <see cref="T:System.Threading.CancellationToken" /> zostało anulowane.</summary>
        <returns>
          <see cref="T:System.Threading.CancellationTokenRegistration" /> Wystąpienia, który może służyć do wyrejestrowania wywołania zwrotnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli token ten jest już w stanie anulowane, delegat będą uruchamiane natychmiast. Wszystkie wyjątki, delegat generowanego przez będzie propagowane poza wywołanie tej metody.  
  
 Bieżący <xref:System.Threading.ExecutionContext> przechwytywania wraz z obiektem delegowanym i będą używane podczas jej wykonywania. 

 Bieżące <xref:System.Threading.SynchronizationContext> nie są przechwytywane.
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Skojarzony <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action callback, bool useSynchronizationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action callback, bool useSynchronizationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action, useSynchronizationContext As Boolean) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action ^ callback, bool useSynchronizationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="useSynchronizationContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callback">Delegowaną, która ma zostać wykonana po <see cref="T:System.Threading.CancellationToken" /> zostało anulowane.</param>
        <param name="useSynchronizationContext">Wartość, która wskazuje, czy do przechwycenia bieżącego <see cref="T:System.Threading.SynchronizationContext" /> i używać go podczas wywoływania <c>wywołania zwrotnego</c>.</param>
        <summary>Rejestruje delegata, który zostanie wywołana podczas to <see cref="T:System.Threading.CancellationToken" /> zostało anulowane.</summary>
        <returns>
          <see cref="T:System.Threading.CancellationTokenRegistration" /> Wystąpienia, który może służyć do wyrejestrowania wywołania zwrotnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli token ten jest już w stanie anulowane, delegat będą uruchamiane natychmiast. Wszystkie wyjątki, delegat generowanego przez będzie propagowane poza wywołanie tej metody.  
  
 Bieżący <xref:System.Threading.ExecutionContext> przechwytywania wraz z obiektem delegowanym i będą używane podczas jej wykonywania. 

 Jeśli `useSynchronizationContext` jest `true`, bieżący <xref:System.Threading.SynchronizationContext>, jeśli jeden istnieje, jest również przechwytywany wraz z obiektem delegowanym i będą używane podczas jej wykonywania. W przeciwnym razie <xref:System.Threading.SynchronizationContext> nie są przechwytywane.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Skojarzony <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action&lt;object&gt; callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action`1&lt;object&gt; callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action(Of Object), state As Object) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegowaną, która ma zostać wykonana po <see cref="T:System.Threading.CancellationToken" /> zostało anulowane.</param>
        <param name="state">Stan do przekazania do <c>wywołania zwrotnego</c> po wywołaniu obiektu delegowanego. Może to być wartość null.</param>
        <summary>Rejestruje delegata, który zostanie wywołana podczas to <see cref="T:System.Threading.CancellationToken" /> zostało anulowane.</summary>
        <returns>
          <see cref="T:System.Threading.CancellationTokenRegistration" /> Wystąpienia, który może służyć do wyrejestrowania wywołania zwrotnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli token ten jest już w stanie anulowane, delegat będą uruchamiane natychmiast. Wszystkie wyjątki, delegat generowanego przez będzie propagowane poza wywołanie tej metody.  
  
 Bieżący <xref:System.Threading.ExecutionContext> przechwytywania wraz z obiektem delegowanym i będą używane podczas jej wykonywania. 

 Bieżące <xref:System.Threading.SynchronizationContext> nie są przechwytywane.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Skojarzony <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action&lt;object&gt; callback, object state, bool useSynchronizationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action`1&lt;object&gt; callback, object state, bool useSynchronizationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action(Of Object), state As Object, useSynchronizationContext As Boolean) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state, bool useSynchronizationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="useSynchronizationContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callback">Delegowaną, która ma zostać wykonana po <see cref="T:System.Threading.CancellationToken" /> zostało anulowane.</param>
        <param name="state">Stan do przekazania do <c>wywołania zwrotnego</c> po wywołaniu obiektu delegowanego. Może to być wartość null.</param>
        <param name="useSynchronizationContext">Wartość logiczna, która wskazuje, czy do przechwycenia bieżącego <see cref="T:System.Threading.SynchronizationContext" /> i używać go podczas wywoływania <c>wywołania zwrotnego</c>.</param>
        <summary>Rejestruje delegata, który zostanie wywołana podczas to <see cref="T:System.Threading.CancellationToken" /> zostało anulowane.</summary>
        <returns>
          <see cref="T:System.Threading.CancellationTokenRegistration" /> Wystąpienia, który może służyć do wyrejestrowania wywołania zwrotnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli token ten jest już w stanie anulowane, delegat będą uruchamiane natychmiast. Wszystkie wyjątki, delegat generowanego przez będzie propagowane poza wywołanie tej metody.  
  
 Bieżący <xref:System.Threading.ExecutionContext> przechwytywania wraz z obiektem delegowanym i będą używane podczas jej wykonywania. 

 Jeśli `useSynchronizationContext` jest `true`, bieżący <xref:System.Threading.SynchronizationContext>, jeśli jeden istnieje, jest również przechwytywany wraz z obiektem delegowanym i będą używane podczas jej wykonywania. W przeciwnym razie <xref:System.Threading.SynchronizationContext> nie są przechwytywane.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Skojarzony <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfCancellationRequested">
      <MemberSignature Language="C#" Value="public void ThrowIfCancellationRequested ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ThrowIfCancellationRequested() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.ThrowIfCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public Sub ThrowIfCancellationRequested ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ThrowIfCancellationRequested();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza wyjątek <see cref="T:System.OperationCanceledException" /> gdyby ten token ma żądanie anulowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia równoważne funkcje:  
  
 C#  
  
```csharp  
if (token.IsCancellationRequested)   
    throw new OperationCanceledException(token);  
```  
  
```vb  
If token.IsCancellationRequested Then  
    Throw New OperationCanceledException(token)  
End If  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Token miał żądanie anulowania.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzony <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle WaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle WaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.WaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ WaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.WaitHandle" /> który jest sygnalizowane po anulowaniu tokenu.</summary>
        <value>A <see cref="T:System.Threading.WaitHandle" /> który jest sygnalizowane po anulowaniu tokenu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uzyskiwanie dostępu do tej właściwości spowoduje, że <xref:System.Threading.WaitHandle> zostać utworzone. Zaleca się do użycia tylko tej właściwości, gdy jest to konieczne, a następnie usuwania skojarzonego <xref:System.Threading.CancellationTokenSource> wystąpienia w możliwie najkrótszym (disposing źródło zlikwiduje ta dojścia przydzielonego). Nie można zamknąć lub usunięty bezpośrednio dojście.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Skojarzony <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="GenericRootAutomationPeer" FullName="System.Windows.Automation.Peers.GenericRootAutomationPeer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aa62a693f4921eda9b150caa67efcd2cec5208d4" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55388856" /></Metadata><TypeSignature Language="C#" Value="public class GenericRootAutomationPeer : System.Windows.Automation.Peers.UIElementAutomationPeer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GenericRootAutomationPeer extends System.Windows.Automation.Peers.UIElementAutomationPeer" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Peers.GenericRootAutomationPeer" />
  <TypeSignature Language="VB.NET" Value="Public Class GenericRootAutomationPeer&#xA;Inherits UIElementAutomationPeer" />
  <TypeSignature Language="C++ CLI" Value="public ref class GenericRootAutomationPeer : System::Windows::Automation::Peers::UIElementAutomationPeer" />
  <TypeSignature Language="F#" Value="type GenericRootAutomationPeer = class&#xA;    inherit UIElementAutomationPeer" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Automation.Peers.UIElementAutomationPeer</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia <see cref="T:System.Windows.Interop.HwndSource" /> typów do automatyzacji interfejsu użytkownika.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Peers.GenericRootAutomationPeer> jest używany jako element równorzędny dla <xref:System.Windows.Interop.HwndSource> jeśli zawiera on następujące drzewo:  
  
 ![HwndSource&#45;&#62;Visual&#45;&#62;2 obiekty UIElement](~/add/media/apgenericroot.png "HwndSource -> Visual -> 2 obiekty UIElement")  
  
 Ponieważ tylko <xref:System.Windows.UIElement> typy mają elementów równorzędnych, a wizualizacje są <xref:System.Windows.UIElement> typów, typowe nadrzędny nie istnieje w drzewa automatyzacji interfejsu użytkownika dla <xref:System.Windows.UIElement> typów. Automatyzacja interfejsu użytkownika oczekuje elementu równorzędnego z jednym elementem głównym, z poziomu aplikacji; w związku z tym, .NET Framework tworzy <xref:System.Windows.Automation.Peers.GenericRootAutomationPeer> dla <xref:System.Windows.Interop.HwndSource> służących jako elementu równorzędnego z jednym elementem głównym partnerom nadrzędnego dwóch <xref:System.Windows.UIElement> typów.  
  
 Zazwyczaj jest głównym elementu równorzędnego <xref:System.Windows.Automation.Peers.WindowAutomationPeer>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GenericRootAutomationPeer (System.Windows.UIElement owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.UIElement owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Peers.GenericRootAutomationPeer.#ctor(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (owner As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GenericRootAutomationPeer(System::Windows::UIElement ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Windows.Automation.Peers.GenericRootAutomationPeer : System.Windows.UIElement -&gt; System.Windows.Automation.Peers.GenericRootAutomationPeer" Usage="new System.Windows.Automation.Peers.GenericRootAutomationPeer owner" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="owner"><see cref="T:System.Windows.UIElement" /> Skojarzony z tym <see cref="T:System.Windows.Automation.Peers.GenericRootAutomationPeer" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Automation.Peers.GenericRootAutomationPeer" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAutomationControlTypeCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationControlType GetAutomationControlTypeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Automation.Peers.AutomationControlType GetAutomationControlTypeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Peers.GenericRootAutomationPeer.GetAutomationControlTypeCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAutomationControlTypeCore () As AutomationControlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationControlType GetAutomationControlTypeCore();" />
      <MemberSignature Language="F#" Value="override this.GetAutomationControlTypeCore : unit -&gt; System.Windows.Automation.Peers.AutomationControlType" Usage="genericRootAutomationPeer.GetAutomationControlTypeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationControlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ kontrolki dla <see cref="T:System.Windows.UIElement" /> skojarzony z tym <see cref="T:System.Windows.Automation.Peers.GenericRootAutomationPeer" />. Ta metoda jest wywoływana <see cref="M:System.Windows.Automation.Peers.AutomationPeer.GetAutomationControlType" />.</summary>
        <returns><see cref="F:System.Windows.Automation.Peers.AutomationControlType.Pane" /> Wartość wyliczenia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangleCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Rect GetBoundingRectangleCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Rect GetBoundingRectangleCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Peers.GenericRootAutomationPeer.GetBoundingRectangleCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetBoundingRectangleCore () As Rect" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Rect GetBoundingRectangleCore();" />
      <MemberSignature Language="F#" Value="override this.GetBoundingRectangleCore : unit -&gt; System.Windows.Rect" Usage="genericRootAutomationPeer.GetBoundingRectangleCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Rect" /> reprezentujący prostokąt otaczający <see cref="T:System.Windows.UIElement" /> skojarzony z tym <see cref="T:System.Windows.Automation.Peers.GenericRootAutomationPeer" />. Ta metoda jest wywoływana <see cref="M:System.Windows.Automation.Peers.AutomationPeer.GetBoundingRectangle" />.</summary>
        <returns>Prostokąt otaczający.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetClassNameCore">
      <MemberSignature Language="C#" Value="protected override string GetClassNameCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string GetClassNameCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Peers.GenericRootAutomationPeer.GetClassNameCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetClassNameCore () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::String ^ GetClassNameCore();" />
      <MemberSignature Language="F#" Value="override this.GetClassNameCore : unit -&gt; string" Usage="genericRootAutomationPeer.GetClassNameCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera nazwę <see cref="T:System.Windows.UIElement" /> skojarzony z tym <see cref="T:System.Windows.Automation.Peers.GenericRootAutomationPeer" />. Ta metoda jest wywoływana <see cref="M:System.Windows.Automation.Peers.AutomationPeer.GetClassName" />.</summary>
        <returns>Ciąg, który zawiera "W okienku".</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNameCore">
      <MemberSignature Language="C#" Value="protected override string GetNameCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string GetNameCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Peers.GenericRootAutomationPeer.GetNameCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetNameCore () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::String ^ GetNameCore();" />
      <MemberSignature Language="F#" Value="override this.GetNameCore : unit -&gt; string" Usage="genericRootAutomationPeer.GetNameCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera tekst etykiety z <see cref="T:System.Windows.UIElement" /> skojarzony z tym <see cref="T:System.Windows.Automation.Peers.GenericRootAutomationPeer" />. Ta metoda jest wywoływana <see cref="M:System.Windows.Automation.Peers.AutomationPeer.GetName" />.</summary>
        <returns>Ciąg, który zawiera etykietę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tak, jakby był to ciąg tekstowy, używanego przez użytkowników do formantu, który odnosi się do wyjaśnienia można traktować właściwości name. Należy upewnić się, że masz tekstowa reprezentacja dla wszystkich kontrolek w [!INCLUDE[TLA#tla_gui](~/includes/tlasharptla-gui-md.md)] tak, aby można programowane odwoływanie się do kontrolki, w sposób zlokalizowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="IContextManager" FullName="System.ServiceModel.Channels.IContextManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a5d5ce43f3c3e70741b8908cac9117a9e955ba75" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36422154" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IContextManager" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IContextManager" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IContextManager" />
  <TypeSignature Language="VB.NET" Value="Public Interface IContextManager" />
  <TypeSignature Language="C++ CLI" Value="public interface class IContextManager" />
  <TypeSignature Language="F#" Value="type IContextManager = interface" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje interfejs, który umożliwia pobieranie i ustawianie kontekstu w kanale.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla kanałów używające <xref:System.ServiceModel.WSHttpContextBinding> z <xref:System.ServiceModel.SessionMode.NotAllowed> wartość zestawu, nie można pobrać kontekstu na kliencie przy użyciu <xref:System.ServiceModel.Channels.IContextManager> ponieważ nowy kanał, który ustanawia sesję jest tworzony za każdym razem <xref:System.ServiceModel.Channels.IChannelFactory.GetProperty%2A> jest wywoływana w celu wymuszenia <xref:System.ServiceModel.SessionMode.NotAllowed> Semantyka w kanale. Oznacza to, że nawet, jeśli kontekst poprawnie propagowane w takim przypadku do klienta, nie można przywrócić za pomocą <xref:System.ServiceModel.Channels.IContextManager>. Nadal można pobierać za pomocą <xref:System.ServiceModel.Channels.ContextMessageProperty> jak pokazano w poniższym kodzie.  
  
```csharp  
using (new OperationContextScope((IContextChannel)channel))  
{  
    channel.MyChannel("Test");  
    ContextMessageProperty context;  
    if (ContextMessageProperty.TryGet(OperationContext.Current.IncomingMessageProperties, out context))  
    {  
        Console.WriteLine(context.Count);  
    }  
}  
  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IContextManager.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.ServiceModel.Channels.IContextManager.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy włączono zarządzanie kontekstem.</summary>
        <value>
          <see langword="true" /> Jeśli kontekst jest włączone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po włączeniu zarządzania kontekstem kanału kontekstu buforuje kontekstu w okresie użytkowania. Kontekst można pobrać z kanału za pośrednictwem `IContextManager` właściwość kanału przez wywołanie metody <xref:System.ServiceModel.Channels.IContextManager.GetContext%2A> dla niego metodę. Kanał również może być wstępnie zainicjowana z kontekstem przed otwierany przez wywołanie metody <xref:System.ServiceModel.Channels.IContextManager.SetContext%2A> metody dla właściwości kanału. Gdy kanał jest inicjowany z kontekstu nie może być resetowany.  
  
 Invariants w tym trybie są następujące:  
  
-   Wszelkie wywołanie <xref:System.ServiceModel.Channels.IContextManager.SetContext%2A> zgłasza wyjątek, po otwarciu kanału `InvalidOperationException`.  
  
-   Wszelkie próbę wysłania kontekstu za pomocą `ContextMessageProperty` w komunikacie wychodzącym zgłasza `InvalidOperationException`.  
  
-   Jeśli wiadomość zostanie odebrana z serwera z kontekstem, gdy kanał został już zainicjowany z kontekstem `ProtocolException` jest generowany. Zauważ, że można wystąpi początkowej kontekstu z serwera po otwarciu kanału bez jawnego ustawiania kontekstu.  
  
-   `ContextMessageProperty` Na wiadomości przychodzącej jest zawsze `null`.  
  
 Jeśli zarządzanie kontekstem nie jest włączona, kanał kontekstu nie zarządza kontekstu. Odpowiedzialność aplikacji do pobrania, zarządzania i zastosować kontekstu za pomocą `ContextMessageProperty`. Próby wywołania <xref:System.ServiceModel.Channels.IContextManager.GetContext%2A> lub <xref:System.ServiceModel.Channels.IContextManager.SetContext%2A> przy użyciu za pośrednictwem `IContextManager` kanału powoduje właściwości `InvalidOperationException`.  
  
 Wszystkie pliki cookie HTTP, z wyjątkiem kontekstu HTTP plików cookie, są obsługiwane na poziomie kanału. Pliki cookie HTTP kontekstu są zarządzane na poziomie aplikacji. Może to mieć nieoczekiwane problemy podczas kanały są udostępniane, aby komunikował się z różnymi wystąpieniami objęci <xref:System.ServiceModel.Channels.ContextMessageProperty>. W poniższej tabeli przedstawiono wpływ plików cookie protokołu HTTP podczas <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> jest ustawiona jako `true` lub `false`.  
  
|Powiązanie|Wartość IContextManager.Enabled|Zakres pliku Cookie HTTP kontekstu|Zakres pliki cookie innych HTTP|  
|-------------|-----------------------------------|-------------------------------|------------------------------|  
|BasicHttpBinding|n/d|ChannelFactory|ChannelFactory|  
|BasicHttpContextBinding|true|Kanał|Kanał|  
|BasicHttpContextBinding|false|Dla każdego komunikatu (jawnie zarządzane przez aplikację)|Kanał|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IContextManager.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GetContext();" />
      <MemberSignature Language="F#" Value="abstract member GetContext : unit -&gt; System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="iContextManager.GetContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kontekst.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IDictionary`2" /> Par klucz/wartość z przestrzeni nazw i nazwę kontekstu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przedstawia sposób kontekstu można uzyskać z wystąpienia typu serwera proxy na komputerze klienckim.  
  
```  
IDictionary<string, string> context;  
CalculatorProxy proxy;  
IContextManager cm = proxy.InnerChannel.GetProperty<IContextManager>();  
if (cm != null)  
    context = cm.GetContext();  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetContext">
      <MemberSignature Language="C#" Value="public void SetContext (System.Collections.Generic.IDictionary&lt;string,string&gt; context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContext(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IContextManager.SetContext(System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetContext (context As IDictionary(Of String, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetContext(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ context);" />
      <MemberSignature Language="F#" Value="abstract member SetContext : System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; unit" Usage="iContextManager.SetContext context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Collections.Generic.IDictionary`2" /> Par klucz/wartość z przestrzeni nazw i nazwę kontekstu, która jest ustawiona.</param>
        <summary>Ustawia kontekst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przedstawia sposób kontekstu można ustawić na kliencie.  
  
```  
IDictionary<string, string> context;  
CalculatorProxy proxy;  
IContextManager cm = proxy.InnerChannel.GetProperty<IContextManager>();  
if (cm != null)  
    cm.SetContext(context);  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
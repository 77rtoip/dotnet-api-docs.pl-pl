<Type Name="IReplyChannel" FullName="System.ServiceModel.Channels.IReplyChannel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="59a62b5af42b1a06346ccd412414096f0908aa4f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30572536" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IReplyChannel : System.ServiceModel.Channels.IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IReplyChannel implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IReplyChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IReplyChannel&#xA;Implements IChannel" />
  <TypeSignature Language="C++ CLI" Value="public interface class IReplyChannel : System::ServiceModel::Channels::IChannel" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Definiuje interfejs, który kanał musi implementować się po stronie odbiorczej powiadomienia "żądanie-odpowiedź" między punktami końcowymi obsługi wiadomości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IReplyChannel> Interfejs zawiera synchroniczne i asynchroniczne wariantów <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> metody zwracany <xref:System.ServiceModel.Channels.RequestContext> można skonstruować odpowiedzi na żądania odebrane.  
  
 Umowa zawiera synchroniczne i asynchroniczne wariantów Receive, spróbuj odbierania i oczekiwania na wiadomość funkcje.  
  
 <xref:System.ServiceModel.Channels.IReplyChannel> Niekoniecznie nie jest powiązany z jednego nadawcy. Inne kanały i interfejsy kanału zapewniają korelacji między nadawcą i kanał odpowiedzi, ale podstawowego kontraktu sprawia, że ma takie ograniczenia.  
  
 Model polegający na ściąganiu jest używany z <xref:System.ServiceModel.Channels.IReplyChannel> do odbierania wiadomości. Ten model składa się z telefoniczną <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> (lub jeden z jej wariantów), a następnie oczekiwanie na odebranie wiadomości.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginReceiveRequest">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną do obierania żądań od dostępne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveRequest (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceiveRequest(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveRequest (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveRequest(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który otrzymuje powiadomienie o asynchroniczną odbierania, że operacja żądania zostało ukończone.</param>
        <param name="state">Obiekt określony przez aplikację, zawierający informacje o stanie skojarzone z asynchronicznego odbioru operacji żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną do obierania żądań dostępne z domyślny limit czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się asynchronicznego odbioru żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29> Metoda implementuje wzorzec standardowy do wywoływania <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> asynchronicznie. Domyślny limit czasu wynosi 1 min. Jeśli limit czasu odbioru jest ustawiona na powiązanie użyty do skonfigurowania połączenia, ta wartość jest używana. Użyj <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Jeśli chcesz określić jawne limit czasu wywołania, który zastępuje te inne wartości.  
  
 Jeśli odebrany komunikat żądania jest większy, że maksymalna komunikatu rozmiar dozwolony przez powiązanie jest używany, <xref:System.ServiceModel.QuotaExceededException> jest generowany. Maksymalny rozmiar wiadomości jest ustawiana przez <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> właściwości. Wartość domyślna to 65 536 bajtów.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceiveRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu oczekiwania na odebranie dostępne żądania.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który otrzymuje powiadomienie o asynchroniczną odbierania, że operacja żądania zostało ukończone.</param>
        <param name="state">Obiekt określony przez aplikację, zawierający informacje o stanie skojarzone z asynchronicznego odbioru operacji żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną do obierania żądań dostępne z określonego limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się asynchronicznego odbioru żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Metoda implementuje wzorzec standardowy do wywoływania <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29> asynchronicznie. Limit czasu ustawiony dla tej metody przesłania limit czasu odbioru ustawiony dla powiązania używanego w taki sposób, aby skonfigurować połączenie.  
  
 Jeśli odebrany komunikat żądania jest większy, że maksymalna komunikatu rozmiar dozwolony przez powiązanie jest używany, <xref:System.ServiceModel.QuotaExceededException> jest generowany. Maksymalny rozmiar wiadomości jest ustawiana przez <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> właściwości. Wartość domyślna to 65 536 bajtów.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTryReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTryReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginTryReceiveRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTryReceiveRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma zostać ukończona przed limit czasu i zwracanie operacji żądania odbierania <see langword="false" />.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który otrzymuje powiadomienie o asynchroniczną odbierania, że operacja żądania zostało ukończone.</param>
        <param name="state">Obiekt określony przez aplikację, zawierający informacje o stanie skojarzone z asynchronicznego odbioru operacji żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną komunikat żądania, który ma określony limit czasu i skojarzonych z nim obiekt stanu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja żądania asynchronicznego odbioru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie asynchronicznego <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> metody, gdy będziesz potrzebować przetwarzania aplikacji, aby kontynuować bez oczekiwania. Użyj jednej z synchronicznego <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> metod, gdy nie jest możliwa do bieżącego wątku zablokowanie, gdy w odpowiedzi na komunikat żądania lub dopóki nie zostanie przekroczony limit czasu.  
  
 Ta metoda otrzymuje powiadomienie, poprzez wywołanie zwrotne, tożsamości programu obsługi zdarzeń dla tej operacji. Operacja nie jest pełną, dopóki komunikat o stanie się dostępny w kanale albo występuje limit czasu.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zwraca operacji <see langword="false" /> Jeśli określonego <paramref name="timeout" /> został przekroczony.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWaitForRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu oczekiwania na odebranie dostępne żądania.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który otrzymuje powiadomienie o asynchroniczną odbierania, że operacja żądania zostało ukończone.</param>
        <param name="state">Obiekt określony przez aplikację, zawierający informacje o stanie skojarzone z asynchronicznego odbioru operacji żądania.</param>
        <summary>Rozpoczyna operację żądania asynchronicznego, która ma określony limit czasu i skojarzonych z nim obiekt stanu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja asynchroniczna oczekiwania na odebranie komunikat żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj synchroniczne <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> metody, gdy nie jest możliwa do bieżącego wątku być blokowane podczas oczekiwania na komunikat żądania w kolejce. Wątek jest zablokowana w górę do określonego `timeout`.  
  
 Ta metoda otrzymuje powiadomienie, poprzez wywołanie zwrotne, tożsamości programu obsługi zdarzeń dla tej operacji. Operacja nie jest pełną, aż do komunikatu żądania staje się dostępna w kanale lub występuje limit czasu.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#10)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zwraca operacji <see langword="false" /> Jeśli określonego <paramref name="timeout" /> został przekroczony.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext EndReceiveRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext EndReceiveRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveRequest (result As IAsyncResult) As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ EndReceiveRequest(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwrócony przez wywołanie do <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> metody.</param>
        <summary>Kończy operację asynchroniczną do obierania żądań od dostępne.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> Użyty do utworzenia odpowiedzi na żądanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli odebrany komunikat żądania jest większy, że maksymalna komunikatu rozmiar dozwolony przez powiązanie jest używany, <xref:System.ServiceModel.QuotaExceededException> jest generowany. Maksymalny rozmiar wiadomości jest ustawiana przez <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> właściwości. Wartość domyślna to 65 536 bajtów.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Operacja powinien zgłosić <see cref="T:System.TimeoutException" /> Jeśli określonego <paramref name="timeout" /> został przekroczony przed zakończeniem operacji.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndTryReceiveRequest">
      <MemberSignature Language="C#" Value="public bool EndTryReceiveRequest (IAsyncResult result, out System.ServiceModel.Channels.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndTryReceiveRequest(class System.IAsyncResult result, [out] class System.ServiceModel.Channels.RequestContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndTryReceiveRequest (result As IAsyncResult, ByRef context As RequestContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndTryReceiveRequest(IAsyncResult ^ result, [Runtime::InteropServices::Out] System::ServiceModel::Channels::RequestContext ^ % context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="context" Type="System.ServiceModel.Channels.RequestContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwrócony przez wywołanie do <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" /> metody.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> Odebrane.</param>
        <summary>Kończy operację asynchroniczną określony komunikat żądania.</summary>
        <returns>
          <see langword="true" /> Jeśli komunikat żądania zostanie odebrana przed określonym interwale upłynie czas; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForRequest">
      <MemberSignature Language="C#" Value="public bool EndWaitForRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndWaitForRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWaitForRequest (result As IAsyncResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndWaitForRequest(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> , Które identyfikują <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" /> operację, aby zakończyć i z którego można pobrać wyniku.</param>
        <summary>Kończy operację określonego komunikatu oczekiwania dla żądania asynchronicznego.</summary>
        <returns>
          <see langword="true" /> Jeśli żądanie zostanie odebrane przed określonym interwale upłynie czas; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress LocalAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress LocalAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IReplyChannel.LocalAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ LocalAddress { System::ServiceModel::EndpointAddress ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres, na którym ten kanał odpowiedzi odbiera wiadomości.</summary>
        <value>
          <see cref="T:System.ServiceModel.EndpointAddress" /> Na którym ten kanał odpowiedzi odbiera wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej właściwości:  
  
 [!code-csharp[S_UE_MessageInterceptor#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveRequest">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kontekst żądania otrzymane, jeśli jest dostępny</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext ReceiveRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext ReceiveRequest() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveRequest () As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ ReceiveRequest();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kontekst żądania otrzymane, jeśli jest dostępny. Kontekst nie jest dostępna, czeka, dopóki nie jest dostępna.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> Użyty do utworzenia odpowiedzi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.RequestContext> hermetyzuje komunikat żądania i mechanizm odpowiedzi na tę wiadomość.  
  
 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> może zostać wywołana wiele razy lub jednocześnie. Tylko jeden <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> na Odebrano żądanie ukończenia wywołania.  
  
 Jeśli odebrany komunikat żądania jest większy, że maksymalna komunikatu rozmiar dozwolony przez powiązanie jest używany, <xref:System.ServiceModel.QuotaExceededException> jest generowany. Maksymalny rozmiar wiadomości jest ustawiana przez <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> właściwości. Wartość domyślna to 65 536 bajtów.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext ReceiveRequest (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext ReceiveRequest(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveRequest (timeout As TimeSpan) As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ ReceiveRequest(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma przed limit czasu i zwracanie wykonaj odbieranie operacji żądania <see langword="false" />.</param>
        <summary>Zwraca kontekst żądania otrzymane, jeśli jest dostępny. Kontekst nie jest dostępna, czeka, dopóki nie jest dostępna.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> Użyty do utworzenia odpowiedzi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.RequestContext> hermetyzuje komunikat żądania i mechanizm odpowiedzi na tę wiadomość.  
  
 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> może zostać wywołana wiele razy lub jednocześnie. Tylko jeden <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> na Odebrano żądanie ukończenia wywołania.  
  
 Jeśli odebrany komunikat żądania jest większy, że maksymalna komunikatu rozmiar dozwolony przez powiązanie jest używany, <xref:System.ServiceModel.QuotaExceededException> jest generowany. Maksymalny rozmiar wiadomości jest ustawiana przez <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> właściwości. Wartość domyślna to 65 536 bajtów.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveRequest">
      <MemberSignature Language="C#" Value="public bool TryReceiveRequest (TimeSpan timeout, out System.ServiceModel.Channels.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveRequest(valuetype System.TimeSpan timeout, [out] class System.ServiceModel.Channels.RequestContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveRequest (timeout As TimeSpan, ByRef context As RequestContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReceiveRequest(TimeSpan timeout, [Runtime::InteropServices::Out] System::ServiceModel::Channels::RequestContext ^ % context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="context" Type="System.ServiceModel.Channels.RequestContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma przed limit czasu i zwracanie wykonaj odbieranie operacji żądania <see langword="false" />.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> Odebrane.</param>
        <summary>Zwraca wartość wskazującą, czy przed o określony interwał czasu upłynie zostanie odebrane żądanie.</summary>
        <returns>
          <see langword="true" /> Jeśli komunikat żądania zostanie odebrana przed określonym interwale upłynie czas; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na komunikat żądania w kolejce. Wątek jest zablokowana w górę do określonego `timeout`. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez oczekiwania na użycie asynchronicznego <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> metody.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zwraca operacji <see langword="false" /> Jeśli określonego <paramref name="timeout" /> został przekroczony.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WaitForRequest">
      <MemberSignature Language="C#" Value="public bool WaitForRequest (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitForRequest(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForRequest (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForRequest(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określa, jak długo żądanie operacji musi zostać ukończona przed limit czasu i zwracanie <see langword="false" />.</param>
        <summary>Zwraca wartość wskazującą, czy przed o określony interwał czasu upłynie odebraniu komunikatu żądania.</summary>
        <returns>
          <see langword="true" /> Jeśli żądanie zostanie odebrane przed określonym interwale upłynie czas; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> nie powoduje komunikat żądania trwa odebranych lub przetwarzane w dowolny sposób.  
  
 <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Istnieje metoda przede wszystkim dotyczące transakcyjne scenariusze, w których użytkownik chce odbierać wiadomości przy użyciu transakcji. Używając po prostu <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> zwykle w tym celu użytkownik musi utworzyć transakcji, a następnie wywołać <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> i nadzieję, że komunikat dociera przed transakcji limitu czasu, który może nie być możliwe.  
  
 Zamiast tego użytkownik może wywołać <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> i określ limit czasu (nawet nieskończone), a następnie po nadejściu wiadomości mogą otwierać transakcji, wywołaj <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> i mieć pewność, że komunikat może uzyskać przed wygaśnięciem transakcji.  
  
 Użyj <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Wątek jest zablokowana w górę do określonego `timeout`. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez oczekiwania na użycie asynchronicznego <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> metody.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób implementowania tej metody:  
  
 [!code-csharp[S_UE_MessageInterceptor#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#9)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zwraca operacji <see langword="false" /> Jeśli określonego <paramref name="timeout" /> został przekroczony.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
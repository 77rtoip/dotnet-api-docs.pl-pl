<Type Name="IReplyChannel" FullName="System.ServiceModel.Channels.IReplyChannel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="160c6657f10ed6ec444d5721a21779d9a3ea7b6b" />
    <Meta Name="ms.sourcegitcommit" Value="1afcc8f9041ff3093fd13fb0afda92ac188878a9" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="09/06/2018" />
    <Meta Name="ms.locfileid" Value="43850544" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IReplyChannel : System.ServiceModel.Channels.IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IReplyChannel implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IReplyChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IReplyChannel&#xA;Implements IChannel" />
  <TypeSignature Language="C++ CLI" Value="public interface class IReplyChannel : System::ServiceModel::Channels::IChannel" />
  <TypeSignature Language="F#" Value="type IReplyChannel = interface&#xA;    interface IChannel&#xA;    interface ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Definiuje interfejs, który kanał muszą implementować się po stronie odbierania powiadomienia "żądanie-odpowiedź" między punktami końcowymi przesyłania komunikatów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-interface-note](~/includes/untrusted-data-interface-note.md)]

 <xref:System.ServiceModel.Channels.IReplyChannel> Interfejs zawiera synchroniczne i asynchroniczne warianty <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> zwrotu metody <xref:System.ServiceModel.Channels.RequestContext> można skonstruować odpowiedzi odebranych żądań.  
  
 Umowa zawiera synchroniczne i asynchroniczne warianty receive, spróbuj odbierania i oczekiwania na komunikat funkcje.  
  
 <xref:System.ServiceModel.Channels.IReplyChannel> Niekoniecznie nie jest powiązany z jednego nadawcy. Inne kanały i interfejsy kanału zapewniają korelacji między nadawcą i kanału odpowiedzi, ale podstawowego kontraktu sprawia, że nie ma tego ograniczenia.  
  
 Model ściągania jest używana z <xref:System.ServiceModel.Channels.IReplyChannel> do odbierania komunikatów. Ten model, który składa się z wywołaniem <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> (lub jeden z jej wariantów) i następnie oczekiwanie na dostarczenie wiadomości.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginReceiveRequest">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną do odbierania żądań dostępne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveRequest (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceiveRequest(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveRequest (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveRequest(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceiveRequest : AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginReceiveRequest (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o asynchroniczną odbierania, że kończy operację żądania.</param>
        <param name="state">Obiekt określony przez aplikację, która zawiera informacje o stanie związane z asynchronicznego odbioru operacji żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną do odbierania żądanie dostępne z domyślny limit czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się asynchronicznego odbioru żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29> Metoda implementuje standardowego wzorca do wywoływania <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> asynchronicznie. Domyślny limit czasu wynosi 1 minutę. Jeśli limit czasu odbioru jest ustawiona na powiązanie używane do skonfigurowania połączenia, ta wartość jest używana. Użyj <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Jeśli chcesz określić jawnego limitu czasu za pomocą wywołania, która zastępuje te inne wartości.  
  
 Jeśli Odebrano komunikat żądania jest większy, że maksymalna komunikatu rozmiar dozwolony przez powiązanie, jest używane, <xref:System.ServiceModel.QuotaExceededException> zgłaszany. Maksymalny rozmiar wiadomości jest ustawiana przez <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> właściwości. Wartość domyślna to 65536 bajtów.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceiveRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceiveRequest : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginReceiveRequest (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu oczekiwania na odbiór dostępne żądania.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o asynchroniczną odbierania, że kończy operację żądania.</param>
        <param name="state">Obiekt określony przez aplikację, która zawiera informacje o stanie związane z asynchronicznego odbioru operacji żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną do odbierania żądanie dostępne z określonego limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się asynchronicznego odbioru żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Metoda implementuje standardowego wzorca do wywoływania <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29> asynchronicznie. Limit czasu ustawiony w tej metodzie przesłania limit czasu odbioru ustawiona na powiązanie, które służy do konfigurowania połączenia.  
  
 Jeśli Odebrano komunikat żądania jest większy, że maksymalna komunikatu rozmiar dozwolony przez powiązanie, jest używane, <xref:System.ServiceModel.QuotaExceededException> zgłaszany. Maksymalny rozmiar wiadomości jest ustawiana przez <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> właściwości. Wartość domyślna to 65536 bajtów.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTryReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTryReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginTryReceiveRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTryReceiveRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginTryReceiveRequest : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginTryReceiveRequest (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, ile operacji żądania odbioru musi ukończyć przed wyczerpaniem i zwracanie <see langword="false" />.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o asynchroniczną odbierania, że kończy operację żądania.</param>
        <param name="state">Obiekt określony przez aplikację, która zawiera informacje o stanie związane z asynchronicznego odbioru operacji żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną komunikat żądania, która ma określony limit czasu i obiektu stanu skojarzonych z nim.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja żądania asynchronicznego odbioru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie asynchronicznego <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> metody, gdy będziesz potrzebować przetwarzania aplikacji, aby kontynuować bez zbędnego oczekiwania. Użyj jednej z synchronicznej <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> metody, gdy jest dopuszczalny dla bieżącego wątku zablokowana, gdy zostanie wysłana odpowiedź na komunikat żądania lub dopóki nie zostanie przekroczony limit czasu.  
  
 Ta metoda otrzymuje powiadomienia, za pośrednictwem wywołania zwrotnego, tożsamość programu obsługi zdarzeń dla tej operacji. Operacja nie została zakończona, aż do komunikat o stanie się dostępny w kanale lub występuje limit czasu.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Operacja zwraca <see langword="false" /> Jeśli określony <paramref name="timeout" /> zostanie przekroczony.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWaitForRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWaitForRequest : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginWaitForRequest (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu oczekiwania na odbiór dostępne żądania.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o asynchroniczną odbierania, że kończy operację żądania.</param>
        <param name="state">Obiekt określony przez aplikację, która zawiera informacje o stanie związane z asynchronicznego odbioru operacji żądania.</param>
        <summary>Rozpoczyna operację żądania asynchronicznego, która ma określony limit czasu i obiektu stanu skojarzonych z nim.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja asynchroniczna oczekiwania na komunikat żądania zostanie dostarczona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj synchronicznej <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> metody, gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat żądania w kolejce. Wątek jest blokowany w górę do określonego `timeout`.  
  
 Ta metoda otrzymuje powiadomienia, za pośrednictwem wywołania zwrotnego, tożsamość programu obsługi zdarzeń dla tej operacji. Operacja nie została zakończona, aż do komunikatu żądania staje się dostępna w kanale lub występuje limit czasu.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#10)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Operacja zwraca <see langword="false" /> Jeśli określony <paramref name="timeout" /> zostanie przekroczony.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext EndReceiveRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext EndReceiveRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveRequest (result As IAsyncResult) As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ EndReceiveRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReceiveRequest : IAsyncResult -&gt; System.ServiceModel.Channels.RequestContext" Usage="iReplyChannel.EndReceiveRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwracany przez wywołanie <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> metody.</param>
        <summary>Kończy operację asynchroniczną do odbierania żądań dostępne.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> Użytego do stworzenia odpowiedź na żądanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli Odebrano komunikat żądania jest większy, że maksymalna komunikatu rozmiar dozwolony przez powiązanie, jest używane, <xref:System.ServiceModel.QuotaExceededException> zgłaszany. Maksymalny rozmiar wiadomości jest ustawiana przez <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> właściwości. Wartość domyślna to 65536 bajtów.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Operacja powinno zgłosić <see cref="T:System.TimeoutException" /> Jeśli określony <paramref name="timeout" /> zostanie przekroczony, zanim operacja została wykonana.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndTryReceiveRequest">
      <MemberSignature Language="C#" Value="public bool EndTryReceiveRequest (IAsyncResult result, out System.ServiceModel.Channels.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndTryReceiveRequest(class System.IAsyncResult result, [out] class System.ServiceModel.Channels.RequestContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndTryReceiveRequest (result As IAsyncResult, ByRef context As RequestContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndTryReceiveRequest(IAsyncResult ^ result, [Runtime::InteropServices::Out] System::ServiceModel::Channels::RequestContext ^ % context);" />
      <MemberSignature Language="F#" Value="abstract member EndTryReceiveRequest : IAsyncResult *  -&gt; bool" Usage="iReplyChannel.EndTryReceiveRequest (result, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="context" Type="System.ServiceModel.Channels.RequestContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwracany przez wywołanie <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" /> metody.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> Odebrane.</param>
        <summary>Wykonuje określoną operacją asynchroniczną w celu odebrania komunikatu żądania.</summary>
        <returns>
          <see langword="true" /> odebranie komunikatu żądania przed określonym interwale czasu upłynie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForRequest">
      <MemberSignature Language="C#" Value="public bool EndWaitForRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndWaitForRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWaitForRequest (result As IAsyncResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndWaitForRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWaitForRequest : IAsyncResult -&gt; bool" Usage="iReplyChannel.EndWaitForRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Określający <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" /> operację, aby zakończyć z którego mają zostać pobrane wynik końcowy.</param>
        <summary>Kończy operację określony komunikat oczekiwania dla żądania asynchronicznego.</summary>
        <returns>
          <see langword="true" /> Jeśli żądanie zostanie odebrane przed określonym interwale czasu upłynie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress LocalAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress LocalAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IReplyChannel.LocalAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ LocalAddress { System::ServiceModel::EndpointAddress ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalAddress : System.ServiceModel.EndpointAddress" Usage="System.ServiceModel.Channels.IReplyChannel.LocalAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres, na którym tym kanale odpowiedzi odbiera komunikaty.</summary>
        <value>
          <see cref="T:System.ServiceModel.EndpointAddress" /> Na którym tym kanale odpowiedzi odbiera komunikaty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ilustruje sposób implementacji tej właściwości:  
  
 [!code-csharp[S_UE_MessageInterceptor#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveRequest">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kontekst żądania otrzymane, jeśli jest dostępny</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext ReceiveRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext ReceiveRequest() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveRequest () As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ ReceiveRequest();" />
      <MemberSignature Language="F#" Value="abstract member ReceiveRequest : unit -&gt; System.ServiceModel.Channels.RequestContext" Usage="iReplyChannel.ReceiveRequest " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kontekst żądania otrzymane, jeśli jest dostępny. Jeśli kontekst jest niedostępny, czeka, aż jest dostępna.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> Użytego do stworzenia odpowiedzi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.RequestContext> hermetyzuje komunikatu żądania i mechanizm do odpowiadania na tę wiadomość.  
  
 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> może być wywoływana wiele razy lub jednocześnie. Tylko jeden <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> ukończenia wywołania na Odebrano żądanie.  
  
 Jeśli Odebrano komunikat żądania jest większy, że maksymalna komunikatu rozmiar dozwolony przez powiązanie, jest używane, <xref:System.ServiceModel.QuotaExceededException> zgłaszany. Maksymalny rozmiar wiadomości jest ustawiana przez <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> właściwości. Wartość domyślna to 65536 bajtów.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext ReceiveRequest (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext ReceiveRequest(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveRequest (timeout As TimeSpan) As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ ReceiveRequest(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member ReceiveRequest : TimeSpan -&gt; System.ServiceModel.Channels.RequestContext" Usage="iReplyChannel.ReceiveRequest timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo odbieranie operację żądania musi ukończyć przed wyczerpaniem i zwracanie <see langword="false" />.</param>
        <summary>Zwraca kontekst żądania otrzymane, jeśli jest dostępny. Jeśli kontekst jest niedostępny, czeka, aż jest dostępna.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> Użytego do stworzenia odpowiedzi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.RequestContext> hermetyzuje komunikatu żądania i mechanizm do odpowiadania na tę wiadomość.  
  
 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> może być wywoływana wiele razy lub jednocześnie. Tylko jeden <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> ukończenia wywołania na Odebrano żądanie.  
  
 Jeśli Odebrano komunikat żądania jest większy, że maksymalna komunikatu rozmiar dozwolony przez powiązanie, jest używane, <xref:System.ServiceModel.QuotaExceededException> zgłaszany. Maksymalny rozmiar wiadomości jest ustawiana przez <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> właściwości. Wartość domyślna to 65536 bajtów.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveRequest">
      <MemberSignature Language="C#" Value="public bool TryReceiveRequest (TimeSpan timeout, out System.ServiceModel.Channels.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveRequest(valuetype System.TimeSpan timeout, [out] class System.ServiceModel.Channels.RequestContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveRequest (timeout As TimeSpan, ByRef context As RequestContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReceiveRequest(TimeSpan timeout, [Runtime::InteropServices::Out] System::ServiceModel::Channels::RequestContext ^ % context);" />
      <MemberSignature Language="F#" Value="abstract member TryReceiveRequest : TimeSpan *  -&gt; bool" Usage="iReplyChannel.TryReceiveRequest (timeout, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="context" Type="System.ServiceModel.Channels.RequestContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo odbieranie operację żądania musi ukończyć przed wyczerpaniem i zwracanie <see langword="false" />.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> Odebrane.</param>
        <summary>Zwraca wartość wskazującą, czy przed o określony interwał czasu upłynie zostanie odebrane żądanie.</summary>
        <returns>
          <see langword="true" /> odebranie komunikatu żądania przed określonym interwale czasu upłynie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat żądania w kolejce. Wątek jest blokowany w górę do określonego `timeout`. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez zbędnego oczekiwania, użycie asynchronicznego <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> metody.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Operacja zwraca <see langword="false" /> Jeśli określony <paramref name="timeout" /> zostanie przekroczony.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WaitForRequest">
      <MemberSignature Language="C#" Value="public bool WaitForRequest (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitForRequest(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForRequest (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForRequest(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitForRequest : TimeSpan -&gt; bool" Usage="iReplyChannel.WaitForRequest timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo żądanie operacji musi ukończyć przed wyczerpaniem i zwracanie <see langword="false" />.</param>
        <summary>Zwraca wartość wskazującą, czy przed o określony interwał czasu upłynie odebraniu komunikatu żądania.</summary>
        <returns>
          <see langword="true" /> Jeśli żądanie zostanie odebrane przed określonym interwale czasu upłynie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> nie powoduje trwa komunikatu żądania otrzymane lub przetwarzania w dowolny sposób.  
  
 <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Istnieje metoda głównie dla scenariuszy transakcyjne, gdy użytkownik chce, aby odbierać wiadomości przy użyciu transakcji. Korzystając z właśnie <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> zwykle w tym celu użytkownik musi utworzyć transakcji, a następnie wywołaj <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> i mamy nadzieję, komunikat dociera przed transakcji upłynie limit czasu, który może nie być możliwe.  
  
 Zamiast tego użytkownik może wywołać <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> i określ limit czasu (nawet nieskończona), a następnie po nadejściu wiadomości mogą otwierać transakcji, wywołaj <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> i mieć pewność, że otrzymują wiadomości przed wygaśnięciem transakcji.  
  
 Użyj <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Wątek jest blokowany w górę do określonego `timeout`. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez zbędnego oczekiwania, użycie asynchronicznego <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> metody.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#9)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Operacja zwraca <see langword="false" /> Jeśli określony <paramref name="timeout" /> zostanie przekroczony.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
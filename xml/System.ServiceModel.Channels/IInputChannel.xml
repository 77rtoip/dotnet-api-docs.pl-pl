<Type Name="IInputChannel" FullName="System.ServiceModel.Channels.IInputChannel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="40c8ffa57b4d9f6bcbed9b66bd5abaed8e71f031" /><Meta Name="ms.sourcegitcommit" Value="7461f9e28c2f184bd1596e6f07c25a3f34984516" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/28/2019" /><Meta Name="ms.locfileid" Value="58553765" /></Metadata><TypeSignature Language="C#" Value="public interface IInputChannel : System.ServiceModel.Channels.IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IInputChannel implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IInputChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IInputChannel&#xA;Implements IChannel" />
  <TypeSignature Language="C++ CLI" Value="public interface class IInputChannel : System::ServiceModel::Channels::IChannel" />
  <TypeSignature Language="F#" Value="type IInputChannel = interface&#xA;    interface IChannel&#xA;    interface ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
    <AssemblyVersion>4.5.0.3</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.ICommunicationObject</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Definiuje interfejs, który musi implementować kanał, aby komunikat o błędzie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-interface-note](~/includes/untrusted-data-interface-note.md)]

 <xref:System.ServiceModel.Channels.IInputChannel> Umowa obejmuje synchroniczne i asynchroniczne warianty receive, spróbuj odbierania i oczekiwania na komunikat funkcje.  
  
 Model ściągania jest zwykle używana z <xref:System.ServiceModel.Channels.IInputChannel> do odbierania komunikatów: wywołanie <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (w celu "ściągania" wiadomości z kanału) i poczekaj na nadejściu wiadomości. Wzorzec użycia alternatywnych jest wywołanie <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> lub <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>, a następnie wywołaj <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>. To podejście jest często transakcyjnych użycia, z którego zaczynasz transakcji między wywołaniami do <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> i <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.  
  
 <xref:System.ServiceModel.Channels.IInputChannel> Niekoniecznie nie jest powiązany z jednego nadawcy. Inne kanały i interfejsy kanału może zapewnić korelacja określonych nadawców i <xref:System.ServiceModel.Channels.IInputChannel>, ale podstawowego kontraktu sprawia, że nie ma tego ograniczenia. Wdrożenia można utworzyć nową <xref:System.ServiceModel.Channels.IInputChannel> dla każdego komunikatu lub ponownie użyj tego samego <xref:System.ServiceModel.Channels.IInputChannel> dla wielu komunikatów i nadawcy.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się asynchronicznej operacji odbioru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie asynchronicznego <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> metody, gdy chcesz, aby przetwarzania aplikacji, aby kontynuować bez oczekiwania na żądanie do odbioru. Użyj synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> metody, gdy jest dopuszczalny dla bieżącego wątku do zablokowania otrzymanie komunikatu żądania lub przedział czasu określony przez `timeout` został przekroczony. Operacja asynchroniczna jest dostępne z lub bez jawnego limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceive(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginReceive (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegata, który będą wysyłane powiadomienia o zakończeniu operacji asynchronicznej.</param>
        <param name="state">Obiekt określony przez aplikację, która zawiera informacje o stanie związane z operacją asynchroniczną.</param>
        <summary>Rozpoczyna operację asynchroniczną, aby otrzymać komunikat, który ma obiektu stanu skojarzonych z nim.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Która odwołuje się do odbierania komunikatów asynchronicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie asynchronicznego <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> metody, gdy chcesz, aby przetwarzania aplikacji, aby kontynuować bez oczekiwania na żądanie do odbioru. Użyj synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> metody, gdy jest dopuszczalny dla bieżącego wątku do zablokowania otrzymanie komunikatu żądania lub przedział czasu określony przez `timeout` został przekroczony. Operacja asynchroniczna jest dostępne z lub bez jawnego limitu czasu.  
  
 Ta metoda otrzymuje powiadomienia, za pośrednictwem wywołania zwrotnego, tożsamość programu obsługi zdarzeń dla tej operacji. Operacja nie została zakończona, aż komunikat o stanie się dostępny w kanale.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#15](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceive : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginReceive (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Która określa czas oczekiwania na udostępnienie wiadomości.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegata, który będą wysyłane powiadomienia o zakończeniu operacji asynchronicznej.</param>
        <param name="state">Obiekt określony przez aplikację, która zawiera informacje o stanie związane z operacją asynchroniczną.</param>
        <summary>Rozpoczyna operację asynchroniczną do odbierania komunikatów, która ma określony limit czasu i obiektu stanu skojarzonych z nim.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołania asynchronicznych operacji odbioru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie asynchronicznego <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> metody, gdy chcesz, aby przetwarzania aplikacji, aby kontynuować bez oczekiwania na żądanie do odbioru. Użyj synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> metody, gdy jest dopuszczalny dla bieżącego wątku do zablokowania otrzymanie komunikatu żądania lub przedział czasu określony przez `timeout` został przekroczony. Operacja asynchroniczna jest dostępne z lub bez jawnego limitu czasu.  
  
 Operacja nie została zakończona, aż do komunikat o stanie się dostępny w kanale lub występuje limit czasu.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Określony <paramref name="timeout" /> zostanie przekroczony, zanim operacja została wykonana.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Określono limit czasu jest mniejsza niż zero.</exception>
        <block subset="none" type="overrides"><para>Operacja zgłosi <see cref="T:System.TimeoutException" /> Jeśli określony <paramref name="timeout" /> zostanie przekroczony, przed ukończeniem.</para></block>
      </Docs>
    </Member>
    <Member MemberName="BeginTryReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTryReceive (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginTryReceive(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTryReceive (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTryReceive(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginTryReceive : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginTryReceive (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Która określa czas oczekiwania na udostępnienie wiadomości.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegata, który będą wysyłane powiadomienia o zakończeniu operacji asynchronicznej.</param>
        <param name="state">Obiekt określony przez aplikację, która zawiera informacje o stanie związane z operacją asynchroniczną.</param>
        <summary>Rozpoczyna operację asynchroniczną do odbierania komunikatów, która ma określony limit czasu i obiektu stanu skojarzonych z nim.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołania asynchronicznych operacji odbioru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie asynchronicznego <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> metody, gdy chcesz, aby przetwarzania aplikacji, aby kontynuować bez zbędnego oczekiwania. Użyj synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> metody, gdy jest dopuszczalny dla bieżącego wątku zablokowana, gdy zostanie wysłana odpowiedź na komunikat żądania lub dopóki nie zostanie przekroczony limit czasu.  
  
 Operacja nie została zakończona, dopóki nie zostanie przekroczony limit czasu lub komunikat o stanie się dostępny w kanale.  
  
 Jeśli zamierzasz obsługiwać przekroczeń limitu czasu i nie tylko ponownie wygenerować lub zawijania <xref:System.TimeoutException>, a następnie należy wywołać <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> zamiast <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>.  
  
 Jeśli nie ma specjalnie traktują przekroczeń limitu czasu następnie po prostu Wywołaj <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>, w przeciwnym razie utracisz informacje o błędzie.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Określony <paramref name="timeout" /> zostanie przekroczony, zanim operacja została wykonana.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Określono limit czasu jest mniejsza niż zero.</exception>
        <block subset="none" type="overrides"><para>Operacja zwraca <see langword="false" /> z <see cref="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" /> Jeśli określony <paramref name="timeout" /> zostanie przekroczony.</para></block>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForMessage">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForMessage (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWaitForMessage(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForMessage (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForMessage(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWaitForMessage : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginWaitForMessage (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Która określa czas oczekiwania na udostępnienie wiadomości.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegata, który będą wysyłane powiadomienia o zakończeniu operacji asynchronicznej.</param>
        <param name="state">Obiekt określony przez aplikację, która zawiera informacje o stanie związane z operacją asynchroniczną.</param>
        <summary>Rozpoczyna operację asynchroniczną wait-for-a-message-to-arrive, która ma określony limit czasu i obiektu stanu skojarzonych z nim.</summary>
        <returns><see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja asynchroniczna oczekiwania na dostarczenie wiadomości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie asynchronicznego <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> metody, jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez oczekiwania na komunikat do odbierania. Użyj synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> metody, gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Wątek jest blokowany w górę do określonego `timeout`.  
  
 Ta metoda otrzymuje powiadomienia, za pośrednictwem wywołania zwrotnego, tożsamość programu obsługi zdarzeń dla tej operacji. Operacja nie została zakończona, aż do komunikat o stanie się dostępny w kanale lub występuje limit czasu.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#22](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Określony <paramref name="timeout" /> zostanie przekroczony, zanim operacja została wykonana.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Określono limit czasu jest mniejsza niż zero.</exception>
        <block subset="none" type="overrides"><para>Operacja zwraca <see langword="false" /> Jeśli określony <paramref name="timeout" /> zostanie przekroczony, nie wyjątek limitu czasu.</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message EndReceive (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message EndReceive(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ EndReceive(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReceive : IAsyncResult -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" /> Zwrócony przez wywołanie do jednego z <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> metody.</param>
        <summary>Kończy operację asynchroniczną na komunikat o błędzie.</summary>
        <returns><see cref="T:System.ServiceModel.Channels.Message" /> Odebrane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndTryReceive">
      <MemberSignature Language="C#" Value="public bool EndTryReceive (IAsyncResult result, out System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndTryReceive(class System.IAsyncResult result, [out] class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndTryReceive (result As IAsyncResult, ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndTryReceive(IAsyncResult ^ result, [Runtime::InteropServices::Out] System::ServiceModel::Channels::Message ^ % message);" />
      <MemberSignature Language="F#" Value="abstract member EndTryReceive : IAsyncResult *  -&gt; bool" Usage="iInputChannel.EndTryReceive (result, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" /> Zwracany przez wywołanie <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" /> metody.</param>
        <param name="message"><see cref="T:System.ServiceModel.Channels.Message" /> Odebrane.</param>
        <summary>Wykonuje określoną operacją asynchroniczną w celu odebrania komunikatu.</summary>
        <returns><see langword="true" /> gdy wiadomość zostaje odebrana przed określonym interwale czasu upłynie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForMessage">
      <MemberSignature Language="C#" Value="public bool EndWaitForMessage (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndWaitForMessage(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndWaitForMessage(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWaitForMessage (result As IAsyncResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndWaitForMessage(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWaitForMessage : IAsyncResult -&gt; bool" Usage="iInputChannel.EndWaitForMessage result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" /> Określający <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" /> operację, aby zakończyć z którego mają zostać pobrane wynik końcowy.</param>
        <summary>Wykonuje określoną operacją asynchroniczną oczekiwania dla wiadomości.</summary>
        <returns><see langword="true" /> Jeśli komunikat jest już dostępna przed <paramref name="timeout" /> została przekroczona; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#23](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress LocalAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress LocalAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IInputChannel.LocalAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ LocalAddress { System::ServiceModel::EndpointAddress ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalAddress : System.ServiceModel.EndpointAddress" Usage="System.ServiceModel.Channels.IInputChannel.LocalAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres, na którym kanał wejściowy odbiera komunikaty.</summary>
        <value><see cref="T:System.ServiceModel.EndpointAddress" /> Na którym kanał wejściowy odbiera komunikaty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten kanał wejściowy nie ma adresu autonomiczny (na przykład jest dane wejściowe boku kanału TCP zainicjowane przez klienta), a następnie ta właściwość jest `null`.  
  
 Ta właściwość może służyć przez kanały wyższego poziomu dla korelacji. Na przykład, jeśli kanał wyższego poziomu implementuje żądanie odpowiedź, w górnej części <xref:System.ServiceModel.Channels.IDuplexChannel>, można użyć <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> właściwości w nagłówku protokołu WS-Addressing ReplyTo.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób implementacji tej właściwości:  
  
 [!code-csharp[S_UE_MessageInterceptor#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.ServiceProcess.TimeoutException">Operacja nie została ukończona z interwałem limitu czasu.</exception>
        <exception cref="T:System.ServiceModel.CommunicationException">Kanał wejściowy nie powiodło się.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectAbortedException">Kanał wejściowy został przerwany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Kanał wejściowy błędne.</exception>
        <summary>Zwraca komunikat odbierane przez kanał wejściowy, jeśli jest dostępny w odstępie czasu, który jest jawnie lub niejawnie zdefiniowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> metody, gdy jest dopuszczalny dla bieżącego wątku zablokowany, dopóki odbierze komunikatu żądania lub przekroczy ten interwał czasu określonego przez `timeout`. Użycie asynchronicznego <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> metody, gdy będziesz potrzebować przetwarzania aplikacji, aby kontynuować bez oczekiwania na żądanie do odbioru.  
  
 Synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operacja jest niedostępna, z lub bez jawnego limitu czasu.  
  
 Jeśli komunikat nie jest dostępna, blokuje, dopóki nie jest dostępny, lub dopóki nie zostanie przekroczony limit czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="abstract member Receive : unit -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca komunikat, jeśli jest dostępny. Jeśli komunikat nie jest dostępna, bloki domyślny interwał czasu.</summary>
        <returns><see cref="T:System.ServiceModel.Channels.Message" /> Odebrane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> metody, gdy jest dopuszczalny dla bieżącego wątku zablokowany, dopóki odbierze komunikatu żądania lub przekroczy ten interwał czasu określonego przez `timeout`. Użycie asynchronicznego <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> metody, gdy chcesz, aby przetwarzania aplikacji, aby kontynuować bez oczekiwania na żądanie do odbioru.  
  
 Synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operacja jest niedostępna, z lub bez jawnego limitu czasu.  
  
 Jeśli komunikat nie jest dostępna, blokuje, dopóki nie jest dostępny, lub dopóki nie zostanie przekroczony limit czasu.  
  
 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> może być wywoływana wiele razy lub jednocześnie. Tylko jeden <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> wywołania można wykonać dla każdego komunikatu odebranego.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Receive : TimeSpan -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Określający, ile operacji odbierania musi ukończyć przed wyczerpaniem i zostanie zgłoszony <see cref="T:System.TimeoutException" />.</param>
        <summary>Zwraca komunikat, jeśli jest dostępny. Jeśli komunikat nie jest dostępna, bloków dla określonego przedziału czasu.</summary>
        <returns><see cref="T:System.ServiceModel.Channels.Message" /> Odebrane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> metody, gdy jest dopuszczalny dla bieżącego wątku zablokowany, dopóki odbierze komunikatu żądania lub przekroczy ten interwał czasu określonego przez `timeout`. Użycie asynchronicznego <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> metody, gdy chcesz, aby przetwarzania aplikacji, aby kontynuować bez oczekiwania na żądanie do odbioru.  
  
 Synchronicznej <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operacja jest niedostępna, z lub bez jawnego limitu czasu.  
  
 Jeśli komunikat nie jest dostępna, blokuje, dopóki nie jest dostępny, lub dopóki nie zostanie przekroczony limit czasu.  
  
 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> może być wywoływana wiele razy lub jednocześnie. Tylko jeden <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> wywołania można wykonać dla każdego komunikatu odebranego.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#14](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Określony <paramref name="timeout" /> zostanie przekroczony, zanim operacja została wykonana.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Określono limit czasu jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (TimeSpan timeout, out System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(valuetype System.TimeSpan timeout, [out] class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.TryReceive(System.TimeSpan,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (timeout As TimeSpan, ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReceive(TimeSpan timeout, [Runtime::InteropServices::Out] System::ServiceModel::Channels::Message ^ % message);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : TimeSpan *  -&gt; bool" Usage="iInputChannel.TryReceive (timeout, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.IAsyncResult" /> Zwrócony przez wywołanie do jednego z <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> metody.</param>
        <param name="message"><see cref="T:System.ServiceModel.Channels.Message" /> Odebrane.</param>
        <summary>Stara się komunikat o błędzie w określonym interwale czasu.</summary>
        <returns><see langword="true" /> gdy wiadomość zostaje odebrana przed <paramref name="timeout" /> została przekroczona; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zamierzasz obsługiwać przekroczeń limitu czasu i nie tylko ponownie wygenerować lub zawijania <xref:System.TimeoutException>, a następnie należy wywołać <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> zamiast <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.  
  
 Jeśli nie ma specjalnie traktują przekroczeń limitu czasu następnie po prostu Wywołaj <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>, w przeciwnym razie utracisz informacje o błędzie.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Określony <paramref name="timeout" /> zostanie przekroczony, zanim operacja została wykonana.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Określono limit czasu jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForMessage">
      <MemberSignature Language="C#" Value="public bool WaitForMessage (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitForMessage(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.WaitForMessage(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForMessage (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForMessage(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitForMessage : TimeSpan -&gt; bool" Usage="iInputChannel.WaitForMessage timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Określa maksymalny interwał czasu oczekiwania na wiadomość dotrze przed przekroczeniem limitu czasu.</param>
        <summary>Zwraca wartość wskazującą, czy komunikat jest już dostępna w określonym interwale czasu.</summary>
        <returns><see langword="true" /> Jeśli komunikat jest już dostępna przed <paramref name="timeout" /> została przekroczona; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> nie powoduje komunikat, że otrzymano lub przetwarzania w jakikolwiek inny sposób.  
  
 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> Istnieje metoda głównie dla scenariuszy transakcyjne, gdy użytkownik chce, aby odbierać wiadomości przy użyciu transakcji. Korzystając z właśnie <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> zwykle w tym celu użytkownik musi utworzyć transakcję i następnie wywołać <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> i mamy nadzieję, komunikat dociera przed transakcji upłynie limit czasu, który może nie być możliwe.  
  
 Zamiast tego użytkownik może wywołać <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> przy użyciu niezależnie od limitu czasu chcą (nawet nieskończona), a następnie po nadejściu wiadomości mogą otwierać transakcji, wywołaj <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> i mieć pewność, że otrzymują wiadomości przed wygaśnięciem transakcji.  
  
 Ta metoda jest synchroniczne, więc blokują bieżący wątek, aż komunikat jest dostępny lub występuje limit czasu. Użyj <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Wątek jest blokowany w górę do określonego `timeout`. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez zbędnego oczekiwania, użycie asynchronicznego <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> metody.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób zaimplementować tę metodę:  
  
 [!code-csharp[S_UE_MessageInterceptor#21](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Określony <paramref name="timeout" /> zostanie przekroczony, zanim operacja została wykonana.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Określono limit czasu jest mniejsza niż zero.</exception>
        <block subset="none" type="overrides"><para>Operacja zwraca <see langword="false" /> Jeśli określony <paramref name="timeout" /> zostanie przekroczony, nie wyjątek limitu czasu.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
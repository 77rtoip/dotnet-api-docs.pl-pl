<Type Name="WebContentTypeMapper" FullName="System.ServiceModel.Channels.WebContentTypeMapper">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d66c64b657f82f9f5f0ea5d4f7cba3d49c47cd7e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30572737" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WebContentTypeMapper" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WebContentTypeMapper extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.WebContentTypeMapper" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WebContentTypeMapper" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebContentTypeMapper abstract" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Web</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Określa format, na którą jest zamapowany typ zawartości wiadomości przychodzącej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest punkt rozszerzalności w modelu programowania, który jest używany przez koder komunikatów sieci Web do zastąpienia, jak formatuje zawartość, którą typy są mapowane na. Do implementowania tej klasy, należy zastąpić <xref:System.ServiceModel.Channels.WebContentTypeMapper.GetMessageFormatForContentType%28System.String%29> metody.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WebContentTypeMapper ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.WebContentTypeMapper.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WebContentTypeMapper();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.WebContentTypeMapper" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageFormatForContentType">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.WebContentFormat GetMessageFormatForContentType (string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.ServiceModel.Channels.WebContentFormat GetMessageFormatForContentType(string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.WebContentTypeMapper.GetMessageFormatForContentType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMessageFormatForContentType (contentType As String) As WebContentFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::ServiceModel::Channels::WebContentFormat GetMessageFormatForContentType(System::String ^ contentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.WebContentFormat</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="contentType">Typ zawartości, który wskazuje typ MIME danych, które należy interpretować.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej zwraca komunikat format użyty dla określonego typu zawartości.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.WebContentFormat" /> , Który określa format, na którą jest zamapowany typ treści komunikatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ma to być mechanizm rozszerzalności, który może służyć do zastępowania typów jak zawartości są mapowane na formaty zawartości sieci Web. Na przykład, jeśli komunikaty przychodzące są przetwarzane jako "nieprzetworzone dane binarne" bez kiedykolwiek podczas analizowania XML lub JSON, można zaimplementować <xref:System.ServiceModel.Channels.WebContentTypeMapper> zwróconą zawsze <xref:System.ServiceModel.Channels.WebContentFormat.Raw> niezależnie od tego typu zawartości, która została przekazana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
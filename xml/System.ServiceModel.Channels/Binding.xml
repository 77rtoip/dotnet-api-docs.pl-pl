<Type Name="Binding" FullName="System.ServiceModel.Channels.Binding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="34bfe6c0ef74f86c6e3e88ca43711922e2626695" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34317233" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Binding : System.ServiceModel.IDefaultCommunicationTimeouts" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Binding extends System.Object implements class System.ServiceModel.IDefaultCommunicationTimeouts" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.Binding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Binding&#xA;Implements IDefaultCommunicationTimeouts" />
  <TypeSignature Language="C++ CLI" Value="public ref class Binding abstract : System::ServiceModel::IDefaultCommunicationTimeouts" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.IDefaultCommunicationTimeouts</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zawiera elementy powiązania, które określają protokołów transportu i kodery komunikatu używany do komunikacji między klientami i usługami.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentuje kolekcję elementów, wiązania, z których każdy zawiera opis aspektu jak punkt końcowy komunikuje się z innych punktów końcowych i wbudowanych, spójnie na fabryki kanałów na kliencie i na odbiornik kanału usługi. Powiązanie zawiera kolekcję powiązania elementów, które odpowiadają kanały protokołów, kanały transportu i kodery wiadomości. Może być dowolną liczbę elementów powiązania protokołu kanały ale tylko jeden element powiązania dla każdej kodera transportu i komunikatu. Występują najczęściej sześciu warstwy elementów wiązania w powiązaniu. Wymagane są tylko transport i kodowanie elementy powiązania w dolnej części stosu. Ponieważ jest wymagane kodowanie dla każdego powiązania, jeśli nie określono kodowania, Windows Communication Foundation (WCF) dodaje domyślne kodowanie dla Ciebie. Wartość domyślna to Text/XML dla transportu HTTP i HTTPS, a danych binarnych dla innych transportu.  
  
 W poniższej tabeli przedstawiono opcje dla każdej warstwy.  
  
|Warstwy|Opcje|Wymagane|  
|-----------|-------------|--------------|  
|Przepływ transakcji|<xref:System.ServiceModel.Channels.TransactionFlowBindingElement>|Nie|  
|Niezawodność|<xref:System.ServiceModel.Channels.ReliableSessionBindingElement>|Nie|  
|Zabezpieczenia|Symetryczne, asymetrycznego, poziomu transportu|Nie|  
|Zmiana kształtu|<xref:System.ServiceModel.Channels.CompositeDuplexBindingElement>|Nie|  
|Transport uaktualnień|Strumień protokołu SSL, strumienia systemu Windows, program rozpoznawania elementów równorzędnych|Nie|  
|Kodowanie|Tekst, Binary, MTOM, niestandardowe|Tak|  
|Transportu|TCP i nazwane potoki, HTTP, HTTPS, usługa MSMQ, niestandardowe|Tak|  
  
 Każdy element powiązania zawiera specyfikację tworzenie fabryki kanałów na kliencie i odbiornik kanału usługi. Gdy jest tworzony na stosie fabryki kanałów, na przykład istnieje jeden fabryki kanałów w stosie dla każdego elementu powiązania w powiązaniu. Jest taka sama mapowanie dotyczy odbiorniki kanałów w stosie usługi. Spójność na kliencie i usługa jest krytyczne w celu nawiązania połączenia na podstawie kanału między tymi punktami końcowymi. Każdej fabryki i odbiornika, z kolei przetwarza wysyłania i akceptowanie odpowiednich kanałów w stosie kanału, który łączy je, i tych kanałów umożliwia wysyłanie i odbieranie komunikatów używany do komunikacji.  
  
 Każde wystąpienie <xref:System.ServiceModel.Channels.Binding> ma <xref:System.ServiceModel.Channels.Binding.Name%2A> i <xref:System.ServiceModel.Channels.Binding.Namespace%2A> tym razem jednoznacznie zidentyfikować w metadanych usługi. Jeśli nie nazwę lub przestrzeń nazw jest określony, WCF dodaje wartości domyślne. Nazwa domyślna to `null` i domyślnej przestrzeni nazw jest http://tempuri.org/. Ta nazwa użytkownika dla powiązania różni się od specyfikacji nazwy protokołu, który jest określony przez <xref:System.ServiceModel.Channels.Binding.Scheme%2A> właściwości. Jeśli chcesz dodać więcej powiązania protokołu HTTP, na przykład można nazwać je niezależnie od mają i ustawić dla wszystkich ich schematy "http". Nie ma żadnej związanego z używaniem aplikacji ani wysyłania maszyny, na podstawie <xref:System.ServiceModel.Channels.Binding.Scheme%2A>. Dlatego można uniknąć typowych problemu nie będą mogli zarejestrować dodatkowe programy obsługi dla dobrze znanych protokołów. Można również łatwo pracować z wieloma wersjami powiązanie side-by-side, zapewniając każdej wersji inną nazwę.  
  
 <xref:System.ServiceModel.Channels.Binding> Klasa implementuje <xref:System.ServiceModel.IDefaultCommunicationTimeouts> interfejsu w osłabianiu ataków typu odmowa usługi (DOS), korzystające z zajmowania zasobów dla rozszerzonych przedziały czasu. Wdrożenia określa wartości limitów czasu komunikacji do otwierania i zamykania połączeń i do odczytu, zapisu operacji związanych z odbieranie i wysyłanie wiadomości. Te właściwości są używane do pobierania i ustawiania tych limitów czasu i ich operacje wartości domyślnej przedstawiono w poniższej tabeli.  
  
|Właściwość limit czasu|Wartość domyślna|  
|----------------------|-------------------|  
|<xref:System.ServiceModel.Channels.Binding.OpenTimeout%2A>|1 minuta|  
|<xref:System.ServiceModel.Channels.Binding.CloseTimeout%2A>|1 minuta|  
|<xref:System.ServiceModel.Channels.Binding.SendTimeout%2A>|1 minuta|  
|<xref:System.ServiceModel.Channels.Binding.ReceiveTimeout%2A>|10 minut|  
  
 Podczas tworzenia powiązania przez dziedziczenie z <xref:System.ServiceModel.Channels.Binding>, konieczne jest przesłonięcie <xref:System.ServiceModel.Channels.Binding.CreateBindingElements%2A>.  
  
 Ponadto można definiować własne elementy powiązania i wstawione między poszczególnych warstw zdefiniowanych w powyższej tabeli. Aby uzyskać więcej informacji, zobacz <xref:System.ServiceModel.Channels.CustomBinding> klasy.  
  
   
  
## Examples  
 [!code-csharp[S_UEBinding#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebinding/cs/service.cs#11)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.Binding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Binding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Binding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.Binding" /> z domyślnej nazwy i przestrzeni nazw.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa domyślna to `null` i domyślnej przestrzeni nazw jest http://tempuri.org/.  
  
   
  
## Examples  
 [!code-csharp[S_UEBinding#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebinding/cs/service.cs#2)]
 [!code-vb[S_UEBinding#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebinding/vb/service.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Binding (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Binding(System::String ^ name, System::String ^ ns);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="P:System.ServiceModel.Channels.Binding.Name" /> Powiązania.</param>
        <param name="ns">
          <see cref="P:System.ServiceModel.Channels.Binding.Namespace" /> Powiązania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.Binding" /> klasy z określonego powiązania usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.Binding.Name%2A> i <xref:System.ServiceModel.Channels.Binding.Namespace%2A> razem jednoznacznie zidentyfikować wystąpienie <xref:System.ServiceModel.Channels.Binding> w metadanych usługi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest <see langword="null" /> lub ciąg pusty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ns" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy stosu fabryki kanałów na kliencie, określony przez powiązanie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.BuildChannelFactory``1(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BuildChannelFactory(Of TChannel) (ParamArray parameters As Object()) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Tworzy typ kanału fabryki kanałów.</typeparam>
        <param name="parameters">Tablica obiektów, która określa wymagania, fabryki kanałów, która została skompilowana.</param>
        <summary>Tworzy stosu fabryki kanałów na komputerze klienckim, który tworzy określony typ kanału i odpowiadającej funkcji określonej przez tablicę obiektów.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> Typu <paramref name="TChannel" /> odpowiadającej funkcji określonej przez kolekcji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element transportu jest brakujący lub uszkodzony lub schemat jest nieprawidłowy lub nie określono wersji wiadomości.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.BuildChannelFactory``1(System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BuildChannelFactory(Of TChannel) (parameters As BindingParameterCollection) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; virtual System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Tworzy typ kanału fabryki kanałów.</typeparam>
        <param name="parameters">
          <see cref="T:System.ServiceModel.Channels.BindingParameterCollection" /> , Który określa wymagania wbudowane fabryki kanałów.</param>
        <summary>Tworzy stosu fabryki kanałów na komputerze klienckim, który tworzy określony typ kanału i odpowiadającej funkcji określonej przez kolekcję wiązania parametrów.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> Typu <paramref name="TChannel" /> odpowiadającej funkcji określonej przez kolekcji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element transportu jest brakujący lub uszkodzony lub schemat jest nieprawidłowy lub nie określono wersji wiadomości.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BuildChannelListener&lt;TChannel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiornik kanału opiera się na usługę, która przyjmuje się, że określony typ kanału i że spełnia określone funkcje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (params object[] parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.BuildChannelListener``1(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BuildChannelListener(Of TChannel As {Class, IChannel}) (ParamArray parameters As Object()) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który akceptuje odbiornika kanałów.</typeparam>
        <param name="parameters">Tablica obiektów, która określa wymagania, wbudowane fabryki kanałów.</param>
        <summary>Odbiornik kanału opiera się na usługę, która przyjmuje się, że określony typ kanału i że spełnia określone funkcje.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <paramref name="TChannel" /> spełniającego określone funkcje.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element transportu jest brakujący lub uszkodzony lub schemat jest nieprawidłowy lub nie określono wersji wiadomości.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingParameterCollection parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.BuildChannelListener``1(System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BuildChannelListener(Of TChannel As {Class, IChannel}) (parameters As BindingParameterCollection) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który akceptuje odbiornika kanałów.</typeparam>
        <param name="parameters">
          <see cref="T:System.ServiceModel.Channels.BindingParameterCollection" /> , Który określa wymagania dotyczące odbiornika kanału, która została skompilowana.</param>
        <summary>Odbiornik kanału opiera się na usługę, która przyjmuje się, że określony typ kanału i że spełnia określone przez kolekcję wiązania parametrów funkcji.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <paramref name="TChannel" /> spełniającego określone funkcje.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element transportu jest brakujący lub uszkodzony lub schemat jest nieprawidłowy lub nie określono wersji wiadomości.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (Uri listenUriBaseAddress, string listenUriRelativeAddress, params object[] parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.Uri listenUriBaseAddress, string listenUriRelativeAddress, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.BuildChannelListener``1(System.Uri,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BuildChannelListener(Of TChannel As {Class, IChannel}) (listenUriBaseAddress As Uri, listenUriRelativeAddress As String, ParamArray parameters As Object()) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(Uri ^ listenUriBaseAddress, System::String ^ listenUriRelativeAddress, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="listenUriBaseAddress" Type="System.Uri" />
        <Parameter Name="listenUriRelativeAddress" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który akceptuje odbiornika kanałów.</typeparam>
        <param name="listenUriBaseAddress">
          <see cref="T:System.Uri" /> Zapewnia adres podstawowy, na którym nasłuchuje usługa.</param>
        <param name="listenUriRelativeAddress">Adres, określany względem adresu podstawowego, na którym nasłuchuje usługa.</param>
        <param name="parameters">Tablica obiektów, która określa wymagania, fabryki kanałów, która została skompilowana.</param>
        <summary>Odbiornik kanału opiera się na usługę, która przyjmuje się, że określony typ kanału i że spełnia określone funkcje.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <paramref name="TChannel" /> spełniającego określone funkcje.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element transportu jest brakujący lub uszkodzony lub schemat jest nieprawidłowy lub nie określono wersji wiadomości.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (Uri listenUriBaseAddress, string listenUriRelativeAddress, System.ServiceModel.Channels.BindingParameterCollection parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.Uri listenUriBaseAddress, string listenUriRelativeAddress, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.BuildChannelListener``1(System.Uri,System.String,System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BuildChannelListener(Of TChannel As {Class, IChannel}) (listenUriBaseAddress As Uri, listenUriRelativeAddress As String, parameters As BindingParameterCollection) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(Uri ^ listenUriBaseAddress, System::String ^ listenUriRelativeAddress, System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="listenUriBaseAddress" Type="System.Uri" />
        <Parameter Name="listenUriRelativeAddress" Type="System.String" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który akceptuje odbiornika kanałów.</typeparam>
        <param name="listenUriBaseAddress">
          <see cref="T:System.Uri" /> Zapewnia adres podstawowy, na którym nasłuchuje usługa.</param>
        <param name="listenUriRelativeAddress">Adres, określany względem adresu podstawowego, na którym nasłuchuje usługa.</param>
        <param name="parameters">
          <see cref="T:System.ServiceModel.Channels.BindingParameterCollection" /> , Który określa wymagania dotyczące odbiornika kanału, która została skompilowana.</param>
        <summary>Odbiornik kanału opiera się na usługę, która przyjmuje się, że określony typ kanału i że spełnia określone funkcje.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <paramref name="TChannel" /> spełniającego określone funkcje.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element transportu jest brakujący lub uszkodzony lub schemat jest nieprawidłowy lub nie określono wersji wiadomości.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (Uri listenUriBaseAddress, params object[] parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.Uri listenUriBaseAddress, object[] parameters) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.BuildChannelListener``1(System.Uri,System.Object[])" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BuildChannelListener(Of TChannel As {Class, IChannel}) (listenUriBaseAddress As Uri, ParamArray parameters As Object()) As IChannelListener(Of TChannel)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(Uri ^ listenUriBaseAddress, ... cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (Uri listenUri, params object[] parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.Uri listenUri, object[] parameters) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BuildChannelListener(Of TChannel As {Class, IChannel}) (listenUri As Uri, ParamArray parameters As Object()) As IChannelListener(Of TChannel)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(Uri ^ listenUri, ... cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="listenUriBaseAddress" Type="System.Uri" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;netframework-4.7.2" />
        <Parameter Name="listenUri" Type="System.Uri" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Object[]" Index="1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który akceptuje odbiornika kanałów.</typeparam>
        <param name="listenUriBaseAddress">To be added.</param>
        <param name="listenUri">To be added.</param>
        <param name="parameters">Tablica obiektów, która określa wymagania, fabryki kanałów, która została skompilowana.</param>
        <summary>Odbiornik kanału opiera się na usługę, która przyjmuje się, że określony typ kanału i że spełnia określone funkcje.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <paramref name="TChannel" /> spełniającego określone funkcje.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element transportu jest brakujący lub uszkodzony lub schemat jest nieprawidłowy lub nie określono wersji wiadomości.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (Uri listenUriBaseAddress, System.ServiceModel.Channels.BindingParameterCollection parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.Uri listenUriBaseAddress, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.BuildChannelListener``1(System.Uri,System.ServiceModel.Channels.BindingParameterCollection)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BuildChannelListener(Of TChannel As {Class, IChannel}) (listenUriBaseAddress As Uri, parameters As BindingParameterCollection) As IChannelListener(Of TChannel)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(Uri ^ listenUriBaseAddress, System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (Uri listenUri, System.ServiceModel.Channels.BindingParameterCollection parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.Uri listenUri, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BuildChannelListener(Of TChannel As {Class, IChannel}) (listenUri As Uri, parameters As BindingParameterCollection) As IChannelListener(Of TChannel)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(Uri ^ listenUri, System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="listenUriBaseAddress" Type="System.Uri" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;netframework-4.7.2" />
        <Parameter Name="listenUri" Type="System.Uri" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" Index="1" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który akceptuje odbiornika kanałów.</typeparam>
        <param name="listenUriBaseAddress">To be added.</param>
        <param name="listenUri">To be added.</param>
        <param name="parameters">
          <see cref="T:System.ServiceModel.Channels.BindingParameterCollection" /> , Który określa wymagania dotyczące odbiornika kanału, która została skompilowana.</param>
        <summary>Odbiornik kanału opiera się na usługę, która przyjmuje się, że określony typ kanału i że spełnia określone funkcje.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <paramref name="TChannel" /> spełniającego określone funkcje.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element transportu jest brakujący lub uszkodzony lub schemat jest nieprawidłowy lub nie określono wersji wiadomości.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (Uri listenUriBaseAddress, string listenUriRelativeAddress, System.ServiceModel.Description.ListenUriMode listenUriMode, params object[] parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.Uri listenUriBaseAddress, string listenUriRelativeAddress, valuetype System.ServiceModel.Description.ListenUriMode listenUriMode, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.BuildChannelListener``1(System.Uri,System.String,System.ServiceModel.Description.ListenUriMode,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(Uri ^ listenUriBaseAddress, System::String ^ listenUriRelativeAddress, System::ServiceModel::Description::ListenUriMode listenUriMode, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="listenUriBaseAddress" Type="System.Uri" />
        <Parameter Name="listenUriRelativeAddress" Type="System.String" />
        <Parameter Name="listenUriMode" Type="System.ServiceModel.Description.ListenUriMode" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który akceptuje odbiornika kanałów.</typeparam>
        <param name="listenUriBaseAddress">
          <see cref="T:System.Uri" /> Zapewnia adres podstawowy, na którym nasłuchuje usługa.</param>
        <param name="listenUriRelativeAddress">Adres, określany względem adresu podstawowego, na którym nasłuchuje usługa.</param>
        <param name="listenUriMode">Wartość <see cref="T:System.ServiceModel.Description.ListenUriMode" /> wskazująca, czy transport musi zapewnić, że identyfikator URI dostarczony dla usługi do nasłuchiwania jest unikatowa można używać tak jak została podana.</param>
        <param name="parameters">Tablica obiektów, która określa wymagania, fabryki kanałów, która została skompilowana.</param>
        <summary>Odbiornik kanału opiera się na usługę, która przyjmuje się, że określony typ kanału i że spełnia określone funkcje.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <paramref name="TChannel" /> spełniającego określone funkcje.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element transportu jest brakujący lub uszkodzony lub schemat jest nieprawidłowy lub nie określono wersji wiadomości.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (Uri listenUriBaseAddress, string listenUriRelativeAddress, System.ServiceModel.Description.ListenUriMode listenUriMode, System.ServiceModel.Channels.BindingParameterCollection parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.Uri listenUriBaseAddress, string listenUriRelativeAddress, valuetype System.ServiceModel.Description.ListenUriMode listenUriMode, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.BuildChannelListener``1(System.Uri,System.String,System.ServiceModel.Description.ListenUriMode,System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(Uri ^ listenUriBaseAddress, System::String ^ listenUriRelativeAddress, System::ServiceModel::Description::ListenUriMode listenUriMode, System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="listenUriBaseAddress" Type="System.Uri" />
        <Parameter Name="listenUriRelativeAddress" Type="System.String" />
        <Parameter Name="listenUriMode" Type="System.ServiceModel.Description.ListenUriMode" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który akceptuje odbiornika kanałów.</typeparam>
        <param name="listenUriBaseAddress">
          <see cref="T:System.Uri" /> Zapewnia adres podstawowy, na którym nasłuchuje usługa.</param>
        <param name="listenUriRelativeAddress">Adres, określany względem adresu podstawowego, na którym nasłuchuje usługa.</param>
        <param name="listenUriMode">Wartość <see cref="T:System.ServiceModel.Description.ListenUriMode" /> wskazująca, czy transport musi zapewnić, że identyfikator URI dostarczony dla usługi do nasłuchiwania jest unikatowa można używać tak jak została podana.</param>
        <param name="parameters">
          <see cref="T:System.ServiceModel.Channels.BindingParameterCollection" /> , Który określa wymagania dotyczące odbiornika kanału, która została skompilowana.</param>
        <summary>Odbiornik kanału opiera się na usługę, która przyjmuje się, że określony typ kanału i że spełnia określone funkcje.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <paramref name="TChannel" /> spełniającego określone funkcje.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element transportu jest brakujący lub uszkodzony lub schemat jest nieprawidłowy lub nie określono wersji wiadomości.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy bieżącego powiązania można utworzyć stosu fabryki kanałów na kliencie, które spełniają pewne określone kryteria.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda Jeśli chcesz sprawdzić, czy fabryka kanałów dla kanałów typu `TChannel` może być kompilacji `context` podana przed podjęciem próby zbudowaniem fabryka. Alternatywnie, spróbuj zbudować fabryki kanału przez wywołanie metody <xref:System.ServiceModel.Channels.BindingElement.BuildChannelFactory%2A> i przechwytywać elementu exception generowany, gdy nie może zostać utworzony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public bool CanBuildChannelFactory&lt;TChannel&gt; (params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanBuildChannelFactory&lt;TChannel&gt;(object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.CanBuildChannelFactory``1(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CanBuildChannelFactory(Of TChannel) (ParamArray parameters As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; bool CanBuildChannelFactory(... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, dla którego jest poddawana testom fabryka.</typeparam>
        <param name="parameters">Tablica obiektów, która określa wymagania, fabryki kanałów, która została skompilowana.</param>
        <summary>Zwraca wartość wskazującą, czy bieżącego powiązania można utworzyć stosu fabryki kanałów na kliencie który spełnia wymagania określone przez tablicę obiektów.</summary>
        <returns>
          <see langword="true" /> Jeśli stosu fabryki określonego kanału można tworzyć na kliencie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda Jeśli chcesz sprawdzić, czy fabryka kanałów dla kanałów typu `TChannel` może być kompilacji dla powiązania `parameters` określony przed podjęciem próby zbudowaniem fabryka. Alternatywnie, spróbuj zbudować fabryki kanału przez wywołanie metody <xref:System.ServiceModel.Channels.Binding.BuildChannelFactory%60%601%28System.Object%5B%5D%29> i przechwytywać elementu exception generowany, gdy nie może zostać utworzony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanBuildChannelFactory(Of TChannel) (parameters As BindingParameterCollection) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; virtual bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, dla którego jest poddawana testom fabryka.</typeparam>
        <param name="parameters">
          <see cref="T:System.ServiceModel.Channels.BindingParameterCollection" /> , Który określa wymagania fabryki kanałów, która została skompilowana.</param>
        <summary>Zwraca wartość wskazującą, czy bieżącego powiązania można utworzyć stosu fabryki kanałów na kliencie który spełnia kolekcji powiązania z określonymi parametrami.</summary>
        <returns>
          <see langword="true" /> Jeśli stosu fabryki określonego kanału można tworzyć na kliencie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda Jeśli chcesz sprawdzić, czy fabryka kanałów dla kanałów typu `TChannel` może być kompilacji dla powiązania `parameters` określony przed podjęciem próby zbudowaniem fabryka. Alternatywnie, spróbuj zbudować fabryki kanału przez wywołanie metody <xref:System.ServiceModel.Channels.Binding.BuildChannelFactory%60%601%28System.ServiceModel.Channels.BindingParameterCollection%29> i przechwytywać elementu exception generowany, gdy nie może zostać utworzony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy bieżącego powiązania można utworzyć stosu odbiornika kanału od usługi, która spełnia niektóre określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public bool CanBuildChannelListener&lt;TChannel&gt; (params object[] parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.CanBuildChannelListener``1(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (ParamArray parameters As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel bool CanBuildChannelListener(... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, dla którego jest poddawana testom odbiornika.</typeparam>
        <param name="parameters">Tablica obiektów, która określa wymagania, fabryki kanałów, która została skompilowana.</param>
        <summary>Zwraca wartość wskazującą, czy bieżącego powiązania można tworzyć stosu odbiornik kanału usługi który spełnia kryteria określone w tablicy obiektów.</summary>
        <returns>
          <see langword="true" /> Jeśli stosu odbiornika określonego kanału można tworzyć w usłudze; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda Jeśli chcesz sprawdzić, czy kanał odbiornika kanałów typu `TChannel` może być kompilacji dla powiązania `parameters` określony przed podjęciem próby zbudowaniem odbiornika. Alternatywnie próby skompilowania odbiornika kanałów przez wywołanie metody <xref:System.ServiceModel.Channels.Binding.BuildChannelListener%60%601%28System.Object%5B%5D%29> i przechwytywać elementu exception generowany, gdy nie może zostać utworzony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingParameterCollection parameters) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (parameters As BindingParameterCollection) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel virtual bool CanBuildChannelListener(System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, dla którego jest poddawana testom odbiornika.</typeparam>
        <param name="parameters">
          <see cref="T:System.ServiceModel.Channels.BindingParameterCollection" /> , Który określa wymagania dotyczące odbiornika kanału, która została skompilowana.</param>
        <summary>Zwraca wartość wskazującą, czy bieżącego powiązania można tworzyć stosu odbiornik kanału usługi który spełnia kolekcji powiązania z określonymi parametrami.</summary>
        <returns>
          <see langword="true" /> Jeśli stosu odbiornika określonego kanału można tworzyć w usłudze; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda Jeśli chcesz sprawdzić, czy kanał odbiornika kanałów typu `TChannel` może być kompilacji dla powiązania `parameters` określony przed podjęciem próby zbudowaniem odbiornika. Alternatywnie próby skompilowania odbiornika kanałów przez wywołanie metody <xref:System.ServiceModel.Channels.Binding.BuildChannelListener%60%601%28System.ServiceModel.Channels.BindingParameterCollection%29> i przechwytywać elementu exception generowany, gdy nie może zostać utworzony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan CloseTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan CloseTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.Binding.CloseTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CloseTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan CloseTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia interwał podany dla połączenia zamknąć przed transportu zgłasza wyjątek.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu operacji zamknięcia. Wartość domyślna to 1 minutę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest używany przez kanałów i odbiorników utworzone za pomocą fabryk powiązania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza niż zero lub jest zbyt duży.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateBindingElements">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.BindingElementCollection CreateBindingElements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.BindingElementCollection CreateBindingElements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.CreateBindingElements" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateBindingElements () As BindingElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::ServiceModel::Channels::BindingElementCollection ^ CreateBindingElements();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElementCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy kolekcję zawierającą elementy wiązania, które są częścią bieżącego powiązania.</summary>
        <returns>A <see cref="T:System.Collections.Generic.ICollection`1" /> typu obiektu <see cref="T:System.ServiceModel.Channels.BindingElement" /> zawierający elementy wiązania z bieżącego obiektu wiązania w odpowiedniej kolejności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy nie powinny odwoływać się żadnych elementów wewnętrznych który <xref:System.ServiceModel.Channels.Binding> obiekt zastosowań.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingParameterCollection parameters) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.GetProperty``1(System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty(Of T As Class) (parameters As BindingParameterCollection) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T GetProperty(System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typizowany obiekt, dla którego metoda wykonywania zapytania.</typeparam>
        <param name="parameters">
          <see cref="T:System.ServiceModel.Channels.BindingParameterCollection" /> , Który określa wymagania dotyczące odbiornika kanału, która została skompilowana.</param>
        <summary>Zwraca typizowany obiekt wymagane, jeśli jest obecny, z odpowiednią warstwę stosu powiązania.</summary>
        <returns>Typizowany obiekt <paramref name="T" /> wymagane, jeśli jest obecny lub <see langword="null" /> Jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku warstwy obsługuje zwracania żądanego obiektu, zwraca go. W przeciwnym razie deleguje ona wywołania do następnej warstwy ze stosu. Jeśli pełne w dół stosu i warstwy nie obsługuje żądanego obiektu, a następnie metoda zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageVersion MessageVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageVersion MessageVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.Binding.MessageVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageVersion As MessageVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageVersion ^ MessageVersion { System::ServiceModel::Channels::MessageVersion ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję komunikatu używany przez klientów i usług skonfigurowany dla powiązania.</summary>
        <value>
          <see cref="T:System.ServiceModel.Channels.MessageVersion" /> Używany przez klientów i usług skonfigurowany dla powiązania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.Binding.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę powiązania.</summary>
        <value>Nazwa powiązania. Nazwa domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każde wystąpienie <xref:System.ServiceModel.Channels.Binding> ma <xref:System.ServiceModel.Channels.Binding.Name%2A> i <xref:System.ServiceModel.Channels.Binding.Namespace%2A> tym razem jednoznacznie zidentyfikować nazwę użytkownika dla powiązania w metadanych usługi.  
  
 Ta nazwa użytkownika dla powiązania różni się od specyfikacji nazwy protokołu, który jest określony przez <xref:System.ServiceModel.Channels.Binding.Scheme%2A> właściwości. Jeśli chcesz dodać więcej powiązania protokołu HTTP, na przykład można nazwać je niezależnie od mają i ustawić dla wszystkich ich schematy "http". Nie ma żadnej związanego z używaniem aplikacji ani wysyłania maszyny, na podstawie <xref:System.ServiceModel.Channels.Binding.Scheme%2A>. Dlatego można uniknąć typowych problemu nie będą mogli zarejestrować dodatkowe programy obsługi dla dobrze znanych protokołów. Można również łatwo pracować z wieloma wersjami powiązanie side-by-side, zapewniając każdej wersji inną nazwę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podana wartość nie może być <see langword="null" /> lub ciąg pusty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.Binding.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar nazw XML powiązania.</summary>
        <value>Przestrzeń nazw XML powiązania. Wartość domyślna to "http://tempuri.org/".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każde wystąpienie <xref:System.ServiceModel.Channels.Binding> ma <xref:System.ServiceModel.Channels.Binding.Name%2A> i <xref:System.ServiceModel.Channels.Binding.Namespace%2A> tym razem jednoznacznie zidentyfikować nazwę użytkownika dla powiązania w metadanych usługi.  
  
 Ta nazwa użytkownika dla powiązania różni się od specyfikacji nazwy protokołu, który jest określony przez <xref:System.ServiceModel.Channels.Binding.Scheme%2A> właściwości. Jeśli chcesz dodać więcej powiązania protokołu HTTP, na przykład można nazwać je niezależnie od mają i ustawić dla wszystkich ich schematy "http". Nie ma żadnej związanego z używaniem aplikacji ani wysyłania maszyny, na podstawie <xref:System.ServiceModel.Channels.Binding.Scheme%2A>. Dlatego można uniknąć typowych problemu nie będą mogli zarejestrować dodatkowe programy obsługi dla dobrze znanych protokołów. Można również łatwo pracować z wieloma wersjami powiązanie side-by-side, zapewniając każdej wersji inną nazwę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Podana wartość nie może być <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan OpenTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan OpenTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.Binding.OpenTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property OpenTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan OpenTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia interwał podany dla połączenia otworzyć przed transportu zgłasza wyjątek.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu operacji otwarcia. Wartość domyślna to 1 minutę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest używany przez kanałów i odbiorników utworzone za pomocą fabryk powiązania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza niż zero lub jest zbyt duży.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.Binding.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ReceiveTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia interwał połączenie może pozostawać aktywne, podczas którego nie aplikacji są odbierane wiadomości, zanim zostanie odrzucone.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> Określający, jak długo aplikacja ma być wyświetlany komunikat przed przekroczeniem limitu czasu. Wartość domyślna to 10 minut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używając niezawodnej sesji, istnieją dwie czasomierzy innej aktywności, które muszą być spełnione, aby podtrzymywania połączenia. Jeśli jeden z tych czasomierzy bezczynności zostanie wyłączone, połączenie zostało przerwane.  
  
-   Pierwszy czasomierza bezczynności znajduje się w niezawodnej sesji i jest nazywany <xref:System.ServiceModel.ReliableSession.InactivityTimeout%2A>. Ten czasomierz aktywności generowane odebranie żadnych komunikatów aplikacji lub infrastruktury, przed upływem limitu czasu. Komunikat infrastruktury jest generowany jest jeden z tych protokołów w stosie kanałów, takich jak podtrzymanie aktywności lub potwierdzenie, a nie zawierającego dane aplikacji na potrzeby.  
  
-   Drugi czasomierza aktywności w usłudze a używa <xref:System.ServiceModel.Channels.Binding.ReceiveTimeout%2A> ustawienia powiązania. Ten czasomierz aktywności generowane odebranie żadnych komunikatów aplikacji przed upływem limitu czasu. To ustawienie określa, na przykład maksymalny czas trwania klient może wysyłać do serwera co najmniej jeden komunikat, zanim serwer zamknie kanału używany przez sesję. Takie zachowanie gwarantuje, że klienci nie może przechowywać do zasobów serwera dla dowolnego dłuższe okresy.  
  
 Ponieważ połączenie jest przerywane, jeśli generowane albo czasomierza bezczynności, zwiększenie <xref:System.ServiceModel.ReliableSession.InactivityTimeout%2A> po jest większy niż <xref:System.ServiceModel.Channels.Binding.ReceiveTimeout%2A> nie ma wpływu. Wartość domyślna dla obu tych limitów czasu jest 10 minut, dzięki czemu zawsze trzeba zwiększyć ich aby różnica podczas korzystania z niezawodnej sesji.  
  
 Jeśli przepływu transakcji jest włączony na powiązanie lub kanału, operacja może trwać dłużej wykonać niż określony limit czasu. W takiej sytuacji, który kończy się niepowodzeniem z powodu wygasły limitu czasu i transakcji przerywa odpowiednio.  
  
 Podczas sesji, będą używane zabezpieczenia <xref:System.ServiceModel.Channels.Binding.ReceiveTimeout%2A> wartość ustawioną dla powiązania jest również używany jako limit czasu sesji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza niż zero lub jest zbyt duży.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public abstract string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.Binding.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej, ustawia schemat URI, który określa transportu używany przez fabryki kanału i odbiornika zbudowane na podstawie powiązania.</summary>
        <value>Schemat identyfikatora URI, który jest używany przez kanały lub odbiorników, które są tworzone za pomocą fabryk utworzony przez bieżącego powiązania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta nazwa użytkownika dla powiązania różni się od specyfikacji nazwy protokołu, który jest określony przez <xref:System.ServiceModel.Channels.Binding.Scheme%2A> właściwości. Każde wystąpienie <xref:System.ServiceModel.Channels.Binding> ma <xref:System.ServiceModel.Channels.Binding.Name%2A> i <xref:System.ServiceModel.Channels.Binding.Namespace%2A> tym razem jednoznacznie zidentyfikować nazwę użytkownika dla powiązania w metadanych usługi. Jeśli chcesz dodać więcej powiązania protokołu HTTP, na przykład można nazwać je niezależnie od mają i ustawić dla wszystkich ich schematy "http". Nie ma żadnej związanego z używaniem aplikacji ani wysyłania maszyny, na podstawie <xref:System.ServiceModel.Channels.Binding.Scheme%2A>. Dlatego można uniknąć typowych problemu nie będą mogli zarejestrować dodatkowe programy obsługi dla dobrze znanych protokołów. Można również łatwo pracować z wieloma wersjami powiązanie side-by-side, zapewniając każdej wersji inną nazwę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.Binding.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan SendTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia interwał przeznaczony na zakończenie przed transportu zgłasza wyjątek operacji zapisu.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu operacji zapisu. Wartość domyślna to 1 minutę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli przepływu transakcji jest włączony na powiązanie lub kanału, operacja może trwać dłużej wykonać niż określony limit czasu. W takiej sytuacji, który kończy się niepowodzeniem z powodu wygasły limitu czasu i transakcji przerywa odpowiednio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza niż zero lub jest zbyt duży.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.ShouldSerializeName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeName();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy nazwę powiązania, powinny być serializowane.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwa powiązanie powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeNamespace">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeNamespace ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeNamespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.Binding.ShouldSerializeNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeNamespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeNamespace();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy powinny być serializowane przestrzeni nazw powiązania.</summary>
        <returns>
          <see langword="true" /> Jeśli przestrzeń nazw powiązanie powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
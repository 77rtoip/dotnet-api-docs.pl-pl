<Type Name="ChannelBase" FullName="System.ServiceModel.Channels.ChannelBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d479ae325bd1f4692cd83d0ff4643b5b53a8f976" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51309147" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ChannelBase : System.ServiceModel.Channels.CommunicationObject, System.ServiceModel.Channels.IChannel, System.ServiceModel.IDefaultCommunicationTimeouts" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChannelBase extends System.ServiceModel.Channels.CommunicationObject implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject, class System.ServiceModel.IDefaultCommunicationTimeouts" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.ChannelBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChannelBase&#xA;Inherits CommunicationObject&#xA;Implements IChannel, IDefaultCommunicationTimeouts" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChannelBase abstract : System::ServiceModel::Channels::CommunicationObject, System::ServiceModel::Channels::IChannel, System::ServiceModel::IDefaultCommunicationTimeouts" />
  <TypeSignature Language="F#" Value="type ChannelBase = class&#xA;    inherit CommunicationObject&#xA;    interface ICommunicationObject&#xA;    interface IChannel&#xA;    interface IDefaultCommunicationTimeouts" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.CommunicationObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.ICommunicationObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.IDefaultCommunicationTimeouts</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia implementację podstawową dla kanałów niestandardowych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 <xref:System.ServiceModel.Channels.ChannelBase> Klasa zawiera implementację abstrakcyjna klasa bazowa <xref:System.ServiceModel.Channels.IChannel> interfejsu. Wymaga również, że każdy kanał wiązać się z Menedżera kanałów. Należy pamiętać, że tylko konstruktorem dostępnych do tworzenia wystąpień <xref:System.ServiceModel.Channels.ChannelBase> wymaga `channelManager` parametr wejściowy.  
  
 Zmiany stanu są zarządzane przez dziedziczenie z <xref:System.ServiceModel.Channels.CommunicationObject> implementacji automatu stanów.  
  
 <xref:System.ServiceModel.Channels.ChannelBase> Pobiera limity czasu jego domyślne komunikacji dla otwarte, zamknij operacji wysyłania i odbierania z <xref:System.ServiceModel.Channels.ChannelManagerBase> skojarzonych z nim.  
  
 <xref:System.ServiceModel.Channels.ChannelBase> Zarządza także menedżera dla Ciebie. Oprócz udostępniania odwołania do menedżera, klasa bazowa również powiadamia menedżera, gdy kanały są tworzone i niszczone. Ale odwołania do Menedżera nadaje się tylko do momentu zniszczenia jest kanału.  
  
 Nawet wtedy, gdy jest używana klasa bazowa, nadal musisz podać zachowania do otwierania i zamykania kanału. Domyślna implementacja metody te nie zawierają przydatne informacje.  
  
 Należy również upewnić się zastąpić <xref:System.ServiceModel.Channels.ChannelBase.GetProperty%2A> zawsze, gdy należy zaimplementować kanał. <xref:System.ServiceModel.Channels.ChannelBase.GetProperty%2A> to świetny sposób przekazywania informacji wzdłuż stosu kanału bez znajomości kanały są poniżej lub kanały co powyżej, które może wykonywać zapytania. Definiowanie interfejsów, które można wykonywać zapytania, aby uzyskać informacje o dostępnych. Zawsze, gdy nie rozpoznają typ argumentu dla <xref:System.ServiceModel.Channels.ChannelBase.GetProperty%2A>delegować do następnego kanału w stosie i zwraca `null` Jeśli tworzysz nowy kanał transportu na dole stosu.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChannelBase (System.ServiceModel.Channels.ChannelManagerBase channelManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Channels.ChannelManagerBase channelManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ChannelBase.#ctor(System.ServiceModel.Channels.ChannelManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (channelManager As ChannelManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChannelBase(System::ServiceModel::Channels::ChannelManagerBase ^ channelManager);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Channels.ChannelBase : System.ServiceModel.Channels.ChannelManagerBase -&gt; System.ServiceModel.Channels.ChannelBase" Usage="new System.ServiceModel.Channels.ChannelBase channelManager" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="channelManager" Type="System.ServiceModel.Channels.ChannelManagerBase" />
      </Parameters>
      <Docs>
        <param name="channelManager">
          <see cref="T:System.ServiceModel.Channels.ChannelManagerBase" /> Zapewnia domyślne przekroczeń limitu czasu operacji kanału (wysyłanie, odbieranie, Otwórz i zamknij).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.ChannelBase" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że tylko konstruktorem dostępnych do tworzenia wystąpień <xref:System.ServiceModel.Channels.ChannelBase> wymaga `channelManager` parametr wejściowy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="channelManager" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultCloseTimeout">
      <MemberSignature Language="C#" Value="protected internal override TimeSpan DefaultCloseTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultCloseTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ChannelBase.DefaultCloseTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property DefaultCloseTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property TimeSpan DefaultCloseTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCloseTimeout : TimeSpan" Usage="System.ServiceModel.Channels.ChannelBase.DefaultCloseTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny interwał czasu przewidzianego na zakończenie operacji zamknięcia.</summary>
        <value>Wartość domyślna <see cref="T:System.TimeSpan" /> określający, jak długo operację zamknięcia musi ukończyć przed przekroczeniem limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobiera <xref:System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout%2A> skojarzony <xref:System.ServiceModel.Channels.ChannelBase.Manager%2A> dla kanału.  
  
 Wszystkie operacje, które są potencjalnie długotrwałej musi mieć limitu czasu. Metody, które nie przyjmują jawne przekroczeń limitu czasu, musi delegować do tych metod przy użyciu domyślnego przekroczeń limitu czasu lub musi wykonać dowolną działają, które blokuje. Limity czasu to łączny limit operacji wysokiego poziomu, do których prowadzą do ukończenia, więc dowolnego powtórzeń muszą być ograniczone do czasu nie jest jeszcze dostępne dla wcześniejszych prób.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultOpenTimeout">
      <MemberSignature Language="C#" Value="protected internal override TimeSpan DefaultOpenTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultOpenTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ChannelBase.DefaultOpenTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property DefaultOpenTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property TimeSpan DefaultOpenTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultOpenTimeout : TimeSpan" Usage="System.ServiceModel.Channels.ChannelBase.DefaultOpenTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny interwał czasu przewidzianego na zakończenie operacji Otwórz.</summary>
        <value>Wartość domyślna <see cref="T:System.TimeSpan" /> określający, ile operacji otwierania musi ukończyć przed przekroczeniem limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobiera <xref:System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout%2A> skojarzony <xref:System.ServiceModel.Channels.ChannelBase.Manager%2A> dla kanału.  
  
 Wszystkie operacje, które są potencjalnie długotrwałej musi mieć limitu czasu. Metody, które nie przyjmują jawne przekroczeń limitu czasu, musi delegować do tych metod przy użyciu domyślnego przekroczeń limitu czasu lub musi wykonać dowolną działają, które blokuje. Limity czasu to łączny limit operacji wysokiego poziomu, do których prowadzą do ukończenia, więc dowolnego powtórzeń muszą być ograniczone do czasu nie jest jeszcze dostępne dla wcześniejszych prób.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultReceiveTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan DefaultReceiveTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ChannelBase.DefaultReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DefaultReceiveTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property TimeSpan DefaultReceiveTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultReceiveTimeout : TimeSpan" Usage="System.ServiceModel.Channels.ChannelBase.DefaultReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny interwał czasu przewidzianego na ukończenie operacji odbierania.</summary>
        <value>Wartość domyślna <see cref="T:System.TimeSpan" /> określający, ile operacji odbierania musi ukończyć przed przekroczeniem limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobiera <xref:System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout%2A> skojarzony <xref:System.ServiceModel.Channels.ChannelBase.Manager%2A> dla kanału.  
  
 Wszystkie operacje, które są potencjalnie długotrwałej musi mieć limitu czasu. Metody, które nie przyjmują jawne przekroczeń limitu czasu, musi delegować do tych metod przy użyciu domyślnego przekroczeń limitu czasu lub musi wykonać dowolną działają, które blokuje. Limity czasu to łączny limit operacji wysokiego poziomu, do których prowadzą do ukończenia, więc dowolnego powtórzeń muszą być ograniczone do czasu nie jest jeszcze dostępne dla wcześniejszych prób.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSendTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan DefaultSendTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultSendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ChannelBase.DefaultSendTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DefaultSendTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property TimeSpan DefaultSendTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSendTimeout : TimeSpan" Usage="System.ServiceModel.Channels.ChannelBase.DefaultSendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny interwał czasu przewidzianego na ukończenie operacji wysyłania.</summary>
        <value>Wartość domyślna <see cref="T:System.TimeSpan" /> określający, ile operacji wysyłania musi ukończyć przed przekroczeniem limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobiera <xref:System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout%2A> skojarzony <xref:System.ServiceModel.Channels.ChannelBase.Manager%2A> dla kanału.  
  
 Wszystkie operacje, które są potencjalnie długotrwałej musi mieć limitu czasu. Metody, które nie przyjmują jawne przekroczeń limitu czasu, musi delegować do tych metod przy użyciu domyślnego przekroczeń limitu czasu lub musi wykonać dowolną działają, które blokuje. Limity czasu to łączny limit operacji wysokiego poziomu, do których prowadzą do ukończenia, więc dowolnego powtórzeń muszą być ograniczone do czasu nie jest jeszcze dostępne dla wcześniejszych prób.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public virtual T GetProperty&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!T GetProperty&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ChannelBase.GetProperty``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProperty(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class virtual T GetProperty();" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : unit -&gt; 'T (requires 'T : null)&#xA;override this.GetProperty : unit -&gt; 'T (requires 'T : null)" Usage="channelBase.GetProperty " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Channels.IChannel.GetProperty``1</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typizowany obiekt, dla której metodę wykonywania zapytań.</typeparam>
        <summary>Zwraca typizowany obiekt wymagane, jeśli jest obecny, z odpowiednią warstwę stosu kanału.</summary>
        <returns>Typizowany obiekt <paramref name="T" /> wymagane, jeśli jest obecny, lub <see langword="null" />, jeśli nie jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Umożliwia to żądanie typizowany obiekt, takich jak interfejs do ustawiania właściwości lub pobierania stanu z odpowiednią warstwę stosu kanału. Jeśli warstwa obsługuje zwraca żądany obiekt, zwraca go. W przeciwnym razie deleguje ona wywołania do następnej warstwy ze stosu. Jeśli otrzymuje na dole stosu i nie warstwy kanału obsługiwane żądany obiekt, a następnie metoda zwraca `null`.  
  
 Należy również upewnić się zastąpić <xref:System.ServiceModel.Channels.ChannelBase.GetProperty%2A> zawsze, gdy należy zaimplementować kanał. <xref:System.ServiceModel.Channels.ChannelBase.GetProperty%2A> to świetny sposób przekazywania informacji wzdłuż stosu kanału bez znajomości kanały są poniżej lub kanały co powyżej, które może wykonywać zapytania. Definiowanie interfejsów, które można wykonywać zapytania, aby uzyskać informacje o dostępnych. Zawsze, gdy nie rozpoznają typ argumentu dla <xref:System.ServiceModel.Channels.ChannelBase.GetProperty%2A>delegować do następnego kanału w stosie i zwraca `null` Jeśli tworzysz nowy kanał transportu na dole stosu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Manager">
      <MemberSignature Language="C#" Value="protected System.ServiceModel.Channels.ChannelManagerBase Manager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.ChannelManagerBase Manager" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ChannelBase.Manager" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Manager As ChannelManagerBase" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ServiceModel::Channels::ChannelManagerBase ^ Manager { System::ServiceModel::Channels::ChannelManagerBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Manager : System.ServiceModel.Channels.ChannelManagerBase" Usage="System.ServiceModel.Channels.ChannelBase.Manager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.ChannelManagerBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Menedżera kanału, który jest skojarzony z bieżącym kanału.</summary>
        <value>
          <see cref="T:System.ServiceModel.Channels.ChannelManagerBase" /> Skojarzonego z bieżącego kanału.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy <xref:System.ServiceModel.Channels.ChannelBase> musi mieć <xref:System.ServiceModel.Channels.ChannelManagerBase> skojarzonych z nim.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected override void OnClosed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClosed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ChannelBase.OnClosed" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnClosed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnClosed();" />
      <MemberSignature Language="F#" Value="override this.OnClosed : unit -&gt; unit" Usage="channelBase.OnClosed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używa śledzenia diagnostycznego podczas przejścia w stan zamknięcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zarezerwowana do użycia przez system i nie powinno być wywołane przez użytkownika.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout">
      <MemberSignature Language="C#" Value="TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ChannelBase.System#ServiceModel#IDefaultCommunicationTimeouts#CloseTimeout" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CloseTimeout As TimeSpan Implements IDefaultCommunicationTimeouts.CloseTimeout" />
      <MemberSignature Language="C++ CLI" Value="property TimeSpan System::ServiceModel::IDefaultCommunicationTimeouts::CloseTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Usage="System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przedział czasu, po którym close — metoda wywoływana przez obiekt komunikacji upłynie limit czasu.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu oczekiwania na metody close przekroczenie limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.ChannelBase.System%23ServiceModel%23IDefaultCommunicationTimeouts%23CloseTimeout%2A> wywołania <xref:System.ServiceModel.Channels.ChannelBase.DefaultCloseTimeout%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout">
      <MemberSignature Language="C#" Value="TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ChannelBase.System#ServiceModel#IDefaultCommunicationTimeouts#OpenTimeout" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property OpenTimeout As TimeSpan Implements IDefaultCommunicationTimeouts.OpenTimeout" />
      <MemberSignature Language="C++ CLI" Value="property TimeSpan System::ServiceModel::IDefaultCommunicationTimeouts::OpenTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Usage="System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przedział czasu, po czym otwórz metody wywoływane przez obiekt komunikacji upłynie limit czasu.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> , Która określa czas oczekiwania w metodzie otwartych przekroczenie limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.ChannelBase.System%23ServiceModel%23IDefaultCommunicationTimeouts%23OpenTimeout%2A> wywołania <xref:System.ServiceModel.Channels.ChannelBase.DefaultOpenTimeout%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout">
      <MemberSignature Language="C#" Value="TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ChannelBase.System#ServiceModel#IDefaultCommunicationTimeouts#ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ReceiveTimeout As TimeSpan Implements IDefaultCommunicationTimeouts.ReceiveTimeout" />
      <MemberSignature Language="C++ CLI" Value="property TimeSpan System::ServiceModel::IDefaultCommunicationTimeouts::ReceiveTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Usage="System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przedział czasu, po upływie limitu czasu metody receive wywołany przez obiekt komunikacji.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu oczekiwania na metody receive przekroczenie limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.ChannelBase.System%23ServiceModel%23IDefaultCommunicationTimeouts%23ReceiveTimeout%2A> wywołania <xref:System.ServiceModel.Channels.ChannelBase.DefaultReceiveTimeout%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout">
      <MemberSignature Language="C#" Value="TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ChannelBase.System#ServiceModel#IDefaultCommunicationTimeouts#SendTimeout" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SendTimeout As TimeSpan Implements IDefaultCommunicationTimeouts.SendTimeout" />
      <MemberSignature Language="C++ CLI" Value="property TimeSpan System::ServiceModel::IDefaultCommunicationTimeouts::SendTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Usage="System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przedział czasu, po upływie limitu czasu metody send wywołany przez obiekt komunikacji.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu oczekiwania na metody send przekroczenie limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.ChannelBase.System%23ServiceModel%23IDefaultCommunicationTimeouts%23SendTimeout%2A> wywołania <xref:System.ServiceModel.Channels.ChannelBase.DefaultSendTimeout%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
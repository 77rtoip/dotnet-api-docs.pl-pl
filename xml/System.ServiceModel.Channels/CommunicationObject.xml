<Type Name="CommunicationObject" FullName="System.ServiceModel.Channels.CommunicationObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bc1ccd681ed4246ff719dda7318566a403a30547" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34317311" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CommunicationObject : System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CommunicationObject extends System.Object implements class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.CommunicationObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CommunicationObject&#xA;Implements ICommunicationObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class CommunicationObject abstract : System::ServiceModel::ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.ICommunicationObject</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia typowe Podstawowa implementacja dla komputera stanu podstawowe wspólne dla wszystkich obiektów zorientowane na komunikacji w systemie, w tym kanałów i odbiorników, fabryki kanału i odbiornika.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject> Klasa implementuje <xref:System.ServiceModel.ICommunicationObject> interfejs dla wszystkich obiektów komunikacyjnych w systemie Windows Communication Foundation (WCF). Implementacje metod obsługi sprawdzanie poprawności parametru, zgłoś zdarzenia, które wystąpienie przejścia stanów Powiadamiaj, podaj sposób dodatkowego przetwarzania skojarzone z tymi przejść stanu i upewnij się, że takie zmiany stanu są skoordynowane.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.CommunicationObject" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CommunicationObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CommunicationObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.CommunicationObject" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CommunicationObject (object mutex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object mutex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (mutex As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CommunicationObject(System::Object ^ mutex);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mutex" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mutex">Wykluczają się wzajemnie blokada chroniącego wystąpienie klasy podczas przejścia stanu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.CommunicationObject" /> klasy wykluczają się wzajemnie blokada ochrony przejścia do stanu określony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Abort();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Abort</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że obiekt komunikacyjny przejście bezpośrednio z jego bieżącym stanie w stan zamknięcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody oznacza, że wszystkie — Praca nieukończona powinien ignorowane, lub ungracefully zakończone przed zwróceniem. <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A> Metody można użyć do anulowania oczekujących operacji, w tym wywołania oczekujące <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A>.  
  
 Do poprawnego działania przejścia <xref:System.ServiceModel.Channels.CommunicationObject> z dowolnej innej niż stan <xref:System.ServiceModel.CommunicationState.Closed> do <xref:System.ServiceModel.CommunicationState.Closed> stanu, należy wywołać <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> lub jednej z jego asynchronicznych wersji <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginClose">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną, aby zamknąć obiektu komunikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginClose">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginClose (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginClose(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginClose(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginClose (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginClose(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginClose(System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu asynchroniczną operację zamknięcia.</param>
        <param name="state">Obiekt określony przez aplikację, który zawiera informacje o stanie skojarzone z asynchroniczną operację zamknięcia.</param>
        <summary>Rozpoczyna operację asynchroniczną, aby zamknąć obiektu komunikacji.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się asynchroniczną operację zamknięcia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje <xref:System.ServiceModel.Channels.CommunicationObject> do poprawnego działania innych niż przejścia z dowolnego stanu <xref:System.ServiceModel.CommunicationState.Closed> stanu do <xref:System.ServiceModel.CommunicationState.Closed> stanu w domyślny interwał czasu. <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> Metoda pozwala niedokończone pracę, należy wykonać przed zwróceniem. Na przykład wysyła komunikaty buforowanego Zakończ). Ta metoda wywołuje <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Jeśli obiekt komunikacyjny został początkowo w <xref:System.ServiceModel.CommunicationState.Opened> stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginClose">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginClose (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginClose(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginClose (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginClose(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginClose(System.TimeSpan,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu operacji zamknięcia.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu asynchroniczną operację zamknięcia.</param>
        <param name="state">Obiekt określony przez aplikację, który zawiera informacje o stanie skojarzone z asynchroniczną operację zamknięcia.</param>
        <summary>Rozpoczyna operację asynchroniczną, aby zamknąć obiekt komunikacji z określonego limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się asynchroniczną operację zamknięcia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje <xref:System.ServiceModel.Channels.CommunicationObject> do poprawnego działania innych niż przejścia z dowolnego stanu <xref:System.ServiceModel.CommunicationState.Closed> stanu do <xref:System.ServiceModel.CommunicationState.Closed> stanu z w określonym przedziale czasu.  <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> Metoda pozwala niedokończone pracę, należy wykonać przed zwróceniem. Na przykład wysyła komunikaty buforowanego Zakończ). Ta metoda wywołuje <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginClose%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Jeśli obiekt komunikacyjny został początkowo w <xref:System.ServiceModel.CommunicationState.Opened> stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginOpen">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną można otworzyć obiektu komunikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginOpen">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginOpen (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginOpen(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginOpen(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginOpen (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginOpen(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginOpen(System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o ukończeniu operacji asynchronicznej open.</param>
        <param name="state">Obiekt określony przez aplikację, który zawiera informacje o stanie skojarzone z operacji asynchronicznej open.</param>
        <summary>Rozpoczyna operację asynchroniczną można otworzyć obiektu komunikacji.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Otwórz operację asynchroniczną, która odwołuje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> i <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Jeśli obiekt komunikacji jest początkowo w <xref:System.ServiceModel.CommunicationState.Created> stanu.  
  
 Aby wstawić przetwarzania po obiektu komunikacji przechodzi do stanu zamknięcia z powodu wywołania synchronicznego <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> operacji, użyj <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginOpen">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginOpen (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginOpen(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginOpen (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginOpen(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu operacji wysyłania.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o ukończeniu operacji asynchronicznej open.</param>
        <param name="state">Obiekt określony przez aplikację, który zawiera informacje o stanie skojarzone z operacji asynchronicznej open.</param>
        <summary>Rozpoczyna operację asynchroniczną można otworzyć obiektu komunikacji w określonym interwale czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Otwórz operację asynchroniczną, która odwołuje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> i <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Jeśli obiekt komunikacji jest początkowo w <xref:System.ServiceModel.CommunicationState.Created> stanu.  
  
 Aby wstawić przetwarzania po obiektu komunikacji przechodzi do stanu zamknięcia z powodu wywołania synchronicznego <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> operacji, użyj <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że obiekt komunikacyjny przejście od bieżącego stanu w stanie zamkniętym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że obiekt komunikacyjny przejście od bieżącego stanu w stanie zamkniętym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje <xref:System.ServiceModel.Channels.CommunicationObject> do poprawnego działania innych niż przejścia z dowolnego stanu <xref:System.ServiceModel.CommunicationState.Closed> stanu do <xref:System.ServiceModel.CommunicationState.Closed> stanu. <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> Metoda pozwala niedokończone pracę, należy wykonać przed zwróceniem. Na przykład wysyłanie ukończone komunikaty buforowany.  
  
 <xref:System.ServiceModel.Channels.CommunicationObject> Wprowadza <xref:System.ServiceModel.CommunicationState.Closing> stanu i pozostaje w nim po <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> metoda jest wywoływana do przejścia do <xref:System.ServiceModel.CommunicationState.Closed> stanu zostało zakończone. Przejście polega na kolejnych wywołaniach <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%28System.TimeSpan%29>, i <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A>.  
  
 Istnieje również asynchroniczną wersję inicjowanego przez wywołanie metody close <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Close(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Close(System.TimeSpan)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu operacji zamknięcia.</param>
        <summary>Powoduje, że obiekt komunikacyjny przejście od bieżącego stanu w stanie zamkniętym w określonym interwale czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje <xref:System.ServiceModel.Channels.CommunicationObject> do poprawnego działania innych niż przejścia z dowolnego stanu <xref:System.ServiceModel.CommunicationState.Closed> stanu do <xref:System.ServiceModel.CommunicationState.Closed> stanu w określonym interwale czasu. <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> Metoda pozwala niedokończone pracę, należy wykonać przed zwróceniem. Na przykład wysyłanie ukończone komunikaty buforowany.  
  
 <xref:System.ServiceModel.Channels.CommunicationObject> Wprowadza <xref:System.ServiceModel.CommunicationState.Closing> stanu i pozostaje w nim po <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> metoda jest wywoływana do przejścia do <xref:System.ServiceModel.CommunicationState.Closed> stanu zostało zakończone. Przejście polega na kolejnych wywołaniach <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%28System.TimeSpan%29> i <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A>.  
  
 Istnieje również asynchroniczną wersję inicjowanego przez wywołanie metody close <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Closed;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Closed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy obiekt komunikacyjny przejścia w stanie zamkniętym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Closed> Zdarzenie jest wywoływane przez <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A> metodę, która jest wywoływana przez <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> i <xref:System.ServiceModel.Channels.CommunicationObject.EndClose%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event EventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Closing;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Closing</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy obiekt komunikacyjny przechodzi w stan zamknięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Closing> Zdarzenie jest wywoływane przez <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A> metodę, która jest wywoływana przez <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> i <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCloseTimeout">
      <MemberSignature Language="C#" Value="protected internal abstract TimeSpan DefaultCloseTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultCloseTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride ReadOnly Property DefaultCloseTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract property TimeSpan DefaultCloseTimeout { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera domyślny interwał przeznaczony na zakończenie operacji zamknięcia.</summary>
        <value>Wartość domyślna <see cref="T:System.TimeSpan" /> określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu operacji zamknięcia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultOpenTimeout">
      <MemberSignature Language="C#" Value="protected internal abstract TimeSpan DefaultOpenTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultOpenTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride ReadOnly Property DefaultOpenTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract property TimeSpan DefaultOpenTimeout { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera domyślny interwał przeznaczony na zakończenie operacji otwarcia.</summary>
        <value>Wartość domyślna <see cref="T:System.TimeSpan" /> określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu operacji otwarcia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndClose">
      <MemberSignature Language="C#" Value="public void EndClose (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndClose(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.EndClose(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndClose (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndClose(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.EndClose(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który jest zwracany przez wywołanie do <see cref="Overload:System.ServiceModel.Channels.CommunicationObject.BeginClose" /> metody.</param>
        <summary>Kończy operację asynchroniczną, aby zamknąć obiektu komunikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Synchroniczną wersję tej metody jest zapewniana przez <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndOpen">
      <MemberSignature Language="C#" Value="public void EndOpen (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndOpen(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.EndOpen(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndOpen (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndOpen(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.EndOpen(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który jest zwracany przez wywołanie do <see cref="Overload:System.ServiceModel.Channels.CommunicationObject.BeginClose" /> metody.</param>
        <summary>Kończy operację asynchroniczną można otworzyć obiektu komunikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Synchroniczną wersję tej metody jest zapewniana przez <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fault">
      <MemberSignature Language="C#" Value="protected void Fault ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Fault() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Fault" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Fault ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Fault();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że obiekt komunikacyjny przejście od bieżącego stanu w nieprawidłowy stan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Faulted> Zdarzenie jest wywoływane przez <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A> metodę, która jest wywoływana przez <xref:System.ServiceModel.Channels.CommunicationObject.Fault%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Faulted">
      <MemberSignature Language="C#" Value="public event EventHandler Faulted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Faulted" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Faulted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Faulted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Faulted;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Faulted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy obiekt komunikacyjny przechodzi w stan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Faulted> Zdarzenie jest wywoływane przez <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A> metodę, która jest wywoływana przez <xref:System.ServiceModel.Channels.CommunicationObject.Fault%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommunicationObjectType">
      <MemberSignature Language="C#" Value="protected virtual Type GetCommunicationObjectType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetCommunicationObjectType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.GetCommunicationObjectType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetCommunicationObjectType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetCommunicationObjectType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ obiektu komunikacji.</summary>
        <returns>Typ obiektu komunikacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="protected bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt komunikacji został usunięty.</summary>
        <value>
          <see langword="true" /> Jeśli obiekt komunikacji jest w stanie zamkniętym; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt jest traktowany jako usunięty po <xref:System.ServiceModel.Channels.CommunicationObject.Closed> zdarzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAbort">
      <MemberSignature Language="C#" Value="protected abstract void OnAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnAbort" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnAbort ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnAbort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstawia przetwarzania obiektu komunikacji po jego przechodzi w stan zamknięcia z powodu wywołania przerwania synchronicznych operacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A> Jeśli obiekt komunikacja nie jest już w <xref:System.ServiceModel.CommunicationState.Closed> stanu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginClose">
      <MemberSignature Language="C#" Value="protected abstract IAsyncResult OnBeginClose (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult OnBeginClose(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnBeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function OnBeginClose (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract IAsyncResult ^ OnBeginClose(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu na operację zamknięcia.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu asynchronicznej operacji zamknięcia.</param>
        <param name="state">Obiekt określony przez aplikację, zawierający informacje o stanie skojarzone z asynchronicznej operacji zamknięcia.</param>
        <summary>Operacja zamykania wstawia przetwarzania po komunikacji obiektu przejścia do stanu zamknięcia z powodu wywołania asynchronicznego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołuje się asynchronicznej operacji zamknięcia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginClose%2A> Jeśli obiekt komunikacji jest początkowo w <xref:System.ServiceModel.CommunicationState.Opened> stanu.  
  
 Aby wstawić przetwarzania po obiektu komunikacji przechodzi do stanu zamknięcia z powodu wywołania synchronicznego <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> operacji, użyj <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%28System.TimeSpan%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnBeginOpen">
      <MemberSignature Language="C#" Value="protected abstract IAsyncResult OnBeginOpen (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult OnBeginOpen(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function OnBeginOpen (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract IAsyncResult ^ OnBeginOpen(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo na operacja otwierania musi zostać ukończona przed przekroczeniem limitu czasu.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, która odbiera powiadomienia o zakończeniu asynchronicznej operacji otwarte.</param>
        <param name="state">Obiekt określony przez aplikację, zawierający informacje o stanie skojarzone z asynchronicznych w operacji otwarcia.</param>
        <summary>Wstawia przetwarzania obiektu komunikacji po jego przechodzi w stan otwarcia, ze względu na wywołania operacji asynchronicznej open.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołuje się asynchronicznych w operacji otwarcia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wstawić przetwarzania po obiektu komunikacji przechodzi do stanu otwarcia z powodu wywołania synchronicznego <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> operacji, użyj <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnClose">
      <MemberSignature Language="C#" Value="protected abstract void OnClose (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClose(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnClose(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnClose (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnClose(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu na operację zamknięcia.</param>
        <summary>Operacja zamykania wstawia przetwarzania obiektu komunikacji po jego przechodzi w stan zamknięcia z powodu wywołania synchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A> Jeśli obiekt komunikacji jest początkowo w <xref:System.ServiceModel.CommunicationState.Opened> stanu.  
  
 Aby wstawić przetwarzania po obiektu komunikacji przechodzi do stanu zamknięcia z powodu wywołania asynchronicznego <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> operacji, użyj <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginClose%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">
          <see cref="Overload:System.ServiceModel.Channels.CommunicationObject.Close" /> została wywołana dla obiekt w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
        <exception cref="T:System.ServiceModel.CommunicationException">Wystąpił błąd komunikacji podczas zamykania obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnClosed" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane podczas przejścia obiektu komunikacji w stan zamknięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A> Jeśli obiekt komunikacji jest początkowo w <xref:System.ServiceModel.CommunicationState.Opened> stanu.  
  
 <xref:System.ServiceModel.Channels.CommunicationObject.EndClose%2A> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A> (i <xref:System.ServiceModel.Channels.CommunicationObject.OnEndClose%28System.IAsyncResult%29> Jeśli obiekt komunikacja nie jest już w <xref:System.ServiceModel.CommunicationState.Closed> stanu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnClosing" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane podczas przejścia obiektu komunikacji w stan zamknięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A> Jeśli obiekt komunikacji jest początkowo w <xref:System.ServiceModel.CommunicationState.Opened> stanu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndClose">
      <MemberSignature Language="C#" Value="protected abstract void OnEndClose (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEndClose(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnEndClose(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnEndClose (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnEndClose(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który jest zwracany przez wywołanie do <see cref="M:System.ServiceModel.Channels.CommunicationObject.OnEndClose(System.IAsyncResult)" /> metody.</param>
        <summary>Kończy operację asynchroniczną na zamknięcia obiektu komunikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.EndClose%28System.IAsyncResult%29> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnEndClose%28System.IAsyncResult%29> Jeśli obiekt komunikacja nie jest już w <xref:System.ServiceModel.CommunicationState.Closed> stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnEndOpen">
      <MemberSignature Language="C#" Value="protected abstract void OnEndOpen (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEndOpen(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnEndOpen(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnEndOpen (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnEndOpen(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który jest zwracany przez wywołanie do <see cref="M:System.ServiceModel.Channels.CommunicationObject.OnEndOpen(System.IAsyncResult)" /> metody.</param>
        <summary>Kończy operację asynchroniczną na otwieranie obiektu komunikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnEndOpen%2A> (i <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnFaulted">
      <MemberSignature Language="C#" Value="protected virtual void OnFaulted ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFaulted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnFaulted" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFaulted ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFaulted();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstawia przetwarzania obiektu komunikacji po jego przechodzi w stan z powodu wywołania operacji synchronicznych błędów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Faulted> Zdarzenie jest wywoływane przez <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A> metodę, która jest wywoływana przez <xref:System.ServiceModel.Channels.CommunicationObject.Fault%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpen">
      <MemberSignature Language="C#" Value="protected abstract void OnOpen (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnOpen(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnOpen(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnOpen (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnOpen(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo na operacja otwierania musi zostać ukończona przed przekroczeniem limitu czasu.</param>
        <summary>Wstawia przetwarzania obiektu komunikacji po jego przechodzi w stan otwarcia, które należy wykonać w określonym interwale czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> Wywołania metody <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%28System.TimeSpan%29> (po wywołaniu <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> i przed wywołaniem <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>) Jeśli obiekt komunikacji jest początkowo w <xref:System.ServiceModel.CommunicationState.Created> stanu.  
  
 Aby wstawić przetwarzania jako komunikacji obiektu przejścia do stanu otwarcia z powodu wywołania asynchronicznego <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> operacji, użyj <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnOpened">
      <MemberSignature Language="C#" Value="protected virtual void OnOpened ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnOpened() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnOpened" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnOpened ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnOpened();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane podczas przejścia obiektu komunikacji w stanie otwartym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dzięki temu można dodać przetwarzania, gdy jest wywoływana przez <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> i <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnOpening ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnOpening() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnOpening" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnOpening ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnOpening();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane podczas przejścia obiektu komunikacyjnego do otwarcia stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dzięki temu można dodać przetwarzania, gdy jest wywoływana przez <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> i <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że obiekt komunikacyjny przejście ze stanu utworzonej w stanie otwartym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> metody powoduje, że <xref:System.ServiceModel.Channels.CommunicationObject> wejścia <xref:System.ServiceModel.CommunicationState.Opening> stanu i wywołania <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>, i <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>.  <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A> Ukończeniu metody <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> metody ustawiania stanu obiektu do <xref:System.ServiceModel.CommunicationState.Opened> stanu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Open();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Open</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że obiekt komunikacyjny przejście ze stanu utworzonej w stanie otwartym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.ServiceModel.Channels.CommunicationObject> jest uruchomiony, zaczyna się w <xref:System.ServiceModel.CommunicationState.Created> stanu. W <xref:System.ServiceModel.CommunicationState.Created> stanu, można skonfigurować obiektu (na przykład można ustawić właściwości lub zdarzenia może być zarejestrowany), ale nie jest jeszcze używany do wysyłania i odbierania wiadomości. Po wywołaniu <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> metody powoduje, że <xref:System.ServiceModel.Channels.CommunicationObject> wejścia <xref:System.ServiceModel.CommunicationState.Opening> stanu i wywołania <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>, i <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>. <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A> Ukończeniu metody <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> metody ustawiania stanu obiektu do <xref:System.ServiceModel.CommunicationState.Opened> stanu.  
  
 W  
  
 <xref:System.ServiceModel.CommunicationState.Opened> Stan, <xref:System.ServiceModel.Channels.CommunicationObject> można używać (na przykład wiadomości mogą być odbierane), ale go nie będzie już można skonfigurować.  
  
 Istnieje również asynchroniczną wersję inicjowanego przez wywołanie metody open <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> oraz zostać zakończona, wywołując <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A>.  
  
### <a name="credentials-capture-with-windows-authentication"></a>Przechwytywanie poświadczenia z uwierzytelnianiem systemu Windows  
 Podczas korzystania z uwierzytelniania systemu Windows, poświadczenia używane przez usługę są oparte na bieżący wątek kontekstu. Poświadczenia są uzyskiwane podczas `Open` metoda jest wywoływana.  
  
> [!NOTE]
>  Dla wywołania asynchroniczne są przechwytywane poświadczeń podczas <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> jest wywoływana. Jednak nie można zagwarantować rzeczywiste poświadczeń. Oznacza to, że poświadczenia obiektu wywołującego może być przełączane tożsamość. Aby uzyskać więcej informacji, zobacz [Zabezpieczanie komunikatów za pomocą klienta systemu Windows](~/docs/framework/wcf/feature-details/message-security-with-a-windows-client.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
        <altmember cref="M:System.ServiceModel.Channels.CommunicationObject.BeginOpen(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Open(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Open(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Open(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Open(System.TimeSpan)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Określający, jak długo ma zostać ukończona przed przekroczeniem limitu czasu operacji otwarcia.</param>
        <summary>Powoduje, że obiekt komunikacyjny przejście ze stanu utworzonej w stanie otwartym w określonym interwale czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.ServiceModel.Channels.CommunicationObject> jest uruchomiony, zaczyna się w <xref:System.ServiceModel.CommunicationState.Created> stanu. W <xref:System.ServiceModel.CommunicationState.Created> stanu, można skonfigurować obiektu (na przykład można ustawić właściwości lub zdarzenia może być zarejestrowany), ale nie jest jeszcze używany do wysyłania i odbierania wiadomości. Po wywołaniu <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> metody powoduje, że <xref:System.ServiceModel.Channels.CommunicationObject> wejścia <xref:System.ServiceModel.CommunicationState.Opening> stanu i wywołania <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>, i <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>.  <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A> Ukończeniu metody <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> metody ustawiania stanu obiektu do <xref:System.ServiceModel.CommunicationState.Opened> stanu.  
  
 W  
  
 <xref:System.ServiceModel.CommunicationState.Opened> Stan, <xref:System.ServiceModel.Channels.CommunicationObject> można używać (na przykład wiadomości mogą być odbierane), ale go nie będzie już można skonfigurować.  
  
 Istnieje również asynchroniczną wersję inicjowanego przez wywołanie metody open <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> oraz zostać zakończona, wywołując <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opened" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.TimeoutException">Domyślny interwał czasu, która została przydzielona dla operacji został przekroczony przed ukończeniem operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Opened">
      <MemberSignature Language="C#" Value="public event EventHandler Opened;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Opened" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Opened" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Opened As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Opened;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Opened</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy obiekt komunikacyjny przejścia w stanie otwartym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Opened> Zdarzenie jest wywoływane przez <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> metodę, która jest wywoływana przez <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> i <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Opening">
      <MemberSignature Language="C#" Value="public event EventHandler Opening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Opening" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Opening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Opening As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Opening;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Opening</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy obiekt komunikacyjny przechodzi w stan otwarcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Opening> Zdarzenie jest wywoływane przez <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> metodę, która jest wywoływana przez <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> i <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public System.ServiceModel.CommunicationState State { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.CommunicationState State" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.State" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property State As CommunicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::CommunicationState State { System::ServiceModel::CommunicationState get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.ICommunicationObject.State</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.CommunicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje bieżący stan obiektu komunikacji.</summary>
        <value>Wartość z zakresu od <see cref="T:System.ServiceModel.CommunicationState" /> wyliczenia, która wskazuje bieżący stan obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThisLock">
      <MemberSignature Language="C#" Value="protected object ThisLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ThisLock" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.ThisLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ThisLock As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ ThisLock { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera blokady wykluczają się wzajemnie, która chroni wystąpienie klasy podczas przejścia stanu.</summary>
        <value>Wykluczają się wzajemnie blokada chroniącego wystąpienie klasy podczas przejścia stanu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfDisposed">
      <MemberSignature Language="C#" Value="protected void ThrowIfDisposed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ThrowIfDisposed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ThrowIfDisposed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ThrowIfDisposed();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza wyjątek, jeśli obiekt komunikacji jest usunięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wyjątku w przypadku obiektu komunikacji w <xref:System.ServiceModel.CommunicationState.Created>, <xref:System.ServiceModel.CommunicationState.Opening> lub <xref:System.ServiceModel.CommunicationState.Opened> stanu. Po usunięciu obiektu komunikacji <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> jest wywoływać w nim.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfDisposedOrImmutable">
      <MemberSignature Language="C#" Value="protected void ThrowIfDisposedOrImmutable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ThrowIfDisposedOrImmutable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ThrowIfDisposedOrImmutable ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ThrowIfDisposedOrImmutable();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza wyjątek, jeśli obiekt komunikacyjny <see cref="P:System.ServiceModel.Channels.CommunicationObject.State" /> nie ustawiono właściwości <see cref="F:System.ServiceModel.CommunicationState.Created" /> stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ obiekt nie można modyfikować po <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> nazywa się na nim tylko stan, który zarówno modyfikowalne i usunięty nie jest <xref:System.ServiceModel.CommunicationState.Created> stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Opening" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opened" /> stanu.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfDisposedOrNotOpen">
      <MemberSignature Language="C#" Value="protected void ThrowIfDisposedOrNotOpen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ThrowIfDisposedOrNotOpen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ThrowIfDisposedOrNotOpen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ThrowIfDisposedOrNotOpen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza wyjątek, jeśli nie jest obiektem komunikacji <see cref="F:System.ServiceModel.CommunicationState.Opened" /> stanu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Obiektu komunikacyjnego nie znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Created" /> lub <see cref="F:System.ServiceModel.CommunicationState.Opening" /> stanu i nie można użyć.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Closing" /> lub <see cref="F:System.ServiceModel.CommunicationState.Closed" /> stanu i nie może być modyfikowany.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Obiektu komunikacyjnego znajduje się w <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> stanu i nie może być modyfikowany.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="TcpTransportBindingElement" FullName="System.ServiceModel.Channels.TcpTransportBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a558f1269159ac6df405103afb8e1f1a5bee44a4" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39961337" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TcpTransportBindingElement : System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpTransportBindingElement extends System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.TcpTransportBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpTransportBindingElement&#xA;Inherits ConnectionOrientedTransportBindingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpTransportBindingElement : System::ServiceModel::Channels::ConnectionOrientedTransportBindingElement" />
  <TypeSignature Language="F#" Value="type TcpTransportBindingElement = class&#xA;    inherit ConnectionOrientedTransportBindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje element powiązania transportu TCP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transport używa identyfikatorów URI w postaci "`net.tcp`://`hostname`:`port`/`path`". Inne składniki identyfikatora URI są opcjonalne.  
  
 <xref:System.ServiceModel.Channels.TcpTransportBindingElement> Klasy jest punktem wyjścia do tworzenia niestandardowego powiązania, który implementuje protokołu transportu TCP. Tego transportu jest zoptymalizowany pod kątem komunikacji WCF.  
  
 Aby utworzyć obiekty fabryki, które implementują model usług WCF korzysta z tej klasy <xref:System.ServiceModel.Channels.IChannelFactory> i <xref:System.ServiceModel.Channels.IChannelListener> interfejsów. Te obiekty fabryki z kolei tworzyć i zaakceptuj kanały, które przesyłają komunikaty protokołu SOAP, przy użyciu protokołu TCP.  
  
 Skonfiguruj fabryki, utworzone przez tę klasę, ustawiając jego właściwości, takie jak <xref:System.ServiceModel.Channels.TcpTransportBindingElement.PortSharingEnabled%2A> i <xref:System.ServiceModel.Channels.TcpConnectionPoolSettings.LeaseTimeout%2A>.  
  
 Można również ustawić właściwości dla klasy bazowej <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement>, takich jak <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.MaxBufferSize%2A>, <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.TransferMode%2A>, i <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement.ConnectionBufferSize%2A>. Aby uzyskać pełną listę właściwości, zobacz <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement>.  
  
 Ponadto można ustawić właściwości dla klasy bazowej <xref:System.ServiceModel.Channels.TransportBindingElement>, takich jak <xref:System.ServiceModel.Channels.TransportBindingElement.ManualAddressing%2A> i <xref:System.ServiceModel.Channels.TransportBindingElement.MaxBufferPoolSize%2A>. Aby uzyskać pełną listę właściwości, zobacz <xref:System.ServiceModel.Channels.TransportBindingElement>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób użycia tej klasy.  
  
 [!code-csharp[S_UETcpTransportBindingElement#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.TcpTransportBindingElement" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TcpTransportBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpTransportBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.TcpTransportBindingElement" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nowe wystąpienie klasy <xref:System.ServiceModel.Channels.TcpTransportBindingElement> klasy.  
  
 [!code-csharp[S_UETcpTransportBindingElement#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TcpTransportBindingElement (System.ServiceModel.Channels.TcpTransportBindingElement elementToBeCloned);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Channels.TcpTransportBindingElement elementToBeCloned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TcpTransportBindingElement.#ctor(System.ServiceModel.Channels.TcpTransportBindingElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (elementToBeCloned As TcpTransportBindingElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TcpTransportBindingElement(System::ServiceModel::Channels::TcpTransportBindingElement ^ elementToBeCloned);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Channels.TcpTransportBindingElement : System.ServiceModel.Channels.TcpTransportBindingElement -&gt; System.ServiceModel.Channels.TcpTransportBindingElement" Usage="new System.ServiceModel.Channels.TcpTransportBindingElement elementToBeCloned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="elementToBeCloned" Type="System.ServiceModel.Channels.TcpTransportBindingElement" />
      </Parameters>
      <Docs>
        <param name="elementToBeCloned">Wystąpienie <see cref="T:System.ServiceModel.Channels.TcpTransportBindingElement" /> klasy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.TcpTransportBindingElement" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest konstruktorem kopiującym używany do klonowania element powiązania i jest widoczna, dzięki czemu można zaimplementować w klasach pochodnych <xref:System.ServiceModel.Channels.TcpTransportBindingElement.Clone%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TcpTransportBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="tcpTransportBindingElement.BuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ fabryki kanałów.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> elementy członkowskie, które opisują powiązania, zachowań, kontrakty i inne informacje wymagane do utworzenia fabryki kanałów.</param>
        <summary>Tworzy fabryki kanałów, który może służyć do utworzenia kanału.</summary>
        <returns>Zwraca fabryki kanałów dla określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia fabryki kanału do wysyłania komunikatów na podstawie konfiguracji elementu powiązania protokołu TCP.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia fabryki kanałów, który może służyć do utworzenia kanału.  
  
 [!code-csharp[S_UETcpTransportBindingElement#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> nie może być <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Przekazano nieprawidłowy argument.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TcpTransportBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="tcpTransportBindingElement.BuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ odbiornika kanałów.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> elementy członkowskie, które opisują powiązania, zachowań, kontrakty i inne informacje wymagane do utworzenia fabryki kanałów.</param>
        <summary>Tworzy odbiornika kanałów, o określonym typie.</summary>
        <returns>Zwraca odbiornika kanałów, o określonym typie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia odbiornika kanału do odbierania wiadomości na podstawie konfiguracji elementu powiązania protokołu TCP.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób zwracania odbiornika kanałów, o określonym typie.  
  
 [!code-csharp[S_UETcpTransportBindingElement#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> nie może być <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Przekazano nieprawidłowy argument.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TcpTransportBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.ServiceModel.Channels.BindingElement" Usage="tcpTransportBindingElement.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię bieżącego elementu powiązania.</summary>
        <returns>Zwraca kopię bieżącego elementu powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć kopię bieżącego elementu powiązania.  
  
 [!code-csharp[S_UETcpTransportBindingElement#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectionPoolSettings">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.TcpConnectionPoolSettings ConnectionPoolSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.TcpConnectionPoolSettings ConnectionPoolSettings" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.TcpTransportBindingElement.ConnectionPoolSettings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConnectionPoolSettings As TcpConnectionPoolSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::TcpConnectionPoolSettings ^ ConnectionPoolSettings { System::ServiceModel::Channels::TcpConnectionPoolSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionPoolSettings : System.ServiceModel.Channels.TcpConnectionPoolSettings" Usage="System.ServiceModel.Channels.TcpTransportBindingElement.ConnectionPoolSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TcpConnectionPoolSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję połączenia ustawień puli.</summary>
        <value>A <see cref="T:System.ServiceModel.Channels.TcpConnectionPoolSettings" /> obiekt, który zawiera różne właściwości związane z puli połączeń.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać kolekcję połączenia ustawień puli.  
  
 [!code-csharp[S_UETcpTransportBindingElement#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.TcpTransportBindingElement.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionPolicy : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy with get, set" Usage="System.ServiceModel.Channels.TcpTransportBindingElement.ExtendedProtectionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżące zasady ochrony rozszerzonej.</summary>
        <value>Zasady ochrony rozszerzonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasady ochrony rozszerzonej jest obiektem, używane przez serwer do weryfikowania przychodzących połączeń klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TcpTransportBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetProperty : System.ServiceModel.Channels.BindingContext -&gt; 'T (requires 'T : null)" Usage="tcpTransportBindingElement.GetProperty context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Obiekt, który można pobrać.</typeparam>
        <param name="context">A <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Pobiera określony obiekt z <see cref="T:System.ServiceModel.Channels.BindingContext" />.</summary>
        <returns>Określony obiekt z <see cref="T:System.ServiceModel.Channels.BindingContext" />, lub <see langword="null" /> Jeśli obiekt nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera określony obiekt z klasy bazowej lub jeden z elementów nadrzędnych tej klasy. Zwrócony obiekt jest zwykle zbiór właściwości, na przykład, obiekt, który implementuje <xref:System.ServiceModel.Channels.ISecurityCapabilities>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można pobrać określonego obiektu z <xref:System.ServiceModel.Channels.BindingContext>.  
  
 [!code-csharp[S_UETcpTransportBindingElement#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ListenBacklog">
      <MemberSignature Language="C#" Value="public int ListenBacklog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ListenBacklog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.TcpTransportBindingElement.ListenBacklog" />
      <MemberSignature Language="VB.NET" Value="Public Property ListenBacklog As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ListenBacklog { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ListenBacklog : int with get, set" Usage="System.ServiceModel.Channels.TcpTransportBindingElement.ListenBacklog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(10)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę żądań w kolejce połączeń, które może być oczekujące.</summary>
        <value>Zwraca maksymalną liczbę żądań w kolejce połączeń, które może być oczekujące. Wartość domyślna wynosi 10.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.TcpTransportBindingElement.ListenBacklog%2A> jest właściwością poziomie gniazd, która opisuje liczbę "Akceptuj oczekujące" żądań w kolejce. Upewnij się, że podstawowej kolejki gniazda nie zostanie przekroczony przez maksymalną liczbę równoczesnych połączeń.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można uzyskać wartość ListenBacklog.  
  
 [!code-csharp[S_UETcpTransportBindingElement#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie może być mniejsza niż jeden.</exception>
      </Docs>
    </Member>
    <Member MemberName="PortSharingEnabled">
      <MemberSignature Language="C#" Value="public bool PortSharingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PortSharingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.TcpTransportBindingElement.PortSharingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PortSharingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PortSharingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PortSharingEnabled : bool with get, set" Usage="System.ServiceModel.Channels.TcpTransportBindingElement.PortSharingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy włączone jest udostępnianie portów TCP dla tego połączenia.</summary>
        <value>
          <see langword="true" /> Jeśli włączone jest udostępnianie portów TCP; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To ustawienie wymaga Włączanie TCP Port do udostępniania usługi WCF, zmieniając jej typ uruchamiania na ręczny lub automatyczny.  
  
 Aby uzyskać informacje o odbiornika TCP i należy ją uruchomić, zobacz [współużytkowania portów Net.TCP](~/docs/framework/wcf/feature-details/net-tcp-port-sharing.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać wartość, która wskazuje, czy włączone jest udostępnianie portów TCP.  
  
 [!code-csharp[S_UETcpTransportBindingElement#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public override string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.TcpTransportBindingElement.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.ServiceModel.Channels.TcpTransportBindingElement.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca schemat identyfikatora URI dla transportu.</summary>
        <value>Zwraca schemat identyfikatora URI dla transportu, która jest "net.tcp".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest dostępna do sprawdzania poprawności powiązania przed adresami podstawowymi.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać schemat identyfikatora URI dla transportu.  
  
 [!code-csharp[S_UETcpTransportBindingElement#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeExtendedProtectionPolicy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeExtendedProtectionPolicy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TcpTransportBindingElement.ShouldSerializeExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeExtendedProtectionPolicy () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeExtendedProtectionPolicy();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeExtendedProtectionPolicy : unit -&gt; bool" Usage="tcpTransportBindingElement.ShouldSerializeExtendedProtectionPolicy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wskazanie, że zasady ochrony rozszerzonej nie jest możliwy do serializacji XAML.</summary>
        <returns>Zwraca <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasady ochrony rozszerzonej jest obiektem, używane przez serwer do weryfikowania przychodzących połączeń klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeListenBacklog">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeListenBacklog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeListenBacklog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TcpTransportBindingElement.ShouldSerializeListenBacklog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeListenBacklog () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeListenBacklog();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeListenBacklog : unit -&gt; bool" Usage="tcpTransportBindingElement.ShouldSerializeListenBacklog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy element powiązania transportu TCP należy serializować zaległości nasłuchiwania.</summary>
        <returns>
          <see langword="True" /> Jeśli element powiązania transportu TCP należy serializować nasłuchiwania zaległości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TeredoEnabled">
      <MemberSignature Language="C#" Value="public bool TeredoEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TeredoEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.TcpTransportBindingElement.TeredoEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property TeredoEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TeredoEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TeredoEnabled : bool with get, set" Usage="System.ServiceModel.Channels.TcpTransportBindingElement.TeredoEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość logiczna określająca, czy jest włączony protokół Teredo (technologia adresować klientów znajdujących się za zaporami).</summary>
        <value>
          <see langword="true" /> Jeśli protokół Teredo jest włączone; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia Teredo dla podstawowej gniazda TCP. Aby uzyskać więcej informacji, zobacz [Przegląd Teredo](http://go.microsoft.com/fwlink/?LinkId=96649).  
  
 Ta właściwość ma zastosowanie tylko w [!INCLUDE[wxpsp2](~/includes/wxpsp2-md.md)] i [!INCLUDE[ws2003](~/includes/ws2003-md.md)]. [!INCLUDE[wv](~/includes/wv-md.md)] jest dostępna opcja konfiguracji komputera dla protokołu Teredo, dlatego podczas uruchamiania [!INCLUDE[wv](~/includes/wv-md.md)], ta właściwość jest ignorowana. Teredo musi mieć czy maszyn klientem a usługą stosu IPv6 firmy Microsoft, zainstalowany i poprawnie skonfigurowany w celu użycia protokołu Teredo. Aby uzyskać więcej informacji na temat konfigurowania protokołu Teredo, zobacz [Przegląd Teredo](http://go.microsoft.com/fwlink/?LinkId=96649). Aby uzyskać więcej informacji na temat instalowania stosu IPv6 firmy Microsoft, zobacz [systemu Windows Server 2003 technologii centra](http://go.microsoft.com/fwlink/?LinkId=96650).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak włączyć protokół Teredo dla podstawowej gniazda TCP.  
  
 [!code-csharp[S_UETcpTransportBindingElement#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_uetcptransportbindingelement/cs/program.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
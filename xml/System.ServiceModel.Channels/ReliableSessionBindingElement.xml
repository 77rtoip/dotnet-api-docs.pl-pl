<Type Name="ReliableSessionBindingElement" FullName="System.ServiceModel.Channels.ReliableSessionBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="96214a2066e7bbd035e38aa6d73cde38ade6668a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36421367" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReliableSessionBindingElement : System.ServiceModel.Channels.BindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReliableSessionBindingElement extends System.ServiceModel.Channels.BindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReliableSessionBindingElement&#xA;Inherits BindingElement&#xA;Implements IPolicyExportExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReliableSessionBindingElement sealed : System::ServiceModel::Channels::BindingElement, System::ServiceModel::Description::IPolicyExportExtension" />
  <TypeSignature Language="F#" Value="type ReliableSessionBindingElement = class&#xA;    inherit BindingElement&#xA;    interface IPolicyExportExtension" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje element powiązania, które mogą wytwarzać wysyłanie i odbieranie kanały wymagane dla sesji niezawodnej między punktami końcowymi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zapewnia sesji i opcjonalnie zapewnia dostarczanie komunikatów uporządkowanej. Ta sesja zaimplementowanym mogą przechodzić pośredników SOAP i transportu.  
  
 Każdy element powiązania reprezentuje krok przetwarzania przy wysyłaniu lub odbieraniu wiadomości. W czasie wykonywania elementy powiązania utworzyć fabryk kanałów i odbiorników, które są niezbędne do utworzenia wychodzące i przychodzące stosy kanału wymagane do wysyłania i odbierania wiadomości. <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> Zapewnia opcjonalne warstwę stosu, który można utworzyć niezawodnej sesji między punktami końcowymi i skonfigurować działanie tej sesji.  
  
 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> Znajduje się na standardowe powiązania w poniższej tabeli.  
  
|Powiązanie|Domyślny|  
|-------------|-------------|  
|<xref:System.ServiceModel.NetTcpBinding>|Off|  
|<xref:System.ServiceModel.WSHttpBinding>|Off|  
|<xref:System.ServiceModel.WSDualHttpBinding>|Na (wymagane)|  
  
   
  
## Examples  
 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> Można dodać do dowolnego niestandardowego powiązania. Jest to realizowane przy użyciu następujących elementów konfiguracji.  
  
```  
<bindings>  
    <customBinding>  
        <binding configurationName="ReliabilityHTTP">  
            <reliableSession/>  
        </binding>  
    </customBinding>  
</bindings>  
```  
  
 Następujący przykładowy kod przedstawia sposób użycia <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> w kodzie.  
  
 [!code-csharp[S_Imperative#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_imperative/cs/service.cs#1)]
 [!code-vb[S_Imperative#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_imperative/vb/service.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReliableSessionBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement (bool ordered);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool ordered) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ordered As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReliableSessionBindingElement(bool ordered);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Channels.ReliableSessionBindingElement : bool -&gt; System.ServiceModel.Channels.ReliableSessionBindingElement" Usage="new System.ServiceModel.Channels.ReliableSessionBindingElement ordered" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ordered" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ordered">
          <see langword="true" /> Jeśli wiadomości muszą być dostarczane w kolejności, w jakiej są wysyłane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> klasy, która określa, czy dostarczanie komunikatów muszą zachować kolejność, w którym są wysyłane wiadomości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcknowledgementInterval">
      <MemberSignature Language="C#" Value="public TimeSpan AcknowledgementInterval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AcknowledgementInterval" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgementInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AcknowledgementInterval { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgementInterval : TimeSpan with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przedział czasu, miejsce docelowe oczekiwania przed wysłaniem potwierdzenia do źródła komunikatu za pośrednictwem niezawodnych kanałów tworzonych przez fabrykę.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu oczekiwania przez usługę do wysyłania do źródła komunikatu potwierdzenia. Wartość domyślna to 2 sekundy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lokalizacji docelowej, która odbiera wiadomości przez niezawodny kanał grupuje potwierdzenia dla tych wiadomości, które są razem w pojedynczym komunikacie zmniejszenie ruchu w sieci oraz zwiększenie gęstości informacje w wiadomości. Grupowanie skaluje się lepiej w miarę zwiększania ruchu. Nie jest podejmowana próba wysłanie potwierdzenia dla każdego komunikatu otrzymaniu tak szybko, jak to możliwe, ale raczej dla interwału czasu, grupowanie potwierdzenia, które zostały dostarczone w tym przedziale, a następnie wysyła je wszystkie razem. Pierwszy komunikat o odebraniu jest wyjątek; zostało potwierdzone, natychmiast po dostarczeniu. Ponadto, jeżeli niezawodnej sesji są używane z jednego połączenia HTTP, jak jest to miejsce w przypadku na przykład <xref:System.ServiceModel.WSHttpBinding> , ale nie <xref:System.ServiceModel.WSDualHttpBinding>, wówczas to ustawienie nie jest używany.  
  
 Wartość, która została skonfigurowana z <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval%2A> właściwość jest zalecane infrastruktury i nienaruszalne ograniczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza niż lub równa zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="reliableSessionBindingElement.BuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który tworzy fabrykę.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zawierający informacje wymagane do utworzenia fabryki, które można tworzyć kanały typu <c>TChannel</c>.</param>
        <summary>Zwraca fabrykę tworzącą kanał o określonym typie, który obsługuje niezawodnej sesji.</summary>
        <returns>A <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> typu <see cref="T:System.ServiceModel.Channels.IChannel" /> zainicjowany z <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IChannel> Tworzone przez fabrykę jest typu `TChannel`. Typy `TChannel` obsługiwane na kliencie jest zależny typów podstawowych kanałów, które połączyć się z usługą. W poniższej tabeli przedstawiono typy kanału niezawodnej sesji są obsługiwane jako funkcja podstawowej kanałów.  
  
|Obsługa niezawodnej sesji `TChannel` typów przez podstawowy kanał typów|IRequestChannel|IRequestSessionChannel|IDuplexChannel|IDuplexSessionChannel|  
|-------------------------------------------------------------------------------|---------------------|----------------------------|--------------------|---------------------------|  
|IOutputSessionChannel|Tak|Tak|Tak|Tak|  
|IRequestSessionChannel|Tak|Tak|Nie|Nie|  
|IDuplexSessionChannel|Nie|Nie|Tak|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TChannel" /> nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="reliableSessionBindingElement.BuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">
          <see cref="T:System.ServiceModel.Channels.IChannel" /> Przeznaczonego do akceptowania odbiornika.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zawierający informacje wymagane do utworzenia odbiorniki akceptujących kanały typu <c>TChannel</c>.</param>
        <summary>Zwraca odbiornik, który akceptuje kanał o określonym typie, który obsługuje niezawodnej sesji.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <see cref="T:System.ServiceModel.Channels.IChannel" /> zainicjowany z <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IChannel> Zaakceptowane przez odbiornik jest typu `TChannel`. Typy `TChannel` obsługiwane na serwerze hostującym usługa jest zależna typów podstawowych kanały używane do nawiązania połączenia przez klienta. W poniższej tabeli przedstawiono typy kanału niezawodnej sesji są obsługiwane jako funkcja podstawowej kanałów.  
  
|Obsługa niezawodnej sesji `TChannel` typów przez podstawowy kanał typów|IReplyChannel|IReplySessionChannel|IDuplexChannel|IDuplexSessionChannel|  
|-------------------------------------------------------------------------------|-------------------|--------------------------|--------------------|---------------------------|  
|IInputSessionChannel|Tak|Tak|Tak|Tak|  
|IReplySessionChannel|Tak|Tak|Nie|Nie|  
|IDuplexSessionChannel|Nie|Nie|Tak|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TChannel" /> nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; bool" Usage="reliableSessionBindingElement.CanBuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który tworzy fabrykę.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zawierający informacje wymagane do utworzenia fabryki, które można tworzyć kanały typu <c>TChannel</c>.</param>
        <summary>Zwraca wartość wskazującą, czy mogą być wbudowane fabryki kanałów dla kanału i kontekstu pod warunkiem, który może obsługiwać niezawodnej sesji.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> typu <paramref name="TChannel" /> może być skompilowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `true` lub `false` dla `TChannel` zgodnie z tabelą wartości podanych w <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory%60%601%28System.ServiceModel.Channels.BindingContext%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; bool (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="reliableSessionBindingElement.CanBuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">
          <see cref="T:System.ServiceModel.Channels.IChannel" /> Który odbiornika kanałów, jeśli kompilacji, akceptuje.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zawierający informacje wymagane do utworzenia odbiorniki akceptujących kanały typu <c>TChannel</c>.</param>
        <summary>Zwraca wartość wskazującą, czy mogą być wbudowane odbiornika kanałów dla kanału i kontekstu pod warunkiem, który może obsługiwać niezawodnej sesji.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.ServiceModel.Channels.ChannelListenerBase`1" /> który może tworzyć <see cref="T:System.ServiceModel.Channels.IChannel" /> typu <paramref name="TChannel" /> może być skompilowany przez element powiązania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stosy kanału są zwykle tworzone przy użyciu wzorca fabryki, której powiązanie tworzy stosu kanału. Podczas wysyłania wiadomości, powiązanie jest używany do tworzenia fabryki kanałów, które z kolei jest oparty na stosie kanału i zwraca odwołanie do kanału top w stosie. Aplikacji można następnie używać tego kanału do wysyłania wiadomości. Podobnie podczas odbierania wiadomości, powiązanie jest używany do tworzenia odbiornika kanałów, które nasłuchuje przychodzących wiadomości. Odbiornik kanału zawiera komunikaty do nasłuchiwania aplikacji, tworząc stosy kanału i przekazywanie aplikacji odwołaniem do górnej kanału.  
  
 Ta metoda zwraca `true` lub `false` dla `TChannel` zgodnie z tabelą wartości podanych w <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener%60%601%28System.ServiceModel.Channels.BindingContext%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.ServiceModel.Channels.BindingElement" Usage="reliableSessionBindingElement.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię elementu powiązania bieżącej sesji niezawodnej.</summary>
        <returns>A <see cref="T:System.ServiceModel.Channels.BindingElement" /> czyli klonowania bieżącego elementu powiązania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowControlEnabled">
      <MemberSignature Language="C#" Value="public bool FlowControlEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FlowControlEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowControlEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FlowControlEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.FlowControlEnabled : bool with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy niezawodnej sesji zawiera sterowanie przepływem włączone.</summary>
        <value>
          <see langword="true" /> Jeśli niezawodnej sesji zawiera sterowanie przepływem włączony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowanie przepływem jest mechanizm niezawodnej sesji zaimplementować w celu zapewnienia nadawców nie wysyłają komunikaty więcej niż odbiornik może obsłużyć. Odbiorniki zostały buforów komunikatów, które służy do uwzględnienia Seria wiadomości i komunikatów poza kolejnością. Odbiorniki anonsowane do nadawców ilość miejsca w buforze, to w każdym ich potwierdzeń. Nadawców można dzięki tym informacjom można zatrzymać wysyłanie wiadomości przy każdym odbiorca nie ma buforu miejsca w lewo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetProperty : System.ServiceModel.Channels.BindingContext -&gt; 'T (requires 'T : null)" Usage="reliableSessionBindingElement.GetProperty context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ właściwości pobrać.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zawierający informacje wymagane do pobrania kanału typu <c>T</c>.</param>
        <summary>Pobiera właściwości dla określonego typu z jego kontekstu powiązania.</summary>
        <returns>Właściwość typu <paramref name="T" /> z określonym <paramref name="context" /> lub <see langword="null" /> Jeśli żadnej właściwości typu <paramref name="T" /> został znaleziony.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InactivityTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan InactivityTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan InactivityTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property InactivityTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan InactivityTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.InactivityTimeout : TimeSpan with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przedział czasu, który pozostaje nieaktywne przed zamknięciem usługi.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu, który pozostaje nieaktywne przed zamknięciem usługi. Wartość domyślna to 10 minut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Działań w kanale jest zdefiniowany jako odbierania komunikatu aplikacji lub infrastruktury. Określa maksymalną ilość czasu podtrzymywania nieaktywnych sesji, parametr limitu czasu bezczynności. Jeśli więcej niż <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout%2A> interwał czasu przekazuje bez żadnych działań, sesja została przerwana przez infrastrukturę i usterek kanału. Niezawodna sesja jest jednostronnie działo.  
  
 Jeśli aplikacja wysyłająca nie zawiera żadnych komunikatów do wysłania następnie niezawodnej sesji zwykle nie występuje błąd z powodu braku aktywności; Zamiast tego mechanizmu keep-alive utrzymuje sesję active nieskończoność. Należy pamiętać, że Dyspozytor niezależnie może przerwać niezawodnej sesji, jeśli żadne komunikaty aplikacji są wysyłane lub odbierane. W związku z tym limit czasu nieaktywności zwykle wygasa, jeśli warunki w sieci są taki sposób, że żadne komunikaty są odbierane lub wystąpił błąd na nadawcy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza lub równa zero lub większa niż albo <see cref="F:System.Int32.MaxValue" /> lub <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPendingChannels">
      <MemberSignature Language="C#" Value="public int MaxPendingChannels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPendingChannels" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPendingChannels As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPendingChannels { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPendingChannels : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia największą liczbę kanałów oczekujących podczas niezawodnej sesji.</summary>
        <value>Maksymalna liczba kanałów oczekujących. Wartość domyślna to 4.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kanały oczekują na kiedy są oczekuje na zatwierdzenie. Po osiągnięciu tego limitu, Brak kanałów są tworzone i Odłóż oczekujących tryb dopóki liczba osiąga (akceptując oczekujących kanałów). Jest to ograniczenie dla każdej odbiornika.  
  
 Po osiągnięciu progu i aplikacji zdalnej próbuje utworzyć nowe niezawodnej sesji, żądanie zostanie odrzucone i otwórz operację, która zostanie wyświetlony monit tej usterki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza lub równa zero lub większa niż 16384.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCount">
      <MemberSignature Language="C#" Value="public int MaxRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRetryCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxRetryCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxRetryCount : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę razy komunikat próbuje przetransferowane w trakcie działania niezawodnej sesji.</summary>
        <value>Maksymalna liczba razy komunikat podejmie próbę ponownego wysyłania. Minimalna wartość to 1; Maksymalna liczba to <see cref="F:System.Int32.MaxValue" />; a wartość domyślna to 8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komunikat jest uznawany za do przeniesienia, jeśli potwierdzenia dostarczenia po stronie odbiorcy przez odbiorcę.  
  
 Jeśli nie otrzymano potwierdzenia w ciągu pewnego czasu dla wiadomości, które zostały przesłane, infrastruktury automatycznie ponownie wysyła wiadomość. Infrastruktura próbuje wysłać wiadomości, co najwyżej <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount%2A> liczbę razy. Nie odbiera potwierdzenia przed osiągnięciem tego limitu jest traktowane jako błąd krytyczny komunikacji oraz powoduje, że się zdarzenia wystąpił błąd kanału.  
  
 Infrastruktura używa algorytm wykładnicze wycofania do określenia, kiedy ponownego przesłania, oparte na obliczona średnia czasu rundy. Podczas początkowej ponownych prób jest obliczana na podstawie na zmierzona czasu ustanowienia sesji. Algorytm retransmisji podwaja opóźnienie co nieudanej próby podania, co prowadzi do przekazywania między przy pierwszej próbie transmisji i ostatnią próbę retransmisji około 8,5 minut. Podczas pierwszej próby retransmisji jest dostosowane według czasu Rundy obliczeniowej i odcinek wynikowy czas trwania tymi próbami różni odpowiednio. Dzięki temu czas retransmisji dynamicznie dostosowywana w zmiennych warunkach sieciowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza niż lub równa zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxTransferWindowSize">
      <MemberSignature Language="C#" Value="public int MaxTransferWindowSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxTransferWindowSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxTransferWindowSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxTransferWindowSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxTransferWindowSize : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia największą liczbę wiadomości, które mogą znajdować się w buforze wysyłania lub bufor odbioru.</summary>
        <value>Maksymalna liczba wiadomości, które można buforować. Minimalna wartość to 1; wartość maksymalna to 4096; a wartość domyślna to 32.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A> można ustawić właściwości nadawcy i odbiorcy. Ta wartość znajduje się w zasadach powiązania WSDL, tak więc jeśli używasz [narzędzie narzędzia metadanych elementu ServiceModel (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) do skonstruowania klienta, ma taką samą wartość. W przeciwnym razie wartość ta jest niezależnie od zostanie ustawiona na kliencie.  
  
 Po osiągnięciu tego limitu na nadawcy, dodatkowe wywołania do wysyłania są zablokowane. Po osiągnięciu tego limitu odbiornika nowe komunikaty przychodzące do podstawowego kanału nie są akceptowane.  
  
 Niezawodnej sesji używa protokołu okien w celu ulepszenia wykorzystania sieci. Ilość buforowania, wymagane jest pochodną bezpośrednio rozmiar okna transmisji. Podczas strojenia tę wartość, należy pamiętać, że okna transmisji optymalne jest powiązany z przepustowości i opóźnień w prosty sposób. Nadaje się doskonale maksymalny rozmiar okna jest przepustowość, czas opóźnienia. Daje mniejszego mniejsza niż użycie sieci 100%; Cokolwiek większych jest po prostu utracona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza lub równa jeden lub większa niż 4096.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ordered">
      <MemberSignature Language="C#" Value="public bool Ordered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Ordered" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.Ordered" />
      <MemberSignature Language="VB.NET" Value="Public Property Ordered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Ordered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Ordered : bool with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.Ordered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dostarczanie komunikatów muszą zachować kolejność, w którym są wysyłane wiadomości.</summary>
        <value>
          <see langword="true" /> Jeśli wiadomości muszą być dostarczane w kolejności, w jakiej są wysyłane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać komunikaty wysyłane w kolejności, należy również ustawić <xref:System.ServiceModel.ConcurrencyMode> do <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReliableMessagingVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.ReliableMessagingVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ReliableMessagingVersion As ReliableMessagingVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ReliableMessagingVersion ^ ReliableMessagingVersion { System::ServiceModel::ReliableMessagingVersion ^ get(); void set(System::ServiceModel::ReliableMessagingVersion ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReliableMessagingVersion : System.ServiceModel.ReliableMessagingVersion with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.ReliableMessagingVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReliableMessagingVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wersję WS-ReliableMessaging określone przez element powiązania.</summary>
        <value>Wystąpienia pochodzące z <see cref="T:System.ServiceModel.ReliableMessagingVersion" /> reprezentujący wersji protokołu WS-ReliableMessaging używanego przez element konfiguracji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie nie istnieją dwie wersje protokołu WS-ReliableMessaging obsługiwane przez Windows Communication Foundation (WCF): WS-ReliableMessaging1.1 i WS-ReliableMessagingFebruary2005. Domyślna wersja jest WS ReliableMessagingFebruary2005.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportPolicy (exporter As MetadataExporter, context As PolicyConversionContext) Implements IPolicyExportExtension.ExportPolicy" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System::ServiceModel::Description::MetadataExporter ^ exporter, System::ServiceModel::Description::PolicyConversionContext ^ context) = System::ServiceModel::Description::IPolicyExportExtension::ExportPolicy;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">
          <see cref="T:System.ServiceModel.Description.MetadataExporter" /> Który Eksportuje informacje o powiązaniu w elemencie powiązanie niezawodnej sesji do elementów WSDL.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Description.PolicyConversionContext" /> Zapewnia mapowanie wyeksportowane elementy WSDL opis punktu końcowego.</param>
        <summary>Mapuje informacje zawarte w elemencie powiązanie niezawodnej sesji do elementów WSDL, które umożliwiają zdalny punkt końcowy do uzyskania dostępu do usługi z niezawodnej sesji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ReliableSessionBindingElement" FullName="System.ServiceModel.Channels.ReliableSessionBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="35b53ab1fd9a9f44c62055447ab53bd929afbad1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39784274" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReliableSessionBindingElement : System.ServiceModel.Channels.BindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReliableSessionBindingElement extends System.ServiceModel.Channels.BindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReliableSessionBindingElement&#xA;Inherits BindingElement&#xA;Implements IPolicyExportExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReliableSessionBindingElement sealed : System::ServiceModel::Channels::BindingElement, System::ServiceModel::Description::IPolicyExportExtension" />
  <TypeSignature Language="F#" Value="type ReliableSessionBindingElement = class&#xA;    inherit BindingElement&#xA;    interface IPolicyExportExtension" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje element powiązania, które może powodować wysyłanie i odbieranie kanały wymagane dla niezawodnej sesji między punktami końcowymi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zapewnia sesji i opcjonalnie zapewnia dostarczanie uporządkowanych komunikatów. Ta sesja zaimplementowano mogą przechodzić pośredników SOAP i mechanizm transportu.  
  
 Każdy element powiązania reprezentuje krok przetwarzania podczas wysyłania lub odbierania komunikatów. W czasie wykonywania elementy powiązania tworzenie fabryki kanałów i odbiorników, które są niezbędne do utworzenia przychodzących i wychodzących stosów kanału wymagane do wysyłania i odbierania komunikatów. <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> Zapewnia opcjonalne warstwę stosu, który można utworzyć niezawodnej sesji między punktami końcowymi i skonfiguruj zachowanie tej sesji.  
  
 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> Znajduje się na standardowych powiązania w poniższej tabeli.  
  
|Powiązanie|Domyślny|  
|-------------|-------------|  
|<xref:System.ServiceModel.NetTcpBinding>|Off|  
|<xref:System.ServiceModel.WSHttpBinding>|Off|  
|<xref:System.ServiceModel.WSDualHttpBinding>|Na (wymagane)|  
  
   
  
## Examples  
 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> Mogą być dodawane do dowolnego niestandardowego powiązania. Odbywa się przy użyciu następujących elementów konfiguracji.  
  
```  
<bindings>  
    <customBinding>  
        <binding configurationName="ReliabilityHTTP">  
            <reliableSession/>  
        </binding>  
    </customBinding>  
</bindings>  
```  
  
 Następujący przykładowy kod przedstawia sposób użycia <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> w kodzie.  
  
 [!code-csharp[S_Imperative#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_imperative/cs/service.cs#1)]
 [!code-vb[S_Imperative#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_imperative/vb/service.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReliableSessionBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement (bool ordered);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool ordered) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ordered As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReliableSessionBindingElement(bool ordered);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Channels.ReliableSessionBindingElement : bool -&gt; System.ServiceModel.Channels.ReliableSessionBindingElement" Usage="new System.ServiceModel.Channels.ReliableSessionBindingElement ordered" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ordered" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ordered">
          <see langword="true" /> Jeśli wiadomości muszą być dostarczane w kolejności, w której są wysyłane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> klasa, która określa, czy dostarczanie komunikatów muszą zachować kolejność, w jakiej komunikaty są wysyłane.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcknowledgementInterval">
      <MemberSignature Language="C#" Value="public TimeSpan AcknowledgementInterval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AcknowledgementInterval" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgementInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AcknowledgementInterval { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgementInterval : TimeSpan with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.TimeSpan), "00:00:00.2")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przedział czasu, miejsce docelowe oczekiwania przed wysłaniem potwierdzenia do źródła wiadomości na niezawodne kanały, które są tworzone przez fabrykę.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu, przez jaki usługa czekać na wysłanie potwierdzenia do źródło komunikatu. Wartość domyślna to 2 sekundy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Miejsce docelowe, która odbiera komunikaty, które w niezawodny kanał grupy potwierdzenia dla tych wiadomości, które są razem w pojedynczym komunikacie zmniejszenie ruchu w sieci oraz zwiększenie gęstości informacje dla wiadomości. Grupowanie skaluje się lepiej w miarę wzrostu ruchu. Nie podjęto próby wysłanie potwierdzenia dla każdego komunikatu odbiera tak szybko, jak to możliwe, ale raczej czeka, aż interwał czasu, grupowanie potwierdzenia, które już korzystać z tego interwału, a następnie wysyła je razem. Pierwszy odebranego komunikatu jest wyjątek; zostało potwierdzone, zaraz po dostarczeniu. Ponadto, jeżeli niezawodnej sesji są używane z jednego połączenia HTTP, co jest w przypadku na przykład <xref:System.ServiceModel.WSHttpBinding> , ale nie <xref:System.ServiceModel.WSDualHttpBinding>, wówczas to ustawienie nie jest używany.  
  
 Wartość, która została ustawiona za pomocą <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval%2A> właściwość to zalecenie, aby infrastruktura i stały limit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="reliableSessionBindingElement.BuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Tworzy typ fabryki kanału.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zawierający informacje wymagane do utworzenia fabryki, którzy mogą tworzyć kanały typu <c>TChannel</c>.</param>
        <summary>Zwraca fabrykę tworzącą kanału o określonym typie, który obsługuje niezawodnej sesji.</summary>
        <returns>A <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> typu <see cref="T:System.ServiceModel.Channels.IChannel" /> inicjowany z <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IChannel> Produkowane przez fabryka jest typu `TChannel`. Typy `TChannel` obsługiwany w klienta zależy od typu podstawowego kanałów, które się z usługą. Poniższa tabela wskazuje, jakie typy kanału niezawodnej sesji są obsługiwane w funkcji podstawowych kanałów.  
  
|Obsługa niezawodnej sesji `TChannel` typy bazowe kanału typów|IRequestChannel|IRequestSessionChannel|IDuplexChannel|IDuplexSessionChannel|  
|-------------------------------------------------------------------------------|---------------------|----------------------------|--------------------|---------------------------|  
|IOutputSessionChannel|Tak|Tak|Tak|Tak|  
|IRequestSessionChannel|Tak|Tak|Nie|Nie|  
|IDuplexSessionChannel|Nie|Nie|Tak|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TChannel" /> nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="reliableSessionBindingElement.BuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">
          <see cref="T:System.ServiceModel.Channels.IChannel" /> Przeznaczonego do akceptowania odbiornika.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zawierający informacje wymagane do kompilowania odbiorniki akceptujące kanały typu <c>TChannel</c>.</param>
        <summary>Zwraca odbiornik, który akceptuje kanał określonego typu, który obsługuje niezawodnej sesji.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <see cref="T:System.ServiceModel.Channels.IChannel" /> inicjowany z <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IChannel> Zaakceptowane przez odbiornik jest typu `TChannel`. Typy `TChannel` obsługiwany na serwerze, który hostuje usługę zależy od typów podstawowych kanały używane do łączenia z klienta. Poniższa tabela wskazuje, jakie typy kanału niezawodnej sesji są obsługiwane w funkcji podstawowych kanałów.  
  
|Obsługa niezawodnej sesji `TChannel` typy bazowe kanału typów|IReplyChannel|IReplySessionChannel|IDuplexChannel|IDuplexSessionChannel|  
|-------------------------------------------------------------------------------|-------------------|--------------------------|--------------------|---------------------------|  
|IInputSessionChannel|Tak|Tak|Tak|Tak|  
|IReplySessionChannel|Tak|Tak|Nie|Nie|  
|IDuplexSessionChannel|Nie|Nie|Tak|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TChannel" /> nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; bool" Usage="reliableSessionBindingElement.CanBuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Tworzy typ fabryki kanału.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zawierający informacje wymagane do utworzenia fabryki, którzy mogą tworzyć kanały typu <c>TChannel</c>.</param>
        <summary>Zwraca wartość wskazującą, czy dla kanału można tworzyć fabryki kanałów i kontekst podane który może obsługiwać niezawodnej sesji.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> typu <paramref name="TChannel" /> może być skompilowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `true` lub `false` dla `TChannel` zgodnie z tabelą wartości podanych w <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory%60%601%28System.ServiceModel.Channels.BindingContext%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; bool (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="reliableSessionBindingElement.CanBuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">
          <see cref="T:System.ServiceModel.Channels.IChannel" /> , Odbiornika kanałów, jeśli kompilacja, akceptuje.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zawierający informacje wymagane do kompilowania odbiorniki akceptujące kanały typu <c>TChannel</c>.</param>
        <summary>Zwraca wartość wskazującą, czy można utworzyć odbiornika kanałów dla kanału i kontekst podane który może obsługiwać niezawodnej sesji.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.ServiceModel.Channels.ChannelListenerBase`1" /> , może utworzyć <see cref="T:System.ServiceModel.Channels.IChannel" /> typu <paramref name="TChannel" /> może być utworzone przez element powiązania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kanał stosy są zwykle tworzone przy użyciu wzorca fabryki, której powiązanie tworzy stosu kanału. Podczas wysyłania komunikatów, powiązania jest używany do tworzenia fabryki kanałów, które z kolei opiera się na stosie kanału i zwraca odwołanie do górnej kanału w stosie. Aplikacja można następnie używać tego kanału do wysyłania wiadomości. Podobnie podczas odbierania wiadomości, powiązania jest używany do tworzenia odbiornika kanału, który nasłuchuje przychodzących wiadomości. Odbiornik kanału zapewnia komunikatów do nasłuchiwania aplikacji, tworząc kanał stosy i przekazywanie aplikacji odwołanie do górnej kanału.  
  
 Ta metoda zwraca `true` lub `false` dla `TChannel` zgodnie z tabelą wartości podanych w <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener%60%601%28System.ServiceModel.Channels.BindingContext%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.ServiceModel.Channels.BindingElement" Usage="reliableSessionBindingElement.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzona jest kopia elementu bieżąca sesja niezawodna powiązania.</summary>
        <returns>A <see cref="T:System.ServiceModel.Channels.BindingElement" /> czyli klonowania bieżącego elementu powiązania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowControlEnabled">
      <MemberSignature Language="C#" Value="public bool FlowControlEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FlowControlEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowControlEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FlowControlEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.FlowControlEnabled : bool with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy niezawodnej sesji ma włączoną kontrolą przepływu.</summary>
        <value>
          <see langword="true" /> Jeśli sterowanie przepływem włączone; niezawodnej sesji w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowanie przepływem to mechanizm, który zaimplementować niezawodnej sesji, aby zapewnić, nadawców bez wysyłania komunikatów jest większa niż odbiorcy mogą obsługiwać. Odbiorniki zostały buforów komunikatów, które jest używane do dostosowania wzrosty wiadomości i komunikatów poza kolejnością. Odbiorniki anonsować do nadawców ilość miejsca, która pozostaje w tym buforze we wszystkich ich potwierdzeń. Nadawców można użyć tych informacji aby zatrzymać wysyłanie nowe wiadomości, zawsze wtedy, gdy odbiornik został pozostało ilość miejsca w buforze.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetProperty : System.ServiceModel.Channels.BindingContext -&gt; 'T (requires 'T : null)" Usage="reliableSessionBindingElement.GetProperty context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Pobrać typ właściwości.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zawierający informacje wymagane do pobierania kanału typu <c>T</c>.</param>
        <summary>Pobiera właściwości dla określonego typu z jego kontekstu powiązania.</summary>
        <returns>Właściwość typu <paramref name="T" /> z określonym <paramref name="context" /> lub <see langword="null" /> Jeśli żadnej właściwości typu <paramref name="T" /> zostanie znaleziony.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InactivityTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan InactivityTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan InactivityTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property InactivityTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan InactivityTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.InactivityTimeout : TimeSpan with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.TimeSpan), "00:10:00")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia interwał czasu, przez jaki usługa pozostaje nieaktywna przed zamknięciem.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu, który usługa pozostaje nieaktywna przed zamknięciem. Wartość domyślna to 10 minut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Działań w kanale jest zdefiniowany jako odbieranie wiadomości aplikację lub infrastrukturę. Parametr limitu czasu bezczynności steruje maksymalną ilość czasu, aby utrzymać aktywność sesji nieaktywne. Jeśli są większe niż <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout%2A> przedział czasu przekazuje bez żadnych działań, sesja została przerwana przez infrastrukturę i usterek kanału. Niezawodna sesja zostaje rozłączona jednostronnie.  
  
 Jeśli aplikacja wysyłająca nie zawiera żadnych komunikatów do wysłania następnie niezawodnej sesji zwykle nie uległa awarii z powodu braku aktywności; Zamiast tego mechanizmu keep-alive przechowuje sesji aktywne przez czas nieokreślony. Należy pamiętać, że Dyspozytor niezależnie może przerwać niezawodnej sesji, jeśli żadne komunikaty aplikacji są wysyłane lub odbierane. W związku z tym limit czasu braku aktywności zazwyczaj wygasa, jeśli warunki w sieci są w taki sposób, że nie komunikaty są odbierane, lub jeśli wystąpi awaria w nadawcy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza niż lub równe zero lub większa niż albo <see cref="F:System.Int32.MaxValue" /> lub <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPendingChannels">
      <MemberSignature Language="C#" Value="public int MaxPendingChannels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPendingChannels" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPendingChannels As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPendingChannels { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPendingChannels : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(4)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia największą liczbę kanałów oczekujących podczas sesji.</summary>
        <value>Największa liczba kanałów, które mogą być oczekujące. Wartość domyślna to 4.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kanały oczekują od tego, kiedy są oczekuje na zatwierdzenie. Po osiągnięciu tego limitu kanałów są tworzone i umieścić w oczekujące tryb dopóki ta liczba zbliża się w dół (akceptując oczekujące kanałów). Jest to limit dla każdego odbiornika.  
  
 Po osiągnięciu progu i zdalna aplikacja próbuje utworzyć nowy niezawodnej sesji, żądanie zostanie odrzucone i otwórz operacji, która zostanie wyświetlony monit tej usterki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza lub równa zero lub większa niż 16384.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCount">
      <MemberSignature Language="C#" Value="public int MaxRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRetryCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxRetryCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxRetryCount : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę prób komunikat próbuje przetransferowane w trakcie niezawodnej sesji.</summary>
        <value>Maksymalna liczba prób próby ponownego wysłania wiadomości. Minimalna wartość to 1; wartość maksymalna to <see cref="F:System.Int32.MaxValue" />; i wartość domyślna wynosi 8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komunikat jest uważany za przesłane, jeśli jego dostarczenia u odbiorcy została potwierdzona przez odbiorcę.  
  
 Jeśli nie otrzymano potwierdzenia w ramach określoną ilość czasu dla wiadomości, które zostały przekazane, infrastruktury automatycznie ponownie wysyła wiadomości. Infrastruktura próbuje wysłać komunikat, co najwyżej <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount%2A> liczbę razy. Zanim ten limit zostanie osiągnięty, nie odbiera potwierdzenie jest traktowane jako błąd krytyczny komunikacji i powoduje, że zdarzenia wystąpił błąd kanału do wywołania.  
  
 Infrastruktury używa wykładniczego wycofywania algorytmu do określenia, kiedy ponowne przesłanie, oparte na obliczanej Średni czas błądzenia. Czas początkowej ponowień jest obliczana na podstawie na mierzonego czasu ustanowienia sesji. Algorytm retransmisji podwaja się opóźnienie w każdej próby, co powoduje przekazanie między pierwszej próby transmisji i ostatnia próba retransmisji około 8,5 minut. Podczas pierwszej próby retransmisji jest dostosowywany zgodnie z obliczony czas błądzenia i wynikowy stretch czas, przez który te próby podjęcia zmienia się odpowiednio. Dzięki temu czas retransmisji dynamicznie dostosowywana do zmiennych warunkach sieciowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxTransferWindowSize">
      <MemberSignature Language="C#" Value="public int MaxTransferWindowSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxTransferWindowSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxTransferWindowSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxTransferWindowSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxTransferWindowSize : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia największą liczbę wiadomości, które może znajdować się w buforze wysyłania lub bufor odbioru.</summary>
        <value>Największa liczba wiadomości, które mogą być buforowane. Minimalna wartość to 1; wartość maksymalna to 4096; a wartość domyślna to 32.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A> właściwość można ustawić na przez nadawcę i odbiorcę. Ta wartość jest dołączana w zasadach Powiązanie WSDL, więc jeśli używasz [narzędzia narzędzie metadanych elementu ServiceModel (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) do konstruowania klienta, ma taką samą wartość. W przeciwnym razie ta wartość jest cokolwiek ustawisz się na komputerze klienckim.  
  
 Po osiągnięciu tego limitu na nadawcy są blokowane dodatkowych połączeń do wysłania. Po osiągnięciu tego limitu w odbiorniku nowych wiadomości przychodzące do kanału źródłowego nie są akceptowane.  
  
 Niezawodnej sesji używa protokołu obsługi okien, aby pomóc w ulepszaniu wykorzystanie sieci. Ilość buforowania wymagane bezpośrednio jest tworzony na podstawie rozmiaru okna transmisji. Podczas dostosowywania tę wartość, należy pamiętać, że okno transmisji o optymalne dotyczy przepustowości i opóźnienia w taki sposób, proste. Idealna maksymalny rozmiar okna jest przepustowość, czas opóźnienia. Mniejsze daje mniejsza niż sieci 100% wykorzystania; większe jest po prostu utracona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest co najwyżej jednego lub większej niż 4096.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ordered">
      <MemberSignature Language="C#" Value="public bool Ordered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Ordered" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.Ordered" />
      <MemberSignature Language="VB.NET" Value="Public Property Ordered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Ordered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Ordered : bool with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.Ordered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dostarczanie komunikatów muszą zachować kolejność, w jakiej komunikaty są wysyłane.</summary>
        <value>
          <see langword="true" /> Jeśli wiadomości muszą być dostarczane w kolejności, w której są wysyłane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać komunikaty wysyłane w kolejności, należy również ustawić <xref:System.ServiceModel.ConcurrencyMode> do <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReliableMessagingVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.ReliableMessagingVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ReliableMessagingVersion As ReliableMessagingVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ReliableMessagingVersion ^ ReliableMessagingVersion { System::ServiceModel::ReliableMessagingVersion ^ get(); void set(System::ServiceModel::ReliableMessagingVersion ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReliableMessagingVersion : System.ServiceModel.ReliableMessagingVersion with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.ReliableMessagingVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.ServiceModel.ReliableMessagingVersion), "WSReliableMessagingFebruary2005")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReliableMessagingVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wersję WS-ReliableMessaging określony przez element powiązania.</summary>
        <value>Wystąpienie jest pochodną <see cref="T:System.ServiceModel.ReliableMessagingVersion" /> reprezentujący wersję protokołu WS-ReliableMessaging używany przez element konfiguracji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie istnieją dwie wersje protokołu WS-ReliableMessaging obsługiwane przez Windows Communication Foundation (WCF): usługi WS-ReliableMessaging1.1 i WS-ReliableMessagingFebruary2005. Wersja domyślna jest WS ReliableMessagingFebruary2005.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportPolicy (exporter As MetadataExporter, context As PolicyConversionContext) Implements IPolicyExportExtension.ExportPolicy" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System::ServiceModel::Description::MetadataExporter ^ exporter, System::ServiceModel::Description::PolicyConversionContext ^ context) = System::ServiceModel::Description::IPolicyExportExtension::ExportPolicy;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">
          <see cref="T:System.ServiceModel.Description.MetadataExporter" /> Który Eksportuje informacje o powiązaniu w elemencie powiązanie niezawodnej sesji do elementów WSDL.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Description.PolicyConversionContext" /> Zapewniający Mapowanie elementów wyeksportowanych WSDL opis punktu końcowego.</param>
        <summary>Mapuje informacji zawartych w elemencie powiązanie niezawodnej sesji do elementów języka WSDL, które umożliwiają zdalny punkt końcowy dostępu do usługi za pomocą niezawodnej sesji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="SecurityBindingElement" FullName="System.ServiceModel.Channels.SecurityBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d30d970a5a518fd72e44fff825b2921a6060af5d" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46616232" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityBindingElement : System.ServiceModel.Channels.BindingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityBindingElement extends System.ServiceModel.Channels.BindingElement" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.SecurityBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityBindingElement&#xA;Inherits BindingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityBindingElement abstract : System::ServiceModel::Channels::BindingElement" />
  <TypeSignature Language="F#" Value="type SecurityBindingElement = class&#xA;    inherit BindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Security</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Klasy abstrakcyjne, która, po wdrożeniu, reprezentuje element powiązania, który obsługuje kanał zabezpieczenia wiadomości protokołu SOAP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest klasą bazową dla elementów powiązania protokołu SOAP wiadomości zabezpieczeń programu WCF. Istnieją trzy implementacje tej klasy abstrakcyjnej: <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement>, <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement>, i <xref:System.ServiceModel.Channels.TransportSecurityBindingElement>. Tych implementacji modelu powiązań zdefiniowanych w specyfikacji WS-Security zasad.  
  
 Powiązanie niestandardowe zawiera kolekcję elementów ułożone w określonej kolejności wiązania: element, który reprezentuje Szczyt stosu powiązania dodaje się najpierw, następnego elementu w dół w stosie powiązanie zostanie dodany drugi, i tak dalej.  
  
 Aby dodać powiązanie tej klasy, wykonaj następujące czynności:  
  
1.  Utwórz <xref:System.ServiceModel.Channels.BindingElementCollection>.  
  
2.  Utwórz element niestandardowego powiązania, który jest powyżej tego elementu powiązania w stosie powiązania, takich jak opcjonalnego <xref:System.ServiceModel.Channels.TransactionFlowBindingElement> i <xref:System.ServiceModel.Channels.ReliableSessionBindingElement>.  
  
3.  Dodaj te elementy w kolejności, opisanej wcześniej <xref:System.ServiceModel.Channels.BindingElementCollection> przy użyciu <xref:System.ServiceModel.Channels.BindingElementCollection.InsertItem%2A> metody.  
  
4.  Utwórz wystąpienie elementu powiązania zabezpieczeń pochodną <xref:System.ServiceModel.Channels.SecurityBindingElement>, takich jak <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement>, <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement>, lub <xref:System.ServiceModel.Channels.TransportSecurityBindingElement>.  
  
5.  Dodawanie elementu powiązania zabezpieczeń pochodnych do kolekcji.  
  
6.  Dodaj wszelkie dodatkowe niestandardowego powiązania elementy do kolekcji, takie jak <xref:System.ServiceModel.Channels.TcpTransportBindingElement>.  
  
 Aby uzyskać więcej informacji o korzystaniu z <xref:System.ServiceModel.Channels.SecurityBindingElement>, zobacz [tryby uwierzytelniania elementu SecurityBindingElement](~/docs/framework/wcf/feature-details/securitybindingelement-authentication-modes.md) i [porady: Tworzenie niestandardowego powiązania za pomocą elementu SecurityBindingElement](~/docs/framework/wcf/feature-details/how-to-create-a-custom-binding-using-the-securitybindingelement.md).  
  
> [!NOTE]
>  Gdy <xref:System.ServiceModel.Channels.SecurityBindingElement> obiekt zostanie utworzony, jego właściwości należy traktować jako niezmienialny. Wywoływanie `set` niektóre właściwości mogą mieć nieprzewidywalne skutki: wiązanie może zachowywać się tak, jakby właściwość zachowane starą wartość, jest jedyną reakcją zgłoszenie błędów czasu wykonywania. Dwie właściwości, znane zachowują się w ten sposób są <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.KeyType%2A> i <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A>. Mogą istnieć inne właściwości, których dotyczy to również.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="http://msdn.microsoft.com/library/12300bf4-c730-4405-9f65-d286f68b5a43">Tryby uwierzytelniania elementu SecurityBindingElement</related>
    <related type="Article" href="http://msdn.microsoft.com/library/203a9f9e-3a73-427c-87aa-721c56265b29">Instrukcje: Tworzenie niestandardowego powiązania za pomocą elementu SecurityBindingElement</related>
  </Docs>
  <Members>
    <Member MemberName="AllowInsecureTransport">
      <MemberSignature Language="C#" Value="public bool AllowInsecureTransport { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowInsecureTransport" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.AllowInsecureTransport" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowInsecureTransport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowInsecureTransport { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowInsecureTransport : bool with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.AllowInsecureTransport" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy trybu mieszanego zabezpieczonych wiadomości mogą być wysyłane za pośrednictwem niezabezpieczonych transportu, takich jak HTTP.</summary>
        <value>
          <see langword="true" /> Jeśli w trybie mieszanym zabezpieczonych wiadomości mogą być wysyłane za pośrednictwem niezabezpieczonych transportu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="securityBindingElement.BuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ fabryki kanałów.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Tworzy fabryki kanałów, na podstawie <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> ustawienia i kontekstu powiązania przekazany. Fabryka kanałów, tworzone jest SOAP fabryki kanałów zabezpieczeń wiadomości, która wewnętrznie odwołuje się do fabryki kanałów, która odnosi się do kontekstu powiązania, (co obejmuje fabryki kanałów transportu).</summary>
        <returns>Na podstawie fabryki kanałów <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> ustawienia i kontekstu powiązania przekazany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fabryka kanałów, tworzone jest SOAP fabryki kanałów zabezpieczeń wiadomości, która wewnętrznie odwołuje się do fabryki kanałów, która odnosi się do kontekstu powiązania, (co obejmuje fabryki kanałów transportu).  
  
 Ta metoda wykonuje sprawdzanie błędów parametr, a następnie wywołuje <xref:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelFactoryCore%2A>. Tej metody, w przypadku zaimplementowania w klasie pochodnej tworzy fabryki kanałów, który jest używany do utworzenia kanału, który przetwarza komunikaty wychodzące dla tego powiązania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Kanał typu <paramref name="TChannel" /> nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactoryCore&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="protected abstract System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactoryCore&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactoryCore&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelFactoryCore``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function BuildChannelFactoryCore(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TChannel&gt;&#xA; abstract System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactoryCore(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member BuildChannelFactoryCore : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="securityBindingElement.BuildChannelFactoryCore context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ fabryki kanałów.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Po wdrożeniu, tworzy fabryki kanałów określonego typu.</summary>
        <returns>Fabryka kanałów, o określonym typie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelFactory%2A>, który wykonuje sprawdzanie wywołania tej metody. Po zaimplementowaniu tej metody w klasie pochodnej tworzy fabryki kanałów, który jest używany do utworzenia kanału, który przetwarza komunikaty wychodzące dla tego powiązania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Kanał typu <paramref name="TChannel" /> nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="securityBindingElement.BuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ odbiornika kanałów.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Odbiornik kanału, na podstawie tworzy <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> ustawienia i kontekstu powiązania przekazany.</summary>
        <returns>Odbiornik kanału na podstawie <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> ustawienia i kontekstu powiązania przekazany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fabryka kanałów, tworzone jest protokołu SOAP wiadomości odbiornika kanału zabezpieczeń, która wewnętrznie odwołuje się do odbiornik kanału, który odnosi się do kontekstu powiązania, w tym odbiornik kanału transportu.  
  
 Ta metoda wykonuje sprawdzanie błędów parametr, a następnie wywołuje <xref:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelListenerCore%2A>. Tej metody, w przypadku zaimplementowania w klasie pochodnej tworzy odbiornika kanału, który jest używany do utworzenia kanału, który przetwarza komunikaty przychodzące dla tego powiązania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Kanał typu <paramref name="TChannel" /> nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListenerCore&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="protected abstract System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListenerCore&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListenerCore&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelListenerCore``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function BuildChannelListenerCore(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel abstract System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListenerCore(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member BuildChannelListenerCore : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="securityBindingElement.BuildChannelListenerCore context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ odbiornika kanałów.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Obiektu.</param>
        <summary>Po wdrożeniu, tworzy odbiornika kanałów, o określonym typie.</summary>
        <returns>Odbiornik kanału o określonym typie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelListener%2A>, który wykonuje sprawdzanie wywołania tej metody. Po zaimplementowaniu tej metody w klasie pochodnej tworzy odbiornika kanału, który jest używany do utworzenia kanału, który przetwarza komunikaty wychodzące dla tego powiązania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Kanał typu <paramref name="TChannel" /> nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; bool" Usage="securityBindingElement.CanBuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ fabryki kanałów.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Określa, czy można utworzyć fabryki kanałów dla określonego typu.</summary>
        <returns>
          <see langword="true" /> Jeśli fabryki kanałów, o określonym typie mogą być wbudowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę należy wywołać przed podjęciem próby tworzenie fabryki kanałów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; bool (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="securityBindingElement.CanBuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ odbiornika kanałów.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Określa, czy można utworzyć odbiornika kanałów, o określonym typie.</summary>
        <returns>
          <see langword="true" /> Jeśli odbiornik kanału o określonym typie mogą być wbudowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed przystąpieniem do tworzenia odbiornika kanału powinna wywołać tę metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateAnonymousForCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateAnonymousForCertificateBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateAnonymousForCertificateBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateAnonymousForCertificateBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAnonymousForCertificateBindingElement () As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateAnonymousForCertificateBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateAnonymousForCertificateBindingElement : unit -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateAnonymousForCertificateBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy elementu powiązania zabezpieczeń symetryczny, który jest skonfigurowany do uwierzytelniania anonimowego klienta i uwierzytelnianie oparte na certyfikatach serwera.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> zawierający nowego powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klient i serwer muszą być skonfigurowane poza pasmem za pomocą certyfikatu usługi.  
  
 Powiązanie jest tworzona przy użyciu <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> równa <xref:System.ServiceModel.MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11%2A> i <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> równa `true`.  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób wywołania tej metody.  
  
 [!code-csharp[c_CustomBindingsAuthMode#3](~/samples/snippets/csharp/VS_Snippets_CFX/c_custombindingsauthmode/cs/source.cs#3)]
 [!code-vb[c_CustomBindingsAuthMode#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_custombindingsauthmode/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateCertificateOverTransportBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy elementu powiązania zabezpieczeń, który oczekuje, że klienci w celu uwierzytelniania opartego na certyfikatach, korzystanie z zabezpieczeń komunikatów protokołu SOAP. Ten element powiązania oczekuje transportu, aby zapewnić uwierzytelnianie serwera, a także ochronę komunikatu (na przykład HTTPS).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klient musi być skonfigurowany przy użyciu certyfikatu używanego do uwierzytelniania.  
  
> [!NOTE]
>  Gdy <xref:System.ServiceModel.Channels.SecurityBindingElement> obiekt jest tworzony przez wywołanie tej metody <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> właściwości powinien być traktowany jako niezmienialny. Zachowanie wiązania niespójne może wystąpić, jeśli ta wartość jest modyfikowana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateCertificateOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateCertificateOverTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateCertificateOverTransportBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateOverTransportBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCertificateOverTransportBindingElement () As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateCertificateOverTransportBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateCertificateOverTransportBindingElement : unit -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateOverTransportBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy elementu powiązania zabezpieczeń, który oczekuje, że klienci w celu uwierzytelniania opartego na certyfikatach, korzystanie z zabezpieczeń komunikatów protokołu SOAP.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element powiązania oczekuje transportu, aby zapewnić uwierzytelnianie serwera, a także ochronę komunikatu (na przykład HTTPS).  
  
 Element powiązania jest skonfigurowany do używania <xref:System.ServiceModel.MessageSecurityVersion.Default%2A> właściwość <xref:System.ServiceModel.MessageSecurityVersion> klasy.  
  
 Utworzone wiązanie ma <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> równa `true`.  
  
 <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCertificateOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateCertificateOverTransportBindingElement (System.ServiceModel.MessageSecurityVersion version);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateCertificateOverTransportBindingElement(class System.ServiceModel.MessageSecurityVersion version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateOverTransportBindingElement(System.ServiceModel.MessageSecurityVersion)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCertificateOverTransportBindingElement (version As MessageSecurityVersion) As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateCertificateOverTransportBindingElement(System::ServiceModel::MessageSecurityVersion ^ version);" />
      <MemberSignature Language="F#" Value="static member CreateCertificateOverTransportBindingElement : System.ServiceModel.MessageSecurityVersion -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateOverTransportBindingElement version" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.ServiceModel.MessageSecurityVersion" />
      </Parameters>
      <Docs>
        <param name="version">
          <see cref="T:System.ServiceModel.MessageSecurityVersion" /> Dla wiązania.</param>
        <summary>Tworzy elementu powiązania zabezpieczeń, który oczekuje, że klienci w celu uwierzytelniania opartego na certyfikatach, korzystanie z zabezpieczeń komunikatów protokołu SOAP.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element powiązania oczekuje transportu, aby zapewnić uwierzytelnianie serwera, a także ochronę komunikatu (na przykład HTTPS). Skonfigurowano element powiązania z określonym <xref:System.ServiceModel.MessageSecurityVersion>.  
  
 Utworzone wiązanie ma <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> równa `true`.  
  
 <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="version" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCertificateSignatureBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateCertificateSignatureBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateCertificateSignatureBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateSignatureBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCertificateSignatureBindingElement () As AsymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::AsymmetricSecurityBindingElement ^ CreateCertificateSignatureBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateCertificateSignatureBindingElement : unit -&gt; System.ServiceModel.Channels.AsymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateSignatureBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.AsymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy element powiązania, za pomocą certyfikatu do podpisywania wiadomości. Ten element powiązania mogą służyć tylko w przypadku wymiany komunikat jednokierunkowy i jest w stanie tylko podpisywania wiadomości.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.AsymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 Ten element powiązania wymaga od klienta skonfigurować certyfikat na potrzeby uwierzytelniania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateIssuedTokenBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenBindingElement (System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenBindingElement(class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement(System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIssuedTokenBindingElement (issuedTokenParameters As IssuedSecurityTokenParameters) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateIssuedTokenBindingElement(System::ServiceModel::Security::Tokens::IssuedSecurityTokenParameters ^ issuedTokenParameters);" />
      <MemberSignature Language="F#" Value="static member CreateIssuedTokenBindingElement : System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement issuedTokenParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="issuedTokenParameters" Type="System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="issuedTokenParameters">A <see cref="T:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" /> czy reprezentuje-klucz symetryczny na podstawie wystawiony token.</param>
        <summary>Tworzy element powiązania zabezpieczeń symetryczne, skonfigurowanym w taki sposób, aby wymagane było uwierzytelnianie klienta przy użyciu klucz symetryczny na podstawie wystawiony token.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry tokenu wystawionego musi mieć typ klucza symetrycznego.  
  
> [!NOTE]
>  Gdy <xref:System.ServiceModel.Channels.SecurityBindingElement> obiekt jest tworzony przez wywołanie tej metody <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.KeyType%2A> właściwości powinien być traktowany jako niezmienialny. Zachowanie wiązania niespójne może wystąpić, jeśli ta wartość jest modyfikowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="issuedTokenParameters" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Typ klucza <paramref name="issuedTokenParameters" /> nie jest symetryczne.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateIssuedTokenForCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForCertificateBindingElement (System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForCertificateBindingElement(class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement(System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIssuedTokenForCertificateBindingElement (issuedTokenParameters As IssuedSecurityTokenParameters) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateIssuedTokenForCertificateBindingElement(System::ServiceModel::Security::Tokens::IssuedSecurityTokenParameters ^ issuedTokenParameters);" />
      <MemberSignature Language="F#" Value="static member CreateIssuedTokenForCertificateBindingElement : System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement issuedTokenParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="issuedTokenParameters" Type="System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="issuedTokenParameters">
          <see cref="T:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" /> Czy reprezentuje-klucz symetryczny na podstawie wystawiony token.</param>
        <summary>Tworzy element powiązania zabezpieczeń symetryczny, który jest skonfigurowany do żądania uwierzytelniania klienta na podstawie wystawionych tokenów i uwierzytelniania serwera, w zależności od certyfikatu serwera.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystawiony token może mieć symetryczne bądź klucza asymetrycznego. Klient i serwer musi być obsługiwana za pomocą certyfikatu serwera.  
  
 Utworzone wiązanie ma <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> równa `true` i <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> równa <xref:System.ServiceModel.MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11%2A>.  
  
> [!NOTE]
>  Gdy <xref:System.ServiceModel.Channels.SecurityBindingElement> obiekt jest tworzony przez wywołanie tej metody <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.KeyType%2A> właściwości powinien być traktowany jako niezmienialny. Zachowanie wiązania niespójne może wystąpić, jeśli ta wartość jest modyfikowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="issuedTokenParameters" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateIssuedTokenForSslBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element powiązania zabezpieczeń symetryczny, który jest skonfigurowany do żądania uwierzytelniania klienta na podstawie wystawionych tokenów i uwierzytelniania serwera, w zależności od certyfikatu serwera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystawiony token może mieć symetryczne bądź klucza asymetrycznego. Klient uwierzytelnia się na serwerze przy użyciu protokołu SSL na poziomie protokołu SOAP.  
  
 Użyj oba przeciążenia <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters> parametru. Jeden z nich zawiera parametr, który określa, czy anulowanie jest wymagane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateIssuedTokenForSslBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForSslBindingElement (System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForSslBindingElement(class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement(System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIssuedTokenForSslBindingElement (issuedTokenParameters As IssuedSecurityTokenParameters) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateIssuedTokenForSslBindingElement(System::ServiceModel::Security::Tokens::IssuedSecurityTokenParameters ^ issuedTokenParameters);" />
      <MemberSignature Language="F#" Value="static member CreateIssuedTokenForSslBindingElement : System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement issuedTokenParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="issuedTokenParameters" Type="System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="issuedTokenParameters">
          <see cref="T:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />.</param>
        <summary>Tworzy element powiązania zabezpieczeń symetryczny, który jest skonfigurowany do żądania uwierzytelniania klienta na podstawie wystawionych tokenów i uwierzytelniania serwera, w zależności od certyfikatu serwera.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serwer wysyła tokenu kontekstu zabezpieczeń na podstawie plików cookie na końcu protokołu SSL.  
  
 Utworzone wiązanie ma <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> równa `true` i <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> równa <xref:System.ServiceModel.MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="issuedTokenParameters" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateIssuedTokenForSslBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForSslBindingElement (System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters, bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForSslBindingElement(class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters, bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement(System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIssuedTokenForSslBindingElement (issuedTokenParameters As IssuedSecurityTokenParameters, requireCancellation As Boolean) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateIssuedTokenForSslBindingElement(System::ServiceModel::Security::Tokens::IssuedSecurityTokenParameters ^ issuedTokenParameters, bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateIssuedTokenForSslBindingElement : System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters * bool -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement (issuedTokenParameters, requireCancellation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="issuedTokenParameters" Type="System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="issuedTokenParameters">
          <see cref="T:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />.</param>
        <param name="requireCancellation">
          <see langword="true" /> w przypadku anulowania jest wymagana. w przeciwnym razie <see langword="false" />. Ustawienie <see langword="false" /> umożliwia tokenu kontekstu zabezpieczeń, które są przydatne w scenariuszach z farmami internetowymi, ponieważ w tym trybie stan sesji jest zakodowany w ustalonych zabezpieczeń tokenu kontekstu, zamiast przechowywane w pamięci serwera.</param>
        <summary>Tworzy element powiązania zabezpieczeń symetryczny, który jest skonfigurowany do żądania uwierzytelniania klienta na podstawie wystawionych tokenów i uwierzytelniania serwera, w zależności od certyfikatu serwera.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utworzone wiązanie ma <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> równa `true` i <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> równa <xref:System.ServiceModel.MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="issuedTokenParameters" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateIssuedTokenOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateIssuedTokenOverTransportBindingElement (System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateIssuedTokenOverTransportBindingElement(class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement(System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIssuedTokenOverTransportBindingElement (issuedTokenParameters As IssuedSecurityTokenParameters) As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateIssuedTokenOverTransportBindingElement(System::ServiceModel::Security::Tokens::IssuedSecurityTokenParameters ^ issuedTokenParameters);" />
      <MemberSignature Language="F#" Value="static member CreateIssuedTokenOverTransportBindingElement : System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement issuedTokenParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="issuedTokenParameters" Type="System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="issuedTokenParameters">
          <see cref="T:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />.</param>
        <summary>Tworzy element powiązania zabezpieczeń skonfigurowana do wymagania uwierzytelniania klienta na podstawie zabezpieczeń SOAP przy użyciu tokenu wystawionego. Ten element powiązania wymaga transportu, aby zapewniać uwierzytelnianie serwera i ochrony komunikatu (na przykład HTTPS).</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utworzone wiązanie ma <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> równa `true`.  
  
 <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
> [!NOTE]
>  Gdy <xref:System.ServiceModel.Channels.SecurityBindingElement> obiekt jest tworzony przez wywołanie tej metody <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.KeyType%2A> właściwości powinien być traktowany jako niezmienialny. Zachowanie wiązania niespójne może wystąpić, jeśli ta wartość jest modyfikowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="issuedTokenParameters" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateKerberosBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateKerberosBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateKerberosBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateKerberosBindingElement () As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateKerberosBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateKerberosBindingElement : unit -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy element powiązania zabezpieczeń symetryczny, który jest skonfigurowany do żądania uwierzytelniania klienta na podstawie tokenów Kerberos klienta.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wykonać uwierzytelnianie Kerberos, na serwerze musi działać w konta mającego usługi, nazwa główna zarejestrowane w usłudze Active Directory. Usługa sieciowa jest takiego konta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateKerberosOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateKerberosOverTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateKerberosOverTransportBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosOverTransportBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateKerberosOverTransportBindingElement () As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateKerberosOverTransportBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateKerberosOverTransportBindingElement : unit -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosOverTransportBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy elementu powiązania zabezpieczeń, który jest skonfigurowany do żądania uwierzytelniania klienta przy użyciu tokenu Kerberos klienta oparty na protokole zabezpieczeń protokołu SOAP. Ten element powiązania wymaga transportu, aby zapewniać uwierzytelnianie serwera i ochrony komunikatu (na przykład HTTPS).</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wykonać uwierzytelnianie Kerberos, na serwerze musi działać w konta mającego usługi, nazwa główna zarejestrowane w usłudze Active Directory. Usługa sieciowa jest takiego konta.  
  
 Utworzone wiązanie ma <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> równa `true`. <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateMutualCertificateBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element powiązania asymetrycznego zabezpieczeń, który jest skonfigurowany do żądania uwierzytelniania opartego na certyfikatach klientów, a także uwierzytelniania opartego na certyfikatach serwera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klient musi być skonfigurowany przy użyciu swojego certyfikatu, jak również w certyfikacie serwera. Serwer musi być skonfigurowany z jego certyfikatem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateMutualCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMutualCertificateBindingElement () As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateMutualCertificateBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateMutualCertificateBindingElement : unit -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy element powiązania asymetrycznego zabezpieczeń, który jest skonfigurowany do żądania uwierzytelniania opartego na certyfikatach klientów, a także uwierzytelniania opartego na certyfikatach serwera.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiązanie jest skonfigurowane tak, aby nowy losowy klucz symetryczny (zaszyfrowane dla serwera) jest generowany dla każdego żądania przez klienta i jest używany do ochrony żądania, a także odpowiedzi z serwera. Certyfikat klienta jest używany jako tokenu pomocniczego w żądaniu.  
  
 Element <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> jest faktycznie tworzona.  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób wywołania tej metody.  
  
 [!code-csharp[c_CreateSecureSession#5](~/samples/snippets/csharp/VS_Snippets_CFX/c_createsecuresession/cs/secureservice.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMutualCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement (System.ServiceModel.MessageSecurityVersion version);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement(class System.ServiceModel.MessageSecurityVersion version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement(System.ServiceModel.MessageSecurityVersion)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMutualCertificateBindingElement (version As MessageSecurityVersion) As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateMutualCertificateBindingElement(System::ServiceModel::MessageSecurityVersion ^ version);" />
      <MemberSignature Language="F#" Value="static member CreateMutualCertificateBindingElement : System.ServiceModel.MessageSecurityVersion -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement version" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.ServiceModel.MessageSecurityVersion" />
      </Parameters>
      <Docs>
        <param name="version">Wersja zabezpieczenia wiadomości.</param>
        <summary>Tworzy element powiązania asymetrycznego zabezpieczeń, który jest skonfigurowany do żądania uwierzytelniania opartego na certyfikatach klientów, a także uwierzytelniania opartego na certyfikatach serwera.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wersja jest elementem WSSecurity10, element powiązania jest skonfigurowany tak, aby żądanie klienta jest podpisany przez certyfikat i zaszyfrowany przy użyciu certyfikatu serwera.  
  
 Jeśli wersja jest WSSecurity11, element powiązania jest skonfigurowany, tak aby nowy losowy klucz symetryczny (zaszyfrowane dla serwera) jest generowany dla każdego żądania przez klienta i jest używany do ochrony żądania, a także odpowiedzi z serwera. Certyfikat klienta jest używany jako tokenu pomocniczego w żądaniu.  
  
> [!NOTE]
>  Gdy <xref:System.ServiceModel.Channels.SecurityBindingElement> obiekt jest tworzony przez wywołanie tej metody <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> właściwość jest niezmienny. Wywoływanie `set` na nie zmienia jej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="version" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateMutualCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement (System.ServiceModel.MessageSecurityVersion version, bool allowSerializedSigningTokenOnReply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement(class System.ServiceModel.MessageSecurityVersion version, bool allowSerializedSigningTokenOnReply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement(System.ServiceModel.MessageSecurityVersion,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMutualCertificateBindingElement (version As MessageSecurityVersion, allowSerializedSigningTokenOnReply As Boolean) As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateMutualCertificateBindingElement(System::ServiceModel::MessageSecurityVersion ^ version, bool allowSerializedSigningTokenOnReply);" />
      <MemberSignature Language="F#" Value="static member CreateMutualCertificateBindingElement : System.ServiceModel.MessageSecurityVersion * bool -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement (version, allowSerializedSigningTokenOnReply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.ServiceModel.MessageSecurityVersion" />
        <Parameter Name="allowSerializedSigningTokenOnReply" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="version">Wersja zabezpieczenia wiadomości.</param>
        <param name="allowSerializedSigningTokenOnReply">
          <see langword="true" /> Aby umożliwić Zserializowany obiekt podpisywania tokenu na odpowiedź; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy element powiązania asymetrycznego zabezpieczeń, który jest skonfigurowany do żądania uwierzytelniania opartego na certyfikatach klientów, a także uwierzytelniania opartego na certyfikatach serwera.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `allowSerializedSigningTokenOnReply` Parametr, gdy `true`, umożliwia współdziałanie ze starszymi wersjami z rozszerzeń usługi sieci Web (WSE).  
  
> [!NOTE]
>  Gdy <xref:System.ServiceModel.Channels.SecurityBindingElement> obiekt jest tworzony przez wywołanie tej metody <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> właściwości powinien być traktowany jako niezmienialny. Zachowanie wiązania niespójne może wystąpić, jeśli ta wartość jest modyfikowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="version" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateMutualCertificateDuplexBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element powiązania asymetrycznego zabezpieczeń, który jest skonfigurowany do żądania uwierzytelniania opartego na certyfikatach klientów, a także uwierzytelniania opartego na certyfikatach serwera. Ten tryb uwierzytelniania mogą służyć do zabezpieczenia wzorców dwukierunkowego wymiany komunikatów i wymaga usługi można skonfigurować za pomocą certyfikatu klienta poza pasmem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateMutualCertificateDuplexBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateMutualCertificateDuplexBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateMutualCertificateDuplexBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateDuplexBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMutualCertificateDuplexBindingElement () As AsymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::AsymmetricSecurityBindingElement ^ CreateMutualCertificateDuplexBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateMutualCertificateDuplexBindingElement : unit -&gt; System.ServiceModel.Channels.AsymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateDuplexBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.AsymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy element powiązania asymetrycznego zabezpieczeń, który jest skonfigurowany do żądania uwierzytelniania opartego na certyfikatach klientów, a także uwierzytelniania opartego na certyfikatach serwera. Ten tryb uwierzytelniania mogą służyć do zabezpieczenia wzorców dwukierunkowego wymiany komunikatów i wymaga usługi można skonfigurować za pomocą certyfikatu klienta poza pasmem.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.AsymmetricSecurityBindingElement" /> Obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMutualCertificateDuplexBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateMutualCertificateDuplexBindingElement (System.ServiceModel.MessageSecurityVersion version);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateMutualCertificateDuplexBindingElement(class System.ServiceModel.MessageSecurityVersion version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateDuplexBindingElement(System.ServiceModel.MessageSecurityVersion)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMutualCertificateDuplexBindingElement (version As MessageSecurityVersion) As AsymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::AsymmetricSecurityBindingElement ^ CreateMutualCertificateDuplexBindingElement(System::ServiceModel::MessageSecurityVersion ^ version);" />
      <MemberSignature Language="F#" Value="static member CreateMutualCertificateDuplexBindingElement : System.ServiceModel.MessageSecurityVersion -&gt; System.ServiceModel.Channels.AsymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateDuplexBindingElement version" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.AsymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.ServiceModel.MessageSecurityVersion" />
      </Parameters>
      <Docs>
        <param name="version">Wersja zabezpieczenia wiadomości.</param>
        <summary>Tworzy element powiązania asymetrycznego zabezpieczeń, który jest skonfigurowany do żądania uwierzytelniania opartego na certyfikatach klientów, a także uwierzytelniania opartego na certyfikatach serwera. Ten tryb uwierzytelniania mogą służyć do zabezpieczenia dwukierunkowego wiadomości programu exchange wzorców i wymaga usługi można skonfigurować za pomocą certyfikatu klienta poza pasmem.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.AsymmetricSecurityBindingElement" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Gdy <xref:System.ServiceModel.Channels.SecurityBindingElement> obiekt jest tworzony przez wywołanie tej metody <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> właściwości powinien być traktowany jako niezmienialny. Zachowanie wiązania niespójne może wystąpić, jeśli ta wartość jest modyfikowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="version" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSecureConversationBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy elementu powiązania zabezpieczeń symetryczny, który jest skonfigurowany do ustanowienia bezpiecznej konwersacji między klientem a usługą. Token kontekstu zabezpieczeń, które są wydawane na końcu uzgadnianie bezpiecznej konwersacji jest używany do zabezpieczenia wiadomości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSecureConversationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement (System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement(class System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement(System.ServiceModel.Channels.SecurityBindingElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSecureConversationBindingElement (bootstrapSecurity As SecurityBindingElement) As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateSecureConversationBindingElement(System::ServiceModel::Channels::SecurityBindingElement ^ bootstrapSecurity);" />
      <MemberSignature Language="F#" Value="static member CreateSecureConversationBindingElement : System.ServiceModel.Channels.SecurityBindingElement -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement bootstrapSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bootstrapSecurity" Type="System.ServiceModel.Channels.SecurityBindingElement" />
      </Parameters>
      <Docs>
        <param name="bootstrapSecurity">Element <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> zawierający specyfikacji na jak są zabezpieczone wiadomości uzgadnianie bezpiecznej konwersacji.</param>
        <summary>Tworzy elementu powiązania zabezpieczeń symetryczny, który jest skonfigurowany do ustanowienia bezpiecznej konwersacji między klientem a usługą. Token kontekstu zabezpieczeń, które są wydawane na końcu uzgadnianie bezpiecznej konwersacji jest używany do zabezpieczenia wiadomości. Element powiązania zabezpieczeń dla uruchamiania Określa, jak są zabezpieczone wiadomości uzgadnianie bezpiecznej konwersacji.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element powiązania jest skonfigurowany do używania tokenów kontekstu zabezpieczeń opartych na sesji.  
  
 `bootstrapSecurity` Służy do wskazywania powiązanie zabezpieczeń i zasady stosowane do wysłania żądania tokenu służącego bezpiecznej konwersacji z usługi.  
  
 Jeśli `bootstrapSecurity` jest <xref:System.ServiceModel.Channels.TransportSecurityBindingElement>, element powiązania zwracanego przez tę metodę jest także jednym, i <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> jest ustawiona na `true`; i <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> właściwość ustawioną na `false`; i <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 W przeciwnym razie <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> jest zwracany za pomocą <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> równa `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bootstrapSecurity" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSecureConversationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement (System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity, bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement(class System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity, bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement(System.ServiceModel.Channels.SecurityBindingElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSecureConversationBindingElement (bootstrapSecurity As SecurityBindingElement, requireCancellation As Boolean) As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateSecureConversationBindingElement(System::ServiceModel::Channels::SecurityBindingElement ^ bootstrapSecurity, bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateSecureConversationBindingElement : System.ServiceModel.Channels.SecurityBindingElement * bool -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement (bootstrapSecurity, requireCancellation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bootstrapSecurity" Type="System.ServiceModel.Channels.SecurityBindingElement" />
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bootstrapSecurity">Element <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> zawierający specyfikacji na jak są zabezpieczone wiadomości uzgadnianie bezpiecznej konwersacji.</param>
        <param name="requireCancellation">
          <see langword="true" /> w przypadku anulowania jest wymagana. w przeciwnym razie <see langword="false" />. Ustawienie tego parametru na <see langword="false" /> umożliwia tokenu kontekstu zabezpieczeń, które są przydatne w scenariuszach z farmami internetowymi, ponieważ w tym trybie stan sesji jest zakodowany w ustalonych zabezpieczeń tokenu kontekstu, zamiast przechowywane w pamięci serwera.</param>
        <summary>Tworzy elementu powiązania zabezpieczeń symetryczny, który jest skonfigurowany do ustanowienia bezpiecznej konwersacji między klientem a usługą. Token kontekstu zabezpieczeń, które są wydawane na końcu uzgadnianie bezpiecznej konwersacji jest używany do zabezpieczenia wiadomości.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `requireCancellation` jest `false`, wystawił tokeny kontekstu zabezpieczeń opartych na plikach cookie; w przeciwnym razie wystawił tokeny kontekstu zabezpieczeń opartych na sesji.  
  
 `bootstrapSecurity` Służy do wskazywania powiązanie zabezpieczeń i zasady stosowane do żądania `SecureConversationToken` z usługi.  
  
 Jeśli `bootstrapSecurity` jest <xref:System.ServiceModel.Channels.TransportSecurityBindingElement>, element powiązania zwracanego przez tę metodę jest również `TransportSecurityBindingElement`, i <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> ustawiono `true`; i <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> ustawioną właściwość Aby `false`; i <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 W przeciwnym razie <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> jest zwracany za pomocą <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> równa `false`.  
  
> [!NOTE]
>  Podczas personifikacji jest wymagany na [!INCLUDE[wxp](~/includes/wxp-md.md)], użyj bezpiecznej sesji bez tokenu kontekstu zabezpieczeń. Kiedy należy używać tokenów kontekstu zabezpieczeń personifikacji <xref:System.InvalidOperationException> zgłaszany. Aby uzyskać więcej informacji, zobacz [nieobsługiwane scenariusze](~/docs/framework/wcf/feature-details/unsupported-scenarios.md). Aby dowiedzieć się więcej o bezpiecznych sesji, zobacz [bezpiecznych sesji](~/docs/framework/wcf/feature-details/secure-sessions.md).  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób wywołania tej metody.  
  
 [!code-csharp[c_CreateSecureSession#6](~/samples/snippets/csharp/VS_Snippets_CFX/c_createsecuresession/cs/secureservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bootstrapSecurity" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSecureConversationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement (System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity, bool requireCancellation, System.ServiceModel.Security.ChannelProtectionRequirements bootstrapProtectionRequirements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement(class System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity, bool requireCancellation, class System.ServiceModel.Security.ChannelProtectionRequirements bootstrapProtectionRequirements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement(System.ServiceModel.Channels.SecurityBindingElement,System.Boolean,System.ServiceModel.Security.ChannelProtectionRequirements)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSecureConversationBindingElement (bootstrapSecurity As SecurityBindingElement, requireCancellation As Boolean, bootstrapProtectionRequirements As ChannelProtectionRequirements) As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateSecureConversationBindingElement(System::ServiceModel::Channels::SecurityBindingElement ^ bootstrapSecurity, bool requireCancellation, System::ServiceModel::Security::ChannelProtectionRequirements ^ bootstrapProtectionRequirements);" />
      <MemberSignature Language="F#" Value="static member CreateSecureConversationBindingElement : System.ServiceModel.Channels.SecurityBindingElement * bool * System.ServiceModel.Security.ChannelProtectionRequirements -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement (bootstrapSecurity, requireCancellation, bootstrapProtectionRequirements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bootstrapSecurity" Type="System.ServiceModel.Channels.SecurityBindingElement" />
        <Parameter Name="requireCancellation" Type="System.Boolean" />
        <Parameter Name="bootstrapProtectionRequirements" Type="System.ServiceModel.Security.ChannelProtectionRequirements" />
      </Parameters>
      <Docs>
        <param name="bootstrapSecurity">Element <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> zawierający specyfikacji na jak są zabezpieczone wiadomości uzgadnianie bezpiecznej konwersacji.</param>
        <param name="requireCancellation">
          <see langword="true" /> w przypadku anulowania jest wymagana. w przeciwnym razie <see langword="false" />. Ustawienie tego parametru na <see langword="false" /> umożliwia tokenu kontekstu zabezpieczeń, które są przydatne w scenariuszach z farmami internetowymi, ponieważ w tym trybie stan sesji jest zakodowany w ustalonych zabezpieczeń tokenu kontekstu, zamiast przechowywane w pamięci serwera.</param>
        <param name="bootstrapProtectionRequirements">
          <see cref="T:System.ServiceModel.Security.ChannelProtectionRequirements" /> Obiektu, który określa wymagania dotyczące ochrony kanału.</param>
        <summary>Tworzy elementu powiązania zabezpieczeń symetryczny, który jest skonfigurowany do ustanowienia bezpiecznej konwersacji między klientem a usługą. Token kontekstu zabezpieczeń, które są wydawane na końcu uzgadnianie bezpiecznej konwersacji jest używany do zabezpieczenia wiadomości. Element powiązania zabezpieczeń dla uruchamiania Określa, jak są zabezpieczone wiadomości uzgadnianie bezpiecznej konwersacji.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `bootstrapProtectionRequirements` Parametr umożliwia dostosowywanie sposobu zabezpieczonych wiadomości wymieniane jako część uzgadniania bezpiecznej konwersacji.  
  
 `bootstrapSecurity` Służy do wskazywania powiązanie zabezpieczeń i zasady stosowane do wysłania żądania tokenu służącego bezpiecznej konwersacji z usługi.  
  
 Jeśli `bootstrapSecurity` jest <xref:System.ServiceModel.Channels.TransportSecurityBindingElement>, element powiązania zwracanego przez tę metodę jest również `TransportSecurityBindingElement`, i <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> ustawiono `true`; i <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> ustawioną właściwość Aby `false`; i <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 W przeciwnym razie <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> jest zwracany za pomocą <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> równa `false`.  
  
> [!NOTE]
>  Podczas personifikacji jest wymagany na [!INCLUDE[wxp](~/includes/wxp-md.md)], użyj bezpiecznej sesji bez tokenu kontekstu zabezpieczeń. Kiedy należy używać tokenów kontekstu zabezpieczeń personifikacji <xref:System.InvalidOperationException> zgłaszany. Aby uzyskać więcej informacji, zobacz [nieobsługiwane scenariusze](~/docs/framework/wcf/feature-details/unsupported-scenarios.md). Aby dowiedzieć się więcej o bezpiecznych sesji, zobacz [bezpiecznych sesji](~/docs/framework/wcf/feature-details/secure-sessions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bootstrapSecurity" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSslNegotiationBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element powiązania symetrycznego zabezpieczeń, który jest skonfigurowany w celu negocjowania protokołu SOAP na poziomie protokołu SSL między klientem i serwerem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSslNegotiationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSslNegotiationBindingElement (bool requireClientCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSslNegotiationBindingElement(bool requireClientCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSslNegotiationBindingElement(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSslNegotiationBindingElement (requireClientCertificate As Boolean) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateSslNegotiationBindingElement(bool requireClientCertificate);" />
      <MemberSignature Language="F#" Value="static member CreateSslNegotiationBindingElement : bool -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSslNegotiationBindingElement requireClientCertificate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireClientCertificate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireClientCertificate">
          <see langword="true" /> Jeśli certyfikat klienta jest wymagane podczas negocjacji w protokole SSL.</param>
        <summary>Tworzy element powiązania symetrycznego zabezpieczeń, która jest skonfigurowana do przeprowadzania negocjacji protokołu SOAP na poziomie protokołu SSL między klientem a serwerem, biorąc pod uwagę, czy certyfikat klienta jest wymagany.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> zawierający nowego powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token kontekstu zabezpieczeń wydane po negocjacji protokołu SSL na podstawie pliku cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSslNegotiationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSslNegotiationBindingElement (bool requireClientCertificate, bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSslNegotiationBindingElement(bool requireClientCertificate, bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSslNegotiationBindingElement(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSslNegotiationBindingElement (requireClientCertificate As Boolean, requireCancellation As Boolean) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateSslNegotiationBindingElement(bool requireClientCertificate, bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateSslNegotiationBindingElement : bool * bool -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSslNegotiationBindingElement (requireClientCertificate, requireCancellation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireClientCertificate" Type="System.Boolean" />
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireClientCertificate">
          <see langword="true" /> Jeśli certyfikat klienta jest wymagane podczas negocjacji w protokole SSL.</param>
        <param name="requireCancellation">
          <see langword="true" /> Jeśli wymagana jest anulowania. Ustawienie <see langword="false" /> umożliwia tokenu kontekstu zabezpieczeń, które są przydatne w scenariuszach z farmami internetowymi, ponieważ w tym trybie stan sesji jest zakodowany w ustalonych zabezpieczeń tokenu kontekstu, zamiast przechowywane w pamięci serwera.</param>
        <summary>Tworzy elementu powiązania zabezpieczeń symetryczne, który wykonuje negocjacji SSL protokołu SOAP, biorąc pod uwagę, czy jest wymagany certyfikat klienta i anulowania.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> zawierający nowego powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token kontekstu zabezpieczeń wydane po negocjacji w protokole SSL oparte na sesji jest `requireCancellation` jest `true`; w przeciwnym razie jest na podstawie pliku cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSspiNegotiationBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element powiązania symetrycznego zabezpieczeń, który wykonuje negocjacji interfejsu SSPI protokołu SOAP na podstawie pakietu uwierzytelniania Negotiate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSspiNegotiationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSspiNegotiationBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSspiNegotiationBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSspiNegotiationBindingElement () As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateSspiNegotiationBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateSspiNegotiationBindingElement : unit -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy element powiązania symetrycznego zabezpieczeń, który wykonuje negocjacji interfejsu SSPI protokołu SOAP na podstawie pakietu uwierzytelniania Negotiate.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token kontekstu zabezpieczeń, które są wydawane na końcu negocjacji interfejsu SSPI jest na podstawie pliku cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSspiNegotiationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSspiNegotiationBindingElement (bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSspiNegotiationBindingElement(bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSspiNegotiationBindingElement (requireCancellation As Boolean) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateSspiNegotiationBindingElement(bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateSspiNegotiationBindingElement : bool -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement requireCancellation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireCancellation">Określa, czy anulowanie jest wymagane. Ustawienie <see langword="false" /> umożliwia tokenu kontekstu zabezpieczeń, które są przydatne w scenariuszach z farmami internetowymi, ponieważ w tym trybie stan sesji jest zakodowany w ustalonych zabezpieczeń tokenu kontekstu, zamiast przechowywane w pamięci serwera.</param>
        <summary>Tworzy element powiązania symetrycznego zabezpieczeń, który wykonuje negocjacji interfejsu SSPI protokołu SOAP na podstawie pakietu uwierzytelniania Negotiate.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `requireCancellation` jest `false`, token kontekstu zabezpieczeń, które są wydawane na końcu negocjacji interfejsu SSPI jest na podstawie pliku cookie; w przeciwnym razie jest oparte na sesji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSspiNegotiationOverTransportBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy elementu powiązania zabezpieczeń, który jest skonfigurowany do uwierzytelniania klientów, w oparciu o negocjacji interfejsu SSPI protokołu SOAP, przy użyciu pakietu uwierzytelniania Negotiate. Element powiązania wymaga transportu do ochrony serwera uwierzytelniania i komunikatu (na przykład HTTPS).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSspiNegotiationOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateSspiNegotiationOverTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateSspiNegotiationOverTransportBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationOverTransportBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSspiNegotiationOverTransportBindingElement () As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateSspiNegotiationOverTransportBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateSspiNegotiationOverTransportBindingElement : unit -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationOverTransportBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy elementu powiązania zabezpieczeń, który jest skonfigurowany do uwierzytelniania klientów, w oparciu o negocjacji interfejsu SSPI protokołu SOAP, przy użyciu pakietu uwierzytelniania Negotiate. Element powiązania wymaga transportu do ochrony serwera uwierzytelniania i komunikatu (na przykład HTTPS).</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token kontekstu zabezpieczeń, które są wydawane na końcu negocjacji interfejsu SSPI jest na podstawie pliku cookie.  
  
 Utworzone wiązanie ma <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> równa `true`. <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSspiNegotiationOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateSspiNegotiationOverTransportBindingElement (bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateSspiNegotiationOverTransportBindingElement(bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationOverTransportBindingElement(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSspiNegotiationOverTransportBindingElement (requireCancellation As Boolean) As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateSspiNegotiationOverTransportBindingElement(bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateSspiNegotiationOverTransportBindingElement : bool -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationOverTransportBindingElement requireCancellation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireCancellation">Określa, czy anulowanie jest wymagane. Ustawienie <see langword="false" /> umożliwia tokenu kontekstu zabezpieczeń, które są przydatne w scenariuszach z farmami internetowymi, ponieważ w tym trybie stan sesji jest zakodowany w ustalonych zabezpieczeń tokenu kontekstu, zamiast przechowywane w pamięci serwera.</param>
        <summary>Tworzy elementu powiązania zabezpieczeń, który jest skonfigurowany do uwierzytelniania klientów, w oparciu o negocjacji interfejsu SSPI protokołu SOAP, przy użyciu pakietu uwierzytelniania Negotiate. Element powiązania wymaga transportu do ochrony serwera uwierzytelniania i komunikatu (na przykład HTTPS).</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `requireCancellation` jest `false`, wystawił tokeny kontekstu zabezpieczeń opartych na plikach cookie; w przeciwnym razie wystawił tokeny kontekstu zabezpieczeń opartych na sesji.  
  
 Utworzone wiązanie ma <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> równa `true`. <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUserNameForCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForCertificateBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForCertificateBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForCertificateBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateUserNameForCertificateBindingElement () As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateUserNameForCertificateBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateUserNameForCertificateBindingElement : unit -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForCertificateBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy element powiązania zabezpieczeń symetryczny, który jest skonfigurowany do żądania uwierzytelniania klienta na podstawie nazwy i hasła użytkownika i uwierzytelniania opartego na certyfikatach serwera. Element utworzone wiązanie wymaga od klienta można skonfigurować za pomocą usługi certyfikatów to znaczy out-of-band przed otwarciem kanał komunikacji z usługą.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certyfikat serwera musi być skonfigurowany poza pasmem po stronie klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateUserNameForSslBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element powiązania zabezpieczeń symetryczny, który jest skonfigurowany do żądania uwierzytelniania klienta na podstawie nazwy i hasła użytkownika i uwierzytelniania opartego na certyfikatach serwera. Klient uwierzytelnia się na serwerze przy użyciu protokołu SSL na poziomie protokołu SOAP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateUserNameForSslBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForSslBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForSslBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForSslBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateUserNameForSslBindingElement () As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateUserNameForSslBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateUserNameForSslBindingElement : unit -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForSslBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy element powiązania zabezpieczeń symetryczny, który jest skonfigurowany do żądania uwierzytelniania klienta na podstawie nazwy i hasła użytkownika i uwierzytelniania opartego na certyfikatach serwera. Klient uwierzytelnia się na serwerze przy użyciu protokołu SSL na poziomie protokołu SOAP.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token kontekstu zabezpieczeń, które są wydawane na końcu negocjacji interfejsu SSPI jest na podstawie pliku cookie.  
  
 Klient nie musi być obsługiwana za pomocą certyfikatu serwera, ponieważ otrzymuje go jako część protokołu SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUserNameForSslBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForSslBindingElement (bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForSslBindingElement(bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForSslBindingElement(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateUserNameForSslBindingElement (requireCancellation As Boolean) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateUserNameForSslBindingElement(bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateUserNameForSslBindingElement : bool -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForSslBindingElement requireCancellation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireCancellation">Określa, czy anulowanie jest wymagane. Ustawienie <see langword="false" /> umożliwia tokenu kontekstu zabezpieczeń, które są przydatne w scenariuszach z farmami internetowymi, ponieważ w tym trybie stan sesji jest zakodowany w ustalonych zabezpieczeń tokenu kontekstu, zamiast przechowywane w pamięci serwera.</param>
        <summary>Tworzy element powiązania zabezpieczeń symetryczny, który jest skonfigurowany do żądania uwierzytelniania klienta na podstawie nazwy i hasła użytkownika i uwierzytelniania opartego na certyfikatach serwera. Klient uwierzytelnia się na serwerze przy użyciu protokołu SSL na poziomie protokołu SOAP.</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `requireCancellation` jest `false`, wystawił tokeny kontekstu zabezpieczeń stanową; w przeciwnym razie wystawił tokeny kontekstu zabezpieczeń bezstanowe.  
  
 Klient nie musi być obsługiwana za pomocą certyfikatu serwera, ponieważ otrzymuje go jako część protokołu SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUserNameOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateUserNameOverTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateUserNameOverTransportBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameOverTransportBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateUserNameOverTransportBindingElement () As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateUserNameOverTransportBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateUserNameOverTransportBindingElement : unit -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameOverTransportBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy elementu powiązania zabezpieczeń, który jest skonfigurowany do uwierzytelniania klienta na podstawie nazwy użytkownika i hasła przesyłanych w ramach komunikatu protokołu SOAP. Element powiązania wymaga transportu do ochrony serwera uwierzytelniania i komunikatu (na przykład HTTPS).</summary>
        <returns>Element <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utworzone wiązanie ma <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> równa `true`. <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> Obiekt zwracany z <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> ma jego <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> właściwością `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultAlgorithmSuite">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.SecurityAlgorithmSuite DefaultAlgorithmSuite { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Security.SecurityAlgorithmSuite DefaultAlgorithmSuite" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.DefaultAlgorithmSuite" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultAlgorithmSuite As SecurityAlgorithmSuite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::SecurityAlgorithmSuite ^ DefaultAlgorithmSuite { System::ServiceModel::Security::SecurityAlgorithmSuite ^ get(); void set(System::ServiceModel::Security::SecurityAlgorithmSuite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultAlgorithmSuite : System.ServiceModel.Security.SecurityAlgorithmSuite with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.DefaultAlgorithmSuite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.SecurityAlgorithmSuite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia komunikat algorytmów szyfrowania i zawijania klucza.</summary>
        <value>
          <see cref="T:System.ServiceModel.Security.SecurityAlgorithmSuite" /> Obiekt, który reprezentuje algorytmów szyfrowania i zawijania klucza komunikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Security.SecurityAlgorithmSuite> Obiekt, który zawiera wiele właściwości, które określają algorytmów zabezpieczeń, które mają być używane do podpisywania, szyfrowania, klucza pochodnego i innych operacji kryptograficznych. To ustawienie steruje również rozmiary kluczy, które są używane do wykonywania tych operacji kryptograficznych.  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób ustawić tę właściwość.  
  
 [!code-csharp[c_CustomBindingsAuthMode#8](~/samples/snippets/csharp/VS_Snippets_CFX/c_custombindingsauthmode/cs/source.cs#8)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ma wartość null na <see langword="set" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableUnsecuredResponse">
      <MemberSignature Language="C#" Value="public bool EnableUnsecuredResponse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableUnsecuredResponse" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.EnableUnsecuredResponse" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableUnsecuredResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableUnsecuredResponse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableUnsecuredResponse : bool with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.EnableUnsecuredResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy WCF można wysyłać i odbierać niezabezpieczony odpowiedzi na żądania zabezpieczone.</summary>
        <value>
          <see langword="true" /> Jeśli WCF można wysyłać i odbierać niezabezpieczony odpowiedzi na żądania zabezpieczonej; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndpointSupportingTokenParameters">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.Tokens.SupportingTokenParameters EndpointSupportingTokenParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Security.Tokens.SupportingTokenParameters EndpointSupportingTokenParameters" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.EndpointSupportingTokenParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndpointSupportingTokenParameters As SupportingTokenParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::Tokens::SupportingTokenParameters ^ EndpointSupportingTokenParameters { System::ServiceModel::Security::Tokens::SupportingTokenParameters ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EndpointSupportingTokenParameters : System.ServiceModel.Security.Tokens.SupportingTokenParameters" Usage="System.ServiceModel.Channels.SecurityBindingElement.EndpointSupportingTokenParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.Tokens.SupportingTokenParameters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punkt końcowy, który obsługuje parametry tokenu.</summary>
        <value>
          <see cref="T:System.ServiceModel.Security.Tokens.SupportingTokenParameters" /> Obiekt, który reprezentuje punkt końcowy, który obsługuje parametry tokenu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tokeny pomocnicze zapewniają dodatkowe oświadczenia poza tymi, które zawarte w głównej tokenów dla wiązania. Zbiorze zwróconym przez <xref:System.ServiceModel.Channels.SecurityBindingElement.EndpointSupportingTokenParameters%2A> zawiera dodatkowe parametry tokenu (<xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters>) dla wszystkich operacji zdefiniowany przez punkt końcowy. Podstawowe parametry tokenu znajdują się w dowolnym <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> lub <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> (zarówno dziedziczyć <xref:System.ServiceModel.Channels.SecurityBindingElement> klasy). W przypadku właściwości <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement>, podstawowe parametry tokenu są zwracane przez <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.ProtectionTokenParameters%2A> właściwości. Na <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> elementu dostępne są dwie właściwości parametru <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement.InitiatorTokenParameters%2A> i <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement.RecipientTokenParameters%2A> właściwości.  
  
> [!NOTE]
>  Właściwości są nazywane parametrami, ponieważ określają typ tokenu zabezpieczeń, a nie rzeczywiste wartości.  
>   
>  Obsługa tokenów można zmniejszyć zakres na poziomie punktu końcowego, w którym to przypadku są one uwzględnione w wszystkich zabezpieczonych wiadomości wysłane przez klienta do usługi. Usługa wymusza na tym, że wszystkie zabezpieczonych wiadomości z klienta zawierają typy tokenów pomocniczych, skonfigurowane przez tę właściwość.  
>   
>  Zapewnienie obsługi tokenów tylko dla operacji (nie wszystkie operacje w punkcie końcowym), użyj <xref:System.ServiceModel.Channels.SecurityBindingElement.OptionalOperationSupportingTokenParameters%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetProperty : System.ServiceModel.Channels.BindingContext -&gt; 'T (requires 'T : null)" Usage="securityBindingElement.GetProperty context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Właściwości do pobrania.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Pobiera określony obiekt przy użyciu określonego <see cref="T:System.ServiceModel.Channels.BindingContext" />.</summary>
        <returns>Określony obiekt z <see cref="T:System.ServiceModel.Channels.BindingContext" /> lub <see langword="null" /> Jeśli obiekt nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera określony obiekt z klasy bazowej lub jeden z elementów nadrzędnych tej klasy. Zwrócony obiekt jest zwykle zbiór właściwości, na przykład, obiekt, który implementuje <xref:System.ServiceModel.Channels.ISecurityCapabilities>.  
  
 Jeśli `SecurityBindingElement` nie rozpoznaje żądany typ właściwości deleguje ona wywołanie stosu element powiązania poniżej przekazywania parametru kontekstu powiązania. Typy właściwości, `SecurityBindingElement` może zapewnić są <xref:System.ServiceModel.Channels.ISecurityCapabilities> i <xref:System.ServiceModel.Security.IdentityVerifier>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeTimestamp">
      <MemberSignature Language="C#" Value="public bool IncludeTimestamp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeTimestamp" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeTimestamp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeTimestamp { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeTimestamp : bool with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy sygnatury czasowe są umieszczane w każdej wiadomości.</summary>
        <value>
          <see langword="true" /> Jeśli sygnatury czasowe są umieszczane w każdej wiadomości; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> właściwość `true` i, jeśli `DetectReplays` jest `true`, WCF wykrywa atak metodą powtórzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyEntropyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.SecurityKeyEntropyMode KeyEntropyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.Security.SecurityKeyEntropyMode KeyEntropyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.KeyEntropyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyEntropyMode As SecurityKeyEntropyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::SecurityKeyEntropyMode KeyEntropyMode { System::ServiceModel::Security::SecurityKeyEntropyMode get(); void set(System::ServiceModel::Security::SecurityKeyEntropyMode value); };" />
      <MemberSignature Language="F#" Value="member this.KeyEntropyMode : System.ServiceModel.Security.SecurityKeyEntropyMode with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.KeyEntropyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.SecurityKeyEntropyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia źródło entropia używana do tworzenia kluczy.</summary>
        <value>
          <see cref="T:System.ServiceModel.Security.SecurityKeyEntropyMode" /> Używany do tworzenia kluczy. Wartość domyślna to <see cref="F:System.ServiceModel.Security.SecurityKeyEntropyMode.CombinedEntropy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.SecurityBindingElement.KeyEntropyMode%2A> Określa, jak tokeny klucza (takie jak <xref:System.ServiceModel.Security.Tokens.SecurityContextSecurityToken>) wystawiony przez usługę jest kolumną obliczaną: tego, czy jest obliczana na klienta klucza materiale tylko na podstawie usługi materiału klucza tylko, lub jako kombinację obu tych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalClientSettings">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.LocalClientSecuritySettings LocalClientSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.LocalClientSecuritySettings LocalClientSettings" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalClientSettings As LocalClientSecuritySettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::LocalClientSecuritySettings ^ LocalClientSettings { System::ServiceModel::Channels::LocalClientSecuritySettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalClientSettings : System.ServiceModel.Channels.LocalClientSecuritySettings" Usage="System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.LocalClientSecuritySettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wiązanie właściwości określonych ustawień zabezpieczeń lokalnych, używany przez klienta.</summary>
        <value>
          <see cref="T:System.ServiceModel.Channels.LocalClientSecuritySettings" /> Reprezentujący wiązanie właściwości określonych ustawień zabezpieczeń lokalnych, używany przez klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienia są lokalne w tym sensie, że nie są one ustawienia pochodzące z zasad zabezpieczeń usługi. Możesz uzyskać <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> obiektu i przy jego użyciu można ustawić właściwości zabezpieczeń dla tego powiązania.  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób dostępu do tej właściwości do ustawiania właściwości w innym obiekcie.  
  
 [!code-csharp[c_MaxClockSkew#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_maxclockskew/cs/source.cs#1)]
 [!code-vb[c_MaxClockSkew#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_maxclockskew/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalServiceSettings">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.LocalServiceSecuritySettings LocalServiceSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.LocalServiceSecuritySettings LocalServiceSettings" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalServiceSettings As LocalServiceSecuritySettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::LocalServiceSecuritySettings ^ LocalServiceSettings { System::ServiceModel::Channels::LocalServiceSecuritySettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalServiceSettings : System.ServiceModel.Channels.LocalServiceSecuritySettings" Usage="System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.LocalServiceSecuritySettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wiązanie właściwości określonych lokalne ustawienia zabezpieczeń używane przez usługę.</summary>
        <value>
          <see cref="T:System.ServiceModel.Channels.LocalServiceSecuritySettings" /> Obiekt, który reprezentuje właściwości powiązania specyficzne lokalne ustawienia zabezpieczeń używane przez usługę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienia są lokalne, ponieważ nie są publikowane jako część zasad zabezpieczeń usługi i nie ma wpływu na powiązań klienta.  
  
 Następujące właściwości <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> obiektu może pomóc zmniejszyć atak typu "odmowa usługi" (DOS) zabezpieczeń:  
  
-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxCachedCookies%2A>: Określa maksymalną liczbę ograniczone czasowo `SecurityContextToken`s, które są buforowane przez serwer po wykonaniu tej negocjacji SPNEGO lub SSL.  
  
-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.IssuedCookieLifetime%2A>: Określa okres istnienia `SecurityContextToken`s, które są wydawane przez serwer po negocjacji SPNEGO lub SSL. Pamięci podręczne serwera `SecurityContextToken`s, w tym okresie czasu.  
  
-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxPendingSessions%2A>: Określa maksymalną liczbę bezpiecznych konwersacji, które są ustalane na serwerze, ale żadne komunikaty aplikacji przetworzonych. Ten limit przydziału uniemożliwia klientom po ustanawianie bezpiecznej konwersacji na usługę, co powoduje usługi do zarządzania stanem dla każdego klienta, ale nigdy z nich korzystać.  
  
-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A>: Określa maksymalny czas, usługa utrzymuje bezpiecznej konwersacji aktywność bez otrzymania kiedykolwiek komunikatu aplikacji na nim. Ten limit przydziału uniemożliwia klientom po ustanawianie bezpiecznej konwersacji na usługę, co powoduje usługi do zarządzania stanem dla każdego klienta, ale nigdy z nich korzystać.  
  
 W sesji bezpiecznej konwersacji, należy pamiętać, że oba <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A> i `ReceiveTimeout` właściwości w powiązaniu wpływa na limit czasu sesji. Im krótsze dwa Określa, kiedy występują przekroczenia limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageSecurityVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.MessageSecurityVersion MessageSecurityVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.MessageSecurityVersion MessageSecurityVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageSecurityVersion As MessageSecurityVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::MessageSecurityVersion ^ MessageSecurityVersion { System::ServiceModel::MessageSecurityVersion ^ get(); void set(System::ServiceModel::MessageSecurityVersion ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageSecurityVersion : System.ServiceModel.MessageSecurityVersion with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.MessageSecurityVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wersji zabezpieczeń komunikatu.</summary>
        <value>
          <see cref="T:System.ServiceModel.MessageSecurityVersion" /> Obiekt, który reprezentuje wersji zabezpieczeń komunikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.MessageSecurityVersion> Zawiera wiele właściwości, które określają numery wersji specyfikacji zabezpieczeń używane podczas zabezpieczania wiadomości wymieniane na kanale.  
  
> [!NOTE]
>  Gdy <xref:System.ServiceModel.Channels.SecurityBindingElement> obiekt zostanie utworzony, ta właściwość jest niezmienny. Wywoływanie `set` na nie zmienia jej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see langword="set" /> o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="OperationSupportingTokenParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt; OperationSupportingTokenParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt; OperationSupportingTokenParameters" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.OperationSupportingTokenParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OperationSupportingTokenParameters As IDictionary(Of String, SupportingTokenParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Security::Tokens::SupportingTokenParameters ^&gt; ^ OperationSupportingTokenParameters { System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Security::Tokens::SupportingTokenParameters ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OperationSupportingTokenParameters : System.Collections.Generic.IDictionary&lt;string, System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt;" Usage="System.ServiceModel.Channels.SecurityBindingElement.OperationSupportingTokenParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję operacji obsługi parametrów tokenu.</summary>
        <value>A <see cref="T:System.Collections.Generic.IDictionary`2" /> typów <see cref="T:System.String" /> (klucz) i <see cref="T:System.ServiceModel.Security.Tokens.SupportingTokenParameters" /> (wartość).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tokeny pomocnicze zapewniają dodatkowe oświadczenia poza tymi, które zawarte w głównej tokenów dla wiązania.  
  
 Zbiorze zwróconym przez <xref:System.ServiceModel.Channels.SecurityBindingElement.OperationSupportingTokenParameters%2A> właściwość zawiera dodatkowe parametry tokenu (<xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters>) dla określonej operacji, które zdefiniowano. Podstawowe parametry tokenu znajdują się w dowolnym <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> lub <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> (zarówno dziedziczyć <xref:System.ServiceModel.Channels.SecurityBindingElement> klasy). W przypadku właściwości <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement>, podstawowe parametry tokenu są zwracane przez <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.ProtectionTokenParameters%2A> właściwości. Na <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> istnieją dwie właściwości parametru <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement.InitiatorTokenParameters%2A> i <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement.RecipientTokenParameters%2A> właściwości.  
  
> [!NOTE]
>  Właściwości są nazywane parametrami, ponieważ określają typ tokenu zabezpieczeń, a nie rzeczywiste wartości.  
  
 Obsługa tokenów można zmniejszyć zakres w zakresie innej niż powiązanie, w tym przypadku operacją, w których przypadku, gdy są one uwzględnione w zabezpieczonej wszystkie komunikaty wysłane przez klienta do usługi, które mają określoną akcję.  
  
 Zapewnienie obsługi tokenów tylko dla operacji (nie wszystkie operacje w punkcie końcowym), użyj <xref:System.ServiceModel.Channels.SecurityBindingElement.OptionalOperationSupportingTokenParameters%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OptionalEndpointSupportingTokenParameters">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.Tokens.SupportingTokenParameters OptionalEndpointSupportingTokenParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Security.Tokens.SupportingTokenParameters OptionalEndpointSupportingTokenParameters" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.OptionalEndpointSupportingTokenParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OptionalEndpointSupportingTokenParameters As SupportingTokenParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::Tokens::SupportingTokenParameters ^ OptionalEndpointSupportingTokenParameters { System::ServiceModel::Security::Tokens::SupportingTokenParameters ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OptionalEndpointSupportingTokenParameters : System.ServiceModel.Security.Tokens.SupportingTokenParameters" Usage="System.ServiceModel.Channels.SecurityBindingElement.OptionalEndpointSupportingTokenParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.Tokens.SupportingTokenParameters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera parametry opcjonalne tokenów pomocniczych dla punktu końcowego usługi.</summary>
        <value>
          <see cref="T:System.ServiceModel.Security.Tokens.SupportingTokenParameters" /> Punktu końcowego usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tokeny pomocnicze zapewniają dodatkowe oświadczenia poza tymi, które zawarte w głównej tokenów dla wiązania. Obsługa tokenów można zmniejszyć zakres w zakresie innej niż powiązanie, w tym przypadku punktu końcowego. Usługa nie odrzuca wiadomości, w przypadku, gdy nie zawiera tokenów, które odpowiadają typom tokenu, określone w <xref:System.ServiceModel.Channels.SecurityBindingElement.OptionalEndpointSupportingTokenParameters%2A> kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OptionalOperationSupportingTokenParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt; OptionalOperationSupportingTokenParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt; OptionalOperationSupportingTokenParameters" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.OptionalOperationSupportingTokenParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OptionalOperationSupportingTokenParameters As IDictionary(Of String, SupportingTokenParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Security::Tokens::SupportingTokenParameters ^&gt; ^ OptionalOperationSupportingTokenParameters { System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Security::Tokens::SupportingTokenParameters ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OptionalOperationSupportingTokenParameters : System.Collections.Generic.IDictionary&lt;string, System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt;" Usage="System.ServiceModel.Channels.SecurityBindingElement.OptionalOperationSupportingTokenParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję opcjonalnych operacji obsługi parametrów tokenu.</summary>
        <value>A <see cref="T:System.Collections.Generic.IDictionary`2" /> typów <see cref="T:System.String" /> (klucz) i <see cref="T:System.ServiceModel.Security.Tokens.SupportingTokenParameters" /> (wartość).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tokeny pomocnicze zapewniają dodatkowe oświadczenia poza tymi, które zawarte w głównej tokenów dla wiązania. Obsługa tokenów można zmniejszyć zakres w zakresie innej niż powiązanie, w tym przypadku operacją. Usługa nie odrzuca wiadomości, w przypadku, gdy nie zawiera tokenów, które odpowiadają typom tokenu, określone w <xref:System.ServiceModel.Channels.SecurityBindingElement.OptionalOperationSupportingTokenParameters%2A> kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectTokens">
      <MemberSignature Language="C#" Value="public bool ProtectTokens { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProtectTokens" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.ProtectTokens" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectTokens As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ProtectTokens { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectTokens : bool with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.ProtectTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informację, czy elementu powiązania zabezpieczeń chroni tokenów.</summary>
        <value>
          <see langword="true" /> Jeśli elementu powiązania zabezpieczeń chroni tokenów. w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityHeaderLayout">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.SecurityHeaderLayout SecurityHeaderLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.Channels.SecurityHeaderLayout SecurityHeaderLayout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.SecurityHeaderLayout" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityHeaderLayout As SecurityHeaderLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::SecurityHeaderLayout SecurityHeaderLayout { System::ServiceModel::Channels::SecurityHeaderLayout get(); void set(System::ServiceModel::Channels::SecurityHeaderLayout value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityHeaderLayout : System.ServiceModel.Channels.SecurityHeaderLayout with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.SecurityHeaderLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityHeaderLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolejność elementów w nagłówku zabezpieczeń dla tego powiązania.</summary>
        <value>
          <see cref="T:System.ServiceModel.Channels.SecurityHeaderLayout" /> Reprezentująca kolejność elementów w nagłówku zabezpieczeń dla tego powiązania. Wartość domyślna to <see cref="F:System.ServiceModel.Channels.SecurityHeaderLayout.Strict" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.SecurityHeaderLayout> Wyliczenie zawiera następujące składniki:  
  
-   <xref:System.ServiceModel.Channels.SecurityHeaderLayout.Strict>: Elementy są dodawane do nagłówka zabezpieczeń, zgodnie z zasadą ogólne "zadeklarować przed użyciem".  
  
-   <xref:System.ServiceModel.Channels.SecurityHeaderLayout.Lax>: Elementy są dodawane do nagłówka zabezpieczeń w dowolnej kolejności, który jest zgodny z programu WSS: zabezpieczeń komunikatu protokołu SOAP.  
  
-   <xref:System.ServiceModel.Channels.SecurityHeaderLayout.LaxTimestampFirst>: Elementy są dodawane do nagłówka zabezpieczeń w dowolnej kolejności, który jest zgodny z programu WSS: SOAP zabezpieczenia komunikatów z tą różnicą, że musi być pierwszym elementem w nagłówku zabezpieczeń `wsse:Timestamp` elementu.  
  
-   <xref:System.ServiceModel.Channels.SecurityHeaderLayout.LaxTimestampLast>: Elementy są dodawane do nagłówka zabezpieczeń w dowolnej kolejności, który jest zgodny z programu WSS: SOAP zabezpieczenia komunikatów z tą różnicą, że po ostatnim elemencie w nagłówku zabezpieczeń musi być `wsse:Timestamp` elementu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest prawidłowym <see cref="T:System.ServiceModel.Channels.SecurityHeaderLayout" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetIssuerBindingContextIfRequired">
      <MemberSignature Language="C#" Value="protected static void SetIssuerBindingContextIfRequired (System.ServiceModel.Security.Tokens.SecurityTokenParameters parameters, System.ServiceModel.Channels.BindingContext issuerBindingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetIssuerBindingContextIfRequired(class System.ServiceModel.Security.Tokens.SecurityTokenParameters parameters, class System.ServiceModel.Channels.BindingContext issuerBindingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.SetIssuerBindingContextIfRequired(System.ServiceModel.Security.Tokens.SecurityTokenParameters,System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetIssuerBindingContextIfRequired (parameters As SecurityTokenParameters, issuerBindingContext As BindingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetIssuerBindingContextIfRequired(System::ServiceModel::Security::Tokens::SecurityTokenParameters ^ parameters, System::ServiceModel::Channels::BindingContext ^ issuerBindingContext);" />
      <MemberSignature Language="F#" Value="static member SetIssuerBindingContextIfRequired : System.ServiceModel.Security.Tokens.SecurityTokenParameters * System.ServiceModel.Channels.BindingContext -&gt; unit" Usage="System.ServiceModel.Channels.SecurityBindingElement.SetIssuerBindingContextIfRequired (parameters, issuerBindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.ServiceModel.Security.Tokens.SecurityTokenParameters" />
        <Parameter Name="issuerBindingContext" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <param name="parameters">
          <see cref="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" />.</param>
        <param name="issuerBindingContext">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Obiekt, który reprezentuje klucz używany dla właściwości wymaganie tokenu, którego wartością jest BindingContext. używany do komunikowania się wystawiający certyfikaty innych firm.</param>
        <summary>Ustawia klucz dla właściwości wymaganie tokenu, którego wartością jest używany do komunikowania się wystawiający certyfikaty innych firm, jeśli wymaganie dotyczy wystawiony token elementu BindingContext.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarezerwowany do użycia przez system.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetKeyDerivation">
      <MemberSignature Language="C#" Value="public virtual void SetKeyDerivation (bool requireDerivedKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetKeyDerivation(bool requireDerivedKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.SetKeyDerivation(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetKeyDerivation (requireDerivedKeys As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetKeyDerivation(bool requireDerivedKeys);" />
      <MemberSignature Language="F#" Value="abstract member SetKeyDerivation : bool -&gt; unit&#xA;override this.SetKeyDerivation : bool -&gt; unit" Usage="securityBindingElement.SetKeyDerivation requireDerivedKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireDerivedKeys" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireDerivedKeys">
          <see langword="true" /> wymagające kluczy pochodnych; w przeciwnym razie <see langword="false" />.</param>
        <summary>Ustawia wartość wskazującą, czy pochodne klucze są wymagane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przedstawia sposób wywołania tej metody.  
  
 [!code-csharp[c_CreateSecureSession#7](~/samples/snippets/csharp/VS_Snippets_CFX/c_createsecuresession/cs/secureservice.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="securityBindingElement.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca opis tej klasy.</summary>
        <returns>Opis bieżącego <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje zwracane przez <xref:System.ServiceModel.Channels.SecurityBindingElement.ToString%2A> obejmuje <xref:System.ServiceModel.Channels.SecurityBindingElement.DefaultAlgorithmSuite%2A>, <xref:System.ServiceModel.Channels.SecurityBindingElement.EndpointSupportingTokenParameters%2A>, <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A>, <xref:System.ServiceModel.Channels.SecurityBindingElement.KeyEntropyMode%2A>, <xref:System.ServiceModel.Channels.SecurityBindingElement.OptionalEndpointSupportingTokenParameters%2A>, <xref:System.ServiceModel.Channels.SecurityBindingElement.SecurityHeaderLayout%2A>, i <xref:System.ServiceModel.Channels.SecurityBindingElement.OperationSupportingTokenParameters%2A> wartości bieżącego wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
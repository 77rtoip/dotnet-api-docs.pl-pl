<Type Name="OneWayBindingElement" FullName="System.ServiceModel.Channels.OneWayBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b34fd076f50817a9e58b7e2fd41a7ba5ed62cbdc" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37460467" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OneWayBindingElement : System.ServiceModel.Channels.BindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OneWayBindingElement extends System.ServiceModel.Channels.BindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.OneWayBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OneWayBindingElement&#xA;Inherits BindingElement&#xA;Implements IPolicyExportExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class OneWayBindingElement sealed : System::ServiceModel::Channels::BindingElement, System::ServiceModel::Description::IPolicyExportExtension" />
  <TypeSignature Language="F#" Value="type OneWayBindingElement = class&#xA;    inherit BindingElement&#xA;    interface IPolicyExportExtension" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Włącza pakiet rutingu i metod jednokierunkowych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby włączyć routing pakietów *jednokierunkowe konwersji* warstwa jest wymagane, na której ta klasa udostępnia. Ta klasa jest powiązanie w stosie powiązania, które wykonuje zmiany kształtu poziom komunikatu o nazwie `OneWayBindingElement`. Ta zmiana kształtu może potrwać <xref:System.ServiceModel.Channels.IDuplexSessionChannel> lub <xref:System.ServiceModel.Channels.IRequestChannel> i udostępnić ją jako <xref:System.ServiceModel.Channels.IInputChannel>, lub odwrotnie może potrwać <xref:System.ServiceModel.Channels.IDuplexSessionChannel> lub <xref:System.ServiceModel.Channels.IRequestChannel> i udostępnić ją jako <xref:System.ServiceModel.Channels.IOutputChannel>. Użytkownik może utworzyć niestandardowego powiązania, które warstw tego powiązania za pośrednictwem obsługujących sesji lub "żądanie-odpowiedź" transportu ułatwiają pakietów obsługi routingu.  
  
 Ta klasa jest również przydatne, gdy chcesz udostępnić metody jednokierunkowe w sposób bardziej natywnych. Kolejnych przekształceń można stosować w tej warstwie, takie jak złożone dwukierunkowego i niezawodną obsługę komunikatów.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OneWayBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OneWayBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.OneWayBindingElement" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="oneWayBindingElement.BuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który tworzy fabrykę.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zapewniający kontekst elementu powiązania.</param>
        <summary>Inicjuje fabryki kanałów do produkcji jednokierunkowe kanałów z kontekstu powiązania.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> Typu <see cref="T:System.ServiceModel.Channels.IChannel" /> inicjowany z <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy fabryki kanałów, który jest używany do utworzenia kanału, który przetwarza komunikaty wychodzące dla tego powiązania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Typ <paramref name="TChannel" /> nie <see cref="T:System.ServiceModel.Channels.IOutputChannel" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie obsługuje elementu wewnętrznego powiązania <see cref="T:System.ServiceModel.Channels.IDuplexSessionChannel" /> lub <see cref="T:System.ServiceModel.Channels.IRequestChannel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="oneWayBindingElement.BuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ kanału, który odbiornik został opracowany pod kątem akceptowania.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zapewniający kontekst elementu powiązania.</param>
        <summary>Inicjuje odbiornik kanału do akceptowania jednokierunkowe kanały.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> Typu <see cref="T:System.ServiceModel.Channels.IChannel" /> inicjowany z <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy odbiornika kanału, który jest używany do utworzenia kanału, który przetwarza komunikaty przychodzące dla tego powiązania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Typ <paramref name="TChannel" /> nie <see cref="T:System.ServiceModel.Channels.IInputChannel" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie obsługuje elementu wewnętrznego powiązania <see cref="T:System.ServiceModel.Channels.IDuplexSessionChannel" /> lub <see cref="T:System.ServiceModel.Channels.IRequestChannel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; bool" Usage="oneWayBindingElement.CanBuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ fabryki kanałów do kompilacji.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zapewniający kontekst elementu powiązania.</param>
        <summary>Pobiera wartość wskazującą, czy można utworzyć fabryki kanałów dla określonego typu.</summary>
        <returns>
          <see langword="true" /> Jeśli fabryki kanałów, o określonym typie mogą być wbudowane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę należy wywołać przed podjęciem próby tworzenie fabryki kanałów.  
  
 Ta metoda zwraca `true` podczas `TChannel` jest <xref:System.ServiceModel.Channels.IOutputChannel>, a powiązanie poniżej bieżącej, jeden w stosie powiązania jest <xref:System.ServiceModel.Channels.IDuplexSessionChannel> lub <xref:System.ServiceModel.Channels.IRequestChannel>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; bool (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="oneWayBindingElement.CanBuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Typ odbiornika kanału do kompilacji.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zapewniający kontekst elementu powiązania.</param>
        <summary>Pobiera wartość wskazującą, czy można utworzyć odbiornika kanałów, o określonym typie.</summary>
        <returns>
          <see langword="true" /> Jeśli odbiornik kanału o określonym typie mogą być wbudowane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed przystąpieniem do tworzenia odbiornika kanału powinna wywołać tę metodę.  
  
 Ta metoda zwraca `true` podczas `TChannel` jest <xref:System.ServiceModel.Channels.IInputChannel>, a powiązanie poniżej bieżącej, jeden w stosie powiązania jest <xref:System.ServiceModel.Channels.IDuplexSessionChannel> lub <xref:System.ServiceModel.Channels.IReplyChannel>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChannelPoolSettings">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.ChannelPoolSettings ChannelPoolSettings { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.ChannelPoolSettings ChannelPoolSettings" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.OneWayBindingElement.ChannelPoolSettings" />
      <MemberSignature Language="VB.NET" Value="Public Property ChannelPoolSettings As ChannelPoolSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::ChannelPoolSettings ^ ChannelPoolSettings { System::ServiceModel::Channels::ChannelPoolSettings ^ get(); void set(System::ServiceModel::Channels::ChannelPoolSettings ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ChannelPoolSettings : System.ServiceModel.Channels.ChannelPoolSettings with get, set" Usage="System.ServiceModel.Channels.OneWayBindingElement.ChannelPoolSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.ChannelPoolSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kanał ustawienia puli.</summary>
        <value>A <see cref="T:System.ServiceModel.Channels.ChannelPoolSettings" /> obiekt, który zawiera właściwości puli kanału skojarzone z tym elementem powiązania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.ServiceModel.Channels.BindingElement" Usage="oneWayBindingElement.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klony wystąpienia tej klasy.</summary>
        <returns>Sklonowanej kopii tego wystąpienia tej klasy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetProperty : System.ServiceModel.Channels.BindingContext -&gt; 'T (requires 'T : null)" Usage="oneWayBindingElement.GetProperty context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ właściwości.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> Zapewniający kontekst elementu powiązania.</param>
        <summary>Pobiera właściwości ze stosu wiązanie, jeśli jest obecny.</summary>
        <returns>A <paramref name="T" /> obiekt ze stosu wiązanie, jeśli jest obecny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otrzymuje kontekstu powiązania jako parametr wejściowy, który reprezentuje stosu elementów wiązania.  
  
 Każdy element powiązania w stosie może obsługiwać zapytania sam lub przekazać zapytania lub kombinacji obu. Każdy element powiązania można zmodyfikować kontekstu, jeśli deleguje ona zapytania. Jednak element powiązania transportu obsługuje samego zapytania.  
  
 Ta metoda jest implementowana przez powiązanie elementów, a także środowiska uruchomieniowego obiektów, takich jak <xref:System.ServiceModel.Channels.IChannelFactory>, <xref:System.ServiceModel.Channels.IChannelListener>, i <xref:System.ServiceModel.Channels.IChannel>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxAcceptedChannels">
      <MemberSignature Language="C#" Value="public int MaxAcceptedChannels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxAcceptedChannels" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.OneWayBindingElement.MaxAcceptedChannels" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxAcceptedChannels As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxAcceptedChannels { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxAcceptedChannels : int with get, set" Usage="System.ServiceModel.Channels.OneWayBindingElement.MaxAcceptedChannels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(10)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę kanałów, które mogą być akceptowane.</summary>
        <value>Maksymalną liczbę kanałów, które mogą być akceptowane. Wartość domyślna to 10.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PacketRoutable">
      <MemberSignature Language="C#" Value="public bool PacketRoutable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PacketRoutable" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.OneWayBindingElement.PacketRoutable" />
      <MemberSignature Language="VB.NET" Value="Public Property PacketRoutable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PacketRoutable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PacketRoutable : bool with get, set" Usage="System.ServiceModel.Channels.OneWayBindingElement.PacketRoutable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest włączony pakiet routingu.</summary>
        <value>
          <see langword="true" /> Jeśli jest włączony pakiet routingu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa Opcjonalnie można użyć protokołu poziom komunikatu, który przekształca `DuplexSessionChannel` / `RequestChannel` / `ReplyChannel` jednokierunkowe kanał i zezwala na komunikaty z kanału po przekształceniu kierowania. Użycie tego protokołu jest kontrolowana przez <xref:System.ServiceModel.Channels.OneWayBindingElement.PacketRoutable%2A> właściwości.  
  
 Gdy ta właściwość jest `true`, od `DuplexSessionChannel` inicjowania (na przykład, buforowane TCP i nazwane potoki), ta klasa dodaje nagłówek komunikatu (MustUnderstand = `false`, podpisane, jeśli zabezpieczenia) semantycznie oznacza "możesz trasy pakietów Ten kanał". Na stronie wykonawca, gdy ta właściwość jest `true`, ta klasa szuka tego pliku nagłówkowego w pierwszy komunikat odebrany w kanale. Jeśli nie ma tego pliku nagłówkowego, WCF błędów kanału. Jeśli istnieje nagłówek, następnie WCF Lejki nowy kanał do udostępnionego kanału danych wejściowych.  
  
 Aby przekształcić kanał "żądanie-odpowiedź" (na przykład, przesyłania strumieniowego TCP lub HTTP) gdy ta właściwość jest `true`, ten nagłówek zostanie dodany do każdego żądania do sygnalizowania, że żądanie może być kierowany pakietów. Usługi WCF również sprawdza, czy `SendRequest` zwraca `null` i odpowiada za pomocą `null` na serwerze.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeChannelPoolSettings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeChannelPoolSettings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeChannelPoolSettings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.ShouldSerializeChannelPoolSettings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeChannelPoolSettings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeChannelPoolSettings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeChannelPoolSettings : unit -&gt; bool" Usage="oneWayBindingElement.ShouldSerializeChannelPoolSettings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca, czy powinien zostać Zserializowany właściwości puli kanału, które są skojarzone z tym elementem powiązania.</summary>
        <returns>
          <see langword="true" /> Jeśli ustawienia puli kanału powinien zostać Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.OneWayBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportPolicy (exporter As MetadataExporter, context As PolicyConversionContext) Implements IPolicyExportExtension.ExportPolicy" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System::ServiceModel::Description::MetadataExporter ^ exporter, System::ServiceModel::Description::PolicyConversionContext ^ context) = System::ServiceModel::Description::IPolicyExportExtension::ExportPolicy;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">
          <see cref="T:System.ServiceModel.Description.MetadataExporter" /> Służące do modyfikowania proces eksportowania.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Description.PolicyConversionContext" /> Służącego do wstawiania Twoje potwierdzenie zasad niestandardowych.</param>
        <summary>Eksportuje asercji zasad niestandardowych, który reprezentuje element powiązania jednokierunkowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapisuje stwierdzenia dotyczące powiązania w informacje WSDL udostępnianych przez określonej umowy i jest używany przez usługę WCF do komunikowania się klientów istnienie tego elementu niestandardowego powiązania w stosie powiązania.  
  
 Ta metoda przyjmuje dwa parametry: <xref:System.ServiceModel.Description.MetadataExporter> i <xref:System.ServiceModel.Description.PolicyConversionContext> obiektów. Użyj <xref:System.ServiceModel.Description.PolicyConversionContext.GetBindingAssertions%2A>, <xref:System.ServiceModel.Description.PolicyConversionContext.GetMessageBindingAssertions%2A>, i <xref:System.ServiceModel.Description.PolicyConversionContext.GetOperationBindingAssertions%2A> metody w celu uzyskania kolekcji asercji zasad, które zostały już wyeksportowane w różnych zakresach. Następnie użyć tej metody, aby dodać własne asercji zasad do odpowiedniej kolekcji.  
  
 <xref:System.ServiceModel.Description.PolicyConversionContext.Contract%2A> Ujawnia właściwość <xref:System.ServiceModel.Description.ContractDescription> dla punktu końcowego, który jest eksportowany. Dzięki temu tę metodę, aby poprawnie zakres ich asercji zasad wyeksportowany. Na przykład atrybuty zabezpieczeń w kodzie można dodać zachowania do <xref:System.ServiceModel.Description.ContractDescription> wskazujące, której powinny zostać dodane asercji zasad zabezpieczeń.  
  
 Dołączone do informacji WSDL niestandardowych asercji zasad klienci mogą wykrywać i importowanie asercji niestandardowego powiązania, implementując <xref:System.ServiceModel.Description.IPolicyImportExtension> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
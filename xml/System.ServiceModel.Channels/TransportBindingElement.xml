<Type Name="TransportBindingElement" FullName="System.ServiceModel.Channels.TransportBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e4e14689e429e5be42d2759a69b210738b823cb5" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39961252" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TransportBindingElement : System.ServiceModel.Channels.BindingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TransportBindingElement extends System.ServiceModel.Channels.BindingElement" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.TransportBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TransportBindingElement&#xA;Inherits BindingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class TransportBindingElement abstract : System::ServiceModel::Channels::BindingElement" />
  <TypeSignature Language="F#" Value="type TransportBindingElement = class&#xA;    inherit BindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see langword="abstract" /> Podstawowa klasa, która reprezentuje element powiązania transportu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czynniki tej klasy, się właściwości, które są wspólne dla wszystkich elementy powiązania transportu, które są dostarczane przez Windows Communication Foundation (WCF). Obsługuje on tłumaczenie ustawienia podstawowej transportu do przejawy czasu wykonywania. Deleguje ona tłumaczenie logiki ustawienia specyficzne dla transportu (na przykład HttpProxySettings dla protokołu HTTP) w jej klasy pochodne konkretnej powiązania transportu, które obejmują następujące klasy:  
  
-   <xref:System.ServiceModel.Channels.PeerTransportBindingElement>  
  
-   <xref:System.ServiceModel.Channels.HttpTransportBindingElement>  
  
-   <xref:System.ServiceModel.Channels.HttpsTransportBindingElement>  
  
-   <xref:System.ServiceModel.Channels.TcpTransportBindingElement>  
  
-   <xref:System.ServiceModel.Channels.NamedPipeTransportBindingElement>  
  
-   <xref:System.ServiceModel.Channels.MsmqTransportBindingElement>  
  
-   <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBindingElement>  
  
-   <xref:System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement>  
  
> [!NOTE]
>  Deweloperzy element powiązania transportu niestandardowego musi dziedziczyć z tej klasy, która jest pochodną <xref:System.ServiceModel.Channels.BindingElement> klasy.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TransportBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TransportBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie tej klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TransportBindingElement (System.ServiceModel.Channels.TransportBindingElement elementToBeCloned);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Channels.TransportBindingElement elementToBeCloned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TransportBindingElement.#ctor(System.ServiceModel.Channels.TransportBindingElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (elementToBeCloned As TransportBindingElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TransportBindingElement(System::ServiceModel::Channels::TransportBindingElement ^ elementToBeCloned);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Channels.TransportBindingElement : System.ServiceModel.Channels.TransportBindingElement -&gt; System.ServiceModel.Channels.TransportBindingElement" Usage="new System.ServiceModel.Channels.TransportBindingElement elementToBeCloned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="elementToBeCloned" Type="System.ServiceModel.Channels.TransportBindingElement" />
      </Parameters>
      <Docs>
        <param name="elementToBeCloned">
          <see cref="T:System.ServiceModel.Channels.TransportBindingElement" /> Można sklonować.</param>
        <summary>Tworzy nowe wystąpienie tej klasy z istniejącego wystąpienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.TransportBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetProperty : System.ServiceModel.Channels.BindingContext -&gt; 'T (requires 'T : null)" Usage="transportBindingElement.GetProperty context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Właściwości do pobrania.</typeparam>
        <param name="context">A <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Pobiera właściwości z określonego <see cref="T:System.ServiceModel.Channels.BindingContext" />.</summary>
        <returns>Właściwości z określonego <see cref="T:System.ServiceModel.Channels.BindingContext" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otrzymuje kontekstu powiązania jako parametr wejściowy, który reprezentuje stosu elementów wiązania. Ta metoda pobiera określony obiekt bezpośrednio, zapytanie do następnego elementu powiązania niższe w stos lub kombinacji obu deleguje odpowiednie uprawnienia. Można go zmodyfikować kontekstu, jeżeli deleguje ona zapytania. Ten proces można powtarzać każdy element powiązania ze stosu, jeśli ma ona delegowana, aż do osiągnięcia spodzie stosu. Obiekt zwrócony zazwyczaj jest to zbiór właściwości.  
  
 Jeśli typ `T` jest <xref:System.ServiceModel.Security.ChannelProtectionRequirements>, <xref:System.Xml.XmlDictionaryReaderQuotas>, lub <xref:System.ServiceModel.Channels.MessageVersion> zwracana wystąpienia tej klasy. Jeśli typ `T` jest zgodny z typem wystąpienia w <xref:System.ServiceModel.Channels.BindingContext.BindingParameters%2A>, zwracany jest tego wystąpienia.  
  
 Ta metoda jest implementowana przez powiązanie elementów, a także w czasie wykonywania obiektów takich jak <xref:System.ServiceModel.Channels.IChannelFactory>, <xref:System.ServiceModel.Channels.IChannelListener>, i <xref:System.ServiceModel.Channels.IChannel>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManualAddressing">
      <MemberSignature Language="C#" Value="public virtual bool ManualAddressing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ManualAddressing" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.TransportBindingElement.ManualAddressing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ManualAddressing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ManualAddressing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ManualAddressing : bool with get, set" Usage="System.ServiceModel.Channels.TransportBindingElement.ManualAddressing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wymagane jest ręczne adresowanie wiadomości.</summary>
        <value>
          <see langword="true" /> w przypadku ręcznego adresowania wiadomości jest wymagana. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest zwykle używana w scenariuszach routera, gdzie Określa, co kilka miejsc docelowych, można wysłać wiadomości do aplikacji.  
  
 Jeśli ta właściwość jest ustawiona `true`, kanał zakłada komunikat już został rozwiązany i nie dodaje żadnych dodatkowych informacji.  
  
 Jeśli `false`, wysyłanie dotyczy kanału <xref:System.ServiceModel.EndpointAddress> skonfigurowany jako `To` adresat w kanale wiadomości wychodzących.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferPoolSize">
      <MemberSignature Language="C#" Value="public virtual long MaxBufferPoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxBufferPoolSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.TransportBindingElement.MaxBufferPoolSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaxBufferPoolSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long MaxBufferPoolSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferPoolSize : int64 with get, set" Usage="System.ServiceModel.Channels.TransportBindingElement.MaxBufferPoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(524288)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar w bajtach żadnych pul buforu używany przez transportu.</summary>
        <value>Maksymalny rozmiar puli bufora. Wartość domyślna to 524,288 bajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele elementów usług WCF za pomocą buforów. Tworzenie i niszczenie buforów za każdym razem, gdy są one używane jest kosztowne, a także jest kosztowne wyrzucania elementów bezużytecznych dla buforów.  
  
 Dzięki pulom buforu zająć buforu z puli, go używać i przywrócić go do puli, gdy wszystko będzie gotowe. Ten sposób unika się obciążenie tworzeniem i likwidowaniem buforów. Wadą jest to, że istnieje wzrost użycia pamięci, ponieważ swoje bufory nie pojawia się bezużyteczne. Jeśli <xref:System.ServiceModel.Channels.TransportBindingElement.MaxBufferPoolSize%2A> jest ustawiona na wartość 0, buforów są zwracane do puli, a zamiast tego rozpocznie się wyrzucanie elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxReceivedMessageSize">
      <MemberSignature Language="C#" Value="public virtual long MaxReceivedMessageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxReceivedMessageSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaxReceivedMessageSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long MaxReceivedMessageSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxReceivedMessageSize : int64 with get, set" Usage="System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera i ustawia maksymalny dozwolony rozmiar komunikatu, w bajtach, które mogą być odbierane.</summary>
        <value>Rozmiar maksymalny dopuszczalny rozmiar wiadomości, która może być odebrana. Wartość domyślna to 65 536 bajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może liczników scenariusz haker, wysyłania wiadomości o określonej długości lub bardzo dużych nieskończoną lub gdy dane są stale wysyłane do połączonych nazwanego potoku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public abstract string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.TransportBindingElement.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.ServiceModel.Channels.TransportBindingElement.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera schemat identyfikatora URI dla transportu.</summary>
        <value>Zwraca schemat identyfikatora URI dla transportu, która różni się w zależności od tego, jakie klasy pochodnej implementuje tę metodę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest zastępowany przez każdego wykonania konkretnego transportu są udostępniane i można zweryfikować powiązania przed adresami podstawowymi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
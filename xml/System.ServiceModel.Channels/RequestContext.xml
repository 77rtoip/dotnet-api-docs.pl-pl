<Type Name="RequestContext" FullName="System.ServiceModel.Channels.RequestContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6c6932a28b3858d462a9461251439838f9c7a258" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36421540" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class RequestContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit RequestContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.RequestContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class RequestContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class RequestContext abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type RequestContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia odpowiedzi, które są korelowane z przychodzącego żądania.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobierz kontekst żądania od <xref:System.ServiceModel.Channels.IReplyChannel>. Każdy <xref:System.ServiceModel.Channels.RequestContext> hermetyzuje informacje wymagane do odpowiedzi na żądanie, dzięki czemu nie trzeba blok w kanale podczas oczekiwania na każdy komunikat żądania do odpowiedzi.  
  
 W modelu żądania/odpowiedzi <xref:System.ServiceModel.Channels.RequestContext> skojarzenia między polega na żądanie i odpowiedź, który jest wysyłany jest obiekt. Gdy serwer odbiera żądanie, zapewnia <xref:System.ServiceModel.Channels.RequestContext> wystąpienia reprezentujący żądanie do kanału. Kontekst żądania zawiera na pierwotny komunikat żądania wśród innych przydatnych właściwości. Ten kontekst żądania jest następnie zwiniętych wewnątrz <xref:System.ServiceModel.OperationContext> do pobrania przez usługę. Zazwyczaj używają <xref:System.ServiceModel.OperationContext.Current%2A> właściwości do uzyskania dostępu do żądania bieżącej operacji.  
  
 Wartość <xref:System.ServiceModel.Channels.RequestContext> może być `null`. Ponieważ roli kontekstu żądania jest łącze żądań do odpowiedzi, go nie ma sensu na kontekst żądania, gdy nie ma odpowiedzi, a w tym przypadku ustawiono kontekstu `null`. Dla operacji jednokierunkowych na podstawie modelu żądanie/odpowiedź serwer odbiera żądania, ale nie wysyła ponownie odpowiedzi do klienta. Jeśli <xref:System.ServiceModel.Channels.RequestContext> jest `null` nieoczekiwanie, sprawdź najpierw czy kontrakt operacji IsOneWay.  
  
 Specjalna uwaga dla użytkowników zarządzanych C++ wynikające z tej klasy:  
  
-   Umieść programu Oczyszczanie kod w (włączone) (Rozpocznij) Zamknij (i/lub OnAbort), nie w destruktora.  
  
-   Unikaj destruktory: spowodują one kompilatora automatycznie wygenerować <xref:System.IDisposable>.  
  
-   Unikaj-reference elementów członkowskich: spowodują kompilatora automatycznie wygenerować <xref:System.IDisposable>.  
  
-   Należy unikać finalizatorów; ale przeprowadzenie jedną ma pomijać ostrzeżeń kompilacji i wywołanie <xref:System.GC.SuppressFinalize%28System.Object%29> i finalizator się (włączone) (Rozpocznij) Zamknij (i/lub OnAbort) emulować, jakie byłyby generowanych automatycznie <xref:System.IDisposable> zachowanie.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected RequestContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; RequestContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Channels.RequestContext" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public abstract void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.Abort" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Abort();" />
      <MemberSignature Language="F#" Value="abstract member Abort : unit -&gt; unit" Usage="requestContext.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przerwanie przetwarzania żądania skojarzony z kontekstem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReply">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną na udzielenie odpowiedzi na żądanie skojarzone z bieżącego kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna jest dostępne z lub bez jawnego limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReply">
      <MemberSignature Language="C#" Value="public abstract IAsyncResult BeginReply (System.ServiceModel.Channels.Message message, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReply(class System.ServiceModel.Channels.Message message, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.BeginReply(System.ServiceModel.Channels.Message,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract IAsyncResult ^ BeginReply(System::ServiceModel::Channels::Message ^ message, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReply : System.ServiceModel.Channels.Message * AsyncCallback * obj -&gt; IAsyncResult" Usage="requestContext.BeginReply (message, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Przychodzący <see cref="T:System.ServiceModel.Channels.Message" /> zawierający żądania.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który otrzyma powiadomienie o ukończeniu operacji asynchronicznej odpowiedzi.</param>
        <param name="state">Obiekt określony przez aplikację, zawierający informacje o stanie skojarzone z operacji asynchronicznych odpowiedzi.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna operację asynchroniczną na udzielenie odpowiedzi na żądanie skojarzone z bieżącego kontekstu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja asynchronicznego odpowiedzi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie asynchronicznego <xref:System.ServiceModel.Channels.RequestContext.BeginReply%2A> metodą podczas przetwarzania aplikacji należy kontynuować bez oczekiwania. Użyj jednej z synchronicznego <xref:System.ServiceModel.Channels.RequestContext.Reply%2A> metod, gdy nie jest możliwa do bieżącego wątku zablokowanie, gdy w odpowiedzi na komunikat żądania lub dopóki nie zostanie przekroczony limit czasu.  
  
 Ta metoda otrzymuje powiadomienie, poprzez wywołanie zwrotne, tożsamości programu obsługi zdarzeń dla tej operacji. Operacja nie jest pełną, aż do odpowiedź jest wysyłana lub przekroczenia limitu czasu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Operacja zgłasza <see cref="T:System.TimeoutException" /> Jeśli określonego <paramref name="timeout" /> został przekroczony przed zakończeniem działania.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginReply">
      <MemberSignature Language="C#" Value="public abstract IAsyncResult BeginReply (System.ServiceModel.Channels.Message message, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReply(class System.ServiceModel.Channels.Message message, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.BeginReply(System.ServiceModel.Channels.Message,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract IAsyncResult ^ BeginReply(System::ServiceModel::Channels::Message ^ message, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReply : System.ServiceModel.Channels.Message * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="requestContext.BeginReply (message, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Przychodzący <see cref="T:System.ServiceModel.Channels.Message" /> zawierający żądania.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> , Która określa czas oczekiwania na odpowiedź na żądanie dostępne.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który otrzyma powiadomienie o ukończeniu operacji asynchronicznej odpowiedzi.</param>
        <param name="state">Obiekt określony przez aplikację, zawierający informacje o stanie skojarzone z operacji asynchronicznych odpowiedzi.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoczyna operację asynchroniczną na udzielenie odpowiedzi na żądanie skojarzone z bieżącego kontekstu w określonym interwale czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się operacja asynchronicznego odpowiedzi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie asynchronicznego <xref:System.ServiceModel.Channels.RequestContext.BeginReply%2A> metodę, aby zezwolić na przetwarzanie aplikacji kontynuować bez oczekiwania na żądanie zakończyć.  
  
 Użyj jednej z synchronicznego <xref:System.ServiceModel.Channels.RequestContext.Reply%2A> metod, gdy nie jest możliwa do bieżącego wątku zablokowanie, gdy w odpowiedzi na komunikat żądania lub dopóki nie zostanie przekroczony limit czasu. Ta metoda otrzymuje powiadomienie, poprzez wywołanie zwrotne, tożsamości programu obsługi zdarzeń dla tej operacji. Operacja nie jest pełną, aż do odpowiedź jest wysyłana lub przekroczenia limitu czasu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Operacja zgłasza <see cref="T:System.TimeoutException" /> Jeśli określonego <paramref name="timeout" /> został przekroczony przed zakończeniem działania.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamyka operację, która jest podczas odpowiadania na kontekst żądania skojarzonego z bieżącego kontekstu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public abstract void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.Close" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit" Usage="requestContext.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zamyka operację, która jest podczas odpowiadania na kontekst żądania skojarzonego z bieżącego kontekstu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public abstract void Close (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.Close(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Close (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Close(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Close : TimeSpan -&gt; unit" Usage="requestContext.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> , Który określa przedział czasu, w którym należy zamknąć operacji odpowiedzi skojarzone z bieżącego kontekstu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zamyka operację, która jest podczas odpowiadania na kontekst żądania skojarzony z bieżącego kontekstu w określonym interwale czasu.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Operacja powinien zgłosić <see cref="T:System.TimeoutException" /> Jeśli określonego <paramref name="timeout" /> został przekroczony przed zakończeniem działania.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="requestContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby skojarzone z kontekstem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndReply">
      <MemberSignature Language="C#" Value="public abstract void EndReply (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndReply(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.EndReply(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub EndReply (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void EndReply(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReply : IAsyncResult -&gt; unit" Usage="requestContext.EndReply result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Zwrócony przez wywołanie do jednego z <see cref="Overload:System.ServiceModel.Channels.RequestContext.BeginReply" /> metody.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, kończy operację asynchroniczną na udzielenie odpowiedzi na komunikat żądania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reply">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odpowiedzi na komunikat żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reply">
      <MemberSignature Language="C#" Value="public abstract void Reply (System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reply(class System.ServiceModel.Channels.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.Reply(System.ServiceModel.Channels.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Reply(System::ServiceModel::Channels::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Reply : System.ServiceModel.Channels.Message -&gt; unit" Usage="requestContext.Reply message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
      </Parameters>
      <Docs>
        <param name="message">Przychodzący <see cref="T:System.ServiceModel.Channels.Message" /> zawierający żądania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odpowiedzi na komunikat żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.Channels.RequestContext.Reply%2A> gdy jest akceptowalne dla bieżącego wątku zablokowanie, gdy zostanie wysłana odpowiedź na komunikat żądania. Wątek jest zablokowana w górę do określonego `timeout`.  
  
 Jeśli przetwarzanie aplikacji należy kontynuować bez oczekiwania na odpowiedź zakończyć, użycie asynchronicznego <xref:System.ServiceModel.Channels.RequestContext.BeginReply%2A> metody. Ta metoda otrzymuje powiadomienie, poprzez wywołanie zwrotne, tożsamości programu obsługi zdarzeń dla tej operacji. Operacja nie jest pełną, aż do komunikat o stanie się dostępny w kanale lub przekroczenia limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reply">
      <MemberSignature Language="C#" Value="public abstract void Reply (System.ServiceModel.Channels.Message message, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reply(class System.ServiceModel.Channels.Message message, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.Reply(System.ServiceModel.Channels.Message,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Reply(System::ServiceModel::Channels::Message ^ message, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Reply : System.ServiceModel.Channels.Message * TimeSpan -&gt; unit" Usage="requestContext.Reply (message, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="message">Przychodzący <see cref="T:System.ServiceModel.Channels.Message" /> zawierający żądania.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> , Która określa czas oczekiwania na odpowiedź na żądanie.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odpowiedzi na komunikat żądania w określonym interwale czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.Channels.RequestContext.Reply%2A> gdy jest akceptowalne dla bieżącego wątku zablokowanie, gdy zostanie wysłana odpowiedź na komunikat żądania. Wątek jest zablokowana w górę do określonego `timeout`.  
  
 Jeśli przetwarzanie aplikacji należy kontynuować bez oczekiwania na odpowiedź zakończyć, użycie asynchronicznego <xref:System.ServiceModel.Channels.RequestContext.BeginReply%2A> metody. Ta metoda otrzymuje powiadomienie, poprzez wywołanie zwrotne, tożsamości programu obsługi zdarzeń dla tej operacji. Operacja nie jest pełną, aż do komunikat o stanie się dostępny w kanale lub przekroczenia limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestMessage">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.Message RequestMessage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.Message RequestMessage" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.RequestContext.RequestMessage" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property RequestMessage As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::ServiceModel::Channels::Message ^ RequestMessage { System::ServiceModel::Channels::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestMessage : System.ServiceModel.Channels.Message" Usage="System.ServiceModel.Channels.RequestContext.RequestMessage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera komunikat, który zawiera żądanie.</summary>
        <value>
          <see cref="T:System.ServiceModel.Channels.Message" /> Zawierający żądania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.RequestContext.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby zarządzane i niezarządzane skojarzony z kontekstem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
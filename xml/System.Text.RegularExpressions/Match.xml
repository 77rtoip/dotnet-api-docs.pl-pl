<Type Name="Match" FullName="System.Text.RegularExpressions.Match">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c886bcea5d17b2ba683b40687e65b1b31de9ad20" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36408140" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Match : System.Text.RegularExpressions.Group" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Match extends System.Text.RegularExpressions.Group" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Match" />
  <TypeSignature Language="VB.NET" Value="Public Class Match&#xA;Inherits Group" />
  <TypeSignature Language="C++ CLI" Value="public ref class Match : System::Text::RegularExpressions::Group" />
  <TypeSignature Language="F#" Value="type Match = class&#xA;    inherit Group" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.RegularExpressions.Group</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje wyniki z pojedynczego wyrażenia regularnego dopasowanie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Match> Obiektu jest niemodyfikowalna i nie ma publicznego konstruktora. Wystąpienie <xref:System.Text.RegularExpressions.Match> klasy jest zwracany przez <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> — metoda i reprezentuje pierwszy wzorzec zgodne w ciągu. Kolejnych dopasowań są reprezentowane przez <xref:System.Text.RegularExpressions.Match> obiekty zwrócone przez <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody. Ponadto <xref:System.Text.RegularExpressions.MatchCollection> obiekt, który składa się z zero, co najmniej jeden <xref:System.Text.RegularExpressions.Match> obiektów jest zwracany przez <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> metody.  
  
 Jeśli <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> — metoda nie jest zgodny z wzorcem wyrażenia regularnego, w ciągu wejściowym, zwracana jest pusta <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Następnie można użyć `foreach` utworzyć w języku C# lub `For Each` utworzyć w języku Visual Basic w celu wykonania iteracji w kolekcji.  
  
 Jeśli <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> — metoda nie jest zgodny z wzorcem wyrażenia regularnego, zwraca <xref:System.Text.RegularExpressions.Match> obiekt, który jest równy <xref:System.Text.RegularExpressions.Match.Empty%2A?displayProperty=nameWithType>. Można użyć <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości w celu określenia, czy dopasowanie zakończyła się powodzeniem. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/cs/Match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Match.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/vb/Match1.vb#1)]  
  
 Jeśli wzorzec zakończy się pomyślnie, <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg, <xref:System.Text.RegularExpressions.Capture.Index%2A> właściwość wskazuje liczony od zera pozycja początkowa podciąg w ciągu wejściowym i <xref:System.Text.RegularExpressions.Capture.Length%2A> wskazuje właściwość Długość podciąg w ciągu wejściowym.  
  
 Ponieważ jedną pasującą może obejmować wiele grup przechwytywania, <xref:System.Text.RegularExpressions.Match> ma <xref:System.Text.RegularExpressions.Match.Groups%2A> właściwości, która zwraca <xref:System.Text.RegularExpressions.GroupCollection>. <xref:System.Text.RegularExpressions.Match> Wystąpienie jest odpowiednikiem pierwszy obiekt w kolekcji, w `Match.Groups[0]` (`Match.Groups(0)` w języku Visual Basic), który reprezentuje cały dopasowania. Aby dostęp do przechwyconych grup w dopasowania w następujący sposób:  
  
-   Można wykonać iterację członków <xref:System.Text.RegularExpressions.GroupCollection> obiektu za pomocą `foreach` (C#) lub `For Each` konstrukcja (Visual Basic).  
  
-   Można użyć <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29?displayProperty=nameWithType> właściwości do pobrania grup z numerem grupy przechwytywania. Należy pamiętać, że można określić numeru grupy, które znajdują się w wyrażeniu regularnym przez wywołanie metody wystąpienia <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType> metody.  
  
-   Można użyć <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29?displayProperty=nameWithType> właściwości do pobrania grup według nazwy grupy przechwytywania. Należy pamiętać, że można określić grupy o nazwie, które znajdują się w wyrażeniu regularnym przez wywołanie metody wystąpienia <xref:System.Text.RegularExpressions.Regex.GetGroupNames?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższych przykładach użyto wyrażenia regularnego `Console\.Write(Line)?`. Wyrażenie regularne jest interpretowana w następujący sposób:  
  
|||  
|-|-|  
|Konsola\\. Zapisu|Zgodny z ciągiem "Console.Write". Należy pamiętać, że "." znak została zmieniona, tak aby był interpretowany jako literału okres, a nie jako symbolu wieloznacznego, który dopasowuje dowolny znak.|  
|(Linia)?|Zgodne zero lub jeden wystąpienie ciągu "Wiersz".|  
  
 **Przykład 1**  
  
 Następujące przykładowe wywołania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> metodę, aby pobrać wszystkie dopasowania wzorca w parametrach wejściowych. Następnie iteruje <xref:System.Text.RegularExpressions.Match> obiektów w zwróconym <xref:System.Text.RegularExpressions.MatchCollection> obiektu do wyświetlenia informacji o każdym dopasowaniu.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/cs/Match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Match.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/vb/Match2.vb#2)]  
  
 **Przykład 2**  
  
 Następujące przykładowe wywołania <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> i <xref:System.Text.RegularExpressions.Match.NextMatch%2A> metody do pobierania jedno dopasowanie.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/cs/Match3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Match.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/vb/Match3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.RegularExpressions.MatchCollection" />
    <altmember cref="T:System.Text.RegularExpressions.Regex" />
  </Docs>
  <Members>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.RegularExpressions.Match Empty" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Match.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::RegularExpressions::Match ^ Empty { System::Text::RegularExpressions::Match ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Match.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pustej grupy. Wszystkie dopasowania nie powiodło się zwrócić tego dopasowania puste.</summary>
        <value>Pusty dopasowanie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie powinien służyć do ustalenia, czy dopasowanie jest pomyślne. Zamiast tego należy użyć `Match.Success` właściwości (dziedziczoną z <xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Groups">
      <MemberSignature Language="C#" Value="public virtual System.Text.RegularExpressions.GroupCollection Groups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.RegularExpressions.GroupCollection Groups" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Match.Groups" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Groups As GroupCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::RegularExpressions::GroupCollection ^ Groups { System::Text::RegularExpressions::GroupCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Groups : System.Text.RegularExpressions.GroupCollection" Usage="System.Text.RegularExpressions.Match.Groups" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.GroupCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję grup, które są dopasowane wg wyrażenia regularnego.</summary>
        <value>Grup znaków są dopasowane wg ze wzorcem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wzorzec wyrażenia regularnego może obejmować użyto, zdefiniowanych przez zamknięciem część wzorzec wyrażenia regularnego w nawiasach. Każdy taki Podwyrażenie tworzy grupę. <xref:System.Text.RegularExpressions.Match.Groups%2A> Właściwości zapewnia dostęp do informacji o tych Podwyrażenie dopasowań. Na przykład wzorzec wyrażenia regularnego `(\d{3})-(\d{3}-\d{4})`, zgodnej z numerów telefonów w Ameryce Północnej, ma dwa zakresie. Pierwszy składa się z kodu obszaru Redaguj pierwsze trzy cyfry numeru telefonu. Ta grupa jest przechwytywany przez pierwszą część wyrażenia regularnego `(\d{3})`. Druga składa się z numerem telefonu poszczególnych, który Redaguj ostatnie cyfry numeru telefonu. Ta grupa jest przechwytywany przez drugiej części wyrażenia regularnego `(\d{3}-\d{4})`. Następnie można pobrać tych dwóch grup z <xref:System.Text.RegularExpressions.GroupCollection> obiektu, który jest zwracany przez <xref:System.Text.RegularExpressions.Match.Groups%2A> właściwości, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Groups#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.match.groups/cs/groups1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Match.Groups#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.match.groups/vb/groups1.vb#1)]  
  
 <xref:System.Text.RegularExpressions.GroupCollection> Obiektu zwróconego przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwość jest obiekt kolekcji liczony od zera, która zawsze ma co najmniej jednego członka. Jeśli aparat wyrażeń regularnych nie można odnaleźć dopasowań w określonym ciągu wejściowego <xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType> właściwości pojedynczego <xref:System.Text.RegularExpressions.Group> obiektu w kolekcji (obiekt pod indeksem 0) ma ustawioną wartość `false` i <xref:System.Text.RegularExpressions.Group> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A>właściwość jest ustawiona na <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli aparat wyrażeń regularnych można znaleźć dopasowania, pierwszy element <xref:System.Text.RegularExpressions.GroupCollection> zwrócona przez obiekt (element pod indeksem 0) <xref:System.Text.RegularExpressions.Match.Groups%2A> właściwości zawiera ciąg, który odpowiada wzorcowi całego wyrażenia regularnego. Z indeksu, jeden każdego kolejnego elementu w górę, reprezentuje przechwyconej grupy, jeśli wyrażenie regularne obejmuje przechwytywanie grup. Aby uzyskać więcej informacji, zobacz sekcję "Grupowania tworzy i regularnego obiektów wyrażeń" [konstrukcji grupowania](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md) artykułu.  
  
   
  
## Examples  
 Poniższy przykład próbuje zgodne ze wzorcem wyrażenia regularnego względem przykładowy ciąg. W przykładzie użyto <xref:System.Text.RegularExpressions.Match.Groups%2A> właściwości do przechowywania informacji, które są pobierane przez dopasowanie do wyświetlenia w konsoli.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextMatch">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match NextMatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match NextMatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Match.NextMatch" />
      <MemberSignature Language="VB.NET" Value="Public Function NextMatch () As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ NextMatch();" />
      <MemberSignature Language="F#" Value="member this.NextMatch : unit -&gt; System.Text.RegularExpressions.Match" Usage="match.NextMatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nowy <see cref="T:System.Text.RegularExpressions.Match" /> obiekt z wynikami dla następnego dopasowania, zaczynając od pozycji, jaką ostatniego dopasowania Zakończono (o znaków po ostatniego dopasowane znaków).</summary>
        <returns>Następny dopasowanie wyrażenia regularnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest podobna do wywoływania <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> ponownie i przekazywanie (`Index+Length`) jako nowa pozycja początkowa.  
  
> [!NOTE]
>  Ta metoda nie modyfikuje bieżącego wystąpienia. Zamiast tego zwraca nową <xref:System.Text.RegularExpressions.Match> obiektu, który zawiera informacje o następnego dopasowania.  
  
 Podjęto próbę pobrania następnego dopasowania może zgłaszać <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli wartość limitu czasu dla operacji dopasowywania jest włączona, a próba znalezienia następnego dopasowania przekracza ten limit czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> Metoda przechwytywania wyrażenia regularnego odpowiada poza pierwsze dopasowanie.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu.</exception>
        <block subset="none" type="usage">
          <para>Podczas próby dopasowania jest powtarzany, wywołując <see cref="M:System.Text.RegularExpressions.Match.NextMatch" /> metoda, aparat wyrażeń regularnych daje pusty dopasowań szczególnego traktowania. Zazwyczaj <see cref="M:System.Text.RegularExpressions.Match.NextMatch" /> rozpocznie się wyszukiwanie następnego dopasowania dokładnie, gdzie poprzedniego dopasowania przerwał pracę. Jednak po pusty dopasowania <see cref="M:System.Text.RegularExpressions.Match.NextMatch" /> metody przechodzi przez jeden znak przed podjęciem próby następnego dopasowania. Takie zachowanie gwarantuje, że aparat wyrażeń regularnych będzie trakcie poruszania się przez ciąg. W przeciwnym razie ponieważ dopasowanie pusta nie powoduje żadnych ruch do przodu, następnego dopasowania zaczyna się w tym samym miejscu, jako poprzedniego dopasowania, a to dopasuje wielokrotnie ten sam ciąg pusty.  Poniższy przykład stanowi ilustrację. Wzorzec wyrażenia regularnego <c>*</c> wyszukuje zero lub więcej wystąpień litery "" w ciągu "abaabb". Jak pokazano na dane wyjściowe z przykładu, wyszukiwania znajduje sześciu dopasowań. Pierwsza próba dopasowania znajduje pierwszy "". Drugi uruchamia dopasowania, gdzie pierwszy pasować kończy się przed pierwszym b; znajduje zero wystąpienia "a", a zwraca pusty ciąg. Trzeci dopasowania nie zaczyna się dokładnie gdzie drugi dopasowania została zakończona, ponieważ drugi dopasowania zwrócony pusty ciąg. Zamiast tego rozpoczyna jeden znak później, po pierwszym "b". Trzeci dopasowania znajduje dwa wystąpienia "a" i zwraca "aa". Czwarty próbę dopasowania rozpoczyna się, gdy trzeci dopasowania zostało zakończone przed drugi "b" i zwraca pusty ciąg. Piąty próbę dopasowania ponownie przechodzi jeden znak, który rozpoczyna się przed trzeci "b" i zwraca pusty ciąg. Dopasowanie szóstego rozpoczyna się po ostatnim "b" i ponownie zwraca pusty ciąg.  [! code-csharp[System.Text.RegularExpressions.Match.NextMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.match.nextmatch/cs/nextmatch1.cs#1)] [! code-vb[System.Text.RegularExpressions.Match.NextMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.match.nextmatch/vb/nextmatch1.vb#1)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public virtual string Result (string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string Result(string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Match.Result(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Result (replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ Result(System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="abstract member Result : string -&gt; string&#xA;override this.Result : string -&gt; string" Usage="match.Result replacement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="replacement">Zastąpienie składnię.</param>
        <summary>Zwraca rozszerzenia wzorca określonego zastąpienia.</summary>
        <returns>Rozszerzona wersja <paramref name="replacement" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas gdy <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> metoda zastępuje wszystkie dopasowania w ciągu wejściowym wzorzec określonego zastąpienia <xref:System.Text.RegularExpressions.Match.Result%2A> metoda zastępuje pojedynczego dopasowania wzorca określonego zastąpienia. Ponieważ działa ona w poszczególnych dopasowania, jest również można wykonać przetwarzania dopasowany ciąg przed wywołaniem <xref:System.Text.RegularExpressions.Match.Result%2A> metody.  
  
 `replacement` Parametr jest wzorzec zastąpienia standardowego wyrażenia regularnego. Może się składać literały i podstawień wyrażenia regularnego. Aby uzyskać więcej informacji, zobacz [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md).  
  
   
  
## Examples  
 Poniższy przykład zastępuje łączniki, które rozpoczynać i kończyć w nawiasach wyrażenia w nawiasach.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Result#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.match.result/cs/result1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Match.Result#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.match.result/vb/result1.vb#1)]  
  
 Wzorzec wyrażenia regularnego `--(.+?)--` jest interpretowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`--`|Zgodne dwa łączniki.|  
|`(.+?)`|Dopasowuje dowolny znak jeden lub więcej razy, ale jako kilka razy, jak to możliwe. Jest to pierwsza grupa przechwytywania.|  
|`--`|Zgodne dwa łączniki.|  
  
 Należy pamiętać, że wzorzec wyrażenia regularnego `--(.+?)--` korzysta z opóźnieniem kwantyfikatora `+?`. Jeśli intensywnie kwantyfikatora `+` użyto zamiast tego aparat wyrażeń regularnych znajdował jedną pasującą w ciągu wejściowym.  
  
 Ciąg zastępczy `($1)` zamienia pierwszą grupą przechwyconych jest ujęta w nawiasy dopasowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Rozszerzenie nie jest dozwolone dla tego wzorca.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Synchronized (System.Text.RegularExpressions.Match inner);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Synchronized(class System.Text.RegularExpressions.Match inner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (inner As Match) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Synchronized(System::Text::RegularExpressions::Match ^ inner);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Text.RegularExpressions.Match -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Match.Synchronized inner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inner" Type="System.Text.RegularExpressions.Match" />
      </Parameters>
      <Docs>
        <param name="inner">Wyrażenie regularne zgodne wersją oczekiwaną równoważne.</param>
        <summary>Zwraca <see cref="T:System.Text.RegularExpressions.Match" /> odpowiednikiem podany wystąpienia, które jest odpowiednie do udostępniania między wiele wątków.</summary>
        <returns>Dopasowanie wyrażenia regularnego, które jest odpowiednie do udostępniania między wiele wątków.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inner" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
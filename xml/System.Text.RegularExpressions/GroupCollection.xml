<Type Name="GroupCollection" FullName="System.Text.RegularExpressions.GroupCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="226d1b2db20f1fb103360fc90ebd1f3afe31d4f0" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609748" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class GroupCollection : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit GroupCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.GroupCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class GroupCollection&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class GroupCollection : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type GroupCollection = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zwraca zestaw przechwyconych grupach w pojedyncze dopasowanie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.GroupCollection> Klasy jest klasą kolekcji liczony od zera, która składa się z co najmniej jeden <xref:System.Text.RegularExpressions.Group> obiektów, które zawierają informacje o przechwyconych grupach w dopasowanie wyrażenia regularnego. Kolekcja jest niezmienne (tylko do odczytu) i nie ma publicznego konstruktora. A <xref:System.Text.RegularExpressions.GroupCollection> obiekt jest zwracany przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości.  
  
 Kolekcja zawiera jeden lub więcej <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> obiektów. Jeśli dopasowanie się powiedzie, pierwszy element w kolekcji zawiera <xref:System.Text.RegularExpressions.Group> obiekt, który odnosi się do całego dopasowania. Jeśli wyrażenie regularne zawiera grupy przechwytywania, każdego kolejnego elementu reprezentuje przechwyconej grupy. Zgodne z numerowanych grup przechwytywania (bez nazwy) są wyświetlane w kolejności numerycznej przed dopasowania z nazwanych grup przechwytywania. Jeśli dopasowanie zakończy się niepowodzeniem, Kolekcja zawiera pojedynczy <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> którego <xref:System.Text.RegularExpressions.Group.Success%2A> właściwość `false` i którego <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwości jest równa <xref:System.String.Empty?displayProperty=nameWithType>. Aby uzyskać więcej informacji, zobacz sekcję "Grupowanie konstrukcji i regularnego wyrażenia obiekty" w [Grouping Constructs](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md) artykułu.  
  
 Do iterowania po elementach członkowskich kolekcji, należy używać konstrukcji iteracji kolekcji, które są dostarczane przez język (takie jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic) zamiast pobierania moduł wyliczający, który jest zwracany przez <xref:System.Text.RegularExpressions.GroupCollection.GetEnumerator%2A> metody. Ponadto, możesz uzyskać dostęp poszczególnych numerowanej grupy przechwycone z <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29> właściwości (indeksatora w języku C#), a dostęp poszczególnych nazwanych grup przechwycone z <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29> właściwości. Uwaga pobrać tablicę, która zawiera liczby i nazwy grupy przechwytywania wszystkich przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.Regex.GetGroupNames%2A?displayProperty=nameWithType> metod, odpowiednio. Oba wystąpienia metod i wymagają, że wystąpienia <xref:System.Text.RegularExpressions.Regex> obiekt, który reprezentuje wyrażenia regularnego do dopasowania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wyrażenia regularnego z grupy przechwytywania, aby wyodrębnić informacji dotyczących znaków towarowych i zastrzeżonymi znakami towarowymi używany w tekście. Definicję wzorca wyrażenia regularnego jest `\b(\w+?)([\u00AE\u2122])`, który jest interpretowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Zwróć uwagę na granicy wyrazu.|  
|`(\w+?)`|Zwróć uwagę na co najmniej jeden znak słowa. Razem tworzą one będących znakami towarowymi nazwy. (Zwróć uwagę, że tego wyrażenia regularnego przyjęto założenie, że znakiem towarowym firmy składa się z pojedynczego wyrazu). Jest to pierwsza grupa przechwytywania.|  
|`([\u00AE\u2122])`|Wyszukaj® lub™ znaków. Jest to druga grupa przechwytywania.|  
  
 Dla każdego dopasowania <xref:System.Text.RegularExpressions.GroupCollection> zawiera trzy <xref:System.Text.RegularExpressions.Group> obiektów. Pierwszy obiekt zawiera ciąg, który odpowiada całego wyrażenia regularnego. Drugi obiekt, który reprezentuje pierwszej przechwyconej grupy, zawiera nazwę produktu. Trzeci obiekt, który reprezentuje drugi przechwyconej grupy, zawiera znak towarowy lub zarejestrowanych znak towarowy.  
  
 [!code-csharp[System.Text.RegularExpressions.GroupCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.GroupCollection/cs/Example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.GroupCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.GroupCollection/vb/Example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.RegularExpressions.Group" />
  </Docs>
  <Members>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="groupCollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica kolekcji jest ma zostać skopiowana do.</param>
        <param name="arrayIndex">Pozycja w tablicy docelowej, w którym kopiowania jest rozpoczęcie.</param>
        <summary>Kopiuje elementy kolekcji do danej tablicy, zaczynając od danego indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ całej kolekcji jest kopiowana do tablicy, zaczynając od danego indeksu, Tablica docelowa musi być przynajmniej tak duże jak kolekcji.  
  
> [!WARNING]
>  Ten element członkowski nie jest obecny w [!INCLUDE[net_portable](~/includes/net-portable-md.md)]. Jeśli tworzysz aplikacje przeznaczone [!INCLUDE[net_portable](~/includes/net-portable-md.md)], użyj <xref:System.Text.RegularExpressions.GroupCollection.System%23Collections%23ICollection%23CopyTo%2A?displayProperty=nameWithType> metody zamiast tego.  
  
   
  
## Examples  
 Poniższy przykład wyodrębnia z każdego wyrazu w zdaniu i znajdują się w grupie przechwytywania <xref:System.Text.RegularExpressions.GroupCollection.CopyTo%2A> metody jest następnie używany do skopiuj elementy w każdym dopasowaniu <xref:System.Text.RegularExpressions.GroupCollection> obiekt jako tablicę zawierającą Przechwytywanie grup z wszystkie dopasowania. Poszczególnych wyrazów przechwyconych są następnie wyświetlane w konsoli.  
  
 [!code-csharp[System.Text.RegularExpressions.GroupCollection.CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.groupcollection.copyto/cs/copyto1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.GroupCollection.CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.groupcollection.copyto/vb/copyto1.vb#1)]  
  
 Wyrażenie regularne jest zdefiniowane w następujący sposób:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Dopasowuje granicę wyrazu.|  
|`(\S+?)`|Dopasowuje co najmniej jeden znak inny niż biały. Przypisać je do pierwszej grupy przechwytywania.|  
|`\b`|Dopasowuje granicę wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="arrayIndex" /> znajduje się poza granicami <paramref name="array" />.  - lub - <paramref name="arrayIndex" /> oraz <see cref="P:System.Text.RegularExpressions.GroupCollection.Count" /> znajduje się poza granicami <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Text.RegularExpressions.Group[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Text.RegularExpressions.Group[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.CopyTo(System.Text.RegularExpressions.Group[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Group(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Text::RegularExpressions::Group ^&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Text.RegularExpressions.Group[] * int -&gt; unit&#xA;override this.CopyTo : System.Text.RegularExpressions.Group[] * int -&gt; unit" Usage="groupCollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Text.RegularExpressions.Group[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="arrayIndex">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Text.RegularExpressions.GroupCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca liczbę grup w kolekcji.</summary>
        <value>Liczba grup w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.GroupCollection> Obiekt zawsze ma co najmniej jednego członka. Jeśli dopasowanie kończy się niepowodzeniem, <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwość zwraca <xref:System.Text.RegularExpressions.GroupCollection> obiekt, który zawiera jeden element członkowski.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="groupCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dostarcza moduł wyliczający, który iteruje po kolekcji.</summary>
        <returns>Moduł wyliczający, który zawiera wszystkie <see cref="T:System.Text.RegularExpressions.Group" /> obiekty w <see cref="T:System.Text.RegularExpressions.GroupCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływać metodę <xref:System.Text.RegularExpressions.GroupCollection.GetEnumerator%2A> metodę, aby pobrać moduł wyliczający, który umożliwia iteracyjne przeglądanie <xref:System.Text.RegularExpressions.Group> obiekty w kolekcji, należy użyć konstrukcji iteracji grupy (takie jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic), dostarczonej przez język programowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.RegularExpressions.GroupCollection.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kolekcja jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> we wszystkich przypadkach.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Text.RegularExpressions.GroupCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do <see cref="T:System.Text.RegularExpressions.GroupCollection" /> jest synchronizowany (bezpieczna wątkowo).</summary>
        <value>
          <see langword="false" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Ten element członkowski nie jest obecny w [!INCLUDE[net_portable](~/includes/net-portable-md.md)]. Jeśli tworzysz aplikacje przeznaczone [!INCLUDE[net_portable](~/includes/net-portable-md.md)], użyj <xref:System.Text.RegularExpressions.CaptureCollection.System%23Collections%23ICollection%23IsSynchronized%2A?displayProperty=nameWithType> właściwości zamiast tego.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.GroupCollection.SyncRoot" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umożliwia dostęp do jednego elementu członkowskiego kolekcji za pomocą indeksu integer lub string.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Group this[int groupnum] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.RegularExpressions.Group Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(groupnum As Integer) As Group" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::Group ^ default[int] { System::Text::RegularExpressions::Group ^ get(int groupnum); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : System.Text.RegularExpressions.Group" Usage="System.Text.RegularExpressions.GroupCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Group</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupnum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="groupnum">Liczony od zera indeks elementu kolekcji do pobrania.</param>
        <summary>Umożliwia dostęp do składowej klasy kolekcji za pomocą indeksu liczba całkowita.</summary>
        <value>Członek kolekcji określonej przez <paramref name="groupnum" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29> Właściwości indeksu (w języku C#) lub domyślną właściwość (w języku Visual Basic) jest <xref:System.Text.RegularExpressions.GroupCollection> klasy. Umożliwia wyliczenie elementów członkowskich kolekcji za pomocą `foreach` instrukcji w języku C# lub `For Each` instrukcji w języku Visual Basic.  
  
 Ta właściwość służy również do pobrania poszczególnych grup przechwycone przez ich numer indeksu. Możesz pobrać tablicę, która zawiera numery wszystkich grup przechwytywania w wyrażeniu regularnym, wywołując wystąpienie <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType> metody. Możesz również mapować nazwanych grup przechwytywania na ich liczby, przez wywołanie metody wystąpienia <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A?displayProperty=nameWithType> metody.  
  
 Można określić liczbę elementów w kolekcji, poprzez pobranie wartości <xref:System.Text.RegularExpressions.GroupCollection.Count%2A> właściwości. Prawidłowe wartości dla `groupnum` parametru z zakresu od 0 do jednego mniejszy niż liczba elementów w kolekcji.  
  
 <xref:System.Text.RegularExpressions.GroupCollection> Obiektu zwróconego przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwość zawsze ma co najmniej jednego członka. Jeśli aparat wyrażeń regularnych nie może znaleźć dopasowań w określonym ciągu wejściowym, pojedynczy <xref:System.Text.RegularExpressions.Group> obiekt w kolekcji ma jego <xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType> właściwością `false` i jego `Group.Value` właściwością <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Jeśli `groupnum` nie jest indeksem elementu członkowskiego kolekcji, lub jeśli `groupnum` to indeks grupy przechwytywania, który ma nie została dopasowana do ciągu wejściowego, metoda zwraca <xref:System.Text.RegularExpressions.Group> którego <xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType> właściwość jest `false` i którego `Group.Value` właściwość <xref:System.String.Empty?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenie regularne składa się z dwóch numerowanych grup. Pierwsza grupa zawiera jedną lub więcej kolejnych cyfr. Druga grupa dopasowuje pojedynczy znak. Ponieważ aparat wyrażeń regularnych szuka od zera lub jednego wystąpienia pierwszej grupy, nie zawsze znajdzie dopasowanie, nawet jeśli dopasowanie wyrażenia regularnego zakończy się pomyślnie. W przykładzie pokazano następnie wynik po <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29> właściwość jest używana, aby pobrać grupę niedopasowane, dopasowanej grupy i grupy, który nie jest zdefiniowany w wyrażeniu regularnym. W przykładzie zdefiniowano wzorzec wyrażenia regularnego `(\d+)*(\w)\2`, który jest interpretowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(\d+)*`|Dopasowuje jeden lub więcej wystąpień cyfrę dziesiętną. Jest to pierwsza grupa przechwytywania. Pasuje do tego wzorca wartość zero lub jeden raz.|  
|`(\w)`|Jest to druga grupa przechwytywania.|  
|`\k`|Pasuje do ciągu, przechwycone przez to druga grupa przechwytywania.|  
  
 [!code-csharp[System.Text.RegularExpressions.GroupCollection.Item#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.groupcollection.item/cs/item3.cs#2)]
 [!code-vb[System.Text.RegularExpressions.GroupCollection.Item#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.groupcollection.item/vb/item3.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Group this[string groupname] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.RegularExpressions.Group Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(groupname As String) As Group" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::Group ^ default[System::String ^] { System::Text::RegularExpressions::Group ^ get(System::String ^ groupname); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Text.RegularExpressions.Group" Usage="System.Text.RegularExpressions.GroupCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Group</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupname" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupname">Nazwa grupy przechwytywania.</param>
        <summary>Umożliwia dostęp do składowej klasy kolekcji za pomocą indeksu ciągu.</summary>
        <value>Członek kolekcji określonej przez <paramref name="groupname" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `groupName` może być nazwa grupy przechwytywania, który jest definiowany przez `(?<` *nazwa* `>)` element w wyrażeniu regularnym lub ciąg reprezentujący liczbę grupy przechwytywania, który jest definiowany przez grupowanie konstrukcja. Aby uzyskać więcej informacji na temat grup w wyrażeniach regularnych, zobacz [Grouping Constructs](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).  
  
 Można pobrać nazwy wszystkich grup przechwyconych w <xref:System.Text.RegularExpressions.Regex> obiektu przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.GetGroupNames%2A?displayProperty=nameWithType> metody. Można również mapować liczby grupy w wyrażeniu regularnym ich nazwy przechwytywania, wywołując <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A?displayProperty=nameWithType> metody. Poszczególne nazwy z tablicy mogą być następnie przekazywany do <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29> właściwość służąca do pobierania przechwyconych ciągu.  
  
 Jeśli `groupname` nie jest to nazwa grupy przechwytywania w kolekcji, lub jeśli `groupname` to nazwa grupy przechwytywania, który ma nie została dopasowana do ciągu wejściowego, metoda zwraca <xref:System.Text.RegularExpressions.Group> którego <xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType> właściwość `false` i którego `Group.Value` właściwość <xref:System.String.Empty?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenie regularne składa się z dwóch grup o nazwie. Pierwsza grupa `numbers`, przechwytuje jedną lub więcej kolejnych cyfr. Druga grupa `letter`, dopasowuje pojedynczy znak. Ponieważ aparat wyrażeń regularnych szuka zera lub jednego wystąpienia wzorca definicją `numbers` grupy `numbers` grupy nie zawsze jest dostępne, nawet jeśli dopasowanie zakończy się pomyślnie. W przykładzie pokazano następnie wynik po <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29> właściwość jest używana, aby pobrać grupę niedopasowane, dopasowanej grupy i grupy, który nie jest zdefiniowany w wyrażeniu regularnym. W przykładzie zdefiniowano wzorzec wyrażenia regularnego `(?<numbers>\d+)*(?<letter>\w)\k<letter>`, który jest interpretowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(?<numbers>\d+)*`|Dopasowuje jeden lub więcej wystąpień cyfrę dziesiętną. Nazwij to `numbers` grupa przechwytywania. Pasuje do tego wzorca wartość zero lub jeden raz.|  
|`(?<letter>\w)`|Dopasowuje znak słowa. Nazwij to `letter` grupa przechwytywania.|  
|`\k<letter>`|Pasuje do ciągu przechwycone przez `letter` grupa przechwytywania.|  
  
 [!code-csharp[System.Text.RegularExpressions.GroupCollection.Item#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.groupcollection.item/cs/item2.cs#1)]
 [!code-vb[System.Text.RegularExpressions.GroupCollection.Item#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.groupcollection.item/vb/item2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Text.RegularExpressions.GroupCollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Text.RegularExpressions.GroupCollection" />.</summary>
        <value>Kopię <see cref="T:System.Text.RegularExpressions.Match" /> obiektu do synchronizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Ten element członkowski nie jest obecny w [!INCLUDE[net_portable](~/includes/net-portable-md.md)]. Jeśli tworzysz aplikacje przeznaczone [!INCLUDE[net_portable](~/includes/net-portable-md.md)], użyj <xref:System.Text.RegularExpressions.GroupCollection.System%23Collections%23ICollection%23SyncRoot%2A?displayProperty=nameWithType> właściwości zamiast tego.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.GroupCollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;Group&gt;.Add (System.Text.RegularExpressions.Group item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Add(class System.Text.RegularExpressions.Group item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#Generic#ICollection&lt;System#Text#RegularExpressions#Group&gt;#Add(System.Text.RegularExpressions.Group)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As Group) Implements ICollection(Of Group).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Add(System::Text::RegularExpressions::Group ^ item) = System::Collections::Generic::ICollection&lt;System::Text::RegularExpressions::Group ^&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Text.RegularExpressions.Group" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;Group&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#Generic#ICollection&lt;System#Text#RegularExpressions#Group&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of Group).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Clear() = System::Collections::Generic::ICollection&lt;System::Text::RegularExpressions::Group ^&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;Group&gt;.Contains (System.Text.RegularExpressions.Group item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Contains(class System.Text.RegularExpressions.Group item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#Generic#ICollection&lt;System#Text#RegularExpressions#Group&gt;#Contains(System.Text.RegularExpressions.Group)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Group) As Boolean Implements ICollection(Of Group).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Contains(System::Text::RegularExpressions::Group ^ item) = System::Collections::Generic::ICollection&lt;System::Text::RegularExpressions::Group ^&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Text.RegularExpressions.Group" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;Group&gt;.Remove (System.Text.RegularExpressions.Group item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Remove(class System.Text.RegularExpressions.Group item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#Generic#ICollection&lt;System#Text#RegularExpressions#Group&gt;#Remove(System.Text.RegularExpressions.Group)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (item As Group) As Boolean Implements ICollection(Of Group).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Text.RegularExpressions.Group&gt;.Remove(System::Text::RegularExpressions::Group ^ item) = System::Collections::Generic::ICollection&lt;System::Text::RegularExpressions::Group ^&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Text.RegularExpressions.Group" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Text.RegularExpressions.Group&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Text.RegularExpressions.Group&gt; IEnumerable&lt;Group&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;class System.Text.RegularExpressions.Group&gt; System.Collections.Generic.IEnumerable&lt;System.Text.RegularExpressions.Group&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#Generic#IEnumerable&lt;System#Text#RegularExpressions#Group&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Group) Implements IEnumerable(Of Group).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Text::RegularExpressions::Group ^&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Text.RegularExpressions.Group&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Text::RegularExpressions::Group ^&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Text.RegularExpressions.Group&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.IndexOf">
      <MemberSignature Language="C#" Value="int IList&lt;Group&gt;.IndexOf (System.Text.RegularExpressions.Group item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.IndexOf(class System.Text.RegularExpressions.Group item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#Generic#IList&lt;System#Text#RegularExpressions#Group&gt;#IndexOf(System.Text.RegularExpressions.Group)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Group) As Integer Implements IList(Of Group).IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.IndexOf(System::Text::RegularExpressions::Group ^ item) = System::Collections::Generic::IList&lt;System::Text::RegularExpressions::Group ^&gt;::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Text.RegularExpressions.Group" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.Insert">
      <MemberSignature Language="C#" Value="void IList&lt;Group&gt;.Insert (int index, System.Text.RegularExpressions.Group item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.Insert(int32 index, class System.Text.RegularExpressions.Group item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#Generic#IList&lt;System#Text#RegularExpressions#Group&gt;#Insert(System.Int32,System.Text.RegularExpressions.Group)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Group) Implements IList(Of Group).Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.Insert(int index, System::Text::RegularExpressions::Group ^ item) = System::Collections::Generic::IList&lt;System::Text::RegularExpressions::Group ^&gt;::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Text.RegularExpressions.Group" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.Item">
      <MemberSignature Language="C#" Value="System.Text.RegularExpressions.Group System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.RegularExpressions.Group System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.System#Collections#Generic#IList&lt;System#Text#RegularExpressions#Group&gt;#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Group Implements IList(Of Group).Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Text::RegularExpressions::Group ^ System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.Item[int] { System::Text::RegularExpressions::Group ^ get(int index); void set(int index, System::Text::RegularExpressions::Group ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Text.RegularExpressions.GroupCollection.System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Group</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.RemoveAt">
      <MemberSignature Language="C#" Value="void IList&lt;Group&gt;.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#Generic#IList&lt;System#Text#RegularExpressions#Group&gt;#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList(Of Group).RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IList&lt;System.Text.RegularExpressions.Group&gt;.RemoveAt(int index) = System::Collections::Generic::IList&lt;System::Text::RegularExpressions::Group ^&gt;::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="arrayIndex">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Text.RegularExpressions.GroupCollection.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Text.RegularExpressions.GroupCollection.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Text.RegularExpressions.GroupCollection.System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.GroupCollection.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Text.RegularExpressions.GroupCollection.System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.GroupCollection.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
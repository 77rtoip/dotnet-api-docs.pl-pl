<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f5b1b16e45086d2dbf7c8f1afa213b88dfe4f122" />
    <Meta Name="ms.sourcegitcommit" Value="9f18ecaf63382fa565dfaeb7274bc1a9e81c35e9" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/19/2018" />
    <Meta Name="ms.locfileid" Value="36208851" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje niezmienne wyrażenie regularne.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Klasa reprezentuje aparat wyrażeń regularnych programu .NET Framework. Może służyć do szybkiego analizy dużych ilości tekst do znalezienia wzorce określonego znaku; do wyodrębnienia, Edycja, Zamień lub usuń tekst podciągów; i dodać wyodrębnione ciągi do kolekcji do wygenerowania raportu.  
  
> [!NOTE]
>  Jeśli do sprawdzania ciągu przez określenie, czy jest zgodny ze wzorcem określonym zainteresowanie podstawowej, można użyć <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> klasy.  
  
 Aby użyć wyrażeń regularnych, należy zdefiniować wzorzec, który chcesz zidentyfikować w strumieniu tekstu przy użyciu składni udokumentowane w [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Następnie można opcjonalnie utworzyć wystąpienie <xref:System.Text.RegularExpressions.Regex> obiektu. Na koniec należy wywołać metodę, która wykonuje pewne operacje, takie jak zastępowanie tekstu, który jest zgodny ze wzorcem wyrażenia regularnego lub identyfikowania dopasowania wzorca.  
  
> [!NOTE]
>  Dla niektórych typowych wzorców wyrażeń regularnych, zobacz [przykłady wyrażeń regularnych](~/docs/standard/base-types/regular-expression-examples.md). Istnieją również liczba bibliotek online z wyrażeniem regularnym wzorców, takich jak jedną [Expressions.info regularne](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Aby uzyskać więcej informacji o używaniu <xref:System.Text.RegularExpressions.Regex> klasy, zobacz następujące sekcje w tym temacie:  
  
-   [Vs wyrażenia regularnego. Parametry metody](#regex_vs_string)  
  
-   [Statyczne vs. Wystąpienie metody](#static_vs_instance)  
  
-   [Wykonywanie operacji wyrażeń regularnych](#regex_ops)  
  
-   [Definiowanie wartości limitu czasu](#define_timeout)  
  
 Aby uzyskać więcej informacji na temat języka wyrażeń regularnych, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) lub pobrać i wydrukować jeden z tych broszury:  
  
 [Krótki przewodnik w formacie programu Word (.docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Krótki przewodnik w formacie PDF (PDF)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Vs wyrażenia regularnego. Parametry metody  
 <xref:System.String?displayProperty=nameWithType> Klasa zawiera kilka metod wyszukiwania i porównanie, które można wykonać dopasowywanie do wzorca z tekstu. Na przykład <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, i <xref:System.String.StartsWith%2A?displayProperty=nameWithType> metody ustalić, czy wystąpienie ciągu zawiera określony podciąg; i <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, i <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> metody zwracają wskazany podciąg pozycję początkową w ciągu. Użyj metody <xref:System.String?displayProperty=nameWithType> klasy podczas wyszukiwania określonego ciągu. Użyj <xref:System.Text.RegularExpressions.Regex> klasy podczas wyszukiwania określonym wzorcem w ciągu. Aby uzyskać dodatkowe informacje i przykłady, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Powrót do uwagi](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Statyczne vs. Wystąpienie metody  
 Po zdefiniowaniu wzorzec wyrażenia regularnego można Podaj aparat wyrażeń regularnych w jeden z dwóch sposobów:  
  
-   Przy uruchamianiu <xref:System.Text.RegularExpressions.Regex> obiekt, który reprezentuje wyrażenie regularne. W tym celu należy przekazać wzorzec wyrażenia regularnego do <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> konstruktora. A <xref:System.Text.RegularExpressions.Regex> obiektu jest niezmienialny; podczas tworzenia wystąpienia <xref:System.Text.RegularExpressions.Regex> obiekt z wyrażeniem regularnym, nie można zmienić obiektu wyrażenia regularnego.  
  
-   Podając zarówno wyrażenie regularne, jak i tekst do wyszukania do `static` (`Shared` w języku Visual Basic) <xref:System.Text.RegularExpressions.Regex> metody. Dzięki temu można użyć wyrażenia regularnego bez jawnego tworzenia <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 Wszystkie <xref:System.Text.RegularExpressions.Regex> metod identyfikacji wzorzec obejmują obu statyczna i wystąpienia przeciążenia.  
  
 Aparat wyrażeń regularnych należy skompilować określonego wzorca przed użyciem wzorca. Ponieważ <xref:System.Text.RegularExpressions.Regex> obiekty są niezmienne, jest to jednorazowa procedury, która występuje podczas <xref:System.Text.RegularExpressions.Regex> nosi nazwę konstruktora klasy lub metody statycznej. Aby wyeliminować potrzebę wielokrotnie skompilować jedno wyrażenie regularne, aparat wyrażeń regularnych buforuje skompilowane wyrażenia regularnego używanym w wywołaniach metody statycznej. W związku z tym metody dopasowywanie do wzorca wyrażenia regularnego oferują można porównywać pod względem wydajności statyczny i metody wystąpienia.  
  
> [!IMPORTANT]
>  W wyrażeniach regularnych w wersjach 1.0 i 1.1, wszystkich skompilowanych .NET Framework czy były używane w wystąpieniu lub metody statycznej wywołania, były buforowane. Począwszy od programu .NET Framework 2.0, buforowane są tylko wyrażenia regularne używanym w wywołaniach metody statycznej.  
  
 Jednak buforowanie może niekorzystnie wpłynąć na wydajność w dwóch następujących przypadków:  
  
-   Jeśli używasz wywołania metody statycznej z dużą liczbą wyrażeń regularnych. Domyślnie aparat wyrażeń regularnych buforuje 15 ostatnio używane statyczne wyrażenia regularne. Jeśli aplikacja korzysta z więcej niż 15 statyczne wyrażenia regularne, niektóre wyrażeń regularnych musi ponownie kompilowana. Aby zapobiec tej ponownej kompilacji, można zwiększyć <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> właściwości.  
  
-   Kiedy należy utworzyć wystąpienia nowych <xref:System.Text.RegularExpressions.Regex> obiektów wyrażeń regularnych, które wcześniej zostały skompilowane. Na przykład poniższy kod definiuje wyrażenie regularne do zlokalizowania zduplikowanych słów w strumieniu tekstu. Mimo że w przykładzie użyto jednego wyrażenia regularnego, tworzy nową <xref:System.Text.RegularExpressions.Regex> obiektu do przetwarzania każdego wiersza tekstu. Powoduje to kompilację wyrażenia regularnego z każdej iteracji pętli.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Aby zapobiec ponownej kompilacji, należy utworzyć wystąpienia pojedynczy <xref:System.Text.RegularExpressions.Regex> obiektu, który jest dostępny dla żadnego kodu, który wymaga tego, jak pokazano w poniższym przykładzie ponownie zapisane.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Powrót do uwagi](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Wykonywanie operacji na wyrażeniach regularnych  
 Określa, czy użytkownik chce utworzyć wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu i wywołanie jego metody lub wywołać metod statycznych <xref:System.Text.RegularExpressions.Regex> klasy oferuje następujące funkcje dopasowywanie do wzorca:  
  
-   Sprawdzanie poprawności dopasowania. Należy wywołać <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> metodę, aby określić, czy dopasowanie jest obecny.  
  
-   Pobieranie pojedynczego dopasowania. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Match%2A> metoda pobierania <xref:System.Text.RegularExpressions.Match> obiekt, który reprezentuje pierwszego dopasowania w ciągu lub w części ciągu. Kolejnych dopasowań można pobranej poprzez wywołanie <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody.  
  
-   Pobieranie wszystkie dopasowania. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Matches%2A> metoda pobierania <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> obiekt, który reprezentuje wszystkie dopasowania znajdującą się w ciągu lub w części ciągu.  
  
-   Zastąpienie dopasowany tekst. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Replace%2A> metodę, aby zastąpić dopasowany tekst. Tekst zastępczy można również zdefiniować przez wyrażenie regularne. Ponadto niektóre <xref:System.Text.RegularExpressions.Regex.Replace%2A> metod uwzględnić <xref:System.Text.RegularExpressions.MatchEvaluator> parametr, który umożliwia zdefiniowanie programowo tekst zastępczy.  
  
-   Tworzenie tablicy ciągów, który został utworzony z części ciągu wejściowego. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Split%2A> metodę, aby podzielić ciąg wejściowy w pozycjach, które są zdefiniowane przez wyrażenie regularne.  
  
 Oprócz metod jej dopasowywanie do wzorca <xref:System.Text.RegularExpressions.Regex> klasy są dostępne różne metody specjalnych:  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A> Metody specjalne znaków, które mogą być interpretowane jako wyrażenie regularne operatorów w wyrażeniu regularnym lub ciąg wejściowy.  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Metoda usuwa te znaki specjalne.  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Metoda tworzy zestaw, który zawiera wstępnie zdefiniowanych wyrażeń regularnych. .NET Framework zawiera przykłady te zestawy specjalnych w <xref:System.Web.RegularExpressions?displayProperty=nameWithType> przestrzeni nazw.  
  
 [Powrót do uwagi](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definiowanie wartości limitu czasu  
 .NET Framework obsługuje język kompletne wyrażenie regularne, zapewniający znacznej możliwościach i elastyczności w dopasowywania do wzorca. Jednak występować możliwościach i elastyczności przy koszcie: ryzyko pogorszenie wydajności. Wyrażenia regularne, które niskiej wydajności są zaskakująco łatwo utworzyć. W niektórych przypadkach operacje wyrażenie regularne, które opierają się na nadmiernym wykorzystaniem algorytmu wycofywania może się pojawić przestaje odpowiadać podczas przetwarzania tekst niemal pasujący wzorzec wyrażenia regularnego. Aby uzyskać więcej informacji na temat aparatu wyrażeń regularnych programu .NET Framework, zobacz [szczegóły zachowania wyrażeń regularnych](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Aby uzyskać więcej informacji na temat nadmiernym wykorzystaniem algorytmu wycofywania, zobacz [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], można zdefiniować interwał limitu czasu dla wyrażenia regularnego dopasowań. Jeśli aparat wyrażeń regularnych nie może zidentyfikować dopasowania w tym przedziale czasu, zgłasza operacji dopasowywania <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. W większości przypadków zapobiega to aparat wyrażeń regularnych marnować mocy obliczeniowej przez próby dopasowania tekst niemal pasujący wzorzec wyrażenia regularnego. Ponadto może to wskazywać, jednak, czy interwał limitu czasu został ustawiony zbyt mała, lub że bieżącego obciążenia maszyny spowodowała spadku ogólnej wydajności.  
  
 Jak obsłużyć wyjątek, zależy od przyczyną wyjątku. Jeśli wyjątek występuje, ponieważ interwał limitu czasu jest ustawiona zbyt mała lub z powodu maszyny nadmiernego obciążenia, można zwiększyć limit czasu i spróbuj ponownie wykonać operację dopasowywania. Wyjątek występuje, ponieważ wyrażenie regularne zależy od tego, nadmiernym wykorzystaniem algorytmu wycofywania, możesz założono, że istnieje dopasowanie i opcjonalnie może rejestrować informacje, dzięki którym można zmodyfikować wzorzec wyrażenia regularnego.  
  
 Można ustawić limitu czasu, przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> konstruktorem wystąpienia obiektu będącego wyrażeniem regularnym. Dla metody statyczne, można ustawić limitu czasu przez wywołanie metody przeciążenia odpowiadającej metody, która ma `matchTimeout` parametru. Jeśli nie ustawiaj jawnie wartości limitu czasu, domyślną wartość limitu czasu jest określany w następujący sposób:  
  
-   Przy użyciu limit czasu dla całej aplikacji wartość, jeśli istnieje. To może mieć dowolną wartość limitu czasu, która ma zastosowanie do domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> wystąpienie obiektu lub wywołanie metody statycznej. Wartość limitu czasu całej aplikacji przez wywołanie metody <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> metodę przypisania reprezentację ciągu <xref:System.TimeSpan> wartości dla właściwości "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Przy użyciu wartości <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, jeżeli nie ustawiono żadnych wartości limitu czasu całej aplikacji.  
  
> [!IMPORTANT]
>  Firma Microsoft zaleca, ustaw wartość limitu czasu we wszystkich operacjach dopasowania wzorca wyrażenia regularnego. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md).  
  
 [Powrót do uwagi](#remarks)  
  
   
  
## Examples  
 W poniższym przykładzie użyto wyrażenia regularnego, aby sprawdzić, czy są powtarzane wystąpień słowa w ciągu. Wyrażenie regularne `\b(?<word>\w+)\s+(\k<word>)\b` może zostać zinterpretowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Uruchom dopasowania na granicy programu word.|  
|`(?<word>\w+)`|Zgodne z co najmniej jeden znak programu word do granic programu word. Określ nazwę tej grupy przechwyconych `word`.|  
|`\s+`|Zgodne białe znaki.|  
|`(\k<word>)`|Pasuje do przechwyconej grupy, o nazwie `word`.|  
|`\b`|Dopasowuje granicę wyrazu.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 Poniższy przykład przedstawia użycie wyrażenia regularnego, aby sprawdzić, czy ciąg reprezentuje wartość waluty lub ma niepoprawny format do reprezentowania wartości waluty. W takim przypadku wyrażenie regularne jest tworzona dynamicznie z <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości dla bieżącej kultury użytkownika. Jeśli system bieżącej kultury jest en US, wynikowe wyrażenie regularne jest `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. To wyrażenie regularne może zostać zinterpretowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpocząć od początku ciągu.|  
|`\s*`|Dopasowanie do zera lub większej liczby znaków odstępu.|  
|`[\+-]?`|Wystąpienie dopasowania zero lub jeden znak dodatnią lub znakiem minus.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`\$?`|Zgodne wystąpienie zero lub jeden znak dolara ($).|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`\d*`|Dopasowanie do zera lub większej liczby cyfr dziesiętnych.|  
|`\.?`|Zgodne zero lub jeden symbol punktu dziesiętnego.|  
|`\d{2}?`|Dopasowuje dwóch cyfr dziesiętnych zero lub jeden raz.|  
|`(\d*\.?\d{2}?){1}`|Jest zgodna z wzorcem wynikających z zaokrągleń cyfr rozdzielonych symbol punktu dziesiętnego co najmniej jeden raz.|  
|`$`|Zgodne końca ciągu.|  
  
 W takim przypadku wyrażenia regularnego zakłada waluty prawidłowy ciąg nie zawiera symboli separatora grupy i czy ma ona nie cyfr ułamkowych lub liczba cyfr ułamkowych wynika z bieżącej kultury <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> właściwości.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Ponieważ wyrażenie regularne w tym przykładzie jest tworzona dynamicznie, nie wiemy, w czasie projektowania, czy symbol waluty bieżącej kultury, decimal logowania lub dodatnie i ujemne znaków może zostać błędnie zinterpretowane przez aparat wyrażeń regularnych jako operatory języka wyrażeń regularnych. Aby zapobiec błędnej, przykładzie przekazuje każdego dynamicznie generowanym ciąg do <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody.  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <see cref="T:System.Text.RegularExpressions.Regex" /> Klasy nie można modyfikować (tylko do odczytu) i bezpieczne dla wątków. <see cref="T:System.Text.RegularExpressions.Regex" /> obiekty można tworzyć w którymkolwiek wątku i udostępniane między wątkami. Aby uzyskać więcej informacji zobacz [Safety](~/docs/standard/base-types/thread-safety-in-regular-expressions.md) wątku.</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że ten konstruktor jest chroniony; może być wywoływany tylko przez klasy pochodzące od <xref:System.Text.RegularExpressions.Regex> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy dla określonego wyrażenia regularnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tematów.  
  
 Wywoływanie <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> Konstruktor jest odpowiednikiem wywołania <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> konstruktora o wartości <xref:System.Text.RegularExpressions.RegexOptions.None> dla `options` argumentu.  
  
 A <xref:System.Text.RegularExpressions.Regex> obiektu nie można modyfikować, co oznacza, że może służyć tylko do wzorca dopasowania zdefiniować podczas jego tworzenia. Jednak może być używana dowolna liczba razy nie jest ponownie kompilowana.  
  
 Ten konstruktor tworzy wystąpienie obiektu będącego wyrażeniem regularnym, podejmowanych liter alfabetycznej znaków zdefiniowane w `pattern`. Dopasowanie bez uwzględniania wielkości liter, użyj <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób użycia tego konstruktora do utworzenia wystąpienia wyrażenia regularnego pasujący żadnych wyrazu, który rozpoczyna się od litery "a" lub "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Należy pamiętać, że wzorzec wyrażenia regularnego nie można dopasować słowo "" na początku tekstu, ponieważ domyślnie rozróżnia wielkość liter podczas porównywania. Na przykład porównania bez uwzględniania wielkości liter zobacz <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Ten konstruktor tworzy <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt, który używa domyślnej wartości limitu czasu domeny aplikacji, w której została utworzona. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu używa wartości <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia operację z przekroczeniem limitu czasu. Zalecane Konstruktor do tworzenia <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt jest <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, umożliwiające ustawienie interwału limitu czasu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt, który zawiera seryjnych wzorca i <see cref="T:System.Text.RegularExpressions.RegexOptions" /> informacji.</param>
        <param name="context">Miejsce docelowe dla serializacji. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> przy użyciu serializowane dane.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">Wzorzec który <paramref name="info" /> zawiera jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="info" /> zawiera nieprawidłową <see cref="T:System.Text.RegularExpressions.RegexOptions" /> flagi.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które modyfikują wyrażenia regularnego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy dla określonego wyrażenia regularnego z opcjami, które modyfikują wzorzec.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tematów.  
  
 A <xref:System.Text.RegularExpressions.Regex> obiektu nie można modyfikować, co oznacza, że może służyć tylko dla parametrów dopasowania zdefiniować podczas jego tworzenia. Jednak może być używana dowolna liczba razy nie jest ponownie kompilowana.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób użycia tego konstruktora do utworzenia wystąpienia wyrażenia regularnego pasujący żadnych wyrazu, który rozpoczyna się od litery "a" lub "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Należy pamiętać, że kolekcja dopasowania zawiera słowo "" tekst rozpoczyna się, ponieważ `options` parametr jest zdefiniowany porównania bez uwzględniania wielkości liter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> zawiera nieprawidłową flagę.</exception>
        <block subset="none" type="usage">
          <para>Ten konstruktor tworzy <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt, który używa domyślnej wartości limitu czasu domeny aplikacji, w której została utworzona. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu używa wartości <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia operację z przekroczeniem limitu czasu. Zalecane Konstruktor do tworzenia <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt jest <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, umożliwiające ustawienie interwału limitu czasu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które modyfikują wyrażenia regularnego.</param>
        <param name="matchTimeout">Interwał limitu czasu, lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> aby wskazać, że metoda powinna nie upłynął limit czasu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy dla określonego wyrażenia regularnego z opcjami, które modyfikują wzorzec i wartość, która określa, jak długo metody dopasowania wzorca mają podejmować próbę dopasowania, zanim upłynie limit czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tematów.  
  
 A <xref:System.Text.RegularExpressions.Regex> obiektu nie można modyfikować, co oznacza, że może służyć tylko do wzorca dopasowania zdefiniować podczas tworzenia. Jednak może być używana dowolna liczba razy nie jest ponownie kompilowana.  
  
 `matchTimeout` Parametr określa, jak długo dopasowywanie do wzorca metody prób znalezienia dopasowania, zanim upłynie limit czasu. Jeśli nie znaleziono, w tym przedziale czasu, zgłasza dopasowanie wzorca metody <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie domyślną wartość limitu czasu dla domeny aplikacji, w którym zdefiniowano <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Dopasowywanie do wzorca metod instancji honorujących `matchTimeout` interwał limitu czasu są następujące:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Ustawienie limitu czasu uniemożliwia wyrażeń regularnych, które opierają się na nadmiernym wykorzystaniem algorytmu wycofywania wyświetlaniu przestaje odpowiadać podczas przetwarzania danych wejściowych zawierający dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Aby ustawić interwał limitu czasu uzasadnione, należy wziąć pod uwagę następujące czynniki:  
  
-   Długość i złożoność wzorzec wyrażenia regularnego. Wyrażenia regularne dłużej i bardziej złożonej wymagają więcej czasu niż krótsze i łatwiejsze.  
  
-   Obciążenie maszyny oczekiwanego. Przetwarzanie zajmuje więcej czasu na komputerach, które mają wysokie użycie procesora CPU i pamięci.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor do tworzenia wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu o wartość limitu czasu w ciągu sekundy. Wzorzec wyrażenia regularnego `(a+)+$`, podlega zgodnej z co najmniej jeden sekwencji co najmniej jeden "" znak na końcu wiersza, nadmiernym wykorzystaniem algorytmu wycofywania. Jeśli <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> jest zgłoszony, przykładzie zwiększa maksymalnie trzy sekundy wartość maksymalną wartość limitu czasu. W przeciwnym razie odstępuje go nie pasuje do wzorca.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartość.  - lub - <paramref name="matchTimeout" /> jest ujemna, zero, lub większa niż około 24 dni.</exception>
        <block subset="none" type="usage">
          <para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwie sekundy. Jeśli wyłączysz przekroczeń limitu czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednak należy wyłączyć limity czasu tylko w następujących warunkach: — w przypadku wprowadzania przetworzone przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub składa się z tekst statyczny. Obejmuje to tekst, który dynamicznie została wprowadzona przez użytkowników.  — Wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że wydajnie obsługuje on zgodny z systemem innym niż dopasowań, bliskiej zgodny.  -Gdy wzorzec wyrażenia regularnego nie zawiera żadnych elementów języka, mogących powodować nadmiernym wykorzystaniem algorytmu wycofywania, podczas przetwarzania near dopasowania.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę wpisów w bieżącej statycznej pamięci podręcznej skompilowane wyrażenia regularnego.</summary>
        <value>Maksymalna liczba wpisów w statycznej pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Klasa obsługuje wewnętrznej pamięci podręcznej skompilowanych wyrażeń regularnych używanym w wywołaniach metody statycznej. Jeśli wartość określona w operacji set jest mniejsza niż bieżący rozmiar pamięci podręcznej, wpisy w pamięci podręcznej są odrzucane, dopóki nie zostanie określona wartość rozmiaru pamięci podręcznej.  
  
 Domyślnie pamięci podręcznej zawierające 15 skompilowany statyczne wyrażenia regularne. Aplikacji zwykle nie należy zmodyfikować rozmiaru pamięci podręcznej. Użyj <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> właściwość tylko wtedy, gdy chcesz wyłączyć buforowanie lub jeśli masz zbyt dużą pamięci podręcznej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji set jest mniejsza od zera.</exception>
        <block subset="none" type="usage">
          <para>W programie .NET Framework, przed [! INCLUDE[net_v20SP1_short](~/includes/NET-v20sp1-Short-MD.MD)] użyć wyrażeń regularnych w obu statyczna i wywołania metody wystąpienia zostały zapisane. Począwszy od [! Wyrażenia include[net_v20SP1_short](~/includes/NET-v20sp1-Short-MD.MD)], tylko regular używany w metodzie statycznej wywołania są buforowane.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowanych przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia słownik mapujący o nazwie grupy przechwytywania w celu ich wartości indeksu.</summary>
        <value>Słownik, który mapuje nazwę grupy przechwytywania w celu ich wartości indeksu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że ta właściwość jest chroniony; można dostęp tylko z klasą pochodną <xref:System.Text.RegularExpressions.Regex> klasy.  
  
 Próbuje przekonwertować wartość przypisana do właściwości do operacji set <xref:System.Collections.Hashtable> obiektu; w przypadku niepowodzenia konwersji wywołuje <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość przypisana do <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> właściwość w operacji set jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowanych przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia słownik mapujący numerowane grup przechwytywania w celu ich wartości indeksu.</summary>
        <value>Słownik mapujący numerowane grup przechwytywania w celu ich wartości indeksu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że ta właściwość jest chroniony; można dostęp tylko z klasą pochodną <xref:System.Text.RegularExpressions.Regex> klasy.  
  
 Próbuje przekonwertować wartość przypisana do właściwości do operacji set <xref:System.Collections.Hashtable> obiektu; w przypadku niepowodzenia konwersji wywołuje <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość przypisana do <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> właściwość w operacji set jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowanych przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowanych przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kompiluje wyrażeń regularnych i zapisuje je na dysku w jednym zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Na .NET Core wywołań `Regex.CompileToAssembly` throw metody <xref:System.PlatformNotSupportedException>; wypisywanie zestawu nie jest obsługiwane.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tablica, która opisuje wyrażeń regularnych do skompilowania.</param>
        <param name="assemblyname">Nazwa pliku zestawu.</param>
        <summary>Kompiluje co najmniej jeden określony <see cref="T:System.Text.RegularExpressions.Regex" /> obiektów w nazwanym zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> Metoda generuje zestawu .NET Framework, w których każdy zdefiniowany w wyrażeniu regularnym `regexinfos` tablicy jest reprezentowany przez klasę. Zazwyczaj <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> metoda jest wywoływana z oddzielnych aplikacji, która generuje zestawu skompilowane wyrażenia regularnego. Każde wyrażenie regularne zawarte w zestawie ma następującą charakterystykę:  
  
-   Jest pochodną <xref:System.Text.RegularExpressions.Regex> klasy.  
  
-   Jest ona przypisana Pełna nazwa, która jest zdefiniowana przez `fullnamespace` i `name` parametrów odpowiadającymi mu dostawcami <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu.  
  
-   Ma ona domyślnej (lub bez parametrów) konstruktora.  
  
 Zwykle kodu, który tworzy i używa wyrażenia regularnego skompilowanych znajduje się w zestawu lub aplikacji, która różni się od kodu, który tworzy zestaw.  
  
   
  
## Examples  
 Poniższy przykład tworzy zestaw o nazwie RegexLib.dll. Zestaw zawiera dwa skompilowane wyrażenia regularnego. Pierwsza strona, `Utilities.RegularExpressions.DuplicatedString`, odpowiada dwa identyczne wyrazy ciągły. Druga Strona, `Utilities.RegularExpressions.EmailAddress`, sprawdza, czy ciąg ma niepoprawny format jako adresu e-mail.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 Wyrażenie regularne, które sprawdza ciąg zduplikowane wyrazów jest następnie wystąpienie zostało utworzone i używane w poniższym przykładzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Pomyślnie kompilacji, w tym przykładzie drugi wymaga odwołania do RegexLib.dll (zestawu utworzonego w pierwszym przykładzie) ma zostać dodany do projektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="assemblyname" /> parametru <see cref="P:System.Reflection.AssemblyName.Name" /> właściwość jest ciągiem pustym ani mieć wartości null.  - lub - wzorzec wyrażenia regularnego jednego lub więcej obiektów w <paramref name="regexinfos" /> zawiera nieprawidłową składnię.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> lub <paramref name="regexinfos" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Oprogramowanie .NET core: Tworzenie zestawu skompilowanego wyrażeń regularnych nie jest obsługiwane.</exception>
        <block subset="none" type="usage">
          <para>Jeśli tworzysz na komputerze, który ma [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] lub jego zainstalowana wersjach punktu docelowego [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i używasz <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> metodę w celu utworzenia zestawu, który zawiera skompilowane wyrażenia regularne. Próbuje użyć jednego z wyrażeń regularnych w tym zestawie w systemie, która ma [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] zgłasza wyjątek. Aby obejść ten problem, można wykonać jedną z następujących czynności:-Tworzenie zestawu, który zawiera skompilowanych wyrażeń regularnych w systemie, który ma [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] zamiast tego nowszych wersji zainstalowane.  — Zamiast z wywołaniem <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> i pobierania skompilowane wyrażenia regularnego z zestawu, użyj statycznych lub wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> metod <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> podczas można utworzyć wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu lub wywołać wyrażenia regularnego Metoda dopasowania wzorca.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tablica, która opisuje wyrażeń regularnych do skompilowania.</param>
        <param name="assemblyname">Nazwa pliku zestawu.</param>
        <param name="attributes">Tablica, która definiuje atrybutów, które mają zastosowanie do zestawu.</param>
        <summary>Kompiluje co najmniej jeden określony <see cref="T:System.Text.RegularExpressions.Regex" /> obiektów w nazwanym zestawie o określonych atrybutów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> Metoda generuje zestawu .NET Framework, w których każdy zdefiniowany w wyrażeniu regularnym `regexinfos` tablicy jest reprezentowany przez klasę. Zazwyczaj <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> metoda jest wywoływana z oddzielnych aplikacji, która generuje zestawu skompilowane wyrażenia regularnego. Każde wyrażenie regularne zawarte w zestawie ma następującą charakterystykę:  
  
-   Jest pochodną <xref:System.Text.RegularExpressions.Regex> klasy.  
  
-   Jest ona przypisana Pełna nazwa, która jest zdefiniowana przez `fullnamespace` i `name` parametrów odpowiadającymi mu dostawcami <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu.  
  
-   Ma ona domyślnej (lub bez parametrów) konstruktora.  
  
 Zwykle kodu, który tworzy i używa wyrażenia regularnego skompilowanych znajduje się w zestawu lub aplikacji, która różni się od kodu, który tworzy zestaw.  
  
 Ponieważ <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> metoda generuje zestawu .NET Framework, po wywołaniu metody zamiast konkretnego języka definicji class, słowo kluczowe (takich jak `class` w języku C# lub `Class`...`End Class` w języku Visual Basic) nie zezwala się atrybuty .NET Framework ma być przypisany do zestawu przy użyciu Składnia atrybutu standardowego języka programowania. `attributes` Parametru zapewnia alternatywny sposób definiowania atrybutów, które mają zastosowanie do zestawu. Dla każdego atrybutu, który chcesz zastosować do zestawu wykonaj następujące czynności:  
  
1.  Utwórz tablicę <xref:System.Type> obiekty reprezentujące typy parametrów konstruktora atrybutu, który ma zostać wywołana.  
  
2.  Pobrać <xref:System.Type> obiekt reprezentujący klasę atrybutu, który chcesz zastosować do nowego zestawu.  
  
3.  Wywołanie <xref:System.Type.GetConstructor%2A> metody atrybutu <xref:System.Type> obiekt, aby pobrać <xref:System.Reflection.ConstructorInfo> obiekt reprezentujący konstruktora atrybutu, który ma zostać wywołana. Przekaż <xref:System.Type.GetConstructor%2A> Metoda tablicy z <xref:System.Type> obiektów, które reprezentuje typy parametrów konstruktora.  
  
4.  Utwórz <xref:System.Object> tablica, która definiuje parametry do przekazania do konstruktora atrybutu.  
  
5.  Utwórz wystąpienie <xref:System.Reflection.Emit.CustomAttributeBuilder> obiektu przez przekazanie jej konstruktora <xref:System.Reflection.ConstructorInfo> obiekt pobrany w kroku 3 i <xref:System.Object> tablicy utworzonej w kroku 4.  
  
 Tablica te można następnie przekazać <xref:System.Reflection.Emit.CustomAttributeBuilder> obiektów zamiast `attributes` parametr <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy zestaw o nazwie RegexLib.dll i stosuje <xref:System.Reflection.AssemblyTitleAttribute> do niej atrybut. Zestaw zawiera dwa skompilowane wyrażenia regularnego. Pierwsza strona, `Utilities.RegularExpressions.DuplicatedString`, odpowiada dwa identyczne wyrazy ciągły. Druga Strona, `Utilities.RegularExpressions.EmailAddress`, sprawdza, czy ciąg ma niepoprawny format jako adresu e-mail.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Sprawdź, czy <xref:System.Reflection.AssemblyTitleAttribute> zastosować atrybutu do zestawu, sprawdzając jego manifestu z narzędziem odbicia, takich jak narzędzia ILDasm.  
  
 Wyrażenie regularne, które sprawdza ciąg zduplikowane wyrazów jest następnie wystąpienie zostało utworzone i używane w poniższym przykładzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Pomyślnie kompilacji, w tym przykładzie drugi wymaga odwołania do RegexLib.dll (zestawu utworzonego w pierwszym przykładzie) ma zostać dodany do projektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="assemblyname" /> parametru <see cref="P:System.Reflection.AssemblyName.Name" /> właściwość jest ciągiem pustym ani mieć wartości null.  - lub - wzorzec wyrażenia regularnego jednego lub więcej obiektów w <paramref name="regexinfos" /> zawiera nieprawidłową składnię.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> lub <paramref name="regexinfos" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Oprogramowanie .NET core: Tworzenie zestawu skompilowanego wyrażeń regularnych nie jest obsługiwane.</exception>
        <block subset="none" type="usage">
          <para>Jeśli tworzysz na komputerze, który ma [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] lub jego zainstalowana wersjach punktu docelowego [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i używasz <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> metodę w celu utworzenia zestawu, który zawiera skompilowane wyrażenia regularne. Próbuje użyć jednego z wyrażeń regularnych w tym zestawie w systemie, która ma [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] zgłasza wyjątek. Aby obejść ten problem, można wykonać jedną z następujących czynności:-Tworzenie zestawu, który zawiera skompilowanych wyrażeń regularnych w systemie, który ma [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] zamiast tego nowszych wersji zainstalowane.  — Zamiast z wywołaniem <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> i pobierania skompilowane wyrażenia regularnego z zestawu, użyj statycznych lub wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> metod <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> podczas można utworzyć wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu lub wywołać wyrażenia regularnego Metoda dopasowania wzorca.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tablica, która opisuje wyrażeń regularnych do skompilowania.</param>
        <param name="assemblyname">Nazwa pliku zestawu.</param>
        <param name="attributes">Tablica, która definiuje atrybutów, które mają zastosowanie do zestawu.</param>
        <param name="resourceFile">Nazwa pliku zasobów Win32 do uwzględnienia w zestawie.</param>
        <summary>Kompiluje co najmniej jeden określony <see cref="T:System.Text.RegularExpressions.Regex" /> obiektów i plik zasobów określonej w nazwanym zestawie o określonych atrybutów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method generates a .NET Framework assembly in which each regular expression defined in the `regexinfos` array is represented by a class. Zazwyczaj [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > Metoda jest wywoływana z oddzielnych aplikacji, która generuje zestawu skompilowane wyrażenia regularnego. Każde wyrażenie regularne zawarte w zestawie ma następującą charakterystykę:  
  
-   Jest pochodną <xref:System.Text.RegularExpressions.Regex> klasy.  
  
-   Jest ona przypisana Pełna nazwa, która jest zdefiniowana przez `fullnamespace` i `name` parametrów odpowiadającymi mu dostawcami <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu.  
  
-   Ma ona domyślnej (lub bez parametrów) konstruktora.  
  
 Zwykle kodu, który tworzy i używa wyrażenia regularnego skompilowanych znajduje się w zestawu lub aplikacji, która różni się od kodu, który tworzy zestaw.  
  
 Ponieważ <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> metoda generuje zestawu .NET Framework, po wywołaniu metody zamiast konkretnego języka definicji class, słowo kluczowe (takich jak `class` w języku C# lub `Class`...`End Class` w języku Visual Basic) nie zezwala się atrybuty .NET Framework ma być przypisany do zestawu przy użyciu Składnia atrybutu standardowego języka programowania. `attributes` Parametru zapewnia alternatywny sposób definiowania atrybutów, które mają zastosowanie do zestawu. Dla każdego atrybutu, który chcesz zastosować do zestawu wykonaj następujące czynności:  
  
1.  Utwórz tablicę <xref:System.Type> obiekty reprezentujące typy parametrów konstruktora atrybutu, który ma zostać wywołana.  
  
2.  Pobrać <xref:System.Type> obiekt reprezentujący klasę atrybutu, który chcesz zastosować do nowego zestawu.  
  
3.  Wywołanie <xref:System.Type.GetConstructor%2A> metody atrybutu <xref:System.Type> obiekt, aby pobrać <xref:System.Reflection.ConstructorInfo> obiekt reprezentujący konstruktora atrybutu, który ma zostać wywołana. Przekaż <xref:System.Type.GetConstructor%2A> Metoda tablicy z <xref:System.Type> obiektów, które reprezentuje konstruktora typy parametrów  
  
4.  Utwórz <xref:System.Object> tablica, która definiuje parametry do przekazania do konstruktora atrybutu.  
  
5.  Utwórz wystąpienie <xref:System.Reflection.Emit.CustomAttributeBuilder> obiektu przez przekazanie jej konstruktora <xref:System.Reflection.ConstructorInfo> obiekt pobrany w kroku 3 i <xref:System.Object> tablicy utworzonej w kroku 4.  
  
 Tablica te można następnie przekazać <xref:System.Reflection.Emit.CustomAttributeBuilder> obiektów zamiast `attributes` parametr [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5b%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > Metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="assemblyname" /> parametru <see cref="P:System.Reflection.AssemblyName.Name" /> właściwość jest ciągiem pustym ani mieć wartości null.  - lub - wzorzec wyrażenia regularnego jednego lub więcej obiektów w <paramref name="regexinfos" /> zawiera nieprawidłową składnię.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> lub <paramref name="regexinfos" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="resourceFile" /> Parametr określa nieprawidłowy plik zasobów Win32.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Pliku określonego przez <paramref name="resourceFile" /> nie można odnaleźć parametru.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Oprogramowanie .NET core: Tworzenie zestawu skompilowanego wyrażeń regularnych nie jest obsługiwane.</exception>
        <block subset="none" type="usage">
          <para>Jeśli tworzysz na komputerze, który ma [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)] lub jego zainstalowana wersjach punktu docelowego [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i używasz <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> metodę w celu utworzenia zestawu, który zawiera skompilowane wyrażenia regularne. Próbuje użyć jednego z wyrażeń regularnych w tym zestawie w systemie, która ma [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] zgłasza wyjątek. Aby obejść ten problem, można wykonać jedną z następujących czynności:-Tworzenie zestawu, który zawiera skompilowanych wyrażeń regularnych w systemie, który ma [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] zamiast tego nowszych wersji zainstalowane.  — Zamiast z wywołaniem <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> i pobierania skompilowane wyrażenia regularnego z zestawu, użyj statycznych lub wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> metod <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> podczas można utworzyć wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu lub wywołać wyrażenia regularnego Metoda dopasowania wzorca.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg wejściowy zawiera tekst do konwersji.</param>
        <summary>Minimalny zbiór znaki specjalne (\\, *, +,?, |, {, [, (,), ^, $,., # i białe), zastępując je z ich kodami ucieczki. Powoduje to, że aparat wyrażeń regularnych interpretować te znaki jako literału, a nie jako metaznaki.</summary>
        <returns>Ciąg znaków z metaznaki przekonwertowany do postaci zmienionym znaczeniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Konwertuje ciąg, dzięki czemu aparat wyrażeń regularnych będzie interpretować wszystkie metaznaki, która może zawierać jako literały znaków. Rozważmy na przykład wyrażenia regularnego opracowaną w celu wyodrębnienia komentarze, które są rozdzielone przez proste otwierające i zamykające nawiasy kwadratowe ([i]) z pliku tekstowego. W poniższym przykładzie, wyrażenie regularne "[(.*?)]" jest interpretowany jako klasa znaków. Zamiast dopasowania komentarze osadzone w wejściowego tekstu, wyrażenie regularne dopasowuje każdego otwierający lub zamykający nawias okrągły, okres, gwiazdki lub znak zapytania.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Jednak jeśli nawias otwierający została zmieniona przez przekazanie jej <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody, wyrażenia regularnego powiedzie się w odpowiadającym komentarze, które są osadzone w ciągu wejściowym. Ilustruje to poniższy przykład.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 W wyrażeniu regularnym, która jest zdefiniowana za pomocą tekst statyczny, znaki, które mają być interpretowane jako literału, a nie jako metaznaki można wpisywany poprzedzając symbolem ukośnika odwrotnego (\\) oraz przez wywołanie <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody. W wyrażeniu regularnym, które zdefiniowano dynamicznie przy użyciu znaków, które nie są znane w czasie projektowania wywoływania <xref:System.Text.RegularExpressions.Regex.Escape%2A> jest szczególnie ważne upewnić się, że aparat wyrażeń regularnych interpretuje znaki jako literały zamiast — metoda niż jako metaznaki.  
  
> [!NOTE]
>  Jeśli wzorzec wyrażenia regularnego zawiera znakiem numeru (#) lub znaki spacji, ich należy zastosować ucieczkę Jeśli tekst wejściowy jest analizowana z <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> po włączeniu opcji.  
  
 Podczas <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody specjalne proste otwierający nawias kwadratowy ([) i otwieranie znaki nawiasu klamrowego ({), jego nie escape odpowiednie zamknięcia znaków (] i}). W większości przypadków anulowanie te nie jest konieczne. Jeśli zamykający nawias kwadratowy lub klamrowy nie jest poprzedzony jego odpowiedni znak otwierającego, aparat wyrażeń regularnych zinterpretuje ją jako literału. Jeśli braket otwierania lub nawiasu jest interpretowana jako metaznak, aparat wyrażeń regularnych interpretuje odpowiedni pierwszy znak jako metaznak zamykający. Jeśli nie jest zamierzone zachowanie, dołączając jawnie ukośniku odwrotnym wpisywany powinien zamykający nawias kwadratowy lub nawiasu (\\) znaków. Ilustracja zobacz sekcję przykład.  
  
   
  
## Examples  
 Poniższy przykład wyodrębnia komentarz w tekście. Przyjęto założenie, że komentarze są rozdzielone symbolem komentarz begin i symbol komentarza zakończenia wybrany przez użytkownika. Ponieważ symbole komentarz mają być interpretowane jako literału, są przekazywane do <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody, aby upewnić się, że ich nie może być błędnie zinterpretowana jako metaznaki. Ponadto przykładzie jawnie sprawdza, czy symbol komentarza zakończenia wprowadzony przez użytkownika jest zamykającego nawiasu (]) lub nawiasów klamrowych (}). Jeśli tak jest, ukośnika odwrotnego (\\) jest dołączany na początku nawias kwadratowy lub klamrowy tak, aby był interpretowany jako literału. Należy pamiętać, że funkcja <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> kolekcji do wyświetlenia komentarza, zamiast komentarz wraz z jego otwierający i zamykający symbole komentarza.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowanych przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę nazw grup dla wyrażenia regularnego przechwytywania.</summary>
        <returns>Tablica ciągów nazw grup.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja nazw grup zawiera zestaw ciągów używanych do nazwy grup przechwytywania w wyrażeniu. Nawet w przypadku przechwytywania grupy nie zostaną jawnie nazwane, są automatycznie przypisywane nazwy liczbowej ("0", "1", "2", "3" i tak dalej). "0" o nazwie grupy reprezentuje cały tekst są dopasowane wg wzorzec wyrażenia regularnego. Grupy numerowanych poprzedzać grupy jawnie nazwane w kolekcji, a o nazwie grupy są wyświetlane w kolejności, w którym są zdefiniowane w wzorzec wyrażenia regularnego.  
  
 Można użyć <xref:System.Array.Length%2A> właściwości w tablicy zwracanej przez tę metodę, aby określić liczbę grup w wyrażeniu regularnym.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano ogólnego przeznaczenia `ShowMatches` metodę, która wyświetla nazwy grup wyrażenia regularnego i dopasowany tekst.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 W tym przypadku wzorzec wyrażenia regularnego `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` służy do analizowania zdania prosty i do identyfikowania jej pierwszym word, wyraz ostatniej i końcowy znak interpunkcyjny. W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`(?<FirstWord>\w+)`|Dopasowuje co najmniej jeden znak słowa. Jest to `FirstWord` o nazwie grupy.|  
|\s?|Dopasowanie do zera lub jednego znaku odstępu.|  
|(\w+)|Dopasowuje co najmniej jeden znak słowa. Jest to druga grupa przechwytywania.|  
|\s|Dopasowuje znak odstępu.|  
|((\w+)\s)*|Zgodne zero lub więcej wystąpień co najmniej jeden znak word następuje biały znak. Jest to pierwsza grupa przechwytywania.|  
|(? \<LastWord > \w+)?|Wystąpienie dopasowania zero lub jeden co najmniej jeden znak programu word. Jest to `LastWord` o nazwie grupy.|  
|(? \<Znaki interpunkcyjne > \p{Po})|Dopasowuje znak, którego kategorii Unicode jest znaki interpunkcyjne, inne. Jest to `Punctuation` o nazwie grupy.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę Przechwytywanie numery grup, które odpowiadają nazwy grup w tablicy.</summary>
        <returns>Tablica liczby całkowitej liczby grup.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwane i nienazwane przechwytywania grupy jest możliwy według numeru. Nazwy grup są ponumerowane od lewej do prawej począwszy od 1. (Grupy indeksem 0 (zero) w przechwytywaniu reprezentuje dopasowania jako całość).  Grupy nazwane następnie są ponumerowane od lewej do prawej, począwszy liczby, która jest większa niż liczba nienazwane Przechwytywanie grup.  
  
 Odwołanie do grupy za pomocą numeru zamiast według nazwy ciągu zapewnia szybszy dostęp.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenie regularne `\b((?<word>\w+)\s*)+(?<end>[.?!])`, który odpowiada zdania. Wyrażenie regularne zawiera trzy przechwytywania grupy: nazwy grupy, który przechwytuje pojedynczego wyrazu wraz ze spacją, który może wykonać; Grupa o nazwie `word` który przechwytuje poszczególnych wyrazów w zdaniu; i utworzyć grupę o nazwie `end` znajdują się znaki interpunkcyjne, która kończy się zdanie. Przykład wywołania <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> metody, aby uzyskać numery Przechwytywanie wszystkich grup, a następnie wyświetla ich przechwyconych ciągu. Ponadto <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> metody używany do określenia, czy określonej grupy numerowanych odpowiada nazwaną grupę.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Wzorzec wyrażenia regularnego jest interpretowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`(?<word>\w+)`|Zgodne z co najmniej jeden znak programu word i przypisać podciągów grupę o nazwie `word`.|  
|`\s*`|Dopasowanie do zera lub większej liczby znaków odstępu.|  
|`((?<word>\w+)\s*)`|Przypisz `word` przechwyconej grupy, a następnie za pomocą dowolnej przechwycone białe znaki do pierwszej grupy przechwycony.|  
|`((?<word>\w+)\s*)+`|Jest zgodna z wzorcem co najmniej jeden znak słowa następuje znaków spacji jeden lub więcej razy.|  
|`(?<end>[.?!])`|Dopasowanie do kropki, znaku zapytania lub wykrzyknika. Przypisz dopasowane znak `end` Przechwytywanie grupy.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Numer grupy, aby przekonwertować z odpowiednią nazwą grupy.</param>
        <summary>Pobiera nazwę grupy, która odpowiada numerowi określonej grupy.</summary>
        <returns>Ciąg zawierający nazwę grupy skojarzony z numerem określonej grupy. Jeśli nie została żadna nazwa grupy, która odpowiada <paramref name="i" />, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wzorzec wyrażenia regularnego może zawierać nazwanego ani numerowanych grup przechwytywania, które odróżniać użyto w dopasowania wzorca. Grupy numerowanych są rozdzielane składnia (*Podwyrażenie*) i są przypisane numery na podstawie ich kolejności w wyrażeniu regularnym. Grupy nazwane są rozdzielane składnia (?`<` *nazwa*`>`*Podwyrażenie*) lub (? " *nazwa*"*Podwyrażenie*), gdzie *nazwa* jest nazwa identyfikująca Podwyrażenie. (Aby uzyskać więcej informacji, zobacz [konstrukcji grupowania](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Metody identyfikuje zarówno grupy o nazwie, jak i numerem grupy według ich pozycji porządkowej w wyrażeniu regularnym. {Numer porządkowy pozycji zero reprezentuje zawsze całego wyrażenia regularnego. Wszystkie numerem grupy zliczane są następnie przed nazwanych grup, niezależnie od ich rzeczywistego pozycji w wzorzec wyrażenia regularnego.  
  
 Jeśli `i` jest numerem grupy o nazwie, metoda zwraca nazwę grupy. Jeśli `i` jest numerem grupy bez nazwy, metoda zwraca reprezentację ciągu numer. Na przykład jeśli `i` 1, metoda zwraca wartość "1". Jeśli `i` nie jest numer grupy przechwytywania, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Jeśli wzorzec zostanie znaleziony, wartość zwracana przez tę metodę można następnie używane do pobierania <xref:System.Text.RegularExpressions.Group> obiekt, który reprezentuje przechwyconej grupy z <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> właściwości. <xref:System.Text.RegularExpressions.GroupCollection> Obiekt jest zwracany przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wzorzec wyrażenia regularnego, pasujący wiersz adresu zawierającego nazwę miejscowości USA, Nazwa stanu i kod pocztowy. W przykładzie użyto <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> metoda pobierania nazwy grup przechwytywania. Następnie używa tych nazw można pobrać odpowiedniego przechwyconego grup w celu dopasowania.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Wzorzec wyrażenia regularnego jest definiowana za pomocą następującego wyrażenia:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Dopasowuje co najmniej jeden znak alfabetu lub biały znak. Przypisać tę grupę przechwyconych nazwy `city`.|  
|`,`|Zgodne przecinka (,), a następnie znaku odstępu.|  
|`(?<state>[A-Za-z]{2})`|Zgodne dwa znaki alfabetu. Przypisać tę grupę przechwyconych nazwy `state`. Ta grupa powinna następuje biały znak.|  
|`(?<zip>\d{5}(-\d{4})?)`|Zgodne pięciu cyfr następuje zero lub wystąpienie łącznika następuje cztery cyfry. Przypisać tę grupę przechwyconych nazwy `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa grupy można przekonwertować na odpowiedni numer grupy.</param>
        <summary>Zwraca numer grupy, która odpowiada do nazwy określonej grupy.</summary>
        <returns>Numer grupy, który odpowiada nazwie określonej grupy lub wartość -1 Jeśli <paramref name="name" /> nie jest nazwą prawidłową grupą.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wzorzec wyrażenia regularnego może zawierać nazwanego ani numerowanych grup przechwytywania, które odróżniać użyto w dopasowania wzorca. Grupy numerowanych są rozdzielane składnia (*Podwyrażenie*) i są przypisane numery na podstawie ich kolejności w wyrażeniu regularnym. Grupy nazwane są rozdzielane składnia (?`<` *nazwa*`>`*Podwyrażenie*) lub (? " *nazwa*"*Podwyrażenie*), gdzie *nazwa* jest nazwa identyfikująca Podwyrażenie. (Aby uzyskać więcej informacji, zobacz [konstrukcji grupowania](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> Metody identyfikuje zarówno grupy o nazwie, jak i numerem grupy według ich pozycji porządkowej w wyrażeniu regularnym. {Numer porządkowy pozycji zero reprezentuje zawsze całego wyrażenia regularnego. Wszystkie numerem grupy zliczane są następnie przed nazwanych grup, niezależnie od ich rzeczywistego pozycji w wzorzec wyrażenia regularnego.  
  
 Jeśli `name` jest reprezentację ciągu numer grupy, który znajduje się w wzorzec wyrażenia regularnego, zwraca metody, których numer. Jeśli `name` odpowiada nazwane Przechwytywanie grupy, który znajduje się w wzorzec wyrażenia regularnego, metoda zwraca jego jej numer. Porównanie `name` z grupą nazwa jest rozróżniana wielkość liter. Jeśli `name` nie odpowiadają nazwę grupy przechwytywania lub reprezentację ciągu numer przechwytywania grupy, metoda zwraca wartość -1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że operację dopasowywanie do wzorca powinien nie upłynął limit czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Klasy Konstruktor i liczba statycznych pasującego użyj metody <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> stała, aby wskazać, że próba znalezienia dopasowania wzorca powinien nie upłynął limit czasu.  
  
> [!WARNING]
>  Ustawienie wartości limitu czasu przez aparat wyrażeń regularnych <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> może spowodować wyrażeń regularnych, które opierają się na nadmiernym wykorzystaniem algorytmu wycofywania się pojawiać przestaje odpowiadać podczas przetwarzania tekst niemal pasujący wzorzec wyrażenia regularnego. Wyłączenie limitu czasu, należy upewnić się, że wyrażenie regularnego nie zależeć nadmiernym wykorzystaniem algorytmu wycofywania i obsługi tekst niemal pasujący wzorzec wyrażenia regularnego.  
>   
>  Aby uzyskać więcej informacji na temat obsługi śledzenie wsteczne, zobacz [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> Stała można podać jako wartość `matchTimeout` argument następujące elementy:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowanych przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Odwołania zostały już zainicjowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Upłynął limit czasu maksymalną ilość czasu, jaki może upłynąć w dopasowywanie do wzorca operacji przed operacją.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy wyrażenie regularne znalezienia dopasowania w ciągu wejściowym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <summary>Wskazuje, czy wyrażenie regularne określone w <see cref="T:System.Text.RegularExpressions.Regex" /> Konstruktor znalezienia dopasowania w określonym ciągu wejściowego.</summary>
        <returns>
          <see langword="true" /> Jeśli wyrażenie regularne znalezienia dopasowania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> — Metoda jest zwykle używane do sprawdzania ciągu lub do zapewnienia zgodne ciąg do określonego wzorca bez pobierania tego ciągu do manipulacji kolejne. Jeśli chcesz określić, czy co najmniej jeden zgodny z wzorcem wyrażenia regularnego i pobierania ich do kolejnych manipulacji, wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> lub <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji dopasowywania przekracza limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> metodę, aby ustalić, czy numer części prawidłowy ciąg. Wyrażenie regularne przyjęto założenie, że numer części ma określonego formatu, który składa się z trzech zestawów znaki szesnastkowe rozdzielone myślnikami. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znaki alfanumeryczne następuje dwie cyfry następują znaki alfanumeryczne. Drugi zestaw składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestawu, który składa się z czterech znaków, musi mieć trzy cyfry następują znaki alfanumeryczne.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Wzorzec wyrażenia regularnego jest:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpocznij dopasowania na początku wiersza.|  
|`[a-zA-Z0-9]`|Zgodny z pojedynczym znakiem alfabetycznym (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znaku numerycznego.|  
|`\d{2}`|Zgodne dwie cyfry.|  
|`[a-zA-Z0-9]`|Zgodny z pojedynczym znakiem alfabetycznym (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znaku numerycznego.|  
|`-`|Zgodne łącznika.|  
|`\d{3}`|Odpowiada dokładnie trzy cyfry.|  
|`(-\d{3}){2}`|Znajdź łącznik następują trzy znaki numeryczne i odpowiada dwa wystąpienia tego wzorca.|  
|`[a-zA-Z0-9]`|Zgodny z pojedynczym znakiem alfabetycznym (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znaku numerycznego.|  
|`$`|W celu dopasowania na końcu linii.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="startat">Pozycja znaku w którym ma się rozpocząć wyszukiwanie.</param>
        <summary>Wskazuje, czy wyrażenie regularne określone w <see cref="T:System.Text.RegularExpressions.Regex" /> Konstruktor znalezienia dopasowania w określonym ciągu wejściowym, zaczynając od określonej pozycji początkowej w ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli wyrażenie regularne znalezienia dopasowania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> — Metoda jest zwykle używane do sprawdzania ciągu lub do zapewnienia zgodne ciąg do określonego wzorca bez pobierania tego ciągu do manipulacji kolejne. Jeśli chcesz określić, czy co najmniej jeden zgodny z wzorcem wyrażenia regularnego i pobierania ich do kolejnych manipulacji, wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> lub <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji dopasowywania przekracza limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> metodę, aby ustalić, czy numer części prawidłowy ciąg. Wyszukuje numer części, znajdujący się znakiem dwukropka (:), w ciągu. <xref:System.String.IndexOf%28System.Char%29> Metoda jest używana do określenia pozycji znakiem dwukropka, które są następnie przekazywane do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> metody. Wyrażenie regularne przyjęto założenie, że numer części ma określonego formatu, który składa się z trzech zestawów znaki szesnastkowe rozdzielone myślnikami. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znaki alfanumeryczne następuje dwie cyfry następują znaki alfanumeryczne. Drugi zestaw składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestawu, który składa się z czterech znaków, musi mieć trzy cyfry następują znaki alfanumeryczne.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Wzorzec wyrażenia regularnego jest:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Zgodny z pojedynczym znakiem alfabetycznym (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znaku numerycznego.|  
|`\d{2}`|Zgodne dwie cyfry.|  
|`[a-zA-Z0-9]`|Zgodny z pojedynczym znakiem alfabetycznym (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znaku numerycznego.|  
|`-`|Zgodne łącznika.|  
|`\d{3}`|Odpowiada dokładnie trzy cyfry.|  
|`(-\d{3}){2}`|Znajdź łącznik następują trzy znaki numeryczne i odpowiada dwa wystąpienia tego wzorca.|  
|`[a-zA-Z0-9]`|Zgodny z pojedynczym znakiem alfabetycznym (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znaku numerycznego.|  
|`$`|W celu dopasowania na końcu linii.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> jest mniejsza niż zero lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Wskazuje, czy określonego wyrażenia regularnego znalezienia dopasowania w określonym ciągu wejściowego.</summary>
        <returns>
          <see langword="true" /> Jeśli wyrażenie regularne znalezienia dopasowania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> — Metoda jest zwykle używane do sprawdzania ciągu lub do zapewnienia zgodne ciąg do określonego wzorca bez pobierania tego ciągu do manipulacji kolejne. Jeśli chcesz określić, czy co najmniej jeden zgodny z wzorcem wyrażenia regularnego i pobierania ich do kolejnych manipulacji, wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> lub <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody.  
  
 Statycznych <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metoda jest odpowiednikiem konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu z określonej przez wzorzec wyrażenia regularnego `pattern` i wywoływania <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> metody wystąpienia. Ten wzorzec wyrażenia regularnego jest buforowany do szybkiego pobrania przez aparat wyrażeń regularnych.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji dopasowywania przekracza limit czasu określony dla domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli limit czasu nie jest zdefiniowany w właściwości domeny aplikacji lub wartość limitu czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metodę, aby ustalić, czy numer części prawidłowy ciąg. Wyrażenie regularne przyjęto założenie, że numer części ma określonego formatu, który składa się z trzech zestawów znaki szesnastkowe rozdzielone myślnikami. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znaki alfanumeryczne następuje dwie cyfry następują znaki alfanumeryczne. Drugi zestaw składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestawu, który składa się z czterech znaków, musi mieć trzy cyfry następują znaki alfanumeryczne.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Wzorzec wyrażenia regularnego jest:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpocznij dopasowania na początku wiersza.|  
|`[a-zA-Z0-9]`|Zgodny z pojedynczym znakiem alfabetycznym (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znaku numerycznego.|  
|`\d{2}`|Zgodne dwie cyfry.|  
|`[a-zA-Z0-9]`|Zgodny z pojedynczym znakiem alfabetycznym (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znaku numerycznego.|  
|`-`|Zgodne łącznika.|  
|`\d{3}`|Odpowiada dokładnie trzy cyfry.|  
|`(-\d{3}){2}`|Znajdź łącznik następują trzy znaki numeryczne i odpowiada dwa wystąpienia tego wzorca.|  
|`[a-zA-Z0-9]`|Zgodny z pojedynczym znakiem alfabetycznym (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znaku numerycznego.|  
|`$`|W celu dopasowania na końcu linii.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po interwału, który jest taki sam, jak domyślny limit czasu domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Zalecaną metodą statycznych sprawdzania dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, pozwalającej Ustaw interwał limitu czasu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które zapewniają opcje do dopasowania.</param>
        <summary>Wskazuje, czy określonego wyrażenia regularnego znalezienia dopasowania w określonym ciągu wejściowym, przy użyciu podanych opcji dopasowania.</summary>
        <returns>
          <see langword="true" /> Jeśli wyrażenie regularne znalezienia dopasowania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> — Metoda jest zwykle używane do sprawdzania ciągu lub do zapewnienia zgodne ciąg do określonego wzorca bez pobierania tego ciągu do manipulacji kolejne. Jeśli chcesz określić, czy co najmniej jeden zgodny z wzorcem wyrażenia regularnego i pobierania ich do kolejnych manipulacji, wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> lub <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody.  
  
 Statycznych <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metoda jest odpowiednikiem konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu z określonej przez wzorzec wyrażenia regularnego `pattern` i opcje wyrażeń regularnych, określony przez `options` i wywoływania <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> wystąpienia Metoda. Ten wzorzec wyrażenia regularnego jest buforowany do szybkiego pobrania przez aparat wyrażeń regularnych.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji dopasowywania przekracza limit czasu określony dla domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli limit czasu nie jest zdefiniowany w właściwości domeny aplikacji lub wartość limitu czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metodę, aby ustalić, czy numer części prawidłowy ciąg. Wyrażenie regularne przyjęto założenie, że numer części ma określonego formatu, który składa się z trzech zestawów znaki szesnastkowe rozdzielone myślnikami. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znaki alfanumeryczne następuje dwie cyfry następują znaki alfanumeryczne. Drugi zestaw składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestawu, który składa się z czterech znaków, musi mieć trzy cyfry następują znaki alfanumeryczne.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Wzorzec wyrażenia regularnego jest:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpocznij dopasowania na początku ciąg.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczne z `A` za pośrednictwem `Z`, lub dowolnego znaku numerycznego.|  
|`\d{2}`|Zgodne dwie cyfry.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczne z `A` za pośrednictwem `Z`, lub dowolnego znaku numerycznego.|  
|`-`|Zgodne łącznika.|  
|`\d{3}`|Odpowiada dokładnie trzy cyfry.|  
|`(-\d{3}){2}`|Znajdź łącznik następują trzy znaki numeryczne i odpowiadają dwa wystąpienia tego wzorca...|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczne z `A` za pośrednictwem `Z`, lub dowolnego znaku numerycznego.|  
|`$`|Zakończenie dopasowuje koniec ciągu.|  
  
 Wywoływanie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metody z `options` ustawiono parametr <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> jest odpowiednikiem Definiowanie następującym wyrażeniem regularnym:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Dla porównania, zobacz przykład <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartość.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po upływie interwału równą domyślny limit czasu domeny aplikacji, w którym jest wywoływana. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Zalecaną metodą statycznych sprawdzania dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, pozwalającej Ustaw interwał limitu czasu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które zapewniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu, lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> aby wskazać, że metoda powinna nie upłynął limit czasu.</param>
        <summary>Wskazuje, czy określonego wyrażenia regularnego znalezienia dopasowania w określonego ciągu wejściowego przy użyciu określonego pasującego opcje i limit czasu interwału.</summary>
        <returns>
          <see langword="true" /> Jeśli wyrażenie regularne znalezienia dopasowania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> — Metoda jest zwykle używane do sprawdzania ciągu lub do zapewnienia zgodne ciąg do określonego wzorca bez pobierania tego ciągu do manipulacji kolejne. Jeśli chcesz określić, czy co najmniej jeden zgodny z wzorcem wyrażenia regularnego i pobierania ich do kolejnych manipulacji, wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> lub <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody.  
  
 Statycznych <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metoda jest odpowiednikiem konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu z określonej przez wzorzec wyrażenia regularnego `pattern` i opcje wyrażeń regularnych, określony przez `options` i wywoływania <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> wystąpienia Metoda. Ten wzorzec wyrażenia regularnego jest buforowany do szybkiego pobrania przez aparat wyrażeń regularnych.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `matchTimeout` Parametr określa, jak długo dopasowanie wzorca metody prób znalezienia dopasowania, zanim upłynie limit czasu. Ustawienie limitu czasu uniemożliwia wyrażeń regularnych, które opierają się na nadmiernym wykorzystaniem algorytmu wycofywania wyświetlaniu przestaje odpowiadać podczas przetwarzania danych wejściowych zawierający dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli nie znaleziono, w tym przedziale czasu, metoda wygeneruje <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie zdefiniowane dla domeny aplikacji, w której wykonuje metodę domyślną wartość limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodę, aby ustalić, czy numer części prawidłowy ciąg. Wyrażenie regularne przyjęto założenie, że numer części ma określonego formatu, który składa się z trzech zestawów znaki szesnastkowe rozdzielone myślnikami. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znaki alfanumeryczne następuje dwie cyfry następują znaki alfanumeryczne. Drugi zestaw składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestawu, który składa się z czterech znaków, musi mieć trzy cyfry następują znaki alfanumeryczne. Wzorzec wyrażenia regularnego dopasowanie powinny obejmować minimalnego wyszukiwanie za pomocą ciągu wejściowego, metoda ustawia limit czasu 500 milisekund.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Wzorzec wyrażenia regularnego jest:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpocznij dopasowania na początku ciąg.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczne z `A` za pośrednictwem `Z`, lub dowolnego znaku numerycznego.|  
|`\d{2}`|Zgodne dwie cyfry.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczne z `A` za pośrednictwem `Z`, lub dowolnego znaku numerycznego.|  
|`-`|Zgodne łącznika.|  
|`\d{3}`|Odpowiada dokładnie trzy cyfry.|  
|`(-\d{3}){2}`|Znajdź łącznik następują trzy znaki numeryczne i odpowiada dwa wystąpienia tego wzorca.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczne z `A` za pośrednictwem `Z`, lub dowolnego znaku numerycznego.|  
|`$`|Zakończenie dopasowuje koniec ciągu.|  
  
 Wywoływanie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metody z `options` ustawiono parametr <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> jest odpowiednikiem Definiowanie następującym wyrażeniem regularnym:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Dla porównania, zobacz przykład <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartość.  - lub - <paramref name="matchTimeout" /> jest ujemna, zero, lub większa niż około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu.</exception>
        <block subset="none" type="usage">
          <para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwie sekundy. Jeśli wyłączysz przekroczeń limitu czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednak należy wyłączyć limity czasu tylko w następujących warunkach: — w przypadku wprowadzania przetworzone przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub składa się z tekst statyczny. Obejmuje to tekst, który dynamicznie została wprowadzona przez użytkowników.  — Wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że wydajnie obsługuje on zgodny z systemem innym niż dopasowań, bliskiej zgodny.  -Gdy wzorzec wyrażenia regularnego nie zawiera żadnych elementów języka, mogących powodować nadmiernym wykorzystaniem algorytmu wycofywania, podczas przetwarzania near dopasowania.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje ciąg wejściowy dla podciągu, który jest zgodna z wzorcem wyrażenia regularnego i zwraca pierwsze wystąpienie jako pojedynczy <see cref="T:System.Text.RegularExpressions.Match" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <summary>Wyszukuje określony ciągu wejściowego dla pierwszego wystąpienia z wyrażeniem regularnym określonym w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora.</summary>
        <returns>Obiekt zawierający informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Metoda zwraca podciąg pierwszego zgodnego ze wzorcem wyrażenia regularnego w ciągu wejściowego. Informacje o elementach język używany do tworzenia wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wzorzec wyrażenia regularnego został odnaleziony w ciągu wejściowym weryfikując wartość zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znaleziony odpowiednik, zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg `input` który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie znaleziono, jego wartość wynosi <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca podciąg pierwszy w `input` który jest zgodny ze wzorcem wyrażenia regularnego. Możesz pobrać kolejnych dopasowań wywołując wielokrotnie zwróconego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody. Można również pobierać wszystkich dopasowań w wywołaniu metody pojedynczego przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji dopasowywania przekracza limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
   
  
## Examples  
 Poniższy przykład znajduje wzorzec wyrażenia regularnego jest zgodna w ciągu, a następnie określa dopasowanej grupy, przechwytywania i pozycje przechwytywania.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Wzorzec wyrażenia regularnego `(\w+)\s+(car)` odpowiada wystąpienia wyrazu "samochód" wraz z słowo poprzedzającym go tekstem. Jest interpretowany zgodnie z poniższą tabelą.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(\w+)`|Dopasowuje co najmniej jeden znak słowa. Jest to pierwsza grupa przechwytywania.|  
|`\s+`|Zgodne białe znaki.|  
|(samochód)|Zgodny z ciągiem literału "samochód". Jest to druga grupa przechwytywania.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="startat">Pozycję znaku liczony od zera, w której ma się rozpocząć wyszukiwanie.</param>
        <summary>Wyszukuje ciąg wejściowy dla pierwszego wystąpienia wyrażenia regularnego, zaczynając od określonej pozycji początkowej w ciągu.</summary>
        <returns>Obiekt zawierający informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Metoda zwraca podciąg pierwszego zgodnego ze wzorcem wyrażenia regularnego, uruchamianie na lub po `startat` znak pozycji w ciągu wejściowego. Informacje o elementach język używany do tworzenia wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> metoda wyszukuje jest zdefiniowany przez wywołanie do jednego z <xref:System.Text.RegularExpressions.Regex> klasy konstruktorów. Aby uzyskać więcej informacji o elementach tworzących wzorzec wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Opcjonalnie można określić pozycję początkową w ciągu przy użyciu `startat` parametru. Gdy aparat wyrażeń regularnych analizuje od lewej do prawej (wartość domyślna), dopasowania i skanowania są przenoszone rightward, rozpoczynający się od znaku określone w `startat`. Gdy aparat wyrażeń regularnych analizuje od prawej do lewej (gdy jest tworzony wzorzec wyrażenia regularnego z <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opcja), dopasowania i skanowanie w przeciwnym kierunku i rozpoczynać się od znaku w `startat` -1. Jeśli nie określisz pozycja początkowa wyszukiwania zaczyna się od domyślnie `startat` pozycji. Jeśli wyrażenie regularne wyszukiwania od lewej do prawej, domyślnie `startat` położenie jest na końcu po lewej stronie `input`; Jeśli wyszukiwania od prawej do lewej, domyślnie `startat` położenie jest na prawym końcu `input`.  
  
 Jeśli chcesz ograniczyć dopasowanie, tak aby zaczyna się na pozycji określonego znaku w ciągu i aparat wyrażeń regularnych nie skanuje pod kątem dopasowania w pozostałej części ciągu zakotwiczyć wyrażenia regularnego z `\G` (po lewej stronie dla od lewej do prawej wzorzec, lub po prawej stronie dla wzorca od prawej do lewej). Ogranicza dopasowania, więc musi zaczynać się dokładnie w `startat`.  
  
 Można określić, czy wzorzec wyrażenia regularnego został odnaleziony w ciągu wejściowym weryfikując wartość zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znaleziony odpowiednik, zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg `input` który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie znaleziono, jego wartość wynosi <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca pierwszy podciąg znaleziony na lub po `startat` znak pozycja w `input` który jest zgodny ze wzorcem wyrażenia regularnego. Możesz pobrać kolejnych dopasowań wywołując wielokrotnie zwróconego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody. Można również pobierać wszystkich dopasowań w wywołaniu metody pojedynczego przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji dopasowywania przekracza limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek jeśli przekracza operacji dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> jest mniejsza niż zero lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Wyszukuje określony ciągu wejściowego dla pierwszego wystąpienia określonego wyrażenia regularnego.</summary>
        <returns>Obiekt zawierający informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Metoda zwraca podciąg pierwszego zgodnego ze wzorcem wyrażenia regularnego w ciągu wejściowego. Informacje o elementach język używany do tworzenia wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Statycznych <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> metoda jest odpowiednikiem konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywoływanie wystąpienie <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> — metoda. W takim przypadku aparat wyrażeń regularnych buforuje wzorzec wyrażenia regularnego.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wzorzec wyrażenia regularnego został odnaleziony w ciągu wejściowym weryfikując wartość zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znaleziony odpowiednik, zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg `input` który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie znaleziono, jego wartość wynosi <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca podciąg pierwszy w `input` który jest zgodny ze wzorcem wyrażenia regularnego. Możesz pobrać kolejnych dopasowań wywołując wielokrotnie zwróconego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody. Można również pobierać wszystkich dopasowań w wywołaniu metody pojedynczego przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji dopasowywania przekracza limit czasu określony dla domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli limit czasu nie jest zdefiniowany w właściwości domeny aplikacji lub wartość limitu czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> metody do znalezienia pierwsze słowo, która zawiera co najmniej jeden `z` znaków, a następnie wywołania <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody do znalezienia dodatkowych dopasowań.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Wzorzec wyrażenia regularnego `\b\w*z+\w*\b` jest interpretowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w*`|Zgodne zero, jeden lub więcej znaków programu word.|  
|`z+`|Odpowiada jednej lub więcej wystąpień `z` znaków.|  
|`\w*`|Zgodne zero, jeden lub więcej znaków programu word.|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po upływie interwału równą domyślny limit czasu domeny aplikacji, w którym jest wywoływana. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Jest zalecana statyczną metodę pobierania dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, umożliwiające ustawienie interwału limitu czasu.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="beginning">Pozycja znaku liczony od zera w ciągu wejściowym, który definiuje lewej położenie do wyszukania.</param>
        <param name="length">Liczba znaków w podciąg do wyszukiwania.</param>
        <summary>Wyszukuje ciąg wejściowy dla pierwszego wystąpienia wyrażenia regularnego, zaczynając od określonej pozycji początkowej i wyszukiwanie tylko określoną liczbę znaków.</summary>
        <returns>Obiekt zawierający informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda zwraca podciąg pierwszego zgodnego ze wzorcem wyrażenia regularnego w części ciągu wejściowego. Informacje o elementach język używany do tworzenia wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> metoda wyszukuje jest zdefiniowany przez wywołanie do jednego z <xref:System.Text.RegularExpressions.Regex> klasy konstruktorów. Aby uzyskać więcej informacji o elementach tworzących wzorzec wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda szuka część `input` zdefiniowane przez `beginning` i `length` parametrów wzorzec wyrażenia regularnego. `beginning` zawsze definiuje indeksu po lewej stronie znaków do wyszukiwania, a `length` określa maksymalną liczbę znaków do wyszukiwania. Definiują one zakres danych wyszukiwania. Jeśli wyszukiwanie rozpoczynające się od lewej do prawej (wartość domyślna), aparat wyrażeń regularnych wyszukiwania z znak na pozycji indeksu `beginning` na znak na pozycji indeksu `beginning`  +  `length` -1. Jeśli aparat wyrażeń regularnych wystąpienia przy użyciu <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opcję Tak, aby wyszukiwanie rozpoczynające się od prawej do lewej, wyszukiwań aparat wyrażeń regularnych z znak na pozycji indeksu `beginning`  +  `length` -1 do znak w indeksie `beginning`. Ta metoda zwraca pierwsze dopasowanie znalezione w tym zakresie. Możesz pobrać kolejnych dopasowań wywołując wielokrotnie zwróconego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody.  
  
 Można określić, czy wzorzec wyrażenia regularnego został odnaleziony w ciągu wejściowym weryfikując wartość zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znaleziony odpowiednik, zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg `input` który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie znaleziono, jego wartość wynosi <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji dopasowywania przekracza limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz wartość limitu czasu podczas wywoływania konstruktora, wyjątku Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="beginning" /> jest mniejsza niż zero lub większa niż długość <paramref name="input" />.  - lub - <paramref name="length" /> jest mniejsza niż zero lub większa niż długość <paramref name="input" />.  - lub - <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" /> identyfikuje pozycji, która jest poza zakresem <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które zapewniają opcje do dopasowania.</param>
        <summary>Wyszukuje ciąg wejściowy dla pierwszego wystąpienia określonego wyrażenia regularnego przy użyciu podanych opcji dopasowania.</summary>
        <returns>Obiekt zawierający informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Metoda zwraca podciąg pierwszego zgodnego ze wzorcem wyrażenia regularnego w ciągu wejściowego. Informacje o elementach język używany do tworzenia wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Statycznych <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metoda jest odpowiednikiem konstruowania <xref:System.Text.RegularExpressions.Regex> obiekt z <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Konstruktor i wywoływania wystąpienie <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> — metoda.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wzorzec wyrażenia regularnego został odnaleziony w ciągu wejściowym weryfikując wartość zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znaleziony odpowiednik, zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg `input` który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie znaleziono, jego wartość wynosi <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca pierwszy podciąg znaleziony w `input` który jest zgodny ze wzorcem wyrażenia regularnego. Możesz pobrać kolejnych dopasowań wywołując wielokrotnie zwróconego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A> metody. Można również pobierać wszystkich dopasowań w wywołaniu metody pojedynczego przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji dopasowywania przekracza limit czasu określony dla domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli limit czasu nie jest zdefiniowany w właściwości domeny aplikacji lub wartość limitu czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenia regularnego odpowiadający słowa zaczyna się od litery "". Używa <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opcji, aby upewnić się, że wyrażenie regularne lokalizuje słów z obu wielką małe "a" i "".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Wzorzec wyrażenia regularnego `\ba\w*\b` jest interpretowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`a`|Dopasowanie znaku "".|  
|`\w*`|Zgodne zero, jeden lub więcej znaków programu word.|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po upływie interwału równą domyślny limit czasu domeny aplikacji, w którym jest wywoływana. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Jest zalecana statyczną metodę pobierania dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, umożliwiające ustawienie interwału limitu czasu.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które zapewniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu, lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> aby wskazać, że metoda powinna nie upłynął limit czasu.</param>
        <summary>Wyszukuje ciąg wejściowy dla pierwszego wystąpienia określonego wyrażenia regularnego przy użyciu określonego pasującego opcje i limit czasu interwału.</summary>
        <returns>Obiekt zawierający informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Metoda zwraca podciąg pierwszego zgodnego ze wzorcem wyrażenia regularnego w ciągu wejściowego. Informacje o elementach język używany do tworzenia wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Statycznych <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metoda jest odpowiednikiem konstruowania <xref:System.Text.RegularExpressions.Regex> obiekt z <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor i wywoływania wystąpienie <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> — metoda.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wzorzec wyrażenia regularnego został odnaleziony w ciągu wejściowym weryfikując wartość zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znaleziony odpowiednik, zwracana <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg `input` który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie znaleziono, jego wartość wynosi <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca pierwszy podciąg znaleziony w `input` który jest zgodny ze wzorcem wyrażenia regularnego. Możesz pobrać kolejnych dopasowań wywołując wielokrotnie zwróconego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A> metody. Można również pobierać wszystkich dopasowań w wywołaniu metody pojedynczego przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metody.  
  
 `matchTimeout` Parametr określa, jak długo dopasowanie wzorca metody prób znalezienia dopasowania, zanim upłynie limit czasu. Ustawienie limitu czasu uniemożliwia wyrażeń regularnych, które opierają się na nadmiernym wykorzystaniem algorytmu wycofywania wyświetlaniu przestaje odpowiadać podczas przetwarzania danych wejściowych zawierający dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli nie znaleziono, w tym przedziale czasu, metoda wygeneruje <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie zdefiniowane dla domeny aplikacji, w której wykonuje metodę domyślną wartość limitu czasu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  - lub - <paramref name="matchTimeout" /> jest ujemna, zero, lub większa niż około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwie sekundy. Jeśli wyłączysz przekroczeń limitu czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednak należy wyłączyć limity czasu tylko w następujących warunkach: — w przypadku wprowadzania przetworzone przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub składa się z tekst statyczny. Obejmuje to tekst, który dynamicznie została wprowadzona przez użytkowników.  — Wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że wydajnie obsługuje on zgodny z systemem innym niż dopasowań, bliskiej zgodny.  -Gdy wzorzec wyrażenia regularnego nie zawiera żadnych elementów języka, mogących powodować nadmiernym wykorzystaniem algorytmu wycofywania, podczas przetwarzania near dopasowania.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje ciąg wejściowy dla wszystkich wystąpień elementu wyrażenia regularnego i zwraca wszystkie dopasowania.</summary>
        <block subset="none" type="usage">
          <para>Podczas próby dopasowania jest powtarzany, wywołując <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> metoda, aparat wyrażeń regularnych daje pusty dopasowań szczególnego traktowania. Zazwyczaj aparat wyrażeń regularnych rozpocznie się wyszukiwanie następnego dopasowania dokładnie, gdzie poprzedniego dopasowania przerwał pracę. Jednak po pusty dopasowania przez aparat wyrażeń regularnych przesuwa o jeden znak przed podjęciem próby następnego dopasowania. Takie zachowanie gwarantuje, że aparat wyrażeń regularnych będzie trakcie poruszania się przez ciąg. W przeciwnym razie ponieważ dopasowanie pusta nie powoduje żadnych ruch do przodu, następnego dopasowania zaczyna się w tym samym miejscu, jako poprzedniego dopasowania, a to dopasuje wielokrotnie ten sam ciąg pusty.  W poniższym przykładzie wzorzec wyrażenia regularnego <c>*</c> wyszukuje zero lub więcej wystąpień litery "" w ciągu "abaabb". Jako dane wyjściowe w przykładzie pokazano, powstałe w ten sposób <see cref="T:System.Text.RegularExpressions.MatchCollection" /> obiekt zawiera sześć <see cref="T:System.Text.RegularExpressions.Match" /> obiektów. Pierwsza próba dopasowania znajduje pierwszy "". Drugi uruchamia dopasowania, gdzie pierwszy pasować kończy się przed pierwszym b; znajduje zero wystąpienia "a", a zwraca pusty ciąg. Trzeci dopasowania nie zaczyna się dokładnie gdzie drugi dopasowania została zakończona, ponieważ drugi dopasowania zwrócony pusty ciąg. Zamiast tego rozpoczyna jeden znak później, po pierwszym "b". Trzeci dopasowania znajduje dwa wystąpienia "a" i zwraca "aa". Czwarty próbę dopasowania rozpoczyna się, gdy trzeci dopasowania zostało zakończone przed drugi "b" i zwraca pusty ciąg. Piąty próbę dopasowania ponownie przechodzi jeden znak, który rozpoczyna się przed trzeci "b" i zwraca pusty ciąg. Dopasowanie szóstego rozpoczyna się po ostatnim "b" i ponownie zwraca pusty ciąg.  [! code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <summary>Wyszukuje określony ciągu wejściowego dla wszystkich wystąpień elementu wyrażenia regularnego.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> znalezione przez wyszukiwanie obiektów. Jeśli nie znaleziono żadnych wyników, metoda zwraca obiekt pustej kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Metoda jest podobna do <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> znaleźć metody, z wyjątkiem, że zwraca informacje o wszystkich dopasowań w ciągu wejściowym, zamiast pojedynczego dopasowania. Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 Kolekcja zawiera tylko zgodności i kończy się na pierwsze z systemem innym niż — dopasowanie.  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> metoda wyszukuje jest zdefiniowany przez wywołanie do jednego z <xref:System.Text.RegularExpressions.Regex> klasy konstruktorów. Aby uzyskać więcej informacji o elementach tworzących wzorzec wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda używa obliczanie leniwe do wypełnienia zwróconego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Uzyskiwanie dostępu do członków tej kolekcji, takie jak <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> powoduje, że kolekcji do wypełnienia natychmiast. Aby móc korzystać z opóźnieniem oceny, powinien iteracji kolekcji przy użyciu konstrukcję, takich jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic.  
  
 Ze względu na jego obliczanie leniwe wywoływania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> — metoda nie zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. Jednak wyjątku, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> zwracane przez tę metodę, jeśli obiekt <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> właściwość nie jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> , operacja przekracza limit czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> metodę identyfikowania wyrazów w zdaniu, które kończą się "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Wzorzec wyrażenia regularnego `\b\w+es\b` jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Zgodny z ciągiem literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowym, w którym ma się rozpocząć wyszukiwanie.</param>
        <summary>Wyszukuje określony ciągu wejściowego dla wszystkich wystąpień elementu wyrażenia regularnego, zaczynając od określonej pozycji początkowej w ciągu.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> znalezione przez wyszukiwanie obiektów. Jeśli nie znaleziono żadnych wyników, metoda zwraca obiekt pustej kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Metoda jest podobna do <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> znaleźć metody, z wyjątkiem, że zwraca informacje o wszystkich dopasowań w ciągu wejściowym, zamiast pojedynczego dopasowania. Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> metoda wyszukuje jest zdefiniowany przez wywołanie do jednego z <xref:System.Text.RegularExpressions.Regex> klasy konstruktorów. Aby uzyskać więcej informacji o elementach tworzących wzorzec wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda używa obliczanie leniwe do wypełnienia zwróconego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Uzyskiwanie dostępu do członków tej kolekcji, takie jak <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> powoduje, że kolekcji do wypełnienia natychmiast. Aby móc korzystać z opóźnieniem oceny, powinien iteracji kolekcji przy użyciu konstrukcję, takich jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic.  
  
 Ze względu na jego obliczanie leniwe wywoływania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> — metoda nie zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. Jednak wyjątku, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> zwracane przez tę metodę, jeśli obiekt <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> właściwość nie jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> , operacja przekracza limit czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metody do znalezienia pierwsze słowo w zdaniu kończy się na "es", a następnie wywołuje <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> metodę, aby zidentyfikować dodatkowe słowa, które kończą się "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Wzorzec wyrażenia regularnego `\b\w+es\b` jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Zgodny z ciągiem literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> jest mniejsza niż zero lub większa niż długość <paramref name="input" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Wyszukuje określony ciągu wejściowego dla wszystkich wystąpień określonego wyrażenia regularnego.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> znalezione przez wyszukiwanie obiektów. Jeśli nie znaleziono żadnych wyników, metoda zwraca obiekt pustej kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Metoda jest podobna do <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> znaleźć metody, z wyjątkiem, że zwraca informacje o wszystkich dopasowań w ciągu wejściowym, zamiast pojedynczego dopasowania. Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Statycznych `Matches` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Matches`.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda używa obliczanie leniwe do wypełnienia zwróconego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Uzyskiwanie dostępu do członków tej kolekcji, takie jak <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> powoduje, że kolekcji do wypełnienia natychmiast. Aby móc korzystać z opóźnieniem oceny, powinien iteracji kolekcji przy użyciu konstrukcję, takich jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic.  
  
 Ze względu na jego obliczanie leniwe wywoływania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> — metoda nie zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. Jednak wyjątku, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> obiektu zwróconego przez tę metodę, jeżeli interwał limitu czasu jest określona przez właściwość "REGEX_DEFAULT_MATCH_TIMEOUT" bieżącej domeny aplikacji i operacja przekracza ten limit czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metodę, aby zidentyfikować wszelkie wyraz zakończoną "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Wzorzec wyrażenia regularnego `\b\w+es\b` jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Zgodny z ciągiem literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po upływie interwału równą domyślny limit czasu domeny aplikacji, w którym jest wywoływana. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Zalecane metody statycznej pobierania wielu wzorzec zgodny jest <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala określić interwał limitu czasu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które określają opcje do dopasowania.</param>
        <summary>Wyszukuje określony ciąg wejściowy dla wszystkich wystąpień określonego wyrażenia regularnego, przy użyciu podanych opcji dopasowania.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> znalezione przez wyszukiwanie obiektów. Jeśli nie znaleziono żadnych wyników, metoda zwraca obiekt pustej kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Metoda jest podobna do <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> znaleźć metody, z wyjątkiem, że zwraca informacje o wszystkich dopasowań w ciągu wejściowym, zamiast pojedynczego dopasowania. Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Statycznych `Matches` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Matches`.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda używa obliczanie leniwe do wypełnienia zwróconego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Uzyskiwanie dostępu do członków tej kolekcji, takie jak <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> powoduje, że kolekcji do wypełnienia natychmiast. Aby móc korzystać z opóźnieniem oceny, powinien iteracji kolekcji przy użyciu konstrukcję, takich jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic.  
  
 Ze względu na jego obliczanie leniwe wywoływania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> — metoda nie zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. Jednak wyjątku, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> obiektu zwróconego przez tę metodę, jeżeli interwał limitu czasu jest określona przez właściwość "REGEX_DEFAULT_MATCH_TIMEOUT" bieżącej domeny aplikacji i operacja przekracza ten limit czasu.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> identyfikacji dowolnego słowa w zdaniu kończy się na "es", a następnie wywołuje metodę <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodę w celu porównania bez uwzględniania wielkości liter wzorca z ciągu wejściowego. Jak pokazano na dane wyjściowe, te dwie metody zwraca różne wyniki.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Wzorzec wyrażenia regularnego `\b\w+es\b` jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Zgodny z ciągiem literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po upływie interwału równą domyślny limit czasu domeny aplikacji, w którym jest wywoływana. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Zalecane metody statycznej pobierania wielu wzorzec zgodny jest <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, umożliwiające ustawienie interwału limitu czasu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które określają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu, lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> aby wskazać, że metoda powinna nie upłynął limit czasu.</param>
        <summary>Wyszukuje określony ciągu wejściowego dla wszystkich wystąpień określonego wyrażenia regularnego, przy użyciu określonego pasującego opcje i limit czasu interwału.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> znalezione przez wyszukiwanie obiektów. Jeśli nie znaleziono żadnych wyników, metoda zwraca obiekt pustej kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Metoda jest podobna do <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> znaleźć metody, z wyjątkiem, że zwraca informacje o wszystkich dopasowań w ciągu wejściowym, zamiast pojedynczego dopasowania. Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Statycznych `Matches` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Matches`.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda używa obliczanie leniwe do wypełnienia zwróconego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Uzyskiwanie dostępu do członków tej kolekcji, takie jak <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> powoduje, że kolekcji do wypełnienia natychmiast. Aby móc korzystać z opóźnieniem oceny, powinien iteracji kolekcji przy użyciu konstrukcję, takich jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic.  
  
 Ze względu na jego obliczanie leniwe wywoływania <xref:System.Text.RegularExpressions.Regex.Matches%2A> — metoda nie zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. Jednak jest zwracany wyjątek, jeśli operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> zwracane przez tę metodę, jeśli operacja przekroczy ten limit czasu określony przez obiekt`matchTimeout` parametru.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodę w celu porównania z uwzględnieniem wielkości liter, odpowiadający żadnych słowo w instrukcji, które kończy się "es". Następnie wywołuje <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodę w celu porównania bez uwzględniania wielkości liter wzorca z ciągu wejściowego. W obu przypadkach limit czasu wynosi 1 sekundę. Jak pokazano na dane wyjściowe, te dwie metody zwraca różne wyniki.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Wzorzec wyrażenia regularnego `\b\w+es\b` jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Zgodny z ciągiem literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  - lub - <paramref name="matchTimeout" /> jest ujemna, zero, lub większa niż około 24 dni.</exception>
        <block subset="none" type="usage">
          <para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwie sekundy. Jeśli wyłączysz przekroczeń limitu czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednak należy wyłączyć limity czasu tylko w następujących warunkach: — w przypadku wprowadzania przetworzone przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub składa się z tekst statyczny. Obejmuje to tekst, który dynamicznie została wprowadzona przez użytkowników.  — Wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że wydajnie obsługuje on zgodny z systemem innym niż dopasowań, bliskiej zgodny.  -Gdy wzorzec wyrażenia regularnego nie zawiera żadnych elementów języka, mogących powodować nadmiernym wykorzystaniem algorytmu wycofywania, podczas przetwarzania near dopasowania.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera limit czasu bieżącego wystąpienia.</summary>
        <value>Maksymalny czas, jaki może upłynąć w dopasowywanie do wzorca operacji przed <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> jest zgłaszany, lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> wyłączenie limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Właściwość definiuje przybliżony czas maksymalny interwał <xref:System.Text.RegularExpressions.Regex> wystąpienia wykonanie jednej operacji dopasowywania, zanim upłynie limit czasu operacji. Zgłasza wyjątek, aparat wyrażeń regularnych <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek podczas jego następnego sprawdzania czasu po upływie limitu czasu. Zapobiega to przetwarzania ciągów wejściowych, które wymagają nadmiernym wykorzystaniem algorytmu wycofywania aparat wyrażeń regularnych. Aby uzyskać więcej informacji, zobacz [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md) i [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md).  
  
 Ta właściwość jest tylko do odczytu. Wartość można ustawić jawnie dla poszczególnych <xref:System.Text.RegularExpressions.Regex> obiektu przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor; oraz ustawienie jego wartość dla wszystkich <xref:System.Text.RegularExpressions.Regex> dopasowania operacje w domenie aplikacji przez wywołanie metody <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> — metoda i <xref:System.TimeSpan> wartości dla właściwości "REGEX_DEFAULT_MATCH_TIMEOUT", jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Jeśli nie zostanie jawnie ustawiona interwał limitu czasu, wartością domyślną <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> jest używany i zgodnych operacji czy nie upłynął limit czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opcje, które zostały przekazane do <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora.</summary>
        <value>Jeden lub więcej członków <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wyliczenia, które reprezentują opcje, które zostały przekazane do <see cref="T:System.Text.RegularExpressions.Regex" /> — Konstruktor</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Text.RegularExpressions.Regex.Options%2A> właściwości składa się z co najmniej jednego członka z <xref:System.Text.RegularExpressions.RegexOptions> wyliczenia. Jeśli nie zdefiniowano żadnych opcji, w <xref:System.Text.RegularExpressions.Regex> konstruktora klasy, jego wartość wynosi <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Dostępne opcje omówiono szczegółowo w [opcje wyrażeń regularnych](~/docs/standard/base-types/regular-expression-options.md) tematu.  
  
 Należy pamiętać, że <xref:System.Text.RegularExpressions.Regex.Options%2A> właściwości nie odzwierciedla opcji wbudowanego zdefiniowanych w wyrażeniu regularnym wzorca sam.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> jest klasą bazową wyrażeń regularnych utworzone przez <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody. Implementacja klasy podstawowej używać tych skompilowane wyrażenia regularnego <see cref="P:System.Text.RegularExpressions.Regex.Options" /> właściwości. Jeśli wywoływany z klasy pochodnej, <see cref="P:System.Text.RegularExpressions.Regex.Options" /> właściwość zwraca opcje, które zostały przekazane do <paramref name="options" /> parametr <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> konstruktora klasy, które zostało użyte do definiowania wyrażenia regularnego.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowanych przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W określonym ciągu wejściowego zastępuje ciągi zgodne ze wzorcem wyrażenia regularnego z określony ciąg zastępczy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <summary>W określonym ciągu wejściowego zastępuje wszystkie ciągi zgodne ze wzorcem wyrażenia regularnego z określony ciąg zastępczy.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli w bieżącym wystąpieniu nie jest zgodny ze wzorcem wyrażenia regularnego, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj dopasowań, który rozpoczyna się na początku `input` ciągu. Wyrażenie regularne jest wzorcowi określonemu przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `replacement` Parametr określa ciąg, który ma zastąpić każdego dopasowania `input`. `replacement` może zawierać dowolną kombinację literały tekstowe i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zastępczy `a*${test}b` wstawia ciąg "*" następuje podciągu, który działa w kontekście `test` Przechwytywanie grupy, jeśli istnieje, następuje ciąg "b". * Znak nie został rozpoznany jako metaznak w wzorzec zastąpienia.  
  
> [!NOTE]
>  Podstawienia są elementy języka tylko wyrażenie, które są rozpoznawane w układzie zastąpienia. Wszystkie inne wyrażenia regularnego elementy języka, w tym [znak specjalne](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone we wzorcach wyrażenia regularnego tylko i nie są rozpoznawane w wzorce zamiany.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji zamiany przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie wyjątku  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenie regularne `\s+`, białe znaki, które odpowiadają. Ciąg zastępczy "", zastępuje pojedynczy spacją.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 W poniższym przykładzie zdefiniowano wyrażenia regularnego, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`i wzorcem zastąpienia `$2`, który usuwa wiodące lub końcowe symbol waluty z wartością liczbową.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 Wyrażenie regularne jest interpretowane tak jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\p{Sc}`|Zgodne symbol waluty. `{Sc}` Określa dowolny znak, który jest elementem członkowskim znaku Unicode, kategoria waluty.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`(\p{Sc}\s?)?`|Wystąpienie dopasowania zero lub jeden kombinację następuje biały znak zero lub jeden symbol waluty. Jest to pierwsza grupa przechwytywania.|  
|`\d+`|Dopasowanie do co najmniej jednej cyfry dziesiętnej.|  
|`\.?`|Wystąpienie dopasowania zero lub jeden okres (używany jako znak separatora dziesiętnego).|  
|`((?<=\.)\d+)?`|Jeśli okres jest poprzedni znak, odpowiadać co najmniej jeden cyfr dziesiętnych. Ten wzorzec można dopasować zero lub czasu.|  
|`(\d+\.?((?<=\.)\d+)?)`|Jest zgodna z wzorcem jeden lub więcej cyfr dziesiętnych, następuje okres opcjonalne i dodatkowe cyfr dziesiętnych. Jest to druga grupa przechwytywania. Wywołanie <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> metoda zastępuje całego dopasowania wartości tej przechwyconej grupy.|  
|`(?(1)&#124;\s?\p{Sc})?`|Jeśli istnieje pierwszej grupy przechwycone, odpowiada ciągiem pustym. W przeciwnym razie wartość odpowiada zero lub jeden biały znak następuje symbol waluty.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdym dopasowaniu i zwraca oryginalnego ciągu dopasowane lub ciąg zastępczy.</param>
        <summary>W określonym ciągu wejściowego zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegowanie.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli w bieżącym wystąpieniu nie jest zgodny ze wzorcem wyrażenia regularnego, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowanie wyrażenia regularnego, jeśli jest spełniony jeden z następujących warunków:  
  
-   Ciąg zastępczy łatwo nie może zostać określona zastępczy wzorcem wyrażenia regularnego.  
  
-   Ciąg zastępczy wynikiem przetwarza przeprowadzić dopasowany ciąg.  
  
-   Wyniki ciąg zastępczy przetwarzania warunkowego.  
  
 Metoda jest odpowiednikiem wywołania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> — metoda i przekazywanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconym <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegowanie.  
  
 Wyrażenie regularne jest wzorcowi określonemu przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `evaluator` Parametr jest delegowanie dla niestandardowej metody, która należy zdefiniować i która sprawdza, czy każdy dopasowania. Metoda niestandardowy musi mieć następującą sygnaturą odpowiadające <xref:System.Text.RegularExpressions.MatchEvaluator> delegowanie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metodę zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji zamiany przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie wyjątku  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia oryginalnego ciągu, odpowiada każdego wyrazu w oryginalnym ciągu, konwertuje pierwszego znaku w każdym dopasowaniu na wielkie litery, następnie wyświetla skonwertowany ciąg.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="count">Maksymalna liczba wystąpień zastąpienia można.</param>
        <summary>W określonym ciągu wejściowego zastępuje określoną maksymalną liczbę ciągów, które są zgodne ze wzorcem wyrażenia regularnego z określony ciąg zastępczy.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli w bieżącym wystąpieniu nie jest zgodny ze wzorcem wyrażenia regularnego, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj dopasowań, który rozpoczyna się na początku `input` ciągu. Wyrażenie regularne jest wzorzec, który jest definiowana za pomocą konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu. Jeśli `count` jest ujemna, elementy zastępcze w dalszym ciągu końca ciągu. Jeśli `count` przekracza liczbę, zastępuje wszystkie dopasowania.  
  
 `replacement` Parametr określa ciąg, który ma zastąpić pierwszy `count` odpowiada `input`. `replacement` może zawierać dowolną kombinację literały tekstowe i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zastępczy `a*${test}b` wstawia ciąg "*" następuje podciągu, który działa w kontekście `test` Przechwytywanie grupy, jeśli istnieje, następuje ciąg "b". * Znak nie został rozpoznany jako metaznak w wzorzec zastąpienia.  
  
> [!NOTE]
>  Podstawienia są elementy języka tylko wyrażenie, które są rozpoznawane w układzie zastąpienia. Wszystkie inne wyrażenia regularnego elementy języka, w tym [znak specjalne](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone we wzorcach wyrażenia regularnego tylko i nie są rozpoznawane w wzorce zamiany.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji zamiany przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie wyjątku  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład Zamienia pierwsze pięć wystąpień zduplikowanych znaków jednego znaku. Wzorzec wyrażenia regularnego `(\w)\1` uwzględnia kolejnych wystąpień jednego znaku i przypisuje pierwsze wystąpienie do pierwszej grupy przechwytywania. Wzorzec zastępczy `$1` zamienia cały dopasowanie pierwszego przechwyconej grupy.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <summary>W określonym ciągu wejściowego zastępuje wszystkie ciągi, które pasują do podanego wyrażenia regularnego z określony ciąg zastępczy.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli <paramref name="pattern" /> nie jest takie samo w bieżącym wystąpieniu, metoda zwraca wartość bieżącego wystąpienia bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statycznych `Replace` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Replace`.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Wyszukaj dopasowań, który rozpoczyna się na początku `input` ciągu.  
  
 `replacement` Parametr określa ciąg, który ma zastąpić każdego dopasowania `input`. `replacement` może zawierać dowolną kombinację literały tekstowe i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zastępczy `a*${test}b` wstawia ciąg "*" następuje podciągu, który działa w kontekście `test` Przechwytywanie grupy, jeśli istnieje, następuje ciąg "b". * Znak nie został rozpoznany jako metaznak w wzorzec zastąpienia.  
  
> [!NOTE]
>  Podstawienia są elementy języka tylko wyrażenie, które są rozpoznawane w układzie zastąpienia. Wszystkie inne wyrażenia regularnego elementy języka, w tym [znak specjalne](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone we wzorcach wyrażenia regularnego tylko i nie są rozpoznawane w wzorce zamiany.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji zamiany przekroczy limit czasu określony dla domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli limit czasu nie jest zdefiniowany w właściwości domeny aplikacji lub wartość limitu czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenie regularne `\s+`, białe znaki, które odpowiadają. Ciąg zastępczy "", zastępuje pojedynczy spacją.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> metodę, aby zastąpić lokalnej nazwy komputera i dysku w ścieżce UNC ścieżkę do pliku lokalnego. Używa wyrażenia regularnego <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby uwzględnić nazwę komputera lokalnego i <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> metodę w celu uwzględnienia nazwy dysków logicznych. Aby pomyślnie uruchomić przykład, należy zastąpić ciąg literału "MojKomputer" nazwą komputera lokalnego.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Wzorzec wyrażenia regularnego jest definiowana za pomocą następującego wyrażenia:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\\\\`|Dopasowanie dwa kolejne ukośnik odwrotny (`\`) znaków. Ponieważ ukośnika odwrotnego jest interpretowana jako znak ucieczki, każdy ukośnik odwrotny musi wyjściowym z innego ukośnika odwrotnego.|  
|`(?i:" + Environment.MachineName + ")`|Wykonaj bez uwzględniania wielkości liter dopasowanie ciągu, który jest zwracany przez <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości.|  
|`(?:\.\w+)*`|Zgodne okres (`.`) znaków następuje co najmniej jeden znak programu word. To dopasowanie, może wystąpić zero lub więcej razy. Nie przechwytuje Podwyrażenie dopasowany.|  
|`\\`|Zgodne ukośnik odwrotny (`\`) znaków.|  
|`((?i:[" + driveNames + "]))`|Wykonaj bez uwzględniania wielkości liter dopasowanie klasy znaku, która składa się z litery dysku indywidualnych. Tego dopasowania to pierwsze przechwycone Podwyrażenie.|  
|`\$`|Zgodne literału dolara (`$`) znaków.|  
  
 Wzorzec zastępczy `$1` zamienia cały dopasowania pierwsze przechwycone Podwyrażenie. Oznacza to zastępuje nazwę komputera i dysku UNC z literą dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" />, lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po upływie interwału równą domyślny limit czasu domeny aplikacji, w którym jest wywoływana. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Zalecaną metodą statyczny do zastępowania dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, umożliwiające ustawienie interwału limitu czasu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdym dopasowaniu i zwraca oryginalnego ciągu dopasowane lub ciąg zastępczy.</param>
        <summary>W określonym ciągu wejściowego zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegowanie.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli <paramref name="pattern" /> nie jest takie samo w bieżącym wystąpieniu, metoda zwraca wartość bieżącego wystąpienia bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowanie wyrażenia regularnego, jeśli jest spełniony jeden z następujących warunków:  
  
-   Ciąg zastępczy łatwo nie może zostać określona zastępczy wzorcem wyrażenia regularnego.  
  
-   Ciąg zastępczy wynikiem przetwarza przeprowadzić dopasowany ciąg.  
  
-   Wyniki ciąg zastępczy przetwarzania warunkowego.  
  
 Metoda jest odpowiednikiem wywołania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> — metoda i przekazywanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconym <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegowanie.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Parametr jest delegowanie dla niestandardowej metody, która należy zdefiniować i która sprawdza, czy każdy dopasowania. Metoda niestandardowy musi mieć następującą sygnaturą odpowiadające <xref:System.Text.RegularExpressions.MatchEvaluator> delegowanie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metodę zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji zamiany przekroczy limit czasu określony dla domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli limit czasu nie jest zdefiniowany w właściwości domeny aplikacji lub wartość limitu czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład korzysta z wyrażenia regularnego do wyodrębniania poszczególnych wyrazów z ciągiem, a następnie używa <xref:System.Text.RegularExpressions.MatchEvaluator> pełnomocnika, aby wywołać metodę o nazwie `WordScramble` który zaszyfrowanie pojedynczych liter w wyrazie. Aby to zrobić, `WordScramble` metoda tworzy tablicę, która zawiera znaki w dopasowania. Tworzy również równoległych tablica, która wypełnia z losowych liczb zmiennoprzecinkowych. Tablice są sortowane według wywoływania <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> — metoda i posortowana tablica jest dostępna jako argumentu w celu <xref:System.String> konstruktora klasy. Nowo utworzony ciąg jest następnie zwracany przez `WordScramble` metody. Wzorzec wyrażenia regularnego `\w+` co najmniej jeden znak słowa; jest zgodny z aparatem wyrażeń regularnych będą w dalszym ciągu Dodawanie znaków do dopasowania, aż do napotkania znak-word, takich jak biały znak.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" />, lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po upływie interwału równą domyślny limit czasu domeny aplikacji, w którym jest wywoływana. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Zalecaną metodą statycznych obliczenia i zastępowanie dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, umożliwiające ustawienie interwału limitu czasu.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdym dopasowaniu i zwraca oryginalnego ciągu dopasowane lub ciąg zastępczy.</param>
        <param name="count">Maksymalna liczba powtórzeń nastąpi zastąpienie.</param>
        <summary>W określonym ciągu wejściowego zastępuje określoną maksymalną liczbę ciągów, które są zgodne ze wzorcem wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegowanie.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli w bieżącym wystąpieniu nie jest zgodny ze wzorcem wyrażenia regularnego, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowanie wyrażenia regularnego, jeśli jest spełniony jeden z następujących warunków:  
  
-   Ciąg zastępczy łatwo nie może zostać określona zastępczy wzorcem wyrażenia regularnego.  
  
-   Ciąg zastępczy wynikiem przetwarza przeprowadzić dopasowany ciąg.  
  
-   Wyniki ciąg zastępczy przetwarzania warunkowego.  
  
 Metoda jest odpowiednikiem wywołania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> — metoda i przekazywanie pierwszy `count` <xref:System.Text.RegularExpressions.Match> obiektów w zwróconym <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegowanie.  
  
 Wyrażenie regularne jest wzorcowi określonemu przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `evaluator` Parametr jest delegowanie dla niestandardowej metody, która należy zdefiniować i która sprawdza, czy każdy dopasowania. Metoda niestandardowy musi mieć następującą sygnaturą odpowiadające <xref:System.Text.RegularExpressions.MatchEvaluator> delegowanie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metodę zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji zamiany przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie wyjątku  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wyrażenia regularnego, aby celowo błędnie połowę słów na liście. Używa wyrażenia regularnego `\w*(ie|ei)\w*` odpowiadające słowa, które zawierają znaki "ie" lub "ei". Przekazuje ono pierwszy połowę słów pasującego do `ReverseLetter` metodę, która z kolei używa <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodę, aby odwrócić "i" oraz "e" w ciągu dopasowany. Pozostałe wyrazy pozostają niezmienione.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 Wyrażenie regularne `\w*(ie|ei)\w*` jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\w*`|Dopasowuje zero lub więcej znaków słowa.|  
|`(ie&#124;ei)`|Zgodne "ie" lub "ei".|  
|`\w*`|Dopasowuje zero lub więcej znaków słowa.|  
  
 Wzorzec wyrażenia regularnego `([ie])([ie])` w `ReverseLetter` Metoda odpowiada diphthong "ie" lub "ei" pierwszy "i" lub "e" i przypisuje literę pierwszej grupy przechwytywania. Drugi "i" lub "e", a przypisuje literę do drugiej grupy przechwytywania. Dwa znaki są następnie wycofane przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> metody za pomocą wzorca zastępczy `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="count">Maksymalna liczba wystąpień zastąpienia można.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowego, gdy rozpocznie się wyszukiwanie.</param>
        <summary>W wskazany podciąg wejściowego zastępuje określoną maksymalną liczbę ciągów, które są zgodne ze wzorcem wyrażenia regularnego z określony ciąg zastępczy.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli w bieżącym wystąpieniu nie jest zgodny ze wzorcem wyrażenia regularnego, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj dopasowań, który rozpoczyna się `input` string na pozycji określony przez `startat` parametru. Wyrażenie regularne jest wzorcowi określonemu przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu. Jeśli `count` jest ujemna, elementy zastępcze w dalszym ciągu końca ciągu. Jeśli `count` przekracza liczbę, zastępuje wszystkie dopasowania.  
  
 `replacement` Parametr określa ciąg, który ma zastąpić każdego dopasowania `input`. `replacement` może zawierać dowolną kombinację literały tekstowe i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zastępczy `a*${test}b` wstawia ciąg "*" następuje podciągu, który działa w kontekście `test` Przechwytywanie grupy, jeśli istnieje, następuje ciąg "b". * Znak nie został rozpoznany jako metaznak w wzorzec zastąpienia.  
  
> [!NOTE]
>  Podstawienia są elementy języka tylko wyrażenie, które są rozpoznawane w układzie zastąpienia. Wszystkie inne wyrażenia regularnego elementy języka, w tym [znak specjalne](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone we wzorcach wyrażenia regularnego tylko i nie są rozpoznawane w wzorce zamiany.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji zamiany przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie wyjątku  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład double-spaces wszystkie oprócz pierwszego wiersza w ciągu. Definiuje wzorzec wyrażenia regularnego, `^.*$`, wiersz tekstu, wywołania, które odpowiadają <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metody do dopasowania ciągu i używa pierwszego wiersza `Match.Index` i `Match.Count` właściwości do określenia pozycji początkowej drugiego wiersz.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Wzorzec wyrażenia regularnego `^.*$` jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Odpowiada na początku wiersza. (Należy pamiętać, że <xref:System.Text.RegularExpressions.Regex> utworzono wystąpienie obiektu przy użyciu <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opcja; w przeciwnym razie ta klasa znak spowoduje dopasowanie tylko na początku ciąg wejściowy.)|  
|`.*`|Dopasowuje dowolny znak zero lub więcej razy.|  
|`$`|Odpowiada na końcu wiersza. (Należy pamiętać, że <xref:System.Text.RegularExpressions.Regex> utworzono wystąpienie obiektu przy użyciu <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opcja; w przeciwnym razie ta klasa znak spowoduje dopasowanie tylko na początku ciąg wejściowy.)|  
  
 Ciąg zastępczy (`vbCrLf + "$&"` w języku Visual Basic `"\n$&"` w języku C#) umożliwia dodanie nowego wiersza przed dopasowany ciąg. Należy pamiętać, że `\n` w języku C# przykład jest interpretowana jako znak nowego wiersza przez kompilator języka C#; nie reprezentuje ucieczki znaku wyrażenia regularnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> jest mniejsza niż zero lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które zapewniają opcje do dopasowania.</param>
        <summary>W określonym ciągu wejściowego zastępuje wszystkie ciągi, które pasują do podanego wyrażenia regularnego z określony ciąg zastępczy. Opcje zmodyfikować operacji dopasowywania.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli <paramref name="pattern" /> nie jest takie samo w bieżącym wystąpieniu, metoda zwraca wartość bieżącego wystąpienia bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statycznych `Replace` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Replace`.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> dla `options` parametru, wyszukaj dopasowań rozpoczyna się na końcu ciągu wejściowego i przenosi lewej; w przeciwnym razie wartość wyszukiwania rozpoczyna się od początku ciągu wejściowego i przenosi prawo.  
  
 `replacement` Parametr określa ciąg, który ma zastąpić każdego dopasowania `input`. `replacement` może zawierać dowolną kombinację literały tekstowe i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zastępczy `a*${test}b` wstawia ciąg "*" następuje podciągu, który działa w kontekście `test` Przechwytywanie grupy, jeśli istnieje, następuje ciąg "b". * Znak nie został rozpoznany jako metaznak w wzorzec zastąpienia.  
  
> [!NOTE]
>  Podstawienia są elementy języka tylko wyrażenie, które są rozpoznawane w układzie zastąpienia. Wszystkie inne wyrażenia regularnego elementy języka, w tym [znak specjalne](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone we wzorcach wyrażenia regularnego tylko i nie są rozpoznawane w wzorce zamiany.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji zamiany przekroczy limit czasu określony dla domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli limit czasu nie jest zdefiniowany w właściwości domeny aplikacji lub wartość limitu czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodę, aby zastąpić lokalnej nazwy komputera i dysku w ścieżce UNC ścieżkę do pliku lokalnego. Używa wyrażenia regularnego <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby uwzględnić nazwę komputera lokalnego i <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> metodę w celu uwzględnienia nazwy dysków logicznych. Wszystkie porównywania ciągów wyrażenie regularne jest rozróżniana wielkość liter. Aby pomyślnie uruchomić przykład, należy zastąpić ciąg literału "MojKomputer" nazwą komputera lokalnego.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Wzorzec wyrażenia regularnego jest definiowana za pomocą następującego wyrażenia:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\\\\`|Dopasowanie dwa kolejne ukośnik odwrotny (`\`) znaków. Ponieważ ukośnika odwrotnego jest interpretowana jako znak ucieczki, każdy ukośnik odwrotny musi wyjściowym z innego ukośnika odwrotnego.|  
|`+ Environment.MachineName +`|Zgodny z ciągiem, który jest zwracany przez <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości.|  
|`(?:\.\w+)*`|Zgodne okres (`.`) znaków następuje co najmniej jeden znak programu word. To dopasowanie, może wystąpić zero lub więcej razy. Nie przechwytuje Podwyrażenie dopasowany.|  
|`\\`|Zgodne ukośnik odwrotny (`\`) znaków.|  
|`([" + driveNames + "])`|Zgodny z klasą znak składający się z liter poszczególnych dysków. Tego dopasowania to pierwsze przechwycone Podwyrażenie.|  
|`\$`|Zgodne literału dolara (`$`) znaków.|  
  
 Wzorzec zastępczy `$1` zamienia cały dopasowania pierwsze przechwycone Podwyrażenie. Oznacza to zastępuje nazwę komputera i dysku UNC z literą dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" />, lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po upływie interwału równą domyślny limit czasu domeny aplikacji, w którym jest wywoływana. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Zalecaną metodą statyczny do zastępowania dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, umożliwiające ustawienie interwału limitu czasu.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdym dopasowaniu i zwraca oryginalnego ciągu dopasowane lub ciąg zastępczy.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które zapewniają opcje do dopasowania.</param>
        <summary>W określonym ciągu wejściowego zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegowanie. Opcje zmodyfikować operacji dopasowywania.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli <paramref name="pattern" /> nie jest takie samo w bieżącym wystąpieniu, metoda zwraca wartość bieżącego wystąpienia bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania wyrażenia regularnego dopasowania, jeśli jest spełniony jeden z następujących warunków:  
  
-   Ciąg zastępczy łatwo nie może zostać określona zastępczy wzorcem wyrażenia regularnego.  
  
-   Ciąg zastępczy wynikiem przetwarza przeprowadzić dopasowany ciąg.  
  
-   Wyniki ciąg zastępczy przetwarzania warunkowego.  
  
 Metoda jest odpowiednikiem wywołania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> — metoda i przekazywanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconym <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegowanie.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Parametr jest delegowanie dla niestandardowej metody, która należy zdefiniować i która sprawdza, czy każdy dopasowania. Metoda niestandardowy musi mieć następującą sygnaturą odpowiadające <xref:System.Text.RegularExpressions.MatchEvaluator> delegowanie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metodę zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> dla `options` parametru, wyszukaj dopasowań rozpoczyna się na końcu ciągu wejściowego i przenosi lewej; w przeciwnym razie wartość wyszukiwania rozpoczyna się od początku ciągu wejściowego i przenosi prawo.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji zamiany przekroczy limit czasu określony dla domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli limit czasu nie jest zdefiniowany w właściwości domeny aplikacji lub wartość limitu czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład korzysta z wyrażenia regularnego do wyodrębniania poszczególnych wyrazów z ciągiem, a następnie używa <xref:System.Text.RegularExpressions.MatchEvaluator> pełnomocnika, aby wywołać metodę o nazwie `WordScramble` który zaszyfrowanie pojedynczych liter w wyrazie. Aby to zrobić, `WordScramble` metoda tworzy tablicę, która zawiera znaki w dopasowania. Tworzy również równoległych tablica, która wypełnia z losowych liczb zmiennoprzecinkowych. Tablice są sortowane według wywoływania <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> — metoda i posortowana tablica jest dostępna jako argumentu w celu <xref:System.String> konstruktora klasy. Nowo utworzony ciąg jest następnie zwracany przez `WordScramble` metody. Wzorzec wyrażenia regularnego `\w+` co najmniej jeden znak słowa; jest zgodny z aparatem wyrażeń regularnych będą w dalszym ciągu Dodawanie znaków do dopasowania, aż do napotkania znak-word, takich jak biały znak. Wywołanie <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> metoda zawiera <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opcję, aby komentarz w wzorzec wyrażenia regularnego `\w+  # Matches all the characters in a word.` jest ignorowana przez aparat wyrażeń regularnych.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" />, lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdym dopasowaniu i zwraca oryginalnego ciągu dopasowane lub ciąg zastępczy.</param>
        <param name="count">Maksymalna liczba powtórzeń nastąpi zastąpienie.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowego, gdy rozpocznie się wyszukiwanie.</param>
        <summary>W wskazany podciąg wejściowego, zastępuje określoną maksymalną liczbę ciągów, które są zgodne ze wzorcem wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegowanie.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli w bieżącym wystąpieniu nie jest zgodny ze wzorcem wyrażenia regularnego, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowanie wyrażenia regularnego, jeśli jest spełniony jeden z następujących warunków:  
  
-   Ciąg zastępczy łatwo nie może zostać określona zastępczy wzorcem wyrażenia regularnego.  
  
-   Ciąg zastępczy wynikiem przetwarza przeprowadzić dopasowany ciąg.  
  
-   Wyniki ciąg zastępczy przetwarzania warunkowego.  
  
 Metoda jest odpowiednikiem wywołania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> — metoda i przekazywanie pierwszy `count` <xref:System.Text.RegularExpressions.Match> obiektów w zwróconym <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegowanie.  
  
 Wyrażenie regularne jest wzorcowi określonemu przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `evaluator` Parametr jest delegowanie dla niestandardowej metody, która należy zdefiniować i która sprawdza, czy każdy dopasowania. Metoda niestandardowy musi mieć następującą sygnaturą odpowiadające <xref:System.Text.RegularExpressions.MatchEvaluator> delegowanie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metodę zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji zamiany przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie wyjątku  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> jest mniejsza niż zero lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które zapewniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu, lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> aby wskazać, że metoda powinna nie upłynął limit czasu.</param>
        <summary>W określonym ciągu wejściowego zastępuje wszystkie ciągi, które pasują do podanego wyrażenia regularnego z określony ciąg zastępczy. Dodatkowe parametry, określ opcje modyfikujące operacji dopasowywania i limit czasu, jeśli nie znaleziono.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli <paramref name="pattern" /> nie jest takie samo w bieżącym wystąpieniu, metoda zwraca wartość bieżącego wystąpienia bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statycznych `Replace` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Replace`.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> dla `options` parametru, wyszukaj dopasowań rozpoczyna się na końcu ciągu wejściowego i przenosi lewej; w przeciwnym razie wartość wyszukiwania rozpoczyna się od początku ciągu wejściowego i przenosi prawo.  
  
 `replacement` Parametr określa ciąg, który ma zastąpić każdego dopasowania `input`. `replacement` może zawierać dowolną kombinację literały tekstowe i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zastępczy `a*${test}b` wstawia ciąg "*" następuje podciągu, który działa w kontekście `test` Przechwytywanie grupy, jeśli istnieje, następuje ciąg "b". * Znak nie został rozpoznany jako metaznak w wzorzec zastąpienia.  
  
> [!NOTE]
>  Podstawienia są elementy języka tylko wyrażenie, które są rozpoznawane w układzie zastąpienia. Wszystkie inne wyrażenia regularnego elementy języka, w tym [znak specjalne](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone we wzorcach wyrażenia regularnego tylko i nie są rozpoznawane w wzorce zamiany.  
  
 `matchTimeout` Parametr określa, jak długo dopasowanie wzorca metody prób znalezienia dopasowania, zanim upłynie limit czasu. Ustawienie limitu czasu uniemożliwia wyrażeń regularnych, które opierają się na nadmiernym wykorzystaniem algorytmu wycofywania wyświetlaniu przestaje odpowiadać podczas przetwarzania danych wejściowych zawierający dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli nie znaleziono, w tym przedziale czasu, metoda wygeneruje <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie zdefiniowane dla domeny aplikacji, w której wykonuje metodę domyślną wartość limitu czasu.  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodę, aby zastąpić lokalnej nazwy komputera i dysku w ścieżce UNC ścieżkę do pliku lokalnego. Używa wyrażenia regularnego <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby uwzględnić nazwę komputera lokalnego i <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> metodę w celu uwzględnienia nazwy dysków logicznych. Wszystkie porównywania ciągów wyrażenie regularne jest rozróżniana wielkość liter, a jeśli nie można odnaleźć dopasowania w 0,5 sekundy limitu czasu żadnej operacji jednego zastąpienia. Aby pomyślnie uruchomić przykład, należy zastąpić ciąg literału "MojKomputer" nazwą komputera lokalnego.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Wzorzec wyrażenia regularnego jest definiowana za pomocą następującego wyrażenia:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 W poniższej tabeli przedstawiono, jak jest interpretowana wzorzec wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\\\\`|Dopasowanie dwa kolejne ukośnik odwrotny (`\`) znaków. Ponieważ ukośnika odwrotnego jest interpretowana jako znak ucieczki, każdy ukośnik odwrotny musi wyjściowym z innego ukośnika odwrotnego.|  
|`+ Environment.MachineName +`|Zgodny z ciągiem, który jest zwracany przez <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości.|  
|`(?:\.\w+)*`|Zgodne okres (`.`) znaków następuje co najmniej jeden znak programu word. To dopasowanie, może wystąpić zero lub więcej razy. Nie przechwytuje Podwyrażenie dopasowany.|  
|`\\`|Zgodne ukośnik odwrotny (`\`) znaków.|  
|`([" + driveNames + "])`|Zgodny z klasą znak składający się z liter poszczególnych dysków. Tego dopasowania to pierwsze przechwycone Podwyrażenie.|  
|`\$`|Zgodne literału dolara (`$`) znaków.|  
  
 Wzorzec zastępczy `$1` zamienia cały dopasowania pierwsze przechwycone Podwyrażenie. Oznacza to zastępuje nazwę komputera i dysku UNC z literą dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" />, lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  - lub - <paramref name="matchTimeout" /> jest ujemna, zero, lub większa niż około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwie sekundy. Jeśli wyłączysz przekroczeń limitu czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednak należy wyłączyć limity czasu tylko w następujących warunkach: — w przypadku wprowadzania przetworzone przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub składa się z tekst statyczny. Obejmuje to tekst, który dynamicznie została wprowadzona przez użytkowników.  — Wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że wydajnie obsługuje on zgodny z systemem innym niż dopasowań, bliskiej zgodny.  -Gdy wzorzec wyrażenia regularnego nie zawiera żadnych elementów języka, mogących powodować nadmiernym wykorzystaniem algorytmu wycofywania, podczas przetwarzania near dopasowania.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdym dopasowaniu i zwraca oryginalnego ciągu dopasowane lub ciąg zastępczy.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które zapewniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu, lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> aby wskazać, że metoda powinna nie upłynął limit czasu.</param>
        <summary>W określonym ciągu wejściowego zastępuje wszystkie podciągi zgodne z określonego wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegowanie. Dodatkowe parametry, określ opcje modyfikujące operacji dopasowywania i limit czasu, jeśli nie znaleziono.</summary>
        <returns>Nowy ciąg, który jest taki sam jak ciągu wejściowego z tą różnicą, że ciąg zastępczy ma miejsce każdego dopasowany ciąg. Jeśli <paramref name="pattern" /> nie jest takie samo w bieżącym wystąpieniu, metoda zwraca wartość bieżącego wystąpienia bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowanie wyrażenia regularnego, jeśli jest spełniony jeden z następujących warunków:  
  
-   Jeśli ciąg zastępczy łatwo nie może zostać określona zastępczy wzorcem wyrażenia regularnego.  
  
-   Jeśli ciąg zastępczy wyniki z niektórych przetwarzanie jest realizowane na dopasowany ciąg.  
  
-   Jeśli ciąg zastępczy wynikiem przetwarzania warunkowego.  
  
 Metoda jest odpowiednikiem wywołania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> — metoda i przekazywanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconym <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegowanie.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Parametr jest delegowanie dla niestandardowej metody, która należy zdefiniować i która sprawdza, czy każdy dopasowania. Metoda niestandardowy musi mieć następującą sygnaturą odpowiadające <xref:System.Text.RegularExpressions.MatchEvaluator> delegowanie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metodę zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> dla `options` parametru, wyszukaj dopasowań rozpoczyna się na końcu ciągu wejściowego i przenosi lewej; w przeciwnym razie wartość wyszukiwania rozpoczyna się od początku ciągu wejściowego i przenosi prawo.  
  
 `matchTimeout` Parametr określa, jak długo dopasowanie wzorca metody prób znalezienia dopasowania, zanim upłynie limit czasu. Ustawienie limitu czasu uniemożliwia wyrażeń regularnych, korzystające z nadmiernym wykorzystaniem algorytmu wycofywania wyświetlaniu do "przestaje odpowiadać podczas przetwarzania danych wejściowych zawierający dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli nie znaleziono, w tym przedziale czasu, metoda wygeneruje <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie zdefiniowane dla domeny aplikacji, w której wykonuje metodę domyślną wartość limitu czasu.  
  
 Ponieważ metoda zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, można użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda wprowadził wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład korzysta z wyrażenia regularnego do wyodrębniania poszczególnych wyrazów z ciągiem, a następnie używa <xref:System.Text.RegularExpressions.MatchEvaluator> pełnomocnika, aby wywołać metodę o nazwie `WordScramble` który zaszyfrowanie pojedynczych liter w wyrazie. Aby to zrobić, `WordScramble` metoda tworzy tablicę, która zawiera znaki w dopasowania. Tworzy również równoległych tablica, która wypełnia z losowych liczb zmiennoprzecinkowych. Tablice są sortowane według wywoływania <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> — metoda i posortowana tablica jest dostępna jako argumentu w celu <xref:System.String> konstruktora klasy. Nowo utworzony ciąg jest następnie zwracany przez `WordScramble` metody. Wzorzec wyrażenia regularnego `\w+` co najmniej jeden znak słowa; jest zgodny z aparatem wyrażeń regularnych będą w dalszym ciągu Dodawanie znaków do dopasowania, aż do napotkania znak-word, takich jak biały znak. Wywołanie <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> metoda zawiera <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opcję, aby komentarz w wzorzec wyrażenia regularnego `\w+  # Matches all the characters in a word.` jest ignorowana przez aparat wyrażeń regularnych.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" />, lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  - lub - <paramref name="matchTimeout" /> jest ujemna, zero, lub większa niż około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwie sekundy. Jeśli wyłączysz przekroczeń limitu czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednak należy wyłączyć limity czasu tylko w następujących warunkach: — w przypadku wprowadzania przetworzone przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub składa się z tekst statyczny. Obejmuje to tekst, który dynamicznie została wprowadzona przez użytkowników.  — Wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że wydajnie obsługuje on zgodny z systemem innym niż dopasowań, bliskiej zgodny.  -Gdy wzorzec wyrażenia regularnego nie zawiera żadnych elementów języka, mogących powodować nadmiernym wykorzystaniem algorytmu wycofywania, podczas przetwarzania near dopasowania.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wyrażenie regularne wyszukiwania od prawej do lewej.</summary>
        <value>
          <see langword="true" /> Jeśli wyrażenie regularne wyszukiwania od prawej do lewej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> jest `true` Jeśli <xref:System.Text.RegularExpressions.Regex> wystąpienie zostało utworzone z <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> opcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowanych przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dzieli wejściowy ciąg na tablicę podciągów w pozycji zdefiniowane przez dopasowanie wyrażenia regularnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do dzielenia.</param>
        <summary>Dzieli wejściowy ciąg na tablicę podciągów w pozycji zdefiniowane przez wzorzec wyrażenia regularnego, określona w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg przy ogranicznik ustaleniami wyrażenia regularnego zamiast zestawu znaków. Ten ciąg jest dzielony dowolną liczbę razy. Jeśli separator nie zostanie znaleziony, zwracana wartość zawiera jeden element, którego wartość jest oryginalnym ciągu wejściowego.  
  
 Jeśli wiele dopasowań sąsiadujących ze sobą, ciągiem pustym są wstawiane do tablicy. Na przykład podzielić ciąg na pojedynczy łącznik powoduje, że zwracana tablica uwzględnienie pustego ciągu w miejscu, gdzie znaleziono dwóch sąsiadujących ze sobą łączników, jak przedstawiono na poniższym kodem.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Jeśli dopasowanie znajduje się na początku lub końca ciągu wejściowego, ciąg pusty jest dołączony na początku lub końca zwrócony tablicy. W poniższym przykładzie użyto wzorzec wyrażenia regularnego `\d+` podziału wejściowy ciąg znaków liczbowych. Ponieważ ciąg rozpoczyna się i kończy pasujących znaków liczbowych, wartość elementu imię i nazwisko zwracana tablica jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Jeśli przechwytywanie nawiasy są używane w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażenie any przechwycony tekst jest uwzględniany w wynikowej tablicy ciągów. Na przykład podzielić ciąg "plum gruszkowa" na łącznik umieszczony w nawiasach przechwytywania, zwracana tablica zawiera element ciąg, który zawiera łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego obejmuje wiele zestawów Przechwytywanie nawiasów, zachowanie tej metody zależy od wersji programu .NET Framework. .NET Framework 1.0 i 1.1 Jeśli nie znaleziono dopasowania w pierwszym zestawie Przechwytywanie nawiasów, przechwycony tekst z dodatkowe nawiasy przechwytywania nie wchodzi w zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest także dodawane do zwróconej tablicy. Na przykład następujący kod używa dwóch zestawów Przechwytywanie nawiasów wyodrębnić elementy Data, łącznie z ogranicznikami daty z ciągu daty. Pierwszy zestaw Przechwytywanie nawiasów przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod kompilacji i uruchamiać w ramach programu .NET Framework 1.0 lub 1.1, nie obejmuje znaków ukośnika. Jeśli jest skompilowany i uruchamiana .NET Framework 2.0 lub nowszy, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Jeśli wyrażenie regularne może dopasować pusty ciąg <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> będzie podzielić ciąg na tablicę ciągów znaków pojedynczego, ponieważ ogranicznik pusty ciąg, który znajduje się w każdej lokalizacji. Na przykład:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Należy pamiętać, że zwracana tablica zawiera również pustego ciągu na początku i końca tablicy.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji podziału przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie wyjątku  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do podziału.</param>
        <param name="count">Maksymalna liczba wystąpień podziału można.</param>
        <summary>Ciąg wejściowy podziałów określoną maksymalną liczbę razy na tablicę podciągów w miejscach wynika z wyrażeniem regularnym określonym w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%2A?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg przy ogranicznik ustaleniami wyrażenia regularnego zamiast zestawu znaków. `count` Parametr określa maksymalną liczbę podciągów, do którego `input` można podzielić ciąg; ostatni ciąg zawiera sięgnąć końca ciągu. A `count` wartość zero zawiera domyślne zachowanie dzielenia tyle razy, jak to możliwe.  
  
 Jeśli wiele dopasowań znajdują się obok siebie wzajemnie lub dopasowania znajduje się na początku lub na końcu `input`, a liczba znalezionych dopasowań jest co najmniej dwóch mniej niż `count`, ciąg pusty jest wstawiany do tablicy. Oznacza to, zliczane puste ciągi wynikających z sąsiadujących ze sobą zgodne lub dopasowuje początek lub koniec ciągu wejściowego w określeniu, czy liczba dopasowano equals podciągów `count`. W poniższym przykładzie, wyrażenie regularne `/d+` służy do dzielenia wejściowy ciąg, który zawiera jeden lub więcej cyfr dziesiętnych na maksymalnie trzy podciągów. Ponieważ na początku ciąg wejściowy jest zgodny ze wzorcem wyrażenia regularnego, pierwszy element tablicy zawiera <xref:System.String.Empty?displayProperty=nameWithType>, drugi zawiera pierwszy zestaw znaków alfabetu w ciągu wejściowym, a trzeci w pozostałej części ciągu następujący trzeci dopasowania.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Jeśli przechwytywanie nawiasy są używane w wyrażeniu regularnym, przechwycony tekst znajduje się w tablicy ciągów podziału. Jednak wszystkie elementy tablicy, zawierających tekst przechwycony nie są uwzględniane w określeniu, czy osiągnięto liczbę `count`. Na przykład podzielić ciąg "apple morela plum gruszkowa bananów" na maksymalnie cztery powoduje podciągów tablicą siedmiu elementu jako poniższy kod przedstawia.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego obejmuje wiele zestawów Przechwytywanie nawiasów, zachowanie tej metody zależy od wersji programu .NET Framework. .NET Framework 1.0 i 1.1 tylko przechwycony tekst z pierwszego zestawu przechwytywania nawiasów jest uwzględniana w zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest dodawany do zwróconej tablicy. Jednak elementów w tablicy zwrócone, zawierających tekst przechwycony nie są uwzględniane w określeniu, czy liczba dopasowano equals podciągów `count`. Na przykład w poniższym kodzie wyrażenia regularnego wykorzystuje dwa zestawy przechwytywania nawiasów do wyodrębniania elementów daty z ciągu daty. Pierwszy zestaw Przechwytywanie nawiasów przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Wywołanie <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> metody następnie określa maksymalnie dwa elementy w tablicy zwrócony. Jeśli przykładowy kod kompilacji i uruchamiać w ramach programu .NET Framework 1.0 lub 1.1, metoda zwraca tablicy ciągów dwóch elementów. Jeśli jest skompilowany i uruchamiana .NET Framework 2.0 lub nowszy, metoda zwraca tablicy ciągów trzech elementu.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Jeśli wyrażenie regularne może dopasować pusty ciąg <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> będzie podzielić ciąg na tablicę ciągów znaków pojedynczego, ponieważ ogranicznik pusty ciąg, który znajduje się w każdej lokalizacji. Poniższy przykład dzieli na ciąg "znaków", się wiele elementów w znajduje się w ciągu wejściowego. Ponieważ pusty ciąg dopasowuje początek ciągu wejściowego, ciąg pusty jest wstawiany na początku zwróconej tablicy. Powoduje to dziesiątego elementu, który ma zawierać dwa znaki na końcu ciągu wejściowego.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji podziału przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie wyjątku  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do dzielenia.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Dzieli wejściowy ciąg na tablicę podciągów w pozycji zdefiniowane przez wzorzec wyrażenia regularnego.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%2A?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg przy ogranicznik ustaleniami wyrażenia regularnego zamiast zestawu znaków. `input` Ciągu jest podzielony na wiele razy, ile to możliwe. Jeśli `pattern` nie został znaleziony w `input` ciąg, wartość zwracana zawiera jeden element, którego wartość jest oryginalnym `input` ciągu.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Skompilowane wyrażenia regularne używanym w wywołaniach statyczne <xref:System.Text.RegularExpressions.Regex.Split%2A> metody są automatycznie buforowane. Do zarządzania przez czas ich istnienia skompilowane wyrażenia regularnego samodzielnie, użyj wystąpienia <xref:System.Text.RegularExpressions.Regex.Split%2A> metody.  
  
 Jeśli wiele dopasowań sąsiadujących ze sobą, ciągiem pustym są wstawiane do tablicy. Na przykład podzielić ciąg na pojedynczy łącznik powoduje, że zwracana tablica uwzględnienie pustego ciągu w miejscu, gdzie znaleziono dwóch sąsiadujących ze sobą łączników, jak przedstawiono na poniższym kodem.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Jeśli dopasowanie znajduje się na początku lub końca ciągu wejściowego, ciąg pusty jest dołączony na początku lub końca zwrócony tablicy. W poniższym przykładzie użyto wzorzec wyrażenia regularnego `\d+` podziału wejściowy ciąg znaków liczbowych. Ponieważ ciąg rozpoczyna się i kończy pasujących znaków liczbowych, wartość elementu imię i nazwisko zwracana tablica jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Jeśli przechwytywanie nawiasy są używane w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażenie any przechwycony tekst jest uwzględniany w wynikowej tablicy ciągów. Na przykład podzielić ciąg "plum gruszkowa" na łącznik umieszczony w nawiasach przechwytywania, zwracana tablica zawiera element ciąg, który zawiera łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego obejmuje wiele zestawów Przechwytywanie nawiasów, zachowanie tej metody zależy od wersji programu .NET Framework. .NET Framework 1.0 i 1.1 Jeśli nie znaleziono dopasowania w pierwszym zestawie Przechwytywanie nawiasów, przechwycony tekst z dodatkowe nawiasy przechwytywania nie wchodzi w zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest także dodawane do zwróconej tablicy. Na przykład następujący kod używa dwóch zestawów Przechwytywanie nawiasów wyodrębnić elementy Data, łącznie z ogranicznikami daty z ciągu daty. Pierwszy zestaw Przechwytywanie nawiasów przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod kompilacji i uruchamiać w ramach programu .NET Framework 1.0 lub 1.1, nie obejmuje znaków ukośnika. Jeśli jest skompilowany i uruchamiana .NET Framework 2.0 lub nowszy, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Jeśli wyrażenie regularne może dopasować pusty ciąg <xref:System.Text.RegularExpressions.Regex.Split%2A> będzie podzielić ciąg na tablicę ciągów znaków pojedynczego, ponieważ ogranicznik pusty ciąg, który znajduje się w każdej lokalizacji. Na przykład:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Należy pamiętać, że zwracana tablica zawiera również pustego ciągu na początku i końca tablicy.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji podziału przekroczy limit czasu określony dla domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli limit czasu nie jest zdefiniowany w właściwości domeny aplikacji lub wartość limitu czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po interwału, który jest taki sam, jak domyślny limit czasu domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Zalecaną metodą statyczny do dzielenia tekstu w przypadku dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, umożliwiające ustawienie interwału limitu czasu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do podziału.</param>
        <param name="count">Maksymalna liczba wystąpień podziału można.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowego, gdy rozpocznie się wyszukiwanie.</param>
        <summary>Ciąg wejściowy podziałów określoną maksymalną liczbę razy na tablicę podciągów w miejscach wynika z wyrażeniem regularnym określonym w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora. Wyszukaj wzorzec wyrażenia regularnego rozpoczyna się od pozycji określony znak w ciągu wejściowym.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%2A?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg przy ogranicznik ustaleniami wyrażenia regularnego zamiast zestawu znaków. `count` Parametr określa maksymalną liczbę podciągów, do którego `input` dzieli się ciąg; ostatni ciąg zawiera sięgnąć końca ciągu. A `count` wartość zero zawiera domyślne zachowanie dzielenia tyle razy, jak to możliwe. `startat` Parametr określa punkt, od której rozpoczyna się wyszukiwania dla pierwszego ogranicznika (to może być używane do pomijania wiodące biały znak).  
  
 W przypadku nieodnalezienia żadnych dopasowań z `count`+ 1 pozycji w ciągu, metoda zwraca tablicy jeden element, który zawiera `input` ciągu. Jeśli jeden lub więcej dopasowań, pierwszy element macierzy zwrócony zawiera pierwszą część ciągu z pierwszego znaku maksymalnie jeden znak przed dopasowania.  
  
 Jeśli wiele dopasowań znajdują się obok siebie wzajemnie, a liczba znalezionych dopasowań jest co najmniej dwa mniej niż `count`, ciąg pusty jest wstawiany do tablicy. Podobnie jeśli znaleziono dopasowanie na `startat`, który jest pierwszy znak w ciągu, pierwszy element tablicy zwracane jest pustym ciągiem. Oznacza to, puste ciągi wynikających z sąsiadujących ze sobą zgodne są zliczane w określeniu, czy liczba dopasowano equals podciągów `count`. W poniższym przykładzie, wyrażenie regularne `\d+` jest używana do znajdowania pozycja początkowa pierwszego podciągu cyfr w ciągu, a następnie podzielenie ciągu maksymalnie trzy razy początkowy na tej pozycji. Ponieważ wzorzec wyrażenia regularnego dopasowuje początek ciągu wejściowego, tablicy zwracany ciąg składa się z ciągiem pustym, 5 znakowym ciągiem alfabetyczne oraz pozostała część ciągu znaków  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Jeśli przechwytywanie nawiasy są używane w wyrażeniu regularnym, przechwycony tekst znajduje się w tablicy ciągów podziału. Jednak wszystkie elementy tablicy, zawierających tekst przechwycony nie są uwzględniane w określeniu, czy osiągnięto liczbę `count`. Na przykład podzielić ciąg ""apple-apricot-plum-pear-pomegranate-pineapple-peach"na maksymalnie cztery podciągi rozpoczynający się od znaku 15 w wynikach ciąg w tablicy siedmiu element, jak przedstawiono na poniższym kodem.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego obejmuje wiele zestawów Przechwytywanie nawiasów, zachowanie tej metody zależy od wersji programu .NET Framework. W programie .NET Framework 1.0 i 1.1 Jeśli nie znaleziono dopasowania w pierwszym zestawie Przechwytywanie nawiasów, przechwycony tekst z dodatkowe nawiasy przechwytywania nie wchodzi w zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest także dodawane do zwróconej tablicy. Na przykład następujący kod używa dwóch zestawów Przechwytywanie nawiasów wyodrębnić poszczególnych wyrazów w ciągu. Pierwszy zestaw Przechwytywanie nawiasów przechwytuje łącznik, a drugi zestaw przechwytuje pionowy pasek. Jeśli przykładowy kod kompilacji i uruchamiać w ramach programu .NET Framework 1.0 lub 1.1, nie obejmuje pionowy pasek znaków. Jeśli jest skompilowany i uruchamiana .NET Framework 2.0 lub nowszy, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Jeśli wyrażenie regularne może dopasować pusty ciąg <xref:System.Text.RegularExpressions.Regex.Split%2A> będzie podzielić ciąg na tablicę ciągów znaków pojedynczego, ponieważ ogranicznik pusty ciąg, który znajduje się w każdej lokalizacji. Poniższy przykład dzieli ciągu znaków"" na tyle elementów, ponieważ ciąg wejściowy zawiera, począwszy od znaku "". Ponieważ pusty ciąg pasuje do końca ciągu wejściowego, ciąg pusty jest wstawiany na końcu zwróconej tablicy.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji podziału przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie zostanie ustawiony limit czasu podczas wywoływania konstruktora, jest wyjątek Jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub w oknie dialogowym właściwości domeny aplikacji lub jeśli wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie wyjątku  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> jest mniejsza niż zero lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do dzielenia.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które zapewniają opcje do dopasowania.</param>
        <summary>Dzieli wejściowy ciąg na tablicę podciągów w miejscach wynika z określonego wyrażenia regularnego. Opcje zmodyfikować operacji dopasowywania.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg przy ogranicznik ustaleniami wyrażenia regularnego zamiast zestawu znaków. Ten ciąg jest dzielony dowolną liczbę razy. Jeśli separator nie zostanie znaleziony, zwracana wartość zawiera jeden element, którego wartość jest oryginalnym `input` ciągu.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Skompilowane wyrażenia regularne używanym w wywołaniach statyczne <xref:System.Text.RegularExpressions.Regex.Split%2A> metody są automatycznie buforowane. Do zarządzania przez czas ich istnienia skompilowane wyrażenia regularnego samodzielnie, użyj wystąpienia <xref:System.Text.RegularExpressions.Regex.Split%2A> metody.  
  
 Jeśli wiele dopasowań sąsiadujących ze sobą, ciągiem pustym są wstawiane do tablicy. Na przykład podzielić ciąg na pojedynczy łącznik powoduje, że zwracana tablica do uwzględnienia w miejscu, gdzie znajdują się dwóch sąsiadujących ze sobą łącznikach ciągiem pustym.  
  
 Jeśli dopasowanie znajduje się na początku lub końca ciągu wejściowego, ciąg pusty jest dołączony na początku lub końca zwrócony tablicy. W poniższym przykładzie użyto wzorzec wyrażenia regularnego `[a-z]+` podzielenie ciągu wejściowego na dowolnym wielkie i małe litery alfabetu. Ponieważ ciąg rozpoczyna się i kończy dopasowania znaki alfabetyczne, wartość elementu imię i nazwisko zwracana tablica jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Jeśli przechwytywanie nawiasy są używane w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażenie any przechwycony tekst jest uwzględniany w wynikowej tablicy ciągów. Na przykład podzielić ciąg "plum gruszkowa" na łącznik umieszczony w nawiasach przechwytywania, zwracana tablica zawiera element ciąg, który zawiera łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego obejmuje wiele zestawów Przechwytywanie nawiasów, zachowanie tej metody zależy od wersji programu .NET Framework. .NET Framework 1.0 i 1.1 Jeśli nie znaleziono dopasowania w pierwszym zestawie Przechwytywanie nawiasów, przechwycony tekst z dodatkowe nawiasy przechwytywania nie wchodzi w zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest także dodawane do zwróconej tablicy. Na przykład następujący kod używa dwóch zestawów Przechwytywanie nawiasów wyodrębnić elementy Data, łącznie z ogranicznikami daty z ciągu daty. Pierwszy zestaw Przechwytywanie nawiasów przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod kompilacji i uruchamiać w ramach programu .NET Framework 1.0 lub 1.1, nie obejmuje znaków ukośnika. Jeśli jest skompilowany i uruchamiana .NET Framework 2.0 lub nowszy, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Jeśli wyrażenie regularne może dopasować pusty ciąg <xref:System.Text.RegularExpressions.Regex.Split%2A> będzie podzielić ciąg na tablicę ciągów znaków pojedynczego, ponieważ ogranicznik pusty ciąg, który znajduje się w każdej lokalizacji.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jest zgłaszany wyjątek, jeśli czas wykonywania operacji podziału przekroczy limit czasu określony dla domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli limit czasu nie jest zdefiniowany w właściwości domeny aplikacji lub wartość limitu czasu wynosi <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Ta metoda upłynie limit czasu po interwału, który jest taki sam, jak domyślny limit czasu domeny aplikacji, w którym ma zostać wywołana metoda. Jeśli nie zdefiniowano wartości limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, metoda który uniemożliwia limit, jest używany. Zalecaną metodą statyczny do dzielenia tekstu w przypadku dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, umożliwiające ustawienie interwału limitu czasu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do dzielenia.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowe połączenie wartości wyliczenia, które zapewniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu, lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> aby wskazać, że metoda powinna nie upłynął limit czasu.</param>
        <summary>Dzieli wejściowy ciąg na tablicę podciągów w miejscach wynika z określonego wyrażenia regularnego. Dodatkowe parametry, określ opcje modyfikujące operacji dopasowywania i limit czasu, jeśli nie znaleziono.</summary>
        <returns>Tablicy ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg przy ogranicznik ustaleniami wyrażenia regularnego zamiast zestawu znaków. Ten ciąg jest dzielony dowolną liczbę razy. Jeśli separator nie zostanie znaleziony, zwracana wartość zawiera jeden element, którego wartość jest oryginalnym `input` ciągu.  
  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Skompilowane wyrażenia regularne używanym w wywołaniach statyczne <xref:System.Text.RegularExpressions.Regex.Split%2A> metody są automatycznie buforowane. Do zarządzania przez czas ich istnienia skompilowane wyrażenia regularnego samodzielnie, użyj wystąpienia <xref:System.Text.RegularExpressions.Regex.Split%2A> metody.  
  
 Jeśli wiele dopasowań sąsiadujących ze sobą, ciągiem pustym są wstawiane do tablicy. Na przykład podzielić ciąg na pojedynczy łącznik powoduje, że zwracana tablica do uwzględnienia w miejscu, gdzie znajdują się dwóch sąsiadujących ze sobą łącznikach ciągiem pustym.  
  
 Jeśli dopasowanie znajduje się na początku lub końca ciągu wejściowego, ciąg pusty jest dołączony na początku lub końca zwrócony tablicy. W poniższym przykładzie użyto wzorzec wyrażenia regularnego `[a-z]+` podzielenie ciągu wejściowego na dowolnym wielkie i małe litery alfabetu. Ponieważ ciąg rozpoczyna się i kończy dopasowania znaki alfabetyczne, wartość elementu imię i nazwisko zwracana tablica jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Jeśli przechwytywanie nawiasy są używane w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażenie any przechwycony tekst jest uwzględniany w wynikowej tablicy ciągów. Na przykład podzielić ciąg "plum gruszkowa" na łącznik umieszczony w nawiasach przechwytywania, zwracana tablica zawiera element ciąg, który zawiera łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego obejmuje wiele zestawów Przechwytywanie nawiasów, zachowanie tej metody zależy od wersji programu .NET Framework. .NET Framework 1.0 i 1.1 Jeśli nie znaleziono dopasowania w pierwszym zestawie Przechwytywanie nawiasów, przechwycony tekst z dodatkowe nawiasy przechwytywania nie wchodzi w zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest także dodawane do zwróconej tablicy. Na przykład następujący kod używa dwóch zestawów Przechwytywanie nawiasów wyodrębnić elementy Data, łącznie z ogranicznikami daty z ciągu daty. Pierwszy zestaw Przechwytywanie nawiasów przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod kompilacji i uruchamiać w ramach programu .NET Framework 1.0 lub 1.1, nie obejmuje znaków ukośnika. Jeśli jest skompilowany i uruchamiana .NET Framework 2.0 lub nowszy, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Jeśli wyrażenie regularne może dopasować pusty ciąg <xref:System.Text.RegularExpressions.Regex.Split%2A> będzie podzielić ciąg na tablicę ciągów znaków pojedynczego, ponieważ ogranicznik pusty ciąg, który znajduje się w każdej lokalizacji.  
  
 `matchTimeout` Parametr określa, jak długo dopasowanie wzorca metody prób znalezienia dopasowania, zanim upłynie limit czasu. Ustawienie limitu czasu uniemożliwia wyrażeń regularnych, które opierają się na nadmiernym wykorzystaniem algorytmu wycofywania wyświetlaniu przestaje odpowiadać podczas przetwarzania danych wejściowych zawierający dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli nie znaleziono, w tym przedziale czasu, metoda wygeneruje <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie zdefiniowane dla domeny aplikacji, w której wykonuje metodę domyślną wartość limitu czasu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  - lub - <paramref name="matchTimeout" /> jest ujemna, zero, lub większa niż około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Więcej informacji na temat limitów czasu znajduje się w sekcji uwag.</exception>
        <block subset="none" type="usage">
          <para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwie sekundy. Jeśli wyłączysz przekroczeń limitu czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednak należy wyłączyć limity czasu tylko w następujących warunkach: — w przypadku wprowadzania przetworzone przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub składa się z tekst statyczny. Obejmuje to tekst, który dynamicznie została wprowadzona przez użytkowników.  — Wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że wydajnie obsługuje on zgodny z systemem innym niż dopasowań, bliskiej zgodny.  -Gdy wzorzec wyrażenia regularnego nie zawiera żadnych elementów języka, mogących powodować nadmiernym wykorzystaniem algorytmu wycofywania, podczas przetwarzania near dopasowania.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Obiekt do wypełnienia informacjami o serializacji.</param>
        <param name="context">Miejsce do przechowywania i pobierania serializacji danych. Ten parametr jest zarezerwowana do użytku w przyszłości.</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu z danych niezbędnych do deserializacji bieżącego <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wzorzec wyrażenia regularnego, który został przekazany do <see langword="Regex" /> konstruktora.</summary>
        <returns>
          <paramref name="pattern" /> Parametr, który został przekazany <see langword="Regex" /> konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementów języka wyrażeń regularnych symbolicznie opisujące ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> jest klasą bazową wyrażeń regularnych utworzone przez <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody. Są skompilowane Użyj wyrażenia regularne <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> implementacji klasy podstawowej. Jeśli wywoływany z klasy pochodnej, <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> metoda zwraca ciąg, który został przekazany do <paramref name="pattern" /> parametr <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> konstruktora klasy, które zostało użyte do definiowania wyrażenia regularnego.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Zawierającej tekst, który można przekonwertować ciągu wejściowego.</param>
        <summary>Konwertuje wszystkie znaki zmienionym w ciągu wejściowym.</summary>
        <returns>Ciąg znaków o zmienionym znaczeniu znaków przekonwertowany do postaci niezmienionym znaczeniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Metoda wykonuje jeden z następujących dwóch przekształcenia:  
  
-   Odwraca ono przekształcania wykonywane przez <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody przez usunięcie znak ucieczki ("\\") każdego znaku wpisywany z metody. Obejmują one \\, *, +,?, &#124;, {, [, (,), ^, $,., # i białe znaki. Ponadto <xref:System.Text.RegularExpressions.Regex.Unescape%2A> metody unescapes zamykającego nawiasu (]) i zamykający nawias klamrowy (}) znaków.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Nie można wycofać ciągu zmienionym doskonale ponieważ nie można wywnioskować, dokładnie znaków, które zostały zmienione znaczenie,  
  
-   Zastępuje reprezentację niedrukowalne znaki z samych znaków. Na przykład zastępuje \a z \x07. Reprezentacje znak, który zastępuje to \a, \b, \e, \n, \r, \f, \t i \v.  
  
 Jeśli <xref:System.Text.RegularExpressions.Regex.Unescape%2A> metody napotka innych sekwencji unikowych, których nie można dokonać konwersji, takich jak \w lub \s zgłasza <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> zawiera nierozpoznaną sekwencję specjalną.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowanych przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Text.RegularExpressions.Regex.Options" /> właściwość zawiera <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opcję; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowanych przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.Text.RegularExpressions.Regex.Options" /> właściwość zawiera <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> opcję; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Interwał limitu czasu do sprawdzenia.</param>
        <summary>Sprawdza, czy interwał limitu czasu znajduje się w dopuszczalnym zakresie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
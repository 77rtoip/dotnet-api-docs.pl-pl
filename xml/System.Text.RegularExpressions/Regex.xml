<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e146e952129c791265f46e0186848c7e5c620543" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68434896" /></Metadata><TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje niezmienne wyrażenie regularne.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Klasa reprezentuje aparat wyrażeń regularnych .NET Framework. Może służyć do szybkiej analizy dużych ilości tekstu w celu znalezienia określonych wzorców znaków; Aby wyodrębnić, edytować, zamienić lub usunąć podciągi tekstowe; i aby dodać wyodrębnione ciągi do kolekcji w celu wygenerowania raportu.  
  
> [!NOTE]
>  Jeśli podstawowy interes polega na sprawdzeniu ciągu przez określenie, czy jest on zgodny z określonym wzorcem, można użyć <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> klasy.  
  
 Aby używać wyrażeń regularnych, należy zdefiniować wzorzec, który ma być identyfikowany w strumieniu tekstowym przy użyciu składni udokumentowanej w [języku wyrażenia regularnego — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Następnie można opcjonalnie utworzyć wystąpienie <xref:System.Text.RegularExpressions.Regex> obiektu. Na koniec wywoływana jest metoda, która wykonuje pewne operacje, takie jak zastępowanie tekstu, który pasuje do wzorca wyrażenia regularnego lub zidentyfikowanie dopasowania do wzorca.  
  
> [!NOTE]
>  W przypadku niektórych typowych wzorców wyrażeń regularnych zobacz [Przykłady wyrażeń regularnych](~/docs/standard/base-types/regular-expression-examples.md). Istnieje również wiele bibliotek online wzorców wyrażeń regularnych, takich jak te w [Regular-Expressions.info](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a>Aby uzyskać więcej informacji o korzystaniu z <xref:System.Text.RegularExpressions.Regex> klasy, zobacz następujące sekcje w tym temacie:  
  
-   [Wyrażenie regularne a Metody ciągów](#regex_vs_string)  
  
-   [Statyczny a Metody wystąpień](#static_vs_instance)  
  
-   [Wykonywanie operacji na wyrażeniach regularnych](#regex_ops)  
  
-   [Definiowanie wartości limitu czasu](#define_timeout)  
  
 Aby uzyskać więcej informacji na temat języka wyrażeń regularnych, zobacz temat [wyrażenie regularne — krótkie odwołanie](~/docs/standard/base-types/regular-expression-language-quick-reference.md) lub pobieranie i drukowanie jednej z następujących broszur:  
  
 [Krótki przewodnik w formacie Word (. docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Krótki przewodnik w formacie PDF (PDF)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Wyrażenie regularne a Metody ciągów  
 <xref:System.String?displayProperty=nameWithType> Klasa zawiera kilka metod wyszukiwania i porównywania, których można użyć do wykonywania dopasowania do wzorca z tekstem. Na przykład <xref:System.String.Contains%2A?displayProperty=nameWithType>metody, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> <xref:System.String.IndexOf%2A?displayProperty=nameWithType> <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType> <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> , i <xref:System.String.StartsWith%2A?displayProperty=nameWithType> określają, czy wystąpienie ciągu zawiera określony podciąg, a metody,, i zwracają początkowy <xref:System.String.EndsWith%2A?displayProperty=nameWithType> Pozycja określonego podciągu w ciągu. Użyj metod <xref:System.String?displayProperty=nameWithType> klasy podczas wyszukiwania określonego ciągu. <xref:System.Text.RegularExpressions.Regex> Użyj klasy podczas wyszukiwania określonego wzorca w ciągu. Aby uzyskać więcej informacji i przykładów, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md).  
  
 [Wróć do uwag](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Statyczny a Metody wystąpień  
 Po zdefiniowaniu wzorca wyrażenia regularnego można przekazać go do aparatu wyrażeń regularnych na jeden z dwóch sposobów:  
  
-   Utworzenie wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu, który reprezentuje wyrażenie regularne. W tym celu należy przekazać wzorzec wyrażenia regularnego do <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> konstruktora. Obiekt jest niezmienny; podczas tworzenia <xref:System.Text.RegularExpressions.Regex> wystąpienia obiektu za pomocą wyrażenia regularnego nie można zmienić wyrażenia regularnego tego obiektu. <xref:System.Text.RegularExpressions.Regex>  
  
-   Dostarczając zarówno wyrażenie regularne, jak i tekst do przeszukiwania do `static` metody (`Shared` w Visual Basic). <xref:System.Text.RegularExpressions.Regex> Dzięki temu można używać wyrażenia regularnego bez jawnego tworzenia <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 Wszystkie <xref:System.Text.RegularExpressions.Regex> metody identyfikacji wzorców obejmują przeciążenia statyczne i wystąpienia.  
  
 Aby można było użyć wzorca, aparat wyrażeń regularnych musi kompilować określony wzorzec. Ponieważ <xref:System.Text.RegularExpressions.Regex> obiekty są niezmienne, jest to jednorazowa procedura, która występuje, <xref:System.Text.RegularExpressions.Regex> gdy wywoływana jest Konstruktor klasy lub metoda statyczna. Aby wyeliminować konieczność wielokrotnego kompilowania pojedynczego wyrażenia regularnego, aparat wyrażeń regularnych buforuje skompilowane wyrażenia regularne używane w wywołaniach metod statycznych. W rezultacie metody dopasowania do wzorca wyrażeń regularnych oferują porównywalną wydajność dla metod statycznych i wystąpień.  
  
> [!IMPORTANT]
>  W .NET Framework wersje 1,0 i 1,1 wszystkie skompilowane wyrażenia regularne, bez względu na to, czy zostały one użyte w przypadku wywołań metod statycznych, czy są buforowane. Począwszy od .NET Framework 2,0, buforowane są tylko wyrażenia regularne używane w wywołaniach metod statycznych.  
  
 Buforowanie może jednak niekorzystnie wpłynąć na wydajność w następujących dwóch przypadkach:  
  
-   W przypadku używania wywołań metod statycznych z dużą liczbą wyrażeń regularnych. Domyślnie aparat wyrażeń regularnych przechowuje w pamięci podręcznej 15 ostatnio używanych statycznych wyrażeń regularnych. Jeśli aplikacja używa więcej niż 15 statycznych wyrażeń regularnych, należy ponownie skompilować niektóre wyrażenia regularne. Aby zapobiec ponownej kompilacji, można zwiększyć <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> właściwość.  
  
-   Podczas tworzenia wystąpienia nowych <xref:System.Text.RegularExpressions.Regex> obiektów z wyrażeniami regularnymi, które zostały wcześniej skompilowane. Na przykład poniższy kod definiuje wyrażenie regularne do lokalizowania zduplikowanych wyrazów w strumieniu tekstowym. Chociaż w przykładzie jest używany pojedyncze wyrażenie regularne, powoduje to utworzenie wystąpienia nowego <xref:System.Text.RegularExpressions.Regex> obiektu w celu przetworzenia każdego wiersza tekstu. Powoduje to ponowną kompilację wyrażenia regularnego przy każdej iteracji pętli.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Aby zapobiec ponownej kompilacji, należy utworzyć wystąpienie pojedynczego <xref:System.Text.RegularExpressions.Regex> obiektu, który jest dostępny dla całego kodu, który go wymaga, jak pokazano w następującym zapisanym przykładzie.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Wróć do uwag](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Wykonywanie operacji na wyrażeniach regularnych  
 Niezależnie od tego <xref:System.Text.RegularExpressions.Regex> , czy zdecydujesz <xref:System.Text.RegularExpressions.Regex> się utworzyć wystąpienie obiektu i wywołać metody, czy wywołać metody statyczne, Klasa oferuje następujące funkcje dopasowania do wzorca:  
  
-   Walidacja dopasowania. Należy wywołać metodę <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> , aby określić, czy jest to dopasowanie.  
  
-   Pobieranie jednego dopasowania. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Match%2A> metodę, aby <xref:System.Text.RegularExpressions.Match> pobrać obiekt, który reprezentuje pierwsze dopasowanie w ciągu lub w części ciągu. Kolejne dopasowania można pobrać, wywołując <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metodę.  
  
-   Pobieranie wszystkich dopasowań. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Matches%2A> metodę, aby <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> pobrać obiekt, który reprezentuje wszystkie dopasowań znalezionych w ciągu lub w części ciągu.  
  
-   Zastąpienie dopasowanego tekstu. Należy wywołać metodę <xref:System.Text.RegularExpressions.Regex.Replace%2A> , aby zastąpić dopasowany tekst. Tekst zastępczy można również zdefiniować za pomocą wyrażenia regularnego. Ponadto niektóre <xref:System.Text.RegularExpressions.Regex.Replace%2A> metody <xref:System.Text.RegularExpressions.MatchEvaluator> zawierają parametr, który umożliwia programistyczne Definiowanie tekstu zastępczego.  
  
-   Tworzenie tablicy ciągów, która jest tworzona z części ciągu wejściowego. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Split%2A> metodę, aby podzielić ciąg wejściowy w pozycjach, które są zdefiniowane przez wyrażenie regularne.  
  
 Oprócz metod <xref:System.Text.RegularExpressions.Regex> dopasowania do wzorca Klasa zawiera kilka metod specjalnych:  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A> Metoda wyprowadza wszystkie znaki, które mogą być interpretowane jako operatory wyrażenia regularnego w wyrażeniu regularnym lub ciągu wejściowym.  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Metoda usuwa te znaki ucieczki.  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Metoda tworzy zestaw, który zawiera wstępnie zdefiniowane wyrażenia regularne. .NET Framework zawiera przykłady tych zestawów specjalnego przeznaczenia w <xref:System.Web.RegularExpressions?displayProperty=nameWithType> przestrzeni nazw.  
  
 [Wróć do uwag](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definiowanie wartości limitu czasu  
 .NET Framework obsługuje w pełni funkcjonalny język wyrażeń regularnych, który zapewnia znaczną moc i elastyczność w dopasowywaniu wzorców. Jednak moc i elastyczność są tańsze: ryzyko niskiej wydajności. Wyrażenia regularne, które działają nieprawidłowo, są Surprisingly łatwo. W niektórych przypadkach operacje wyrażenia regularnego, które opierają się na nadmiernym wycofywaniu, mogą pojawić się, aby przestać odpowiadać podczas przetwarzania tekstu, który niemal pasuje do wzorca wyrażenia regularnego. Aby uzyskać więcej informacji na temat aparatu wyrażeń regularnych .NET Framework, zobacz [Szczegóły zachowania wyrażenia regularnego](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Aby uzyskać więcej informacji na temat nadmiernego wycofywania [, zobacz](~/docs/standard/base-types/backtracking-in-regular-expressions.md)wycofywanie.  
  
 Począwszy od, można zdefiniować interwał limitu czasu dla dopasowania wyrażenia regularnego. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Jeśli aparat wyrażeń regularnych nie może zidentyfikować dopasowania w tym przedziale czasu, Operacja dopasowania zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek. W większości przypadków zapobiega to marnowaniu mocy obliczeniowej przez aparat wyrażeń regularnych przez próbę dopasowania tekstu, który niemal pasuje do wzorca wyrażenia regularnego. Może jednak wskazywać, że interwał limitu czasu jest zbyt niski lub że bieżące obciążenie maszynowe spowodowało całkowite obniżenie wydajności.  
  
 Sposób obsługi wyjątku zależy od przyczyny wyjątku. Jeśli wystąpi wyjątek, ponieważ interwał limitu czasu jest zbyt niski lub nadmierne obciążenie maszynowe, można zwiększyć interwał limitu czasu i ponownie wykonać operację dopasowywania. Jeśli wystąpi wyjątek, ponieważ wyrażenie regularne polega na nadmiernym wycofywaniu, można założyć, że dopasowanie nie istnieje, a opcjonalnie można rejestrować informacje, które pomogą Ci zmodyfikować wzorzec wyrażenia regularnego.  
  
 Można ustawić interwał limitu czasu, wywołując <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor podczas tworzenia wystąpienia obiektu wyrażenia regularnego. W przypadku metod statycznych można ustawić interwał limitu czasu, wywołując Przeciążenie metody `matchTimeout` zgodnej z parametrem. Jeśli wartość limitu czasu nie zostanie ustawiona jawnie, domyślna wartość limitu czasu jest określana w następujący sposób:  
  
-   Użycie wartości limitu czasu całej aplikacji (jeśli taka istnieje). Może to być dowolna wartość limitu czasu, która ma zastosowanie do domeny aplikacji, w <xref:System.Text.RegularExpressions.Regex> której tworzony jest obiekt lub wywołanie metody statycznej. Możesz ustawić wartość limitu czasu całej aplikacji, wywołując <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> metodę, aby przypisać ciąg reprezentujący <xref:System.TimeSpan> wartość do właściwości "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Przy użyciu wartości <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, jeśli nie została ustawiona wartość limitu czasu dla całej aplikacji.  
  
> [!IMPORTANT]
>  Zalecamy ustawienie wartości limitu czasu we wszystkich operacjach dopasowania do wzorca wyrażenia regularnego. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md).  
  
 [Wróć do uwag](#remarks)  
  
   
  
## Examples  
 Poniższy przykład używa wyrażenia regularnego, aby sprawdzić powtórzone wystąpienia wyrazów w ciągu. Wyrażenie `\b(?<word>\w+)\s+(\k<word>)\b` regularne może być interpretowane jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpocznij dopasowanie na granicy wyrazu.|  
|`(?<word>\w+)`|Dopasowuje jeden lub więcej znaków wyrazu do granicy słowa. Nazwij tę przechwyconą grupę `word`.|  
|`\s+`|Dopasowuje co najmniej jeden znak odstępu.|  
|`(\k<word>)`|Dopasowuje przechwyconą grupę o `word`nazwie.|  
|`\b`|Dopasowuje granicę wyrazu.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 Poniższy przykład ilustruje użycie wyrażenia regularnego w celu sprawdzenia, czy ciąg reprezentuje wartość walutową, czy ma poprawny format do reprezentowania wartości walutowej. W takim przypadku wyrażenie regularne <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>jest kompilowane dynamicznie z właściwości, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> dla bieżącej kultury użytkownika. Jeśli bieżącą kulturą systemu jest EN-US, wynikiem wyrażenia regularnego jest `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. To wyrażenie regularne może być interpretowane jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Zacznij od początku ciągu.|  
|`\s*`|Dopasowanie do zera lub większej liczby znaków odstępu.|  
|`[\+-]?`|Dopasowanie do zera lub jednego wystąpienia znaku dodatniego lub znaku minus.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`\$?`|Dopasowanie do zera lub jednego wystąpienia znaku dolara.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`\d*`|Dopasowanie do zera lub większej liczby cyfr dziesiętnych.|  
|`\.?`|Dopasowuje zero lub jeden symbol separatora dziesiętnego.|  
|`\d{2}?`|Dopasowuje dwa cyfry dziesiętne zero lub jeden raz.|  
|`(\d*\.?\d{2}?){1}`|Dopasowuje wzorzec całkowitych i ułamkowych cyfr oddzielonych symbolem przecinka dziesiętnego co najmniej jeden raz.|  
|`$`|Dopasowuje koniec ciągu.|  
  
 W tym przypadku wyrażenie regularne zakłada, że prawidłowy ciąg waluty nie zawiera symboli separatora grup i nie ma cyfr ułamkowych ani liczby cyfr ułamkowych zdefiniowanych przez <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> Właściwość Current Culture.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Ze względu na to, że wyrażenie regularne w tym przykładzie jest kompilowane dynamicznie, nie wiemy w czasie projektowania, czy symbol waluty bieżącej kultury, znak dziesiętny czy znaki dodatnie i ujemne mogą być nieprawidłowo interpretowane przez aparat wyrażeń regularnych. Operatory języka wyrażeń. Aby zapobiec błędnej interpretacji, przykład przekazuje każdy dynamicznie wygenerowany ciąg do <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody.  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Text.RegularExpressions.Regex" /> Klasa jest niezmienna (tylko do odczytu) i bezpieczna wątkowo. <see cref="T:System.Text.RegularExpressions.Regex" />obiekty mogą być tworzone w dowolnym wątku i udostępniane między wątkami. Aby uzyskać więcej informacji, zobacz [bezpieczeństwo wątków](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">.NET Framework — Wyrażenia regularne</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx">Wyrażenia regularne — krótkie odwołanie (pobieranie w formacie programu Word)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf">Wyrażenia regularne — krótkie odwołanie (pobieranie w formacie PDF)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że ten konstruktor jest chroniony; może być wywoływana tylko przez klasy pochodne od <xref:System.Text.RegularExpressions.Regex> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.RegularExpressions.Regex" /> klasy dla określonego wyrażenia regularnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz tematy [.NET Framework wyrażenia regularne](~/docs/standard/base-types/regular-expressions.md) i [wyrażenie regularne — krótkie informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md) .  
  
 Wywołanie konstruktora jest równoznaczne z <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> wywołaniem <xref:System.Text.RegularExpressions.RegexOptions.None> konstruktora z wartością dla `options` argumentu. <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29>  
  
 <xref:System.Text.RegularExpressions.Regex> Obiekt jest niezmienny, co oznacza, że może być używany tylko dla wzorca dopasowania, który definiujesz podczas jego tworzenia. Można go jednak użyć dowolną liczbę razy bez ponownej kompilacji.  
  
 Ten konstruktor tworzy wystąpienie obiektu wyrażenia regularnego, który podejmuje próbę dopasowania znaków alfabetycznych do wielkości liter zdefiniowanych `pattern`w. W przypadku dopasowania bez uwzględniania wielkości liter należy użyć <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia tego konstruktora do utworzenia wystąpienia wyrażenia regularnego, które pasuje do dowolnego wyrazu rozpoczynającego się od liter "a" lub "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Należy zauważyć, że wzorzec wyrażenia regularnego nie może być zgodny z wyrazem "na początku tekstu, ponieważ domyślnie porównania uwzględniają wielkość liter. Przykład porównania bez uwzględniania wielkości liter, można znaleźć w <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> konstruktorze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Ten konstruktor tworzy <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt, który używa domyślnej wartości limitu czasu domeny aplikacji, w której została utworzona. Jeśli wartość limitu czasu nie została zdefiniowana dla domeny aplikacji, <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt używa wartości <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia wykonanie operacji z limitu czasu. Zalecany Konstruktor do tworzenia <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu to <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, który umożliwia ustawienie interwału limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt, który zawiera serializowany wzorzec i <see cref="T:System.Text.RegularExpressions.RegexOptions" /> informacje.</param>
        <param name="context">Miejsce docelowe dla serializacji. (Ten parametr nie jest używany; Określ <see langword="null" />.)</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.RegularExpressions.Regex" /> klasy za pomocą serializowanych danych.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">Wzorzec <paramref name="info" /> zawierający to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" />zawiera nieprawidłową <see cref="T:System.Text.RegularExpressions.RegexOptions" /> flagę.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia modyfikujących wyrażenie regularne.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.RegularExpressions.Regex" /> klasy dla określonego wyrażenia regularnego z opcjami modyfikującymi wzorzec.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz tematy [.NET Framework wyrażenia regularne](~/docs/standard/base-types/regular-expressions.md) i [wyrażenie regularne — krótkie informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md) .  
  
 <xref:System.Text.RegularExpressions.Regex> Obiekt jest niezmienny, co oznacza, że może być używany tylko dla parametrów dopasowania, które definiujesz podczas jego tworzenia. Można go jednak użyć dowolną liczbę razy bez ponownej kompilacji.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia tego konstruktora do utworzenia wystąpienia wyrażenia regularnego, które pasuje do dowolnego wyrazu rozpoczynającego się od liter "a" lub "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Należy zauważyć, że kolekcja Match zawiera wyraz "The", który rozpoczyna tekst, ponieważ `options` parametr ma zdefiniowane porównania bez uwzględniania wielkości liter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />zawiera nieprawidłową flagę.</exception>
        <block subset="none" type="usage"><para>Ten konstruktor tworzy <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt, który używa domyślnej wartości limitu czasu domeny aplikacji, w której została utworzona. Jeśli wartość limitu czasu nie została zdefiniowana dla domeny aplikacji, <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt używa wartości <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia wykonanie operacji z limitu czasu. Zalecany Konstruktor do tworzenia <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu to <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, który umożliwia ustawienie interwału limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia modyfikujących wyrażenie regularne.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> wskazuje, że metoda nie powinna przekroczyć limitu czasu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.RegularExpressions.Regex" /> klasy dla określonego wyrażenia regularnego, z opcjami modyfikującymi wzorzec i wartość określającą, jak długo Metoda dopasowywania wzorców powinna próbować dopasować przed upływem limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz tematy [.NET Framework wyrażenia regularne](~/docs/standard/base-types/regular-expressions.md) i [wyrażenie regularne — krótkie informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md) .  
  
 <xref:System.Text.RegularExpressions.Regex> Obiekt jest niezmienny, co oznacza, że może być używany tylko dla wzorca dopasowania, który definiuje się podczas jego tworzenia. Można go jednak użyć dowolną liczbę razy bez ponownej kompilacji.  
  
 `matchTimeout` Parametr określa, jak długo Metoda dopasowania do wzorca powinna próbować znaleźć dopasowanie przed upływem limitu czasu. Jeśli w tym interwale czasowym nie znaleziono dopasowania, Metoda dopasowania do wzorca zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek. `matchTimeout`zastępuje wszystkie domyślne wartości limitu czasu zdefiniowane dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Metody dopasowywania do wzorca wystąpienia, które obserwują `matchTimeout` interwał limitu czasu, obejmują:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Ustawienie interwału limitu czasu uniemożliwia wyrażenia regularne, które opierają się na nadmiernym wycofywaniu z wyświetlania, aby przestać odpowiadać podczas przetwarzania danych wejściowych zawierających blisko dopasowań. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) [i wycofywania](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Aby ustawić rozsądny limit czasu, należy wziąć pod uwagę następujące czynniki:  
  
-   Długość i złożoność wzorca wyrażenia regularnego. Dłuższe i bardziej złożone wyrażenia regularne wymagają więcej czasu niż krótsze i prostsze.  
  
-   Oczekiwane obciążenie maszynowe. Przetwarzanie zajmuje więcej czasu na systemach, które mają duże wykorzystanie procesora CPU i pamięci.  
  
   
  
## Examples  
 Poniższy przykład wywołuje konstruktora, <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> aby <xref:System.Text.RegularExpressions.Regex> utworzyć wystąpienie obiektu z wartością limitu czasu jednej sekundy. Wzorzec `(a+)+$`wyrażenia regularnego, który dopasowuje co najmniej jedną sekwencję składającą się z co najmniej jednego znaku "a" na końcu wiersza, podlega nadmiernemu śledzeniu. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli jest zgłaszany, przykład zwiększa wartość limitu czasu do wartości maksymalnej wynoszącej trzy sekundy. W przeciwnym razie porzuca próbkę dopasowania do wzorca.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartością.  
  
—lub— 
 <paramref name="matchTimeout" />jest ujemna, równa zero lub większa niż około 24 dni.</exception>
        <block subset="none" type="usage"><para>Zalecamy ustawienie <paramref name="matchTimeout" /> parametru na odpowiednią wartość, na przykład dwie sekundy. Jeśli wyłączysz limity czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych oferuje nieco lepszą wydajność. Należy jednak wyłączyć limity czasu tylko w następujących warunkach: 
— Gdy dane wejściowe przetwarzane przez wyrażenie regularne pochodzą od znanego i zaufanego źródła lub zawierają tekst statyczny. Wyklucza to tekst, który jest dynamicznie wprowadzany przez użytkowników.  
  
-Kiedy wzorzec wyrażenia regularnego został dokładnie przetestowany w celu zapewnienia, że wydajnie obsługuje dopasowania, nie są dopasowań i blisko dopasowań.  
  
-Kiedy wzorzec wyrażenia regularnego nie zawiera elementów języka, które są znane, aby spowodować nadmierne wycofywanie podczas przetwarzania blisko dopasowania.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Nawracanie</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę wpisów w bieżącej statycznej pamięci podręcznej skompilowanych wyrażeń regularnych.</summary>
        <value>Maksymalna liczba wpisów w statycznej pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Klasa utrzymuje wewnętrzną pamięć podręczną skompilowanych wyrażeń regularnych używanych w wywołaniach metod statycznych. Jeśli wartość określona w operacji zestawu jest mniejsza niż bieżący rozmiar pamięci podręcznej, wpisy pamięci podręcznej są odrzucane do momentu, gdy rozmiar pamięci podręcznej będzie równy podanej wartości.  
  
 Domyślnie pamięć podręczna zawiera 15 skompilowanych statycznych wyrażeń regularnych. Aplikacja zwykle nie będzie musiała modyfikować rozmiaru pamięci podręcznej. <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> Użyj właściwości tylko wtedy, gdy chcesz wyłączyć buforowanie lub jeśli masz nietypową dużą pamięć podręczną.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji zestawu jest mniejsza od zera.</exception>
        <block subset="none" type="usage"><para>W .NET Framework przed [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]wyrażeniami regularnymi używanymi w obu wywołaniach metody statycznej i instancji są buforowane. Począwszy od, w pamięci podręcznej są buforowane tylko wyrażenia regularne używane w wywołaniach metod statycznych. [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używany przez <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt wygenerowany <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> przez metodę.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia słownik, który mapuje nazwane grupy przechwytywania na ich wartości indeksu.</summary>
        <value>Słownik, który mapuje nazwane grupy przechwytywania na ich wartości indeksu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że ta właściwość jest chroniona; dostęp do niego można uzyskać tylko z klasy pochodzącej od <xref:System.Text.RegularExpressions.Regex> klasy.  
  
 Operacja ustawiania podejmuje próbę przekonwertowania wartości przypisanej do właściwości do <xref:System.Collections.Hashtable> obiektu; Jeśli ta konwersja nie powiedzie się, <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> wywoła konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość przypisana do <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> właściwości w operacji zestawu wynosi <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używany przez <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt wygenerowany <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> przez metodę.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia słownik, który mapuje numerowane grupy przechwytywania na ich wartości indeksu.</summary>
        <value>Słownik, który mapuje numerowane grupy przechwytywania na ich wartości indeksu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że ta właściwość jest chroniona; dostęp do niego można uzyskać tylko z klasy pochodzącej od <xref:System.Text.RegularExpressions.Regex> klasy.  
  
 Operacja ustawiania podejmuje próbę przekonwertowania wartości przypisanej do właściwości do <xref:System.Collections.Hashtable> obiektu; Jeśli ta konwersja nie powiedzie się, <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> wywoła konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość przypisana do <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> właściwości w operacji zestawu wynosi <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używany przez <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt wygenerowany <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> przez metodę.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używany przez <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt wygenerowany <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> przez metodę.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kompiluje wyrażenia regularne i zapisuje je na dysku w jednym zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

W przypadku platformy .NET Core wywołania `Regex.CompileToAssembly` metody throw a <xref:System.PlatformNotSupportedException>; napisanie zestawu nie jest obsługiwane.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tablica opisująca wyrażenia regularne do skompilowania.</param>
        <param name="assemblyname">Nazwa pliku zestawu.</param>
        <summary>Kompiluje jeden lub więcej określonych <see cref="T:System.Text.RegularExpressions.Regex" /> obiektów do nazwanego zestawu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje zestaw .NET Framework, w którym każde wyrażenie regularne zdefiniowane `regexinfos` w tablicy jest reprezentowane przez klasę. <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> Zazwyczaj Metoda jest wywoływana z oddzielnej aplikacji, która generuje zestaw skompilowanych wyrażeń regularnych. Każde wyrażenie regularne zawarte w zestawie ma następującą charakterystykę:  
  
-   Pochodzi ona od <xref:System.Text.RegularExpressions.Regex> klasy.  
  
-   Jest przypisana w pełni kwalifikowana nazwa, która jest zdefiniowana przez `fullnamespace` parametry `name` i odpowiedniego <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu.  
  
-   Ma domyślny Konstruktor (lub bezparametrowy).  
  
 Zwykle kod, który tworzy wystąpienie i używa skompilowanego wyrażenia regularnego, znajduje się w zestawie lub aplikacji, który jest oddzielony od kodu, który tworzy zestaw.  
  
   
  
## Examples  
 Poniższy przykład tworzy zestaw o nazwie RegexLib. dll. Zestaw zawiera dwa skompilowane wyrażenia regularne. Pierwsze, `Utilities.RegularExpressions.DuplicatedString`, dopasowuje dwa identyczne słowa ciągłe. W drugim, `Utilities.RegularExpressions.EmailAddress`program sprawdza, czy ciąg ma prawidłowy format jako adres e-mail.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 Wyrażenie regularne, które sprawdza ciąg dla zduplikowanych słów, jest następnie tworzone i używane przez Poniższy przykład.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Pomyślne skompilowanie tego drugiego przykładu wymaga odwołania do RegexLib. dll (zestaw utworzony przez pierwszy przykład), który ma zostać dodany do projektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="assemblyname" /> właściwości<see cref="P:System.Reflection.AssemblyName.Name" /> parametru jest ciągiem pustym lub zerowym.  
  
—lub— 
Wzorzec wyrażenia regularnego co najmniej jednego obiektu w <paramref name="regexinfos" /> zawiera nieprawidłową składnię.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" />lub <paramref name="regexinfos" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET Core: Tworzenie zestawu skompilowanych wyrażeń regularnych nie jest obsługiwane.</exception>
        <block subset="none" type="usage"><para>W przypadku programowania w systemie, w którym [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zainstalowano jego wersje, należy określić element docelowy [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> , a następnie użyć metody do utworzenia zestawu zawierającego skompilowane wyrażenia regularne. Próba użycia jednego z wyrażeń regularnych w tym zestawie w systemie, który zgłosił [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] wyjątek. Aby obejść ten problem, można wykonać jedną z następujących czynności: 
-Kompiluj zestaw zawierający skompilowane wyrażenia regularne w systemie, który ma [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] zamiast zainstalowanych nowszych wersji.  
  
— Zamiast wywoływania <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> i pobierania skompilowanego wyrażenia regularnego z zestawu, użyj metod statycznych lub wystąpień <see cref="T:System.Text.RegularExpressions.Regex" /> z <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opcją podczas tworzenia <see cref="T:System.Text.RegularExpressions.Regex" /> wystąpienia obiektu lub wywołaj wyrażenie regularne Metoda dopasowania do wzorca.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilacja i ponowne użycie</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tablica opisująca wyrażenia regularne do skompilowania.</param>
        <param name="assemblyname">Nazwa pliku zestawu.</param>
        <param name="attributes">Tablica, która definiuje atrybuty, które mają zostać zastosowane do zestawu.</param>
        <summary>Kompiluje jeden lub więcej określonych <see cref="T:System.Text.RegularExpressions.Regex" /> obiektów do nazwanego zestawu o określonych atrybutach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje zestaw .NET Framework, w którym każde wyrażenie regularne zdefiniowane `regexinfos` w tablicy jest reprezentowane przez klasę. <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> Zazwyczaj Metoda jest wywoływana z oddzielnej aplikacji, która generuje zestaw skompilowanych wyrażeń regularnych. Każde wyrażenie regularne zawarte w zestawie ma następującą charakterystykę:  
  
-   Pochodzi ona od <xref:System.Text.RegularExpressions.Regex> klasy.  
  
-   Jest przypisana w pełni kwalifikowana nazwa, która jest zdefiniowana przez `fullnamespace` parametry `name` i odpowiedniego <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu.  
  
-   Ma domyślny Konstruktor (lub bezparametrowy).  
  
 Zwykle kod, który tworzy wystąpienie i używa skompilowanego wyrażenia regularnego, znajduje się w zestawie lub aplikacji, który jest oddzielony od kodu, który tworzy zestaw.  
  
 Ponieważ metoda generuje zestaw .NET Framework z wywołania metody zamiast przy użyciu słowa kluczowego definicji klasy określonego języka (na przykład `class` w C# lub `Class`... <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>`End Class` w Visual Basic) nie zezwala na przypisanie atrybutów .NET Framework do zestawu przy użyciu standardowej składni atrybutów języka deweloperskiego. `attributes` Parametr zawiera alternatywną metodę definiowania atrybutów, które są stosowane do zestawu. Dla każdego atrybutu, który ma zostać zastosowany do zestawu, wykonaj następujące czynności:  
  
1.  Utwórz tablicę <xref:System.Type> obiektów reprezentujących typy parametrów konstruktora atrybutu, które chcesz wywołać.  
  
2.  <xref:System.Type> Pobierz obiekt reprezentujący klasę atrybutu, która ma zostać zastosowana do nowego zestawu.  
  
3.  Wywołaj <xref:System.Type> metodę obiektu atrybutu, aby pobrać <xref:System.Reflection.ConstructorInfo> obiekt reprezentujący konstruktora atrybutu, który chcesz wywołać. <xref:System.Type.GetConstructor%2A> Przekaż metodę tablicę obiektów, która reprezentuje typy parametrów konstruktora. <xref:System.Type> <xref:System.Type.GetConstructor%2A>  
  
4.  <xref:System.Object> Utwórz tablicę, która definiuje parametry do przekazania do konstruktora atrybutu.  
  
5.  Utworzenie wystąpienia <xref:System.Reflection.ConstructorInfo> <xref:System.Object> obiektu przez przekazanie jego konstruktora obiektu pobranego w kroku 3 i tablicy utworzonej w kroku 4. <xref:System.Reflection.Emit.CustomAttributeBuilder>  
  
 Następnie można przekazać tablicę tych <xref:System.Reflection.Emit.CustomAttributeBuilder> obiektów zamiast `attributes` parametru do <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy zestaw o nazwie RegexLib. dll i stosuje <xref:System.Reflection.AssemblyTitleAttribute> do niego atrybut. Zestaw zawiera dwa skompilowane wyrażenia regularne. Pierwsze, `Utilities.RegularExpressions.DuplicatedString`, dopasowuje dwa identyczne słowa ciągłe. W drugim, `Utilities.RegularExpressions.EmailAddress`program sprawdza, czy ciąg ma prawidłowy format jako adres e-mail.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Można sprawdzić, czy <xref:System.Reflection.AssemblyTitleAttribute> atrybut został zastosowany do zestawu, sprawdzając jego manifest za pomocą narzędzia do odbicia, takiego jak Ildasm.  
  
 Wyrażenie regularne, które sprawdza ciąg dla zduplikowanych słów, jest następnie tworzone i używane przez Poniższy przykład.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Pomyślne skompilowanie tego drugiego przykładu wymaga odwołania do RegexLib. dll (zestaw utworzony przez pierwszy przykład), który ma zostać dodany do projektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="assemblyname" /> właściwości<see cref="P:System.Reflection.AssemblyName.Name" /> parametru jest ciągiem pustym lub zerowym.  
  
—lub— 
Wzorzec wyrażenia regularnego co najmniej jednego obiektu w <paramref name="regexinfos" /> zawiera nieprawidłową składnię.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" />lub <paramref name="regexinfos" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET Core: Tworzenie zestawu skompilowanych wyrażeń regularnych nie jest obsługiwane.</exception>
        <block subset="none" type="usage"><para>W przypadku programowania w systemie, w którym [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zainstalowano jego wersje, należy określić element docelowy [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> , a następnie użyć metody do utworzenia zestawu zawierającego skompilowane wyrażenia regularne. Próba użycia jednego z wyrażeń regularnych w tym zestawie w systemie, który zgłosił [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] wyjątek. Aby obejść ten problem, można wykonać jedną z następujących czynności: 
-Kompiluj zestaw zawierający skompilowane wyrażenia regularne w systemie, który ma [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] zamiast zainstalowanych nowszych wersji.  
  
— Zamiast wywoływania <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> i pobierania skompilowanego wyrażenia regularnego z zestawu, użyj metod statycznych lub wystąpień <see cref="T:System.Text.RegularExpressions.Regex" /> z <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opcją podczas tworzenia <see cref="T:System.Text.RegularExpressions.Regex" /> wystąpienia obiektu lub wywołaj wyrażenie regularne Metoda dopasowania do wzorca.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilacja i ponowne użycie</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="resourceFile" Type="System.String" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tablica opisująca wyrażenia regularne do skompilowania.</param>
        <param name="assemblyname">Nazwa pliku zestawu.</param>
        <param name="attributes">Tablica, która definiuje atrybuty, które mają zostać zastosowane do zestawu.</param>
        <param name="resourceFile">Nazwa pliku zasobów Win32 do uwzględnienia w zestawie.</param>
        <summary>Kompiluje jeden lub więcej określonych <see cref="T:System.Text.RegularExpressions.Regex" /> obiektów i określony plik zasobów do nazwanego zestawu o określonych atrybutach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method generates a .NET Framework assembly in which each regular expression defined in the `regexinfos` array is represented by a class. Zwykle [\], AssemblyName, CustomAttributeBuilder\<linki XREF: System. Text. RegularExpressions. wyrażenia regularnego. CompileToAssembly% 28System. Text. RegularExpressions. RegexCompilationInfo% 5B% 5D% 2CSystem. odbicie. AssemblyName% 2CSystem. odbicie. Emituj. CustomAttributeBuilder% 5B% 5D% 2CSystem. String% 29 > Metoda jest wywoływana z oddzielnej aplikacji, która generuje zestaw skompilowanych wyrażeń regularnych. Każde wyrażenie regularne zawarte w zestawie ma następującą charakterystykę:  
  
-   Pochodzi ona od <xref:System.Text.RegularExpressions.Regex> klasy.  
  
-   Jest przypisana w pełni kwalifikowana nazwa, która jest zdefiniowana przez `fullnamespace` parametry `name` i odpowiedniego <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu.  
  
-   Ma domyślny Konstruktor (lub bezparametrowy).  
  
 Zwykle kod, który tworzy wystąpienie i używa skompilowanego wyrażenia regularnego, znajduje się w zestawie lub aplikacji, który jest oddzielony od kodu, który tworzy zestaw.  
  
 Ponieważ metoda generuje zestaw .NET Framework z wywołania metody zamiast przy użyciu słowa kluczowego definicji klasy określonego języka (na przykład `class` w C# lub `Class`... <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>`End Class` w Visual Basic) nie zezwala na przypisanie atrybutów .NET Framework do zestawu przy użyciu standardowej składni atrybutów języka deweloperskiego. `attributes` Parametr zawiera alternatywną metodę definiowania atrybutów, które są stosowane do zestawu. Dla każdego atrybutu, który ma zostać zastosowany do zestawu, wykonaj następujące czynności:  
  
1.  Utwórz tablicę <xref:System.Type> obiektów reprezentujących typy parametrów konstruktora atrybutu, które chcesz wywołać.  
  
2.  <xref:System.Type> Pobierz obiekt reprezentujący klasę atrybutu, która ma zostać zastosowana do nowego zestawu.  
  
3.  Wywołaj <xref:System.Type> metodę obiektu atrybutu, aby pobrać <xref:System.Reflection.ConstructorInfo> obiekt reprezentujący konstruktora atrybutu, który chcesz wywołać. <xref:System.Type.GetConstructor%2A> Przekaż metodę tablicę obiektów, która reprezentuje typy parametrów konstruktora <xref:System.Type> <xref:System.Type.GetConstructor%2A>  
  
4.  <xref:System.Object> Utwórz tablicę, która definiuje parametry do przekazania do konstruktora atrybutu.  
  
5.  Utworzenie wystąpienia <xref:System.Reflection.ConstructorInfo> <xref:System.Object> obiektu przez przekazanie jego konstruktora obiektu pobranego w kroku 3 i tablicy utworzonej w kroku 4. <xref:System.Reflection.Emit.CustomAttributeBuilder>  
  
 Następnie można przekazać <xref:System.Reflection.Emit.CustomAttributeBuilder> tablicę tych obiektów zamiast `attributes` parametru do [\], AssemblyName, CustomAttributeBuilder\<linki XREF: System. Text. RegularExpressions. wyrażenia regularnego. CompileToAssembly% 28System. Text. RegularExpressions. RegexCompilationInfo% 5B% 5D% 2CSystem. odbicie. AssemblyName% 2CSystem. odbicie. Emituj. CustomAttributeBuilder% 5B% 5D% 2CSystem. String% 29 > metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="assemblyname" /> właściwości<see cref="P:System.Reflection.AssemblyName.Name" /> parametru jest ciągiem pustym lub zerowym.  
  
—lub— 
Wzorzec wyrażenia regularnego co najmniej jednego obiektu w <paramref name="regexinfos" /> zawiera nieprawidłową składnię.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" />lub <paramref name="regexinfos" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="resourceFile" /> Parametr określa nieprawidłowy plik zasobów Win32.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku określonego <paramref name="resourceFile" /> przez parametr.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET Core: Tworzenie zestawu skompilowanych wyrażeń regularnych nie jest obsługiwane.</exception>
        <block subset="none" type="usage"><para>W przypadku programowania w systemie, w którym [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zainstalowano jego wersje, należy określić element docelowy [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> , a następnie użyć metody do utworzenia zestawu zawierającego skompilowane wyrażenia regularne. Próba użycia jednego z wyrażeń regularnych w tym zestawie w systemie, który zgłosił [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] wyjątek. Aby obejść ten problem, można wykonać jedną z następujących czynności: 
-Kompiluj zestaw zawierający skompilowane wyrażenia regularne w systemie, który ma [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] zamiast zainstalowanych nowszych wersji.  
  
— Zamiast wywoływania <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> i pobierania skompilowanego wyrażenia regularnego z zestawu, użyj metod statycznych lub wystąpień <see cref="T:System.Text.RegularExpressions.Regex" /> z <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opcją podczas tworzenia <see cref="T:System.Text.RegularExpressions.Regex" /> wystąpienia obiektu lub wywołaj wyrażenie regularne Metoda dopasowania do wzorca.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilacja i ponowne użycie</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg wejściowy, który zawiera tekst do przekonwertowania.</param>
        <summary>Wyprowadza minimalny zestaw znaków (\\, *, +,?, |, {, [, (,), ^, $,., # i białe znaki), zastępując je kodami ucieczki. Powoduje to, że aparat wyrażeń regularnych interpretuje te znaki dosłownie, a nie jako metaznaki.</summary>
        <returns>Ciąg znaków z metaznakami przekonwertowanymi na postać ucieczki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A>Konwertuje ciąg w taki sposób, że aparat wyrażeń regularnych interpretuje wszystkie metaznaki, które mogą zawierać jako literały znakowe. Rozważmy na przykład wyrażenie regularne przeznaczone do wyodrębniania komentarzy, które są rozdzielane przez proste otwierające i zamykające nawiasy klamrowe ([i]) z tekstu. W poniższym przykładzie wyrażenie regularne "[(. *?)]" jest interpretowane jako klasa znaku. Zamiast dopasowywania komentarzy osadzonych w tekście wejściowym wyrażenie regularne dopasowuje się do każdego otwierającego lub zamykającego nawiasu, kropki, gwiazdki lub znaku zapytania.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Jeśli jednak nawias otwierający zostanie zmieniony przez przekazanie go do <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody, wyrażenie regularne powiedzie się w dopasowaniu komentarzy, które są osadzone w ciągu wejściowym. Ilustruje to poniższy przykład.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 W wyrażeniu regularnym, które jest zdefiniowane za pomocą tekstu statycznego, znaki, które mają być interpretowane dosłownie, a nie jako metaznaki, można zmienić, poprzedzając je symbolem\\ukośnika odwrotnego (), <xref:System.Text.RegularExpressions.Regex.Escape%2A> a także wywołując metodę. W wyrażeniu regularnym zdefiniowanym dynamicznie przy użyciu znaków, które nie są znane w czasie projektowania, <xref:System.Text.RegularExpressions.Regex.Escape%2A> wywołanie metody jest szczególnie ważne, aby upewnić się, że aparat wyrażeń regularnych interpretuje poszczególne znaki jako literały niż jako metaznaki.  
  
> [!NOTE]
>  Jeśli wzorzec wyrażenia regularnego zawiera znak numeru (#) lub literał znaków odstępu, muszą one zostać zmienione, jeśli tekst wejściowy jest analizowany z <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> włączoną opcją.  
  
 Podczas <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody specjalne proste otwierający nawias kwadratowy ([) i otwieranie znaki nawiasu klamrowego ({), jego nie escape odpowiednie zamknięcia znaków (] i}). W większości przypadków anulowanie nie jest konieczne. Jeśli nawias zamykający lub nawias klamrowy nie jest poprzedzony odpowiadającym mu znakiem otwierającym, aparat wyrażeń regularnych interpretuje go dosłownie. Jeśli nawias otwierający lub klamrowy jest interpretowany jako metaznak, aparat wyrażeń regularnych interpretuje pierwszy odpowiedni znak zamykający jako metaznak. Jeśli nie jest to wymagane zachowanie, nawias zamykający lub nawias klamrowy powinien być zmieniony przez jawnie oczekiwany znak ukośnika odwrotnego\\(). Ilustracja zapoznaj się z sekcją przykładową.  
  
   
  
## Examples  
 Poniższy przykład wyodrębnia Komentarze z tekstu. Przyjęto założenie, że komentarze są rozdzielane symbolem początkowego komentarza i symbolem komentarza końcowego, który jest wybierany przez użytkownika. Ponieważ symbole komentarzy mają być interpretowane dosłownie, są one przesyłane do <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody, aby upewnić się, że nie mogą być interpretowane jako metaznaki. Ponadto przykład jawnie sprawdza, czy symbol komentarza końcowego wprowadzony przez użytkownika jest nawiasem zamykającym (]) lub nawiasem klamrowym (}). Jeśli jest, znak ukośnika odwrotnego (\\) jest poprzedzony nawiasem lub nawiasem klamrowym, tak aby był interpretowany dosłownie. Należy zauważyć, że w przykładzie używa <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> się również kolekcji do wyświetlania tylko komentarzy, a nie komentarza razem z symbolami otwierającymi i zamykającymi komentarzy.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">Znaki specjalne w wyrażeniach regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używany przez <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt wygenerowany <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> przez metodę.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten element członkowski przesłania element <see cref="M:System.Object.Finalize" />, a dokładniejsza dokumentacja może być dostępna w tym temacie.

Umożliwia próbę zwolnienia zasobów i wykonywanie innych operacji czyszczenia <see cref="T:System.Object" /> przed odzyskiwaniem danych przez wyrzucanie elementów bezużytecznych. <see cref="T:System.Object" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę nazw grup przechwytywania dla wyrażenia regularnego.</summary>
        <returns>Tablica ciągów nazw grup.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja nazw grup zawiera zestaw ciągów używanych do nazywania grup przechwytywania w wyrażeniu. Nawet jeśli grupy przechwytywania nie są jawnie nazwane, są automatycznie przypisywane nazwy liczbowe ("0", "1", "2", "3" itd.). Nazwa grupy "0" reprezentuje wszystkie teksty zgodne z wzorcem wyrażenia regularnego. Numerowane grupy poprzedzają jawnie nazwane grupy w kolekcji, a nazwane grupy są wyświetlane w kolejności, w której są zdefiniowane we wzorcu wyrażenia regularnego.  
  
 Aby określić liczbę grup <xref:System.Array.Length%2A> w wyrażeniu regularnym, można użyć właściwości tablicy zwracanej przez tę metodę.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano metodę ogólnego przeznaczenia `ShowMatches` , która wyświetla nazwy grup wyrażeń regularnych i ich dopasowany tekst.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 W takim przypadku wzorzec `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` wyrażenia regularnego jest przeznaczony do analizowania prostych zdań i do identyfikowania pierwszego wyrazu, ostatniego wyrazu i kończącego znak interpunkcyjny. W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`(?<FirstWord>\w+)`|Dopasowuje co najmniej jeden znak słowa. Jest `FirstWord` to nazwana grupa.|  
|\s?|Dopasowanie do zera lub jednego znaku odstępu.|  
|(\w+)|Dopasowuje co najmniej jeden znak słowa. Jest to druga grupa przechwytywania.|  
|\s|Dopasowuje znak odstępu.|  
|((\w+)\s)*|Dopasowanie do zera lub większej liczby wystąpień jednego lub większej liczby znaków słowa, po których następuje biały znak. Jest to pierwsza grupa przechwytywania.|  
|(? \<LastWord > \w +)?|Dopasowanie do zera lub jednego wystąpienia jednego lub więcej znaków wyrazu. Jest `LastWord` to nazwana grupa.|  
|(? \<Interpunkcja > \p{po})|Dopasowuje znak, którego kategoria Unicode jest interpunkcja, inne. Jest `Punctuation` to nazwana grupa.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Konstrukcje grupujące w wyrażeniach regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę liczb grup przechwytywania, które odpowiadają nazwom grup w tablicy.</summary>
        <returns>Tablica liczb całkowitych numerów grup.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można uzyskać dostęp do zarówno nienazwanych, jak i nazwanych grup przechwytywania przez numer. Grupy bez nazwy są numerowane od lewej do prawej, począwszy od 1. (Grupa przechwytywania w indeksie 0 (zero) reprezentuje dopasowanie jako całość.)  Nazwane grupy są następnie numerowane od lewej do prawej, począwszy od liczby, która jest większa niż liczba grup przechwytywania nienazwanych.  
  
 Odwoływanie się do grupy według jej numeru zamiast według nazwy ciągu może zapewnić szybszy dostęp.  
  
   
  
## Examples  
 Poniższy przykład definiuje wyrażenie regularne, `\b((?<word>\w+)\s*)+(?<end>[.?!])`które pasuje do zdania. Wyrażenie regularne zawiera trzy grupy przechwytywania: nienazwana Grupa, która przechwytuje pojedyncze słowo wraz ze znakiem spacji, który może być umieszczony na nim. Grupa o nazwie `word` , która przechwytuje poszczególne słowa w zdaniu; oraz grupę o `end` nazwie, która przechwytuje dane interpunkcyjne kończące zdanie. Przykład wywołuje metodę, <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> aby pobrać numery wszystkich grup przechwytywania, a następnie wyświetla ich przechwycony ciąg. Ponadto <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Metoda służy do wskazywania, czy konkretna Grupa numerowana odnosi się do nazwanej grupy.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Wzorzec wyrażenia regularnego jest interpretowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`(?<word>\w+)`|Dopasowuje jeden lub więcej znaków słowa i przypisuje dopasowane ciągi do grupy o `word`nazwie.|  
|`\s*`|Dopasowanie do zera lub większej liczby znaków odstępu.|  
|`((?<word>\w+)\s*)`|`word` Przypisz przechwyconą grupę, a następnie wszystkie przechwycone znaki odstępu do pierwszej przechwyconej grupy.|  
|`((?<word>\w+)\s*)+`|Dopasowuje wzorzec jednego lub więcej znaków słowa, po których następuje spacja jeden lub więcej razy.|  
|`(?<end>[.?!])`|Dopasowanie do kropki, znaku zapytania lub wykrzyknika. Przypisz dopasowany znak do `end` grupy przechwytywania.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Konstrukcje grupujące w wyrażeniach regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Numer grupy do przekonwertowania na odpowiadającą nazwę grupy.</param>
        <summary>Pobiera nazwę grupy, która odnosi się do określonego numeru grupy.</summary>
        <returns>Ciąg, który zawiera nazwę grupy skojarzoną z określonym numerem grupy. Jeśli nazwa grupy nie jest zgodna z <paramref name="i" />, metoda zwraca. <see cref="F:System.String.Empty" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wzorzec wyrażenia regularnego może zawierać nazwane lub numerowane grupy przechwytywania, które odróżnić podwyrażenia w ramach dopasowania do wzorca. Numerowane grupy są rozdzielane przez składnię**(Podwyrażenie) i są przypisywane numery na podstawie ich kolejności w wyrażeniu regularnym. Nazwane grupy są rozdzielane przez składnię (?`<` *Nazwa* Podwyrażenie) lub (? ' ** `>` *Nazwa*"*subexpression*", gdzie *name* to nazwa, za pomocą której będzie identyfikowane Podwyrażenie. (Aby uzyskać więcej informacji, zobacz [grupowanie konstrukcji](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)). <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Metoda identyfikuje zarówno nazwane grupy, jak i grupy numerowane według ich pozycji porządkowej w wyrażeniu regularnym. Pozycja porządkowa zero zawsze reprezentuje całe wyrażenie regularne. Wszystkie numerowane grupy są następnie zliczane przed nazwanymi grupami, niezależnie od ich rzeczywistej pozycji we wzorcu wyrażenia regularnego.  
  
 Jeśli `i` jest liczbą nazwanej grupy, metoda zwraca nazwę grupy. Jeśli `i` jest to liczba nienazwanych grup, metoda zwraca ciąg reprezentujący liczbę. Na przykład jeśli `i` jest 1, metoda zwraca wartość "1". Jeśli `i` nie jest liczbą grupy przechwytywania, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 W przypadku znalezienia dopasowania do wzorca wartość zwrócona przez tę metodę może następnie zostać użyta do pobrania <xref:System.Text.RegularExpressions.Group> obiektu, który reprezentuje przechwyconą grupę <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> z właściwości. Obiekt jest zwracany <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> przez właściwość. <xref:System.Text.RegularExpressions.GroupCollection>  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wzorzec wyrażenia regularnego, który jest zgodny z wierszem adresu zawierającym nazwę miasta USA, nazwę stanu i kod pocztowy. W przykładzie zastosowano <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> metodę w celu pobrania nazw grup przechwytywania. Następnie używa tych nazw do pobrania odpowiednich przechwyconych grup dla dopasowania.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Wzorzec wyrażenia regularnego jest definiowany przez następujące wyrażenie:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Dopasowuje jeden lub więcej znaków alfabetycznych lub białych. Przypisz tę przechwyconą grupę `city`nazwę.|  
|`,`|Dopasowuje przecinek (,), po którym następuje znak odstępu.|  
|`(?<state>[A-Za-z]{2})`|Dopasowuje dwa znaki alfabetu. Przypisz tę przechwyconą grupę `state`nazwę. Po tej grupie powinien następować znak odstępu.|  
|`(?<zip>\d{5}(-\d{4})?)`|Dopasowuje pięć cyfr, po których następuje zero lub jedno wystąpienie łącznika, po którym następuje cztery cyfry. Przypisz tę przechwyconą grupę `zip`nazwę.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Konstrukty grupujące</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa grupy do przekonwertowania na odpowiedni numer grupy.</param>
        <summary>Zwraca numer grupy, który odpowiada określonej nazwie grupy.</summary>
        <returns>Numer grupy, który odpowiada określonej nazwie grupy lub-1, jeśli <paramref name="name" /> nie jest prawidłową nazwą grupy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wzorzec wyrażenia regularnego może zawierać nazwane lub numerowane grupy przechwytywania, które odróżnić podwyrażenia w ramach dopasowania do wzorca. Numerowane grupy są rozdzielane przez składnię**(Podwyrażenie) i są przypisywane numery na podstawie ich kolejności w wyrażeniu regularnym. Nazwane grupy są rozdzielane przez składnię (?`<` *Nazwa* Podwyrażenie) lub (? ' ** `>` *Nazwa*"*subexpression*", gdzie *name* to nazwa, za pomocą której będzie identyfikowane Podwyrażenie. (Aby uzyskać więcej informacji, zobacz [grupowanie konstrukcji](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)). <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> Metoda identyfikuje zarówno nazwane grupy, jak i grupy numerowane według ich pozycji porządkowej w wyrażeniu regularnym. Pozycja porządkowa zero zawsze reprezentuje całe wyrażenie regularne. Wszystkie numerowane grupy są następnie zliczane przed nazwanymi grupami, niezależnie od ich rzeczywistej pozycji we wzorcu wyrażenia regularnego.  
  
 Jeśli `name` jest to ciąg reprezentujący numer grupy, który jest obecny we wzorcu wyrażenia regularnego, metoda zwraca tę liczbę. Jeśli `name` odpowiada nazwanej grupie przechwytywania, która jest obecna we wzorcu wyrażenia regularnego, metoda zwraca swój odpowiedni numer. W porównaniu `name` z nazwą grupy jest rozróżniana wielkość liter. Jeśli `name` nie odpowiada nazwie grupy przechwytywania lub ciągowi reprezentującemu liczbę grup przechwytywania, metoda zwróci wartość-1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Konstrukty grupujące</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że operacja dopasowania do wzorca nie powinna przekraczać limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor klasy i wiele statycznych metod dopasowywania <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> używają stałej, aby wskazać, że próba znalezienia dopasowania do wzorca nie powinna przekroczyć limitu czasu. <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
> [!WARNING]
>  Ustawienie wartości limitu czasu aparatu wyrażeń regularnych w taki sposób, <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> aby można było spowodować, że wyrażenia regularne, które opierają się na nadmiernej śledzeniu, mają przestać odpowiadać podczas przetwarzania tekstu, który niemal pasuje do wzorca wyrażenia regularnego. Jeśli wyłączysz limity czasu, upewnij się, że wyrażenie regularne nie polega na nadmiernym wycofywaniu i że obsługuje tekst, który niemal pasuje do wzorca wyrażenia regularnego.  
>   
>  Aby uzyskać więcej informacji o obsłudze wycofywania, [Zobacz](~/docs/standard/base-types/backtracking-in-regular-expressions.md)wycofywanie.  
  
 Stała może być podana jako wartość `matchTimeout` argumentu następujących elementów członkowskich: <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używany przez <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt wygenerowany <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> przez metodę.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Odwołania zostały już zainicjowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Maksymalny czas, jaki może upłynąć w operacji dopasowania do wzorca przed przekroczeniem limitu czasu operacji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy wyrażenie regularne wyszukuje dopasowanie w ciągu wejściowym.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <summary>Wskazuje, czy wyrażenie regularne określone w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktorze znajduje dopasowanie w określonym ciągu wejściowym.</summary>
        <returns><see langword="true" />Jeśli wyrażenie regularne znajdzie dopasowanie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Metoda jest zwykle używana do walidacji ciągu lub w celu upewnienia się, że ciąg jest zgodny z określonym wzorcem bez pobierania tego ciągu do późniejszego manipulowania. Jeśli chcesz określić, czy jeden lub więcej ciągów pasuje do wzorca wyrażenia regularnego, a następnie pobierz je do późniejszego manipulowania <xref:System.Text.RegularExpressions.Regex.Match%2A> , <xref:System.Text.RegularExpressions.Regex.Matches%2A> Wywołaj metodę lub.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji dopasowywania przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub wartość limitu czasu to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> metody, aby określić, czy ciąg jest prawidłowym numerem części. W wyrażeniu regularnym przyjęto, że numer części ma określony format składający się z trzech zestawów znaków oddzielonych łącznikiem. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znak alfanumeryczny, po którym następuje znak alfanumeryczny. Drugi zestaw, który składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestaw, który składa się z czterech znaków, musi zawierać trzy znaki numeryczne, po których następuje znak alfanumeryczny.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Wzorzec wyrażenia regularnego:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpocznij dopasowanie na początku wiersza.|  
|`[a-zA-Z0-9]`|Dopasowuje pojedynczy znak alfabetyczny`a` ( `z` przez `A` lub `Z`przez) lub znak liczbowy.|  
|`\d{2}`|Dopasowuje dwa znaki numeryczne.|  
|`[a-zA-Z0-9]`|Dopasowuje pojedynczy znak alfabetyczny`a` ( `z` przez `A` lub `Z`przez) lub znak liczbowy.|  
|`-`|Dopasowuje łącznik.|  
|`\d{3}`|Dopasowuje dokładnie trzy znaki numeryczne.|  
|`(-\d{3}){2}`|Znajdź łącznik, po którym następują trzy znaki numeryczne i dopasowuje dwa wystąpienia tego wzorca.|  
|`[a-zA-Z0-9]`|Dopasowuje pojedynczy znak alfabetyczny`a` ( `z` przez `A` lub `Z`przez) lub znak liczbowy.|  
|`$`|Zakończ dopasowanie na końcu wiersza.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="startat">Pozycja znaku, w której ma zostać rozpoczęte wyszukiwanie.</param>
        <summary>Wskazuje, czy wyrażenie regularne określone w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktorze znajduje dopasowanie w określonym ciągu wejściowym, zaczynając od określonej pozycji początkowej w ciągu.</summary>
        <returns><see langword="true" />Jeśli wyrażenie regularne znajdzie dopasowanie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Metoda jest zwykle używana do walidacji ciągu lub w celu upewnienia się, że ciąg jest zgodny z określonym wzorcem bez pobierania tego ciągu do późniejszego manipulowania. Jeśli chcesz określić, czy jeden lub więcej ciągów pasuje do wzorca wyrażenia regularnego, a następnie pobierz je do późniejszego manipulowania <xref:System.Text.RegularExpressions.Regex.Match%2A> , <xref:System.Text.RegularExpressions.Regex.Matches%2A> Wywołaj metodę lub.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji dopasowywania przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub wartość limitu czasu to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> metody, aby określić, czy ciąg jest prawidłowym numerem części. Wyszukuje numer części, który następuje po dwukropku (:) znak w ciągu. Metoda jest używana do określenia pozycji dwukropka, która jest następnie przenoszona <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> do metody. <xref:System.String.IndexOf%28System.Char%29> W wyrażeniu regularnym przyjęto, że numer części ma określony format składający się z trzech zestawów znaków oddzielonych łącznikiem. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znak alfanumeryczny, po którym następuje znak alfanumeryczny. Drugi zestaw, który składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestaw, który składa się z czterech znaków, musi zawierać trzy znaki numeryczne, po których następuje znak alfanumeryczny.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Wzorzec wyrażenia regularnego:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Dopasowuje pojedynczy znak alfabetyczny`a` ( `z` przez `A` lub `Z`przez) lub znak liczbowy.|  
|`\d{2}`|Dopasowuje dwa znaki numeryczne.|  
|`[a-zA-Z0-9]`|Dopasowuje pojedynczy znak alfabetyczny`a` ( `z` przez `A` lub `Z`przez) lub znak liczbowy.|  
|`-`|Dopasowuje łącznik.|  
|`\d{3}`|Dopasowuje dokładnie trzy znaki numeryczne.|  
|`(-\d{3}){2}`|Znajdź łącznik, po którym następują trzy znaki numeryczne i dopasowuje dwa wystąpienia tego wzorca.|  
|`[a-zA-Z0-9]`|Dopasowuje pojedynczy znak alfabetyczny`a` ( `z` przez `A` lub `Z`przez) lub znak liczbowy.|  
|`$`|Zakończ dopasowanie na końcu wiersza.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Wskazuje, czy określone wyrażenie regularne znajduje dopasowanie w określonym ciągu wejściowym.</summary>
        <returns><see langword="true" />Jeśli wyrażenie regularne znajdzie dopasowanie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Metoda jest zwykle używana do walidacji ciągu lub w celu upewnienia się, że ciąg jest zgodny z określonym wzorcem bez pobierania tego ciągu do późniejszego manipulowania. Jeśli chcesz określić, czy jeden lub więcej ciągów pasuje do wzorca wyrażenia regularnego, a następnie pobierz je do późniejszego manipulowania <xref:System.Text.RegularExpressions.Regex.Match%2A> , <xref:System.Text.RegularExpressions.Regex.Matches%2A> Wywołaj metodę lub.  
  
 Metoda statyczna <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> jest równoważna z konstruowaniem <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca wyrażenia regularnego <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> określonego `pattern` przez i wywołującego metodę wystąpienia. Ten wzorzec wyrażenia regularnego jest buforowany do szybkiego pobierania przez aparat wyrażeń regularnych.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest zgłaszany, jeśli czas wykonywania operacji dopasowywania przekracza interwał limitu czasu określony dla domeny aplikacji, w której wywoływana jest metoda. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji lub limit czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartością, nie jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metody, aby określić, czy ciąg jest prawidłowym numerem części. W wyrażeniu regularnym przyjęto, że numer części ma określony format składający się z trzech zestawów znaków oddzielonych łącznikiem. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znak alfanumeryczny, po którym następuje znak alfanumeryczny. Drugi zestaw, który składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestaw, który składa się z czterech znaków, musi zawierać trzy znaki numeryczne, po których następuje znak alfanumeryczny.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Wzorzec wyrażenia regularnego:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpocznij dopasowanie na początku wiersza.|  
|`[a-zA-Z0-9]`|Dopasowuje pojedynczy znak alfabetyczny`a` ( `z` przez `A` lub `Z`przez) lub znak liczbowy.|  
|`\d{2}`|Dopasowuje dwa znaki numeryczne.|  
|`[a-zA-Z0-9]`|Dopasowuje pojedynczy znak alfabetyczny`a` ( `z` przez `A` lub `Z`przez) lub znak liczbowy.|  
|`-`|Dopasowuje łącznik.|  
|`\d{3}`|Dopasowuje dokładnie trzy znaki numeryczne.|  
|`(-\d{3}){2}`|Znajdź łącznik, po którym następują trzy znaki numeryczne i dopasowuje dwa wystąpienia tego wzorca.|  
|`[a-zA-Z0-9]`|Dopasowuje pojedynczy znak alfabetyczny`a` ( `z` przez `A` lub `Z`przez) lub znak liczbowy.|  
|`$`|Zakończ dopasowanie na końcu wiersza.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekracza interwał, który jest równy domyślnej wartości limitu czasu domeny aplikacji, w której wywoływana jest metoda. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną weryfikacji dopasowania wzorca jest <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która umożliwia ustawienie interwału limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <summary>Wskazuje, czy określone wyrażenie regularne odnajduje dopasowanie w określonym ciągu wejściowym przy użyciu określonych pasujących opcji.</summary>
        <returns><see langword="true" />Jeśli wyrażenie regularne znajdzie dopasowanie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Metoda jest zwykle używana do walidacji ciągu lub w celu upewnienia się, że ciąg jest zgodny z określonym wzorcem bez pobierania tego ciągu do późniejszego manipulowania. Jeśli chcesz określić, czy jeden lub więcej ciągów pasuje do wzorca wyrażenia regularnego, a następnie pobierz je do późniejszego manipulowania <xref:System.Text.RegularExpressions.Regex.Match%2A> , <xref:System.Text.RegularExpressions.Regex.Matches%2A> Wywołaj metodę lub.  
  
 Metoda <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> statyczna jest równoważna z konstruowaniem <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca wyrażenia regularnego określonego `pattern` przez oraz opcji wyrażenia <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> regularnego określonych `options` przez i wywołujących wystąpienie Method. Ten wzorzec wyrażenia regularnego jest buforowany do szybkiego pobierania przez aparat wyrażeń regularnych.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest zgłaszany, jeśli czas wykonywania operacji dopasowywania przekracza interwał limitu czasu określony dla domeny aplikacji, w której wywoływana jest metoda. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji lub limit czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartością, nie jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metody, aby określić, czy ciąg jest prawidłowym numerem części. W wyrażeniu regularnym przyjęto, że numer części ma określony format składający się z trzech zestawów znaków oddzielonych łącznikiem. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znak alfanumeryczny, po którym następuje znak alfanumeryczny. Drugi zestaw, który składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestaw, który składa się z czterech znaków, musi zawierać trzy znaki numeryczne, po których następuje znak alfanumeryczny.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Wzorzec wyrażenia regularnego:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpocznij dopasowanie na początku ciągu.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczny `Z`z `A` lub dowolny znak liczbowy.|  
|`\d{2}`|Dopasowuje dwa znaki numeryczne.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczny `Z`z `A` lub dowolny znak liczbowy.|  
|`-`|Dopasowuje łącznik.|  
|`\d{3}`|Dopasowuje dokładnie trzy znaki numeryczne.|  
|`(-\d{3}){2}`|Znajdź łącznik, po którym następują trzy znaki numeryczne i dopasowuje dwa wystąpienia tego wzorca.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczny `Z`z `A` lub dowolny znak liczbowy.|  
|`$`|Zakończ dopasowanie na końcu ciągu.|  
  
 Wywołanie metody z parametrem ustawionym na <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> jest równoznaczne z zdefiniowaniem następującego wyrażenia regularnego: `options` <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Aby porównać, zobacz przykład dla <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartością.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekroczy limit czasu, który jest równy domyślnemu limitowi wartości w domenie aplikacji, w której jest wywoływany. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną weryfikacji dopasowania wzorca jest <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która umożliwia ustawienie interwału limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> wskazuje, że metoda nie powinna przekroczyć limitu czasu.</param>
        <summary>Wskazuje, czy określone wyrażenie regularne znajduje dopasowanie w określonym ciągu wejściowym przy użyciu określonych zgodnych opcji i interwału limitu czasu.</summary>
        <returns><see langword="true" />Jeśli wyrażenie regularne znajdzie dopasowanie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Metoda jest zwykle używana do walidacji ciągu lub w celu upewnienia się, że ciąg jest zgodny z określonym wzorcem bez pobierania tego ciągu do późniejszego manipulowania. Jeśli chcesz określić, czy jeden lub więcej ciągów pasuje do wzorca wyrażenia regularnego, a następnie pobierz je do późniejszego manipulowania <xref:System.Text.RegularExpressions.Regex.Match%2A> , <xref:System.Text.RegularExpressions.Regex.Matches%2A> Wywołaj metodę lub.  
  
 Metoda <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> statyczna jest równoważna z konstruowaniem <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca wyrażenia regularnego określonego `pattern` przez oraz opcji wyrażenia <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> regularnego określonych `options` przez i wywołujących wystąpienie Method. Ten wzorzec wyrażenia regularnego jest buforowany do szybkiego pobierania przez aparat wyrażeń regularnych.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `matchTimeout` Parametr określa, jak długo Metoda dopasowywania wzorców powinna próbować znaleźć dopasowanie przed upływem limitu czasu. Ustawienie interwału limitu czasu uniemożliwia wyrażenia regularne, które opierają się na nadmiernym wycofywaniu z wyświetlania, aby przestać odpowiadać podczas przetwarzania danych wejściowych zawierających blisko dopasowań. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) [i wycofywania](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli żadne dopasowanie nie zostanie znalezione w tym interwale czasu, metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek. `matchTimeout`zastępuje wszystkie domyślne wartości limitu czasu zdefiniowane dla domeny aplikacji, w której jest wykonywana metoda.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metody, aby określić, czy ciąg jest prawidłowym numerem części. W wyrażeniu regularnym przyjęto, że numer części ma określony format składający się z trzech zestawów znaków oddzielonych łącznikiem. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znak alfanumeryczny, po którym następuje znak alfanumeryczny. Drugi zestaw, który składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestaw, który składa się z czterech znaków, musi zawierać trzy znaki numeryczne, po których następuje znak alfanumeryczny. Dopasowanie wzorca wyrażenia regularnego powinno wymagać przeszukiwania przez ciąg wejściowy, więc metoda ustawia interwał limitu czasu wynoszący 500 milisekund.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Wzorzec wyrażenia regularnego:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpocznij dopasowanie na początku ciągu.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczny `Z`z `A` lub dowolny znak liczbowy.|  
|`\d{2}`|Dopasowuje dwa znaki numeryczne.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczny `Z`z `A` lub dowolny znak liczbowy.|  
|`-`|Dopasowuje łącznik.|  
|`\d{3}`|Dopasowuje dokładnie trzy znaki numeryczne.|  
|`(-\d{3}){2}`|Znajdź łącznik, po którym następują trzy znaki numeryczne i dopasowuje dwa wystąpienia tego wzorca.|  
|`[A-Z0-9]`|Dopasowuje dowolny pojedynczy znak alfabetyczny `Z`z `A` lub dowolny znak liczbowy.|  
|`$`|Zakończ dopasowanie na końcu ciągu.|  
  
 Wywołanie metody z parametrem ustawionym na <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> jest równoznaczne z zdefiniowaniem następującego wyrażenia regularnego: `options` <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Aby porównać, zobacz przykład dla <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartością.  
  
—lub— 
 <paramref name="matchTimeout" />jest ujemna, równa zero lub większa niż około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu.</exception>
        <block subset="none" type="usage"><para>Zalecamy ustawienie <paramref name="matchTimeout" /> parametru na odpowiednią wartość, na przykład dwie sekundy. Jeśli wyłączysz limity czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych oferuje nieco lepszą wydajność. Należy jednak wyłączyć limity czasu tylko w następujących warunkach: 
— Gdy dane wejściowe przetwarzane przez wyrażenie regularne pochodzą od znanego i zaufanego źródła lub zawierają tekst statyczny. Wyklucza to tekst, który jest dynamicznie wprowadzany przez użytkowników.  
  
-Kiedy wzorzec wyrażenia regularnego został dokładnie przetestowany w celu zapewnienia, że wydajnie obsługuje dopasowania, nie są dopasowań i blisko dopasowań.  
  
-Kiedy wzorzec wyrażenia regularnego nie zawiera elementów języka, które są znane, aby spowodować nadmierne wycofywanie podczas przetwarzania blisko dopasowania.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje ciąg wejściowy dla podciągu, który pasuje do wzorca wyrażenia regularnego i zwraca pierwsze wystąpienie jako <see cref="T:System.Text.RegularExpressions.Match" /> pojedynczy obiekt.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <summary>Wyszukuje określony ciąg wejściowy dla pierwszego wystąpienia wyrażenia regularnego określonego w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktorze.</summary>
        <returns>Obiekt, który zawiera informacje o dopasowaniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Metoda zwraca pierwszy podciąg, który jest zgodny ze wzorcem wyrażenia regularnego w ciągu wejściowym. Informacje o elementach języka użytych do skompilowania wzorca wyrażenia regularnego można znaleźć w sekcji [Język wyrażeń regularnych — szybkie informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wzorzec wyrażenia regularnego został znaleziony w ciągu wejściowym przez sprawdzenie wartości <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości zwracanego obiektu. W przypadku znalezienia dopasowania <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> Właściwość zwracanego obiektu zawiera podciąg z `input` , który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca pierwszy podciąg w `input` , który jest zgodny ze wzorcem wyrażenia regularnego. Kolejne dopasowania można pobrać, wielokrotnie wywołując <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metodę zwracanego obiektu. Możesz również pobrać wszystkie dopasowania w pojedynczym wywołaniu metody, wywołując <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> metodę.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji dopasowywania przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub wartość limitu czasu to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład odnajduje dopasowania wzorca wyrażenia regularnego w ciągu, a następnie wyświetla dopasowane grupy, przechwycenia i położenia przechwytywania.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Wzorzec `(\w+)\s+(car)` wyrażenia regularnego dopasowuje wystąpienia wyrazu "samochód" wraz z słowem poprzedzającym go. Jest interpretowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(\w+)`|Dopasowuje co najmniej jeden znak słowa. Jest to pierwsza grupa przechwytywania.|  
|`\s+`|Dopasowuje co najmniej jeden znak odstępu.|  
|samochód|Dopasowuje ciąg literału "samochód". Jest to druga grupa przechwytywania.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="startat">Pozycja znaku rozpoczynającego się od zera, przy której ma zostać rozpoczęte wyszukiwanie.</param>
        <summary>Wyszukuje ciąg wejściowy dla pierwszego wystąpienia wyrażenia regularnego, zaczynając od określonej pozycji początkowej w ciągu.</summary>
        <returns>Obiekt, który zawiera informacje o dopasowaniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca pierwszy podciąg, który pasuje do wzorca wyrażenia regularnego, rozpoczynając od lub `startat` po pozycji znaku w ciągu wejściowym. <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Informacje o elementach języka użytych do skompilowania wzorca wyrażenia regularnego można znaleźć w sekcji [Język wyrażeń regularnych — szybkie informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Metoda wyszukiwania jest definiowana przez wywołanie jednego <xref:System.Text.RegularExpressions.Regex> z konstruktorów klas. Aby uzyskać więcej informacji o elementach, które mogą tworzyć wzorzec wyrażenia regularnego, zobacz temat [Regular Expression Language-Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Opcjonalnie można określić pozycję początkową w ciągu przy użyciu `startat` parametru. Gdy aparat wyrażeń regularnych przeanalizuje od lewej do prawej (wartość domyślna), dopasowanie i skanowanie Move rightward, rozpoczynając od znaku określonego w `startat`. Gdy aparat wyrażeń regularnych analizuje się od prawej do lewej (gdy wzorzec wyrażenia regularnego jest konstruowany przy użyciu <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opcji), dopasowanie i skanowanie odbywa się w odwrotnym kierunku i zaczyna się od znaku na `startat` 1. Jeśli nie określisz pozycji początkowej, wyszukiwanie rozpoczyna się w pozycji domyślnej `startat` . Jeśli wyrażenie regularne przeszukuje od lewej do prawej, pozycja Domyślna `startat` jest w lewym `input`końcu; jeśli przeszukiwana od prawej do lewej, pozycja Domyślna `startat` jest w prawym końcu `input`.  
  
 Jeśli chcesz ograniczyć dopasowanie tak, aby rozpoczynać się w określonej pozycji znaku w ciągu, a aparat wyrażeń regularnych nie skanuje pozostałej części ciągu dla dopasowania, zakotwiczenie wyrażenia regularnego z `\G` (po lewej stronie od lewej do prawej). wzorzec lub po prawej stronie wzorca od prawej do lewej). Ogranicza to dopasowanie, dlatego musi się zacząć dokładnie o `startat`.  
  
 Można określić, czy wzorzec wyrażenia regularnego został znaleziony w ciągu wejściowym przez sprawdzenie wartości <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości zwracanego obiektu. W przypadku znalezienia dopasowania <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> Właściwość zwracanego obiektu zawiera podciąg z `input` , który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca pierwszy podciąg znaleziony w lub po `startat` pozycji znaku w `input` , która pasuje do wzorca wyrażenia regularnego. Kolejne dopasowania można pobrać, wielokrotnie wywołując <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metodę zwracanego obiektu. Możesz również pobrać wszystkie dopasowania w pojedynczym wywołaniu metody, wywołując <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metodę.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji dopasowywania przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub wartość limitu czasu to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Wyszukuje określony ciąg wejściowy dla pierwszego wystąpienia określonego wyrażenia regularnego.</summary>
        <returns>Obiekt, który zawiera informacje o dopasowaniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Metoda zwraca pierwszy podciąg, który jest zgodny ze wzorcem wyrażenia regularnego w ciągu wejściowym. Informacje o elementach języka użytych do skompilowania wzorca wyrażenia regularnego można znaleźć w sekcji [Język wyrażeń regularnych — szybkie informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Metoda statyczna <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> jest równoważna z konstruowaniem <xref:System.Text.RegularExpressions.Regex> obiektu z określonym wzorcem wyrażenia regularnego i wywołaniem <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metody wystąpienia. W takim przypadku aparat wyrażeń regularnych buforuje wzorzec wyrażenia regularnego.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wzorzec wyrażenia regularnego został znaleziony w ciągu wejściowym przez sprawdzenie wartości <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości zwracanego obiektu. W przypadku znalezienia dopasowania <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> Właściwość zwracanego obiektu zawiera podciąg z `input` , który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca pierwszy podciąg w `input` , który jest zgodny ze wzorcem wyrażenia regularnego. Kolejne dopasowania można pobrać, wielokrotnie wywołując <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metodę zwracanego obiektu. Możesz również pobrać wszystkie dopasowania w pojedynczym wywołaniu metody, wywołując <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> metodę.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest zgłaszany, jeśli czas wykonywania operacji dopasowywania przekracza interwał limitu czasu określony dla domeny aplikacji, w której wywoływana jest metoda. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji lub limit czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartością, nie jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> metodę w celu znalezienia pierwszego wyrazu <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> , który zawiera co najmniej jeden `z` znak, a następnie wywołuje metodę w celu znalezienia wszelkich dodatkowych dopasowań.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Wzorzec `\b\w*z+\w*\b` wyrażenia regularnego jest interpretowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w*`|Dopasowuje zero, jeden lub więcej znaków wyrazu.|  
|`z+`|Dopasowuje jedno lub więcej wystąpień `z` znaku.|  
|`\w*`|Dopasowuje zero, jeden lub więcej znaków wyrazu.|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekroczy limit czasu, który jest równy domyślnemu limitowi wartości w domenie aplikacji, w której jest wywoływany. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną do pobierania dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />jest, która umożliwia ustawienie interwału limitu czasu.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="beginning">Pozycja znaku na podstawie zera w ciągu wejściowym, który definiuje pozycję do przeszukania.</param>
        <param name="length">Liczba znaków w podciągach do uwzględnienia w wyszukiwaniu.</param>
        <summary>Wyszukuje ciąg wejściowy dla pierwszego wystąpienia wyrażenia regularnego, zaczynając od określonej pozycji początkowej i wyszukując tylko określoną liczbę znaków.</summary>
        <returns>Obiekt, który zawiera informacje o dopasowaniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda zwraca pierwszy podciąg, który jest zgodny ze wzorcem wyrażenia regularnego w części ciągu wejściowego. Informacje o elementach języka użytych do skompilowania wzorca wyrażenia regularnego można znaleźć w sekcji [Język wyrażeń regularnych — szybkie informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda wyszukiwania jest definiowana przez wywołanie jednego <xref:System.Text.RegularExpressions.Regex> z konstruktorów klas. Aby uzyskać więcej informacji o elementach, które mogą tworzyć wzorzec wyrażenia regularnego, zobacz temat [Regular Expression Language-Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Metoda przeszukuje `input` część zdefiniowaną przez `beginning` parametry i `length` dla wzorca wyrażenia regularnego. <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> `beginning`zawsze definiuje indeks znaku z lewej strony do uwzględnienia w wyszukiwaniu i `length` definiuje maksymalną liczbę znaków do wyszukania. Razem definiują zakres wyszukiwania. Jeśli wyszukiwanie będzie przebiegać od lewej do prawej (wartość domyślna), aparat `beginning` wyrażeń regularnych przeszukuje znak w indeksie do znaku pod indeksem `beginning`  +  `length` -1. Jeśli wystąpienie aparatu wyrażeń regularnych zostało <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> utworzone przy użyciu opcji, dzięki czemu wyszukiwanie będzie przebiegać od prawej do lewej, aparat wyrażeń regularnych przeszukuje od znaku w indeksie `beginning`  +  `length` -1 do znak w indeksie `beginning`. Ta metoda zwraca pierwsze dopasowanie, które znajduje się w tym zakresie. Kolejne dopasowania można pobrać, wielokrotnie wywołując <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metodę zwracanego obiektu.  
  
 Można określić, czy wzorzec wyrażenia regularnego został znaleziony w ciągu wejściowym przez sprawdzenie wartości <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości zwracanego obiektu. W przypadku znalezienia dopasowania <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> Właściwość zwracanego obiektu zawiera podciąg z `input` , który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji dopasowywania przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz wartości limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu określony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub wartość limitu czasu to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, nie jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="beginning" />jest mniejsza od zera lub większa niż długość <paramref name="input" />.  
  
—lub— 
 <paramref name="length" />jest mniejsza od zera lub większa niż długość <paramref name="input" />.  
  
—lub— 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" />Określa pozycję, która znajduje się poza zakresem <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <summary>Wyszukuje ciąg wejściowy dla pierwszego wystąpienia określonego wyrażenia regularnego przy użyciu określonych pasujących opcji.</summary>
        <returns>Obiekt, który zawiera informacje o dopasowaniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Metoda zwraca pierwszy podciąg, który jest zgodny ze wzorcem wyrażenia regularnego w ciągu wejściowym. Informacje o elementach języka użytych do skompilowania wzorca wyrażenia regularnego można znaleźć w sekcji [Język wyrażeń regularnych — szybkie informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Metoda statyczna <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> jest równoważna z konstruowaniem <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> konstruktora i wywołaniem metody <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> wystąpienia.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wzorzec wyrażenia regularnego został znaleziony w ciągu wejściowym przez sprawdzenie wartości <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości zwracanego obiektu. W przypadku znalezienia dopasowania <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> Właściwość zwracanego obiektu zawiera podciąg z `input` , który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca pierwszy podciąg znaleziony w `input` , który jest zgodny ze wzorcem wyrażenia regularnego. Kolejne dopasowania można pobrać, wielokrotnie wywołując <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A> metodę zwracanego obiektu. Możesz również pobrać wszystkie dopasowania w pojedynczym wywołaniu metody, wywołując <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metodę.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest zgłaszany, jeśli czas wykonywania operacji dopasowywania przekracza interwał limitu czasu określony dla domeny aplikacji, w której wywoływana jest metoda. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji lub limit czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartością, nie jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenie regularne, które pasuje do wyrazów zaczynających się od litery "a". Używa <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opcji, aby upewnić się, że wyrażenie regularne lokalizuje słowa zaczynające się zarówno wielką literą "a" i małą literą "a".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Wzorzec `\ba\w*\b` wyrażenia regularnego jest interpretowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`a`|Dopasowuje znak "a".|  
|`\w*`|Dopasowuje zero, jeden lub więcej znaków wyrazu.|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową bitową kombinacją <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekroczy limit czasu, który jest równy domyślnemu limitowi wartości w domenie aplikacji, w której jest wywoływany. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną do pobierania dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />jest, która umożliwia ustawienie interwału limitu czasu.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> wskazuje, że metoda nie powinna przekroczyć limitu czasu.</param>
        <summary>Wyszukuje ciąg wejściowy dla pierwszego wystąpienia określonego wyrażenia regularnego przy użyciu określonych zgodnych opcji i interwału limitu czasu.</summary>
        <returns>Obiekt, który zawiera informacje o dopasowaniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Metoda zwraca pierwszy podciąg, który jest zgodny ze wzorcem wyrażenia regularnego w ciągu wejściowym. Informacje o elementach języka użytych do skompilowania wzorca wyrażenia regularnego można znaleźć w sekcji [Język wyrażeń regularnych — szybkie informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Metoda statyczna <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> jest równoważna z konstruowaniem <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> konstruktora i wywołaniem metody <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> wystąpienia.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wzorzec wyrażenia regularnego został znaleziony w ciągu wejściowym przez sprawdzenie wartości <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości zwracanego obiektu. W przypadku znalezienia dopasowania <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> Właściwość zwracanego obiektu zawiera podciąg z `input` , który jest zgodny ze wzorcem wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca pierwszy podciąg znaleziony w `input` , który jest zgodny ze wzorcem wyrażenia regularnego. Kolejne dopasowania można pobrać, wielokrotnie wywołując <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A> metodę zwracanego obiektu. Możesz również pobrać wszystkie dopasowania w pojedynczym wywołaniu metody, wywołując <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metodę.  
  
 `matchTimeout` Parametr określa, jak długo Metoda dopasowywania wzorców powinna próbować znaleźć dopasowanie przed upływem limitu czasu. Ustawienie interwału limitu czasu uniemożliwia wyrażenia regularne, które opierają się na nadmiernym wycofywaniu z wyświetlania, aby przestać odpowiadać podczas przetwarzania danych wejściowych zawierających blisko dopasowań. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) [i wycofywania](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli żadne dopasowanie nie zostanie znalezione w tym interwale czasu, metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek. `matchTimeout`zastępuje wszystkie domyślne wartości limitu czasu zdefiniowane dla domeny aplikacji, w której jest wykonywana metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową bitową kombinacją <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  
  
—lub— 
 <paramref name="matchTimeout" />jest ujemna, równa zero lub większa niż około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Zalecamy ustawienie <paramref name="matchTimeout" /> parametru na odpowiednią wartość, na przykład dwie sekundy. Jeśli wyłączysz limity czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych oferuje nieco lepszą wydajność. Należy jednak wyłączyć limity czasu tylko w następujących warunkach: 
— Gdy dane wejściowe przetwarzane przez wyrażenie regularne pochodzą od znanego i zaufanego źródła lub zawierają tekst statyczny. Wyklucza to tekst, który jest dynamicznie wprowadzany przez użytkowników.  
  
-Kiedy wzorzec wyrażenia regularnego został dokładnie przetestowany w celu zapewnienia, że wydajnie obsługuje dopasowania, nie są dopasowań i blisko dopasowań.  
  
-Kiedy wzorzec wyrażenia regularnego nie zawiera elementów języka, które są znane, aby spowodować nadmierne wycofywanie podczas przetwarzania blisko dopasowania.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje ciąg wejściowy dla wszystkich wystąpień wyrażenia regularnego i zwraca wszystkie dopasowania.</summary>
        <block subset="none" type="usage"><para>Gdy próba dopasowania jest powtórzona przez wywołanie metody <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> , aparat wyrażeń regularnych daje puste dopasowanie do specjalnego traktowania. Zwykle aparat wyrażeń regularnych rozpoczyna wyszukiwanie następnego dopasowania dokładnie wtedy, gdy poprzednie dopasowanie zostało pozostawione. Jednak po pustym dopasowaniu aparat wyrażeń regularnych postępuje o jeden znak przed próbą kolejnego dopasowania. To zachowanie gwarantuje, że aparat wyrażeń regularnych będzie postępować przez ciąg. W przeciwnym razie, ponieważ puste dopasowanie nie powoduje żadnego ruchu do przodu, kolejne dopasowanie zostanie uruchomione w dokładnie tym samym miejscu co poprzednie dopasowanie i będzie wielokrotnie zgodne z tym samym pustym ciągiem.  
  
W poniższym przykładzie wzorzec wyrażenia regularnego <c>a *</c> wyszukuje zero lub więcej wystąpień litery "a" w ciągu "abaabb". Jak wynika z przykładu, wynikowy <see cref="T:System.Text.RegularExpressions.MatchCollection" /> obiekt zawiera sześć <see cref="T:System.Text.RegularExpressions.Match" /> obiektów. Pierwsza próba dopasowania powoduje znalezienie pierwszego "a". Drugie dopasowanie zaczyna się dokładnie wtedy, gdy pierwsze dopasowanie zostanie zakończone przed pierwszym b; znajduje zero wystąpień elementu "a" i zwraca pusty ciąg. Trzecie dopasowanie nie zaczyna się dokładnie w miejscu zakończenia drugiego dopasowania, ponieważ drugie dopasowanie zwróciło pusty ciąg. Zamiast tego rozpoczyna jeden znak później, po pierwszym "b". Trzeci odpowiednik znajduje dwa wystąpienia elementu "a" i zwraca wartość "AA". Próba czwartego dopasowania rozpoczyna się od zakończenia trzeciego dopasowania przed drugim "b" i zwraca pusty ciąg. Próba piątego dopasowania spowoduje ponowne naliczenie pierwszego znaku, tak aby zaczynał się przed trzeci "b" i zwraca pusty ciąg. Szóste dopasowanie rozpoczyna się po ostatnim znaku "b" i ponownie zwraca pusty ciąg.  
  
[!code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [!code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <summary>Przeszukuje określony ciąg wejściowy dla wszystkich wystąpień wyrażenia regularnego.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> obiektów znalezionych w wyniku wyszukiwania. Jeśli nie zostaną znalezione żadne dopasowania, metoda zwraca pusty obiekt kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest podobna <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> do metody, z tą różnicą, że zwraca informacje o wszystkich dopasowań znalezionych w ciągu wejściowym zamiast jednego dopasowania. <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 Kolekcja zawiera tylko dopasowania i kończy się przy pierwszym niezgodności.  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Metoda wyszukiwania jest definiowana przez wywołanie jednego <xref:System.Text.RegularExpressions.Regex> z konstruktorów klas. Aby uzyskać więcej informacji o elementach, które mogą tworzyć wzorzec wyrażenia regularnego, zobacz temat [Regular Expression Language-Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Metoda używa oceny z opóźnieniem do wypełnienia zwracanego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Uzyskiwanie dostępu do elementów członkowskich tej <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> kolekcji <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> , takich jak i powoduje natychmiastowe wypełnienie kolekcji. Aby skorzystać z oceny z opóźnieniem, należy wykonać iterację kolekcji przy użyciu konstrukcji, takiej `foreach` jak C# w `For Each`i...`Next` w Visual Basic.  
  
 Ze względu na jego ocenę z opóźnieniem wywołanie <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> metody nie powoduje <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wygenerowania wyjątku. Jednakże wyjątek jest zgłaszany, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> obiekcie zwracanym przez tę metodę, <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Jeśli właściwość nie <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> jest i zgodna operacja przekracza interwał limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> metody do identyfikowania dowolnego wyrazu w zdaniu kończącym się na "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Wzorzec `\b\w+es\b` wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Pasuje do ciągu literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowym, w którym ma zostać rozpoczęte wyszukiwanie.</param>
        <summary>Wyszukuje określony ciąg wejściowy dla wszystkich wystąpień wyrażenia regularnego, zaczynając od określonej pozycji początkowej w ciągu.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> obiektów znalezionych w wyniku wyszukiwania. Jeśli nie zostaną znalezione żadne dopasowania, metoda zwraca pusty obiekt kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest podobna <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> do metody, z tą różnicą, że zwraca informacje o wszystkich dopasowań znalezionych w ciągu wejściowym zamiast jednego dopasowania. <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Metoda wyszukiwania jest definiowana przez wywołanie jednego <xref:System.Text.RegularExpressions.Regex> z konstruktorów klas. Aby uzyskać więcej informacji o elementach, które mogą tworzyć wzorzec wyrażenia regularnego, zobacz temat [Regular Expression Language-Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Metoda używa oceny z opóźnieniem do wypełnienia zwracanego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Uzyskiwanie dostępu do elementów członkowskich tej <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> kolekcji <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> , takich jak i powoduje natychmiastowe wypełnienie kolekcji. Aby skorzystać z oceny z opóźnieniem, należy wykonać iterację kolekcji przy użyciu konstrukcji, takiej `foreach` jak C# w `For Each`i...`Next` w Visual Basic.  
  
 Ze względu na jego ocenę z opóźnieniem wywołanie <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> metody nie powoduje <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wygenerowania wyjątku. Jednakże wyjątek jest zgłaszany, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> obiekcie zwracanym przez tę metodę, <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Jeśli właściwość nie <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> jest i zgodna operacja przekracza interwał limitu czasu. 
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metodę w celu znalezienia pierwszego wyrazu w zdaniu kończącym się ciągiem "es", a następnie <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> wywołanie metody w celu zidentyfikowania wszelkich dodatkowych wyrazów kończących się na "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Wzorzec `\b\w+es\b` wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Pasuje do ciągu literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Wyszukuje określony ciąg wejściowy dla wszystkich wystąpień określonego wyrażenia regularnego.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> obiektów znalezionych w wyniku wyszukiwania. Jeśli nie zostaną znalezione żadne dopasowania, metoda zwraca pusty obiekt kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest podobna <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> do metody, z tą różnicą, że zwraca informacje o wszystkich dopasowań znalezionych w ciągu wejściowym zamiast jednego dopasowania. <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Metody statyczne `Matches` są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu z określonym wzorcem wyrażenia regularnego i wywoływania metody `Matches`wystąpienia.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Metoda używa oceny z opóźnieniem do wypełnienia zwracanego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Uzyskiwanie dostępu do elementów członkowskich tej <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> kolekcji <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> , takich jak i powoduje natychmiastowe wypełnienie kolekcji. Aby skorzystać z oceny z opóźnieniem, należy wykonać iterację kolekcji przy użyciu konstrukcji, takiej `foreach` jak C# w `For Each`i...`Next` w Visual Basic.  
  
 Ze względu na jego ocenę z opóźnieniem wywołanie <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metody nie powoduje <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wygenerowania wyjątku. Jednakże wyjątek jest zgłaszany podczas wykonywania operacji na <xref:System.Text.RegularExpressions.MatchCollection> obiekcie zwróconym przez tę metodę, jeśli interwał limitu czasu jest zdefiniowany przez właściwość "REGEX_DEFAULT_MATCH_TIMEOUT" bieżącej domeny aplikacji i zgodną operację przekracza ten limit czasu.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metody do identyfikowania dowolnego wyrazu w zdaniu kończącym się ciągiem "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Wzorzec `\b\w+es\b` wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Pasuje do ciągu literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekroczy limit czasu, który jest równy domyślnemu limitowi wartości w domenie aplikacji, w której jest wywoływany. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną do pobierania dopasowania wielu wzorców <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />jest, która umożliwia określenie interwału limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które określają opcje do dopasowania.</param>
        <summary>Wyszukuje określony ciąg wejściowy dla wszystkich wystąpień określonego wyrażenia regularnego przy użyciu określonych pasujących opcji.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> obiektów znalezionych w wyniku wyszukiwania. Jeśli nie zostaną znalezione żadne dopasowania, metoda zwraca pusty obiekt kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest podobna <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> do metody, z tą różnicą, że zwraca informacje o wszystkich dopasowań znalezionych w ciągu wejściowym zamiast jednego dopasowania. <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Metody statyczne `Matches` są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu z określonym wzorcem wyrażenia regularnego i wywoływania metody `Matches`wystąpienia.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Metoda używa oceny z opóźnieniem do wypełnienia zwracanego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Uzyskiwanie dostępu do elementów członkowskich tej <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> kolekcji <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> , takich jak i powoduje natychmiastowe wypełnienie kolekcji. Aby skorzystać z oceny z opóźnieniem, należy wykonać iterację kolekcji przy użyciu konstrukcji, takiej `foreach` jak C# w `For Each`i...`Next` w Visual Basic.  
  
 Ze względu na jego ocenę z opóźnieniem wywołanie <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metody nie powoduje <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wygenerowania wyjątku. Jednakże wyjątek jest zgłaszany podczas wykonywania operacji na <xref:System.Text.RegularExpressions.MatchCollection> obiekcie zwróconym przez tę metodę, jeśli interwał limitu czasu jest zdefiniowany przez właściwość "REGEX_DEFAULT_MATCH_TIMEOUT" bieżącej domeny aplikacji i zgodną operację przekracza ten limit czasu.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metodę w celu zidentyfikowania dowolnego wyrazu w zdaniu kończącym się w "es", a następnie <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> wywołuje metodę, aby wykonać porównywanie bez uwzględniania wielkości liter wzorca z ciągiem wejściowym. Ponieważ dane wyjściowe są wyświetlane, dwie metody zwracają różne wyniki.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Wzorzec `\b\w+es\b` wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Pasuje do ciągu literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową bitową kombinacją <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekroczy limit czasu, który jest równy domyślnemu limitowi wartości w domenie aplikacji, w której jest wywoływany. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną do pobierania dopasowania wielu wzorców <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />jest, która umożliwia ustawienie interwału limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które określają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> wskazuje, że metoda nie powinna przekroczyć limitu czasu.</param>
        <summary>Przeszukuje określony ciąg wejściowy dla wszystkich wystąpień określonego wyrażenia regularnego przy użyciu określonych zgodnych opcji i interwału limitu czasu.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> obiektów znalezionych w wyniku wyszukiwania. Jeśli nie zostaną znalezione żadne dopasowania, metoda zwraca pusty obiekt kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest podobna <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> do metody, z tą różnicą, że zwraca informacje o wszystkich dopasowań znalezionych w ciągu wejściowym zamiast jednego dopasowania. <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Metody statyczne `Matches` są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu z określonym wzorcem wyrażenia regularnego i wywoływania metody `Matches`wystąpienia.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Metoda używa oceny z opóźnieniem do wypełnienia zwracanego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Uzyskiwanie dostępu do elementów członkowskich tej <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> kolekcji <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> , takich jak i powoduje natychmiastowe wypełnienie kolekcji. Aby skorzystać z oceny z opóźnieniem, należy wykonać iterację kolekcji przy użyciu konstrukcji, takiej `foreach` jak C# w `For Each`i...`Next` w Visual Basic.  
  
 Ze względu na jego ocenę z opóźnieniem wywołanie <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody nie powoduje <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wygenerowania wyjątku. Jednakże wyjątek jest zgłaszany, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> obiekcie zwróconym przez tę metodę, jeśli zgodna operacja przekracza ten limit czasu określony`matchTimeout` przez parametr.  
  
   
  
## Examples  
 Poniższy przykład wywołuje metodę, <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> aby wykonać porównanie z uwzględnieniem wielkości liter, które dopasowuje dowolny wyraz w zdaniu kończącym się znakami "es". Następnie wywołuje metodę, <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> aby wykonać porównywanie bez uwzględniania wielkości liter wzorca z ciągiem wejściowym. W obu przypadkach interwał limitu czasu jest ustawiony na jedną sekundę. Ponieważ dane wyjściowe są wyświetlane, dwie metody zwracają różne wyniki.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Wzorzec `\b\w+es\b` wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Pasuje do ciągu literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową bitową kombinacją <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  
  
—lub— 
 <paramref name="matchTimeout" />jest ujemna, równa zero lub większa niż około 24 dni.</exception>
        <block subset="none" type="usage"><para>Zalecamy ustawienie <paramref name="matchTimeout" /> parametru na odpowiednią wartość, na przykład dwie sekundy. Jeśli wyłączysz limity czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych oferuje nieco lepszą wydajność. Należy jednak wyłączyć limity czasu tylko w następujących warunkach: 
— Gdy dane wejściowe przetwarzane przez wyrażenie regularne pochodzą od znanego i zaufanego źródła lub zawierają tekst statyczny. Wyklucza to tekst, który jest dynamicznie wprowadzany przez użytkowników.  
  
-Kiedy wzorzec wyrażenia regularnego został dokładnie przetestowany w celu zapewnienia, że wydajnie obsługuje dopasowania, nie są dopasowań i blisko dopasowań.  
  
-Kiedy wzorzec wyrażenia regularnego nie zawiera elementów języka, które są znane, aby spowodować nadmierne wycofywanie podczas przetwarzania blisko dopasowania.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera interwał limitu czasu dla bieżącego wystąpienia.</summary>
        <value>Maksymalny przedział czasu, który może upłynąć w operacji dopasowania do wzorca przed <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> zgłoszeniem lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> w przypadku wyłączenia limitów czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość definiuje przybliżony maksymalny przedział czasu <xref:System.Text.RegularExpressions.Regex> dla wystąpienia do wykonania pojedynczej operacji dopasowania, zanim operacja przekroczy limit czasu. <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Aparat wyrażeń regularnych zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek podczas następnego sprawdzania czasu po upływie limitu czasu. Zapobiega to przetwarzaniu przez aparat wyrażeń regularnych ciągów wejściowych, które wymagają nadmiernego wycofywania. Aby uzyskać więcej informacji, [Zobacz](~/docs/standard/base-types/backtracking-in-regular-expressions.md) wycofywanie i [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md).  
  
 Ta właściwość jest tylko do odczytu. Można ustawić wartość <xref:System.Text.RegularExpressions.Regex> jawnie dla pojedynczego obiektu przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> wywołanie konstruktora; i można ustawić jego wartość dla wszystkich <xref:System.Text.RegularExpressions.Regex> <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> operacji dopasowywania w domenie aplikacji, wywołując metodę i dostarczając <xref:System.TimeSpan> wartość właściwości "REGEX_DEFAULT_MATCH_TIMEOUT", jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Jeśli nie ustawisz jawnie interwału limitu czasu, zostanie użyta wartość <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> domyślna, a operacje dopasowywania nie przekroczą limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opcje, które zostały przesłane do <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora.</summary>
        <value>Co najmniej jeden element członkowski <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wyliczenia reprezentujący opcje, które zostały przesłane <see cref="T:System.Text.RegularExpressions.Regex" /> do konstruktora</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Text.RegularExpressions.Regex.Options%2A> właściwości składa się z co najmniej jednego <xref:System.Text.RegularExpressions.RegexOptions> elementu członkowskiego wyliczenia. Jeśli nie zdefiniowano żadnych opcji w <xref:System.Text.RegularExpressions.Regex> konstruktorze klasy, jego wartość <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>to. Dostępne opcje zostały szczegółowo omówione w temacie [Opcje wyrażenia regularnego](~/docs/standard/base-types/regular-expression-options.md) .  
  
 Należy zauważyć, <xref:System.Text.RegularExpressions.Regex.Options%2A> że właściwość nie odzwierciedla opcji wbudowanych zdefiniowanych w samym wzorcu wyrażenia regularnego.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" />jest klasą bazową wyrażeń regularnych utworzonych przez <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metodę. Te skompilowane wyrażenia regularne używają implementacji <see cref="P:System.Text.RegularExpressions.Regex.Options" /> klasy bazowej właściwości. Jeśli wywoływana z klasy pochodnej, <see cref="P:System.Text.RegularExpressions.Regex.Options" /> Właściwość zwraca opcje, które zostały przesłane <paramref name="options" /> do parametru <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> konstruktora klasy, który został użyty do zdefiniowania wyrażenia regularnego.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">Opcje wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używany przez <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt wygenerowany <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> przez metodę.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W określonym ciągu wejściowym zastępuje ciągi, które pasują do wzorca wyrażenia regularnego z określonym ciągiem zastępczym.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do wzorca wyrażenia regularnego z określonym ciągiem zastępczym.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zamienny przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie dopasowań rozpoczyna się na początku `input` ciągu. Wyrażenie regularne jest wzorcem zdefiniowanym przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 Parametr określa ciąg, który ma zastąpić poszczególne dopasowania w `input`. `replacement` `replacement`może składać się z dowolnej kombinacji tekstu literału [](~/docs/standard/base-types/substitutions-in-regular-expressions.md)i podstawienia. Na przykład wzorzec `a*${test}b` zastępczy wstawia ciąg "a *", po którym następuje podciąg, który jest dopasowany `test` przez grupę przechwytywania, jeśli istnieje, a następnie ciąg "b". Znak * nie jest rozpoznawany jako metaznak w obrębie wzorca zastępczego.  
  
> [!NOTE]
>  Podstawienia są jedynymi elementami języka wyrażeń regularnych, które są rozpoznawane we wzorcu zamiennym. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znaki ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone tylko w wzorcach wyrażeń regularnych i nie są rozpoznawane w wzorcach zamiennych.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji zastępującej przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub w przypadku <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartości limitu czasu, nie jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład definiuje wyrażenie regularne, `\s+`które dopasowuje co najmniej jeden znak odstępu. Ciąg zastępczy "" zastępuje je pojedynczym znakiem odstępu.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 W poniższym przykładzie zdefiniowano wyrażenie regularne, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`i `$2`wzorzec zastępczy, który usuwa wiodący lub końcowy symbol waluty z wartości liczbowej.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 Wyrażenie regularne jest interpretowane tak jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\p{Sc}`|Dopasowuje symbol waluty. `{Sc}`oznacza dowolny znak, który jest elementem członkowskim symbolu Unicode, Kategoria waluty.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`(\p{Sc}\s?)?`|Dopasowanie do zera lub jednego wystąpienia kombinacji symbolu waluty, po którym następuje zero lub jeden znak odstępu. Jest to pierwsza grupa przechwytywania.|  
|`\d+`|Dopasowanie do co najmniej jednej cyfry dziesiętnej.|  
|`\.?`|Dopasowanie do zera lub jednego wystąpienia kropki (używany jako znak separatora dziesiętnego).|  
|`((?<=\.)\d+)?`|Jeśli okres jest poprzednim znakiem, dopasowuje co najmniej jedną cyfrę dziesiętną. Ten wzorzec może być dopasowany zero lub jeden raz.|  
|`(\d+\.?((?<=\.)\d+)?)`|Dopasowuje wzorzec jednej lub więcej cyfr dziesiętnych, po których następuje opcjonalny okres i dodatkowe cyfry dziesiętne. Jest to druga grupa przechwytywania. Wywołanie <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> metody zastępuje całe dopasowanie wartością tej przechwyconej grupy.|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|Jeśli pierwsza przechwycona Grupa istnieje, Dopasuj pusty ciąg. W przeciwnym razie Dopasuj zero lub jeden znak odstępu, po którym następuje symbol waluty.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="evaluator">Metoda niestandardowa, która sprawdza każdy odpowiednik i zwraca oryginalny dopasowany ciąg lub ciąg zastępczy.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego ciągiem zwracanym przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegata.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zastępczy przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Ciąg zamienny nie może być łatwo określony przez wzorzec zamiany wyrażenia regularnego.  
  
-   Ciąg zamienny jest wynikiem niektórych operacji przetwarzania dla dopasowanego ciągu.  
  
-   Ciąg zamienny jest wynikiem przetwarzania warunkowego.  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> Metoda jest równoważna wywołaniu metody i przekazanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconej <xref:System.Text.RegularExpressions.MatchCollection> kolekcji do `evaluator` delegata.  
  
 Wyrażenie regularne jest wzorcem zdefiniowanym przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `evaluator` Parametr jest delegatem dla niestandardowej metody, która jest definiowana i bada każde dopasowanie. Aby można było dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegata, Metoda niestandardowa musi mieć następujący podpis.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Metoda niestandardowa zwraca ciąg, który zastępuje dopasowane dane wejściowe.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji zastępującej przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub w przypadku <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartości limitu czasu, nie jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla oryginalny ciąg, dopasowuje każdy wyraz w oryginalnym ciągu, konwertuje pierwszy znak każdego dopasowania na wielkie litery, a następnie wyświetla przekonwertowany ciąg.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="count">Maksymalna liczba przypadków, w których może wystąpić zastąpienie.</param>
        <summary>W określonym ciągu wejściowym zastępuje określoną maksymalną liczbę ciągów, które pasują do wzorca wyrażenia regularnego z określonym ciągiem zastępczym.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zamienny przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie dopasowań rozpoczyna się na początku `input` ciągu. Wyrażenie regularne jest wzorcem zdefiniowanym przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu. Jeśli `count` jest ujemna, zamienniki są kontynuowane na końcu ciągu. Jeśli `count` przekracza liczbę dopasowań, wszystkie dopasowania są zastępowane.  
  
 Parametr określa ciąg, który ma zastąpić pierwsze `count` dopasowania w `input`. `replacement` `replacement`może składać się z dowolnej kombinacji tekstu literału [](~/docs/standard/base-types/substitutions-in-regular-expressions.md)i podstawienia. Na przykład wzorzec `a*${test}b` zastępczy wstawia ciąg "a *", po którym następuje podciąg, który jest dopasowany `test` przez grupę przechwytywania, jeśli istnieje, a następnie ciąg "b". Znak * nie jest rozpoznawany jako metaznak w obrębie wzorca zastępczego.  
  
> [!NOTE]
>  Podstawienia są jedynymi elementami języka wyrażeń regularnych, które są rozpoznawane we wzorcu zamiennym. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znaki ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone tylko w wzorcach wyrażeń regularnych i nie są rozpoznawane w wzorcach zamiennych.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji zastępującej przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub w przypadku <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartości limitu czasu, nie jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład zastępuje pięć pierwszych wystąpień zduplikowanych znaków pojedynczym znakiem. Wzorzec `(\w)\1` wyrażenia regularnego dopasowuje kolejne wystąpienia pojedynczego znaku i przypisuje pierwsze wystąpienie do pierwszej grupy przechwytywania. Wzorzec `$1` zamieniania zastępuje całe dopasowanie do pierwszej przechwyconej grupy.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego z określonym ciągiem zastępczym.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zamienny przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowane w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody statyczne `Replace` są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu z określonym wzorcem wyrażenia regularnego i wywoływania metody `Replace`wystąpienia.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Wyszukiwanie dopasowań rozpoczyna się na początku `input` ciągu.  
  
 Parametr określa ciąg, który ma zastąpić poszczególne dopasowania w `input`. `replacement` `replacement`może składać się z dowolnej kombinacji tekstu literału [](~/docs/standard/base-types/substitutions-in-regular-expressions.md)i podstawienia. Na przykład wzorzec `a*${test}b` zastępczy wstawia ciąg "a *", po którym następuje podciąg, który jest dopasowany `test` przez grupę przechwytywania, jeśli istnieje, a następnie ciąg "b". Znak * nie jest rozpoznawany jako metaznak w obrębie wzorca zastępczego.  
  
> [!NOTE]
>  Podstawienia są jedynymi elementami języka wyrażeń regularnych, które są rozpoznawane we wzorcu zamiennym. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znaki ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone tylko w wzorcach wyrażeń regularnych i nie są rozpoznawane w wzorcach zamiennych.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest zgłaszany, jeśli czas wykonywania operacji zastępującej przekracza interwał limitu czasu określony dla domeny aplikacji, w której wywoływana jest metoda. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji lub limit czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartością, nie jest zgłaszany żaden wyjątek.  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład definiuje wyrażenie regularne, `\s+`które dopasowuje co najmniej jeden znak odstępu. Ciąg zastępczy "" zastępuje je pojedynczym znakiem odstępu.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 Poniższy przykład używa <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> metody, aby zastąpić nazwy komputera lokalnego i dysku w ścieżce UNC ścieżką pliku lokalnego. Wyrażenie regularne używa <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby dołączyć nazwę komputera lokalnego <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> i metodę dołączania nazw dysków logicznych. Aby pomyślnie uruchomić przykład, należy zastąpić ciąg literału "MojKomputer" nazwą komputera lokalnego.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Wzorzec wyrażenia regularnego jest definiowany przez następujące wyrażenie:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\\\\`| Dopasowuje dwa kolejne znaki ukośnika odwrotnego (`\`). Ponieważ znak ukośnika odwrotnego jest interpretowany jako znak ucieczki, każdy ukośnik odwrotny musi zostać zmieniony z innym ukośnikiem odwrotnym.|  
|`(?i:" + Environment.MachineName + ")`|Wykonaj dopasowanie do wielkości liter ciągu, który jest zwracany przez <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwość.|  
|`(?:\.\w+)*`|Dopasowuje znak kropki (`.`), po którym następuje jeden lub więcej znaków wyrazu. Takie dopasowanie może wystąpić zero lub więcej razy. Dopasowane Podwyrażenie nie jest przechwytywane.|  
|`\\`| Dopasowuje znak ukośnika`\`odwrotnego ().|  
|`((?i:[" + driveNames + "]))`|Wykonaj dopasowanie bez uwzględniania wielkości liter klasy znaków, która składa się z pojedynczych liter dysku. Ten odpowiednik to pierwsze przechwycone Podwyrażenie.|  
|`\$`|Dopasowuje znak dolara literału (`$`).|  
  
 Wzorzec `$1` zamieniania zastępuje całe dopasowanie do pierwszego przechwyconego podwyrażenia. Oznacza to, że zastępuje maszynę UNC i nazwę dysku literą dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekroczy limit czasu, który jest równy domyślnemu limitowi wartości w domenie aplikacji, w której jest wywoływany. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną do zamiany dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />jest, która umożliwia ustawienie interwału limitu czasu.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="evaluator">Metoda niestandardowa, która sprawdza każdy odpowiednik i zwraca oryginalny dopasowany ciąg lub ciąg zastępczy.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego ciągiem zwracanym przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegata.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zastępczy przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowane w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Ciąg zamienny nie może być łatwo określony przez wzorzec zamiany wyrażenia regularnego.  
  
-   Ciąg zamienny jest wynikiem niektórych operacji przetwarzania dla dopasowanego ciągu.  
  
-   Ciąg zamienny jest wynikiem przetwarzania warunkowego.  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> Metoda jest równoważna wywołaniu metody i przekazanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconej <xref:System.Text.RegularExpressions.MatchCollection> kolekcji do `evaluator` delegata.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Parametr jest delegatem dla niestandardowej metody, która jest definiowana i bada każde dopasowanie. Aby można było dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegata, Metoda niestandardowa musi mieć następujący podpis.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Metoda niestandardowa zwraca ciąg, który zastępuje dopasowane dane wejściowe.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest zgłaszany, jeśli czas wykonywania operacji zastępującej przekracza interwał limitu czasu określony dla domeny aplikacji, w której wywoływana jest metoda. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji lub limit czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartością, nie jest zgłaszany żaden wyjątek.  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład używa wyrażenia regularnego w celu wyodrębnienia pojedynczych wyrazów z ciągu, a następnie używa <xref:System.Text.RegularExpressions.MatchEvaluator> delegata do wywołania metody o nazwie `WordScramble` , która szyfruje poszczególne litery w słowie. W tym celu Metoda tworzy tablicę zawierającą znaki w dopasowaniu. `WordScramble` Tworzy również tablicę równoległą, która wypełnia losowo losowe liczby zmiennoprzecinkowe. Tablice są sortowane przez wywołanie <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metody, a posortowana tablica jest dostarczana jako argument <xref:System.String> do konstruktora klasy. Ten nowo utworzony ciąg jest następnie zwracany przez `WordScramble` metodę. Wzorzec `\w+` wyrażenia regularnego dopasowuje jeden lub więcej znaków wyrazu; aparat wyrażeń regularnych będzie nadal dodawać znaki do dopasowania, dopóki nie napotka znaku niebędącego znakiem słowa, takiego jak znak odstępu.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekroczy limit czasu, który jest równy domyślnemu limitowi wartości w domenie aplikacji, w której jest wywoływany. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną do oceny i zastąpienia dopasowania wzorca jest <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która umożliwia ustawienie interwału limitu czasu.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="evaluator">Metoda niestandardowa, która sprawdza każdy odpowiednik i zwraca oryginalny dopasowany ciąg lub ciąg zastępczy.</param>
        <param name="count">Maksymalna liczba wystąpień zamiany.</param>
        <summary>W określonym ciągu wejściowym zastępuje określoną maksymalną liczbę ciągów, które pasują do wzorca wyrażenia regularnego, za pomocą ciągu zwracanego <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> przez delegata.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zastępczy przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Ciąg zamienny nie może być łatwo określony przez wzorzec zamiany wyrażenia regularnego.  
  
-   Ciąg zamienny jest wynikiem niektórych operacji przetwarzania dla dopasowanego ciągu.  
  
-   Ciąg zamienny jest wynikiem przetwarzania warunkowego.  
  
 Metoda jest równoważna wywołaniu <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> metody i przekazaniu pierwszych `count` <xref:System.Text.RegularExpressions.Match> obiektów w zwróconej <xref:System.Text.RegularExpressions.MatchCollection> kolekcji do `evaluator` delegata.  
  
 Wyrażenie regularne jest wzorcem zdefiniowanym przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `evaluator` Parametr jest delegatem dla niestandardowej metody, która jest definiowana i bada każde dopasowanie. Aby można było dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegata, Metoda niestandardowa musi mieć następujący podpis.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Metoda niestandardowa zwraca ciąg, który zastępuje dopasowane dane wejściowe.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji zastępującej przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub w przypadku <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartości limitu czasu, nie jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie używa się wyrażenia regularnego w celu zamierzonego wpisania w połowie słów wyrazów na liście. Używa wyrażenia `\w*(ie|ei)\w*` regularnego do dopasowania wyrazów, które zawierają znaki "IE" lub "ei". Przekazuje pierwszą połowę pasujących słów do `ReverseLetter` metody, która z kolei <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> używa metody do odwrócenia "i" i "e" w dopasowanym ciągu. Pozostałe wyrazy pozostaną bez zmian.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 Wyrażenie `\w*(ie|ei)\w*` regularne jest zdefiniowane, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\w*`|Dopasowuje zero lub więcej znaków słowa.|  
|<code>(ie&#124;ei)</code>|Dopasowuje "IE" lub "ei".|  
|`\w*`|Dopasowuje zero lub więcej znaków słowa.|  
  
 Wzorzec `([ie])([ie])` wyrażenia regularnego `ReverseLetter` w metodzie dopasowuje pierwszy "i" lub "e" w diphthong "IE" lub "ei" i przypisuje literę do pierwszej grupy przechwytywania. Jest on zgodny z drugim "i" lub "e" i przypisuje literę do drugiej grupy przechwytywania. Te dwa znaki są następnie odwracane przez wywołanie <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> metody ze wzorcem `$2$1`zastępczym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="count">Maksymalna liczba przypadków, w których może wystąpić zastąpienie.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowym, w którym rozpoczyna się wyszukiwanie.</param>
        <summary>W określonym podciągu wejściowym zastępuje określoną maksymalną liczbę ciągów, które pasują do wzorca wyrażenia regularnego z określonym ciągiem zastępczym.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zamienny przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie dopasowań rozpocznie się w `input` ciągu na pozycji określonej `startat` przez parametr. Wyrażenie regularne jest wzorcem zdefiniowanym przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu. Jeśli `count` jest ujemna, zamienniki są kontynuowane na końcu ciągu. Jeśli `count` przekracza liczbę dopasowań, wszystkie dopasowania są zastępowane.  
  
 Parametr określa ciąg, który ma zastąpić poszczególne dopasowania w `input`. `replacement` `replacement`może składać się z dowolnej kombinacji tekstu literału [](~/docs/standard/base-types/substitutions-in-regular-expressions.md)i podstawienia. Na przykład wzorzec `a*${test}b` zastępczy wstawia ciąg "a *", po którym następuje podciąg, który jest dopasowany `test` przez grupę przechwytywania, jeśli istnieje, a następnie ciąg "b". Znak * nie jest rozpoznawany jako metaznak w obrębie wzorca zastępczego.  
  
> [!NOTE]
>  Podstawienia są jedynymi elementami języka wyrażeń regularnych, które są rozpoznawane we wzorcu zamiennym. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znaki ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone tylko w wzorcach wyrażeń regularnych i nie są rozpoznawane w wzorcach zamiennych.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji zastępującej przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub w przypadku <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartości limitu czasu, nie jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład zawiera dwie spacje, oprócz pierwszego wiersza ciągu. Definiuje wzorzec `^.*$`wyrażenia regularnego, który dopasowuje wiersz tekstu, <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> wywołuje metodę w celu dopasowania do pierwszego wiersza `Match.Index` ciągu i używa właściwości i `Match.Count` do określenia pozycji początkowej drugiego liniow.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Wzorzec `^.*$` wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Dopasowuje początek wiersza. (Należy zauważyć, <xref:System.Text.RegularExpressions.Regex> że obiekt został skonkretyzowany przy <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> użyciu opcji; w przeciwnym razie ta klasa znaku będzie pasować tylko do początku ciągu wejściowego).|  
|`.*`|Dopasowuje dowolny znak zero lub więcej razy.|  
|`$`|Dopasowuje koniec wiersza. (Należy zauważyć, <xref:System.Text.RegularExpressions.Regex> że obiekt został skonkretyzowany przy <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> użyciu opcji; w przeciwnym razie ta klasa znaku będzie pasować tylko do początku ciągu wejściowego).|  
  
 Ciąg zamienny (`vbCrLf + "$&"` w Visual Basic, `"\n$&"` in C#) dodaje nowy wiersz przed dopasowanym ciągiem. Należy zauważyć `\n` , że C# w przykładzie jest interpretowany jako znak nowego wiersza C# przez kompilator; nie reprezentuje znaku wyrażenia regularnego ucieczki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego z określonym ciągiem zastępczym. Określone opcje modyfikują operację dopasowywania.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zamienny przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowane w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody statyczne `Replace` są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu z określonym wzorcem wyrażenia regularnego i wywoływania metody `Replace`wystąpienia.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> `options` dla parametru, wyszukiwanie trafień rozpoczyna się na końcu ciągu wejściowego i przesuwa się w lewo; w przeciwnym wypadku wyszukiwanie rozpoczyna się na początku ciągu wejściowego i przenosi do prawej.  
  
 Parametr określa ciąg, który ma zastąpić poszczególne dopasowania w `input`. `replacement` `replacement`może składać się z dowolnej kombinacji tekstu literału [](~/docs/standard/base-types/substitutions-in-regular-expressions.md)i podstawienia. Na przykład wzorzec `a*${test}b` zastępczy wstawia ciąg "a *", po którym następuje podciąg, który jest dopasowany `test` przez grupę przechwytywania, jeśli istnieje, a następnie ciąg "b". Znak * nie jest rozpoznawany jako metaznak w obrębie wzorca zastępczego.  
  
> [!NOTE]
>  Podstawienia są jedynymi elementami języka wyrażeń regularnych, które są rozpoznawane we wzorcu zamiennym. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znaki ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone tylko w wzorcach wyrażeń regularnych i nie są rozpoznawane w wzorcach zamiennych.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest zgłaszany, jeśli czas wykonywania operacji zastępującej przekracza interwał limitu czasu określony dla domeny aplikacji, w której wywoływana jest metoda. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji lub limit czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartością, nie jest zgłaszany żaden wyjątek.  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metody, aby zastąpić nazwy komputera lokalnego i dysku w ścieżce UNC ścieżką pliku lokalnego. Wyrażenie regularne używa <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby dołączyć nazwę komputera lokalnego <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> i metodę dołączania nazw dysków logicznych. Wszystkie porównania ciągów regularnych nie uwzględniają wielkości liter. Aby pomyślnie uruchomić przykład, należy zastąpić ciąg literału "MojKomputer" nazwą komputera lokalnego.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Wzorzec wyrażenia regularnego jest definiowany przez następujące wyrażenie:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\\\\`| Dopasowuje dwa kolejne znaki ukośnika odwrotnego (`\`). Ponieważ znak ukośnika odwrotnego jest interpretowany jako znak ucieczki, każdy ukośnik odwrotny musi zostać zmieniony z innym ukośnikiem odwrotnym.|  
|`+ Environment.MachineName +`|Dopasowuje ciąg, który jest zwracany przez <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwość.|  
|`(?:\.\w+)*`|Dopasowuje znak kropki (`.`), po którym następuje jeden lub więcej znaków wyrazu. Takie dopasowanie może wystąpić zero lub więcej razy. Dopasowane Podwyrażenie nie jest przechwytywane.|  
|`\\`| Dopasowuje znak ukośnika`\`odwrotnego ().|  
|`([" + driveNames + "])`|Dopasowuje klasę znaku, która składa się z pojedynczych liter dysku. Ten odpowiednik to pierwsze przechwycone Podwyrażenie.|  
|`\$`|Dopasowuje znak dolara literału (`$`).|  
  
 Wzorzec `$1` zamieniania zastępuje całe dopasowanie do pierwszego przechwyconego podwyrażenia. Oznacza to, że zastępuje maszynę UNC i nazwę dysku literą dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową bitową kombinacją <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekroczy limit czasu, który jest równy domyślnemu limitowi wartości w domenie aplikacji, w której jest wywoływany. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną do zamiany dopasowania wzorca <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />jest, która umożliwia ustawienie interwału limitu czasu.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="evaluator">Metoda niestandardowa, która sprawdza każdy odpowiednik i zwraca oryginalny dopasowany ciąg lub ciąg zastępczy.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego ciągiem zwracanym przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegata. Określone opcje modyfikują operację dopasowywania.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zastępczy przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowane w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Metoda jest przydatna do zamiany dopasowania wyrażenia regularnego w przypadku, gdy spełniony jest dowolny z następujących warunków:  
  
-   Ciąg zamienny nie może być łatwo określony przez wzorzec zamiany wyrażenia regularnego.  
  
-   Ciąg zamienny jest wynikiem niektórych operacji przetwarzania dla dopasowanego ciągu.  
  
-   Ciąg zamienny jest wynikiem przetwarzania warunkowego.  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Metoda jest równoważna wywołaniu metody i przekazanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconej <xref:System.Text.RegularExpressions.MatchCollection> kolekcji do `evaluator` delegata.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Parametr jest delegatem dla niestandardowej metody, która jest definiowana i bada każde dopasowanie. Aby można było dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegata, Metoda niestandardowa musi mieć następujący podpis.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Metoda niestandardowa zwraca ciąg, który zastępuje dopasowane dane wejściowe.  
  
 Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> `options` dla parametru, wyszukiwanie trafień rozpoczyna się na końcu ciągu wejściowego i przesuwa się w lewo; w przeciwnym wypadku wyszukiwanie rozpoczyna się na początku ciągu wejściowego i przenosi do prawej.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest zgłaszany, jeśli czas wykonywania operacji zastępującej przekracza interwał limitu czasu określony dla domeny aplikacji, w której wywoływana jest metoda. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji lub limit czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartością, nie jest zgłaszany żaden wyjątek.  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład używa wyrażenia regularnego w celu wyodrębnienia pojedynczych wyrazów z ciągu, a następnie używa <xref:System.Text.RegularExpressions.MatchEvaluator> delegata do wywołania metody o nazwie `WordScramble` , która szyfruje poszczególne litery w słowie. W tym celu Metoda tworzy tablicę zawierającą znaki w dopasowaniu. `WordScramble` Tworzy również tablicę równoległą, która wypełnia losowo losowe liczby zmiennoprzecinkowe. Tablice są sortowane przez wywołanie <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metody, a posortowana tablica jest dostarczana jako argument <xref:System.String> do konstruktora klasy. Ten nowo utworzony ciąg jest następnie zwracany przez `WordScramble` metodę. Wzorzec `\w+` wyrażenia regularnego dopasowuje jeden lub więcej znaków wyrazu; aparat wyrażeń regularnych będzie nadal dodawać znaki do dopasowania, dopóki nie napotka znaku niebędącego znakiem słowa, takiego jak znak odstępu. Wywołanie <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> metody `\w+  # Matches all the characters in a word.` obejmuje opcję, dzięki czemu komentarz we wzorcu wyrażenia regularnego jest ignorowany przez aparat wyrażeń regularnych. <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową bitową kombinacją <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="evaluator">Metoda niestandardowa, która sprawdza każdy odpowiednik i zwraca oryginalny dopasowany ciąg lub ciąg zastępczy.</param>
        <param name="count">Maksymalna liczba wystąpień zamiany.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowym, w którym rozpoczyna się wyszukiwanie.</param>
        <summary>W określonym podciągu wejściowym zastępuje określoną maksymalną liczbę ciągów, które pasują do wzorca wyrażenia regularnego z ciągiem zwracanym przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegata.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zastępczy przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Ciąg zamienny nie może być łatwo określony przez wzorzec zamiany wyrażenia regularnego.  
  
-   Ciąg zamienny jest wynikiem niektórych operacji przetwarzania dla dopasowanego ciągu.  
  
-   Ciąg zamienny jest wynikiem przetwarzania warunkowego.  
  
 Metoda jest równoważna wywołaniu <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metody i przekazaniu pierwszych `count` <xref:System.Text.RegularExpressions.Match> obiektów w zwróconej <xref:System.Text.RegularExpressions.MatchCollection> kolekcji do `evaluator` delegata.  
  
 Wyrażenie regularne jest wzorcem zdefiniowanym przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `evaluator` Parametr jest delegatem dla niestandardowej metody, która jest definiowana i bada każde dopasowanie. Aby można było dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegata, Metoda niestandardowa musi mieć następujący podpis.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Metoda niestandardowa zwraca ciąg, który zastępuje dopasowane dane wejściowe.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji zastępującej przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub w przypadku <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartości limitu czasu, nie jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="replacement" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> wskazuje, że metoda nie powinna przekroczyć limitu czasu.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego z określonym ciągiem zastępczym. Dodatkowe parametry określają opcje modyfikujące pasującą operację i interwał limitu czasu, jeśli nie znaleziono dopasowania.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zamienny przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowane w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody statyczne `Replace` są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu z określonym wzorcem wyrażenia regularnego i wywoływania metody `Replace`wystąpienia.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> `options` dla parametru, wyszukiwanie trafień rozpoczyna się na końcu ciągu wejściowego i przesuwa się w lewo; w przeciwnym wypadku wyszukiwanie rozpoczyna się na początku ciągu wejściowego i przenosi do prawej.  
  
 Parametr określa ciąg, który ma zastąpić poszczególne dopasowania w `input`. `replacement` `replacement`może składać się z dowolnej kombinacji tekstu literału [](~/docs/standard/base-types/substitutions-in-regular-expressions.md)i podstawienia. Na przykład wzorzec `a*${test}b` zastępczy wstawia ciąg "a *", po którym następuje podciąg, który jest dopasowany `test` przez grupę przechwytywania, jeśli istnieje, a następnie ciąg "b". Znak * nie jest rozpoznawany jako metaznak w obrębie wzorca zastępczego.  
  
> [!NOTE]
>  Podstawienia są jedynymi elementami języka wyrażeń regularnych, które są rozpoznawane we wzorcu zamiennym. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znaki ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone tylko w wzorcach wyrażeń regularnych i nie są rozpoznawane w wzorcach zamiennych.  
  
 `matchTimeout` Parametr określa, jak długo Metoda dopasowywania wzorców powinna próbować znaleźć dopasowanie przed upływem limitu czasu. Ustawienie interwału limitu czasu uniemożliwia wyrażenia regularne, które opierają się na nadmiernym wycofywaniu z wyświetlania, aby przestać odpowiadać podczas przetwarzania danych wejściowych zawierających blisko dopasowań. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) [i wycofywania](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli żadne dopasowanie nie zostanie znalezione w tym interwale czasu, metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek. `matchTimeout`zastępuje wszystkie domyślne wartości limitu czasu zdefiniowane dla domeny aplikacji, w której jest wykonywana metoda.  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metody, aby zastąpić nazwy komputera lokalnego i dysku w ścieżce UNC ścieżką pliku lokalnego. Wyrażenie regularne używa <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby dołączyć nazwę komputera lokalnego <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> i metodę dołączania nazw dysków logicznych. W przypadku wszystkich porównań ciągów regularnych jest rozróżniana wielkość liter, a każda operacja zastępcza jest przepadana, jeśli nie można znaleźć dopasowania w 0,5 sekund. Aby pomyślnie uruchomić przykład, należy zastąpić ciąg literału "MojKomputer" nazwą komputera lokalnego.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Wzorzec wyrażenia regularnego jest definiowany przez następujące wyrażenie:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 W poniższej tabeli przedstawiono sposób interpretowania wzorca wyrażenia regularnego.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\\\\`| Dopasowuje dwa kolejne znaki ukośnika odwrotnego (`\`). Ponieważ znak ukośnika odwrotnego jest interpretowany jako znak ucieczki, każdy ukośnik odwrotny musi zostać zmieniony z innym ukośnikiem odwrotnym.|  
|`+ Environment.MachineName +`|Dopasowuje ciąg, który jest zwracany przez <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwość.|  
|`(?:\.\w+)*`|Dopasowuje znak kropki (`.`), po którym następuje jeden lub więcej znaków wyrazu. Takie dopasowanie może wystąpić zero lub więcej razy. Dopasowane Podwyrażenie nie jest przechwytywane.|  
|`\\`| Dopasowuje znak ukośnika`\`odwrotnego ().|  
|`([" + driveNames + "])`|Dopasowuje klasę znaku, która składa się z pojedynczych liter dysku. Ten odpowiednik to pierwsze przechwycone Podwyrażenie.|  
|`\$`|Dopasowuje znak dolara literału (`$`).|  
  
 Wzorzec `$1` zamieniania zastępuje całe dopasowanie do pierwszego przechwyconego podwyrażenia. Oznacza to, że zastępuje maszynę UNC i nazwę dysku literą dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową bitową kombinacją <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  
  
—lub— 
 <paramref name="matchTimeout" />jest ujemna, równa zero lub większa niż około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Zalecamy ustawienie <paramref name="matchTimeout" /> parametru na odpowiednią wartość, na przykład dwie sekundy. Jeśli wyłączysz limity czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych oferuje nieco lepszą wydajność. Należy jednak wyłączyć limity czasu tylko w następujących warunkach: 
— Gdy dane wejściowe przetwarzane przez wyrażenie regularne pochodzą od znanego i zaufanego źródła lub zawierają tekst statyczny. Wyklucza to tekst, który jest dynamicznie wprowadzany przez użytkowników.  
  
-Kiedy wzorzec wyrażenia regularnego został dokładnie przetestowany w celu zapewnienia, że wydajnie obsługuje dopasowania, nie są dopasowań i blisko dopasowań.  
  
-Kiedy wzorzec wyrażenia regularnego nie zawiera elementów języka, które są znane, aby spowodować nadmierne wycofywanie podczas przetwarzania blisko dopasowania.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Nawracanie</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Najlepsze praktyki dotyczące prawidłowych wyrażeń w .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, aby wyszukać dopasowanie.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="evaluator">Metoda niestandardowa, która sprawdza każdy odpowiednik i zwraca oryginalny dopasowany ciąg lub ciąg zastępczy.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> wskazuje, że metoda nie powinna przekroczyć limitu czasu.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie podciągi, które pasują do określonego wyrażenia regularnego ciągiem zwracanym przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegata. Dodatkowe parametry określają opcje modyfikujące pasującą operację i interwał limitu czasu, jeśli nie znaleziono dopasowania.</summary>
        <returns>Nowy ciąg, który jest identyczny z ciągiem wejściowym, z tą różnicą, że ciąg zamienny przyjmuje miejsce dla każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowane w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Jeśli ciąg zamienny nie może być w łatwy sposób określony przez wzorzec zamiany wyrażenia regularnego.  
  
-   Jeśli ciąg zamienny jest wynikiem niektórych operacji przetwarzania w dopasowanym ciągu.  
  
-   Jeśli ciąg zamienny jest wynikiem przetwarzania warunkowego.  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Metoda jest równoważna wywołaniu metody i przekazanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconej <xref:System.Text.RegularExpressions.MatchCollection> kolekcji do `evaluator` delegata.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Parametr jest delegatem dla niestandardowej metody, która jest definiowana i bada każde dopasowanie. Aby można było dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegata, Metoda niestandardowa musi mieć następujący podpis.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Metoda niestandardowa zwraca ciąg, który zastępuje dopasowane dane wejściowe.  
  
 Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> `options` dla parametru, wyszukiwanie trafień rozpoczyna się na końcu ciągu wejściowego i przesuwa się w lewo; w przeciwnym wypadku wyszukiwanie rozpoczyna się na początku ciągu wejściowego i przenosi do prawej.  
  
 `matchTimeout` Parametr określa, jak długo Metoda dopasowywania wzorców powinna próbować znaleźć dopasowanie przed upływem limitu czasu. Ustawienie interwału limitu czasu uniemożliwia wyrażenia regularne, które opierają się na nadmiernym wycofywaniu, od wyświetlania do "przestać odpowiadać podczas przetwarzania danych wejściowych zawierających blisko dopasowań. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) [i wycofywania](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli żadne dopasowanie nie zostanie znalezione w tym interwale czasu, metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek. `matchTimeout`zastępuje wszystkie domyślne wartości limitu czasu zdefiniowane dla domeny aplikacji, w której jest wykonywana metoda.  
  
 Ponieważ metoda zwraca wartość `input` Unchanged, jeśli nie ma dopasowania, można <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> użyć metody, aby określić, czy metoda wprowadziła jakiekolwiek zamienniki do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład używa wyrażenia regularnego w celu wyodrębnienia pojedynczych wyrazów z ciągu, a następnie używa <xref:System.Text.RegularExpressions.MatchEvaluator> delegata do wywołania metody o nazwie `WordScramble` , która szyfruje poszczególne litery w słowie. W tym celu Metoda tworzy tablicę zawierającą znaki w dopasowaniu. `WordScramble` Tworzy również tablicę równoległą, która wypełnia losowo losowe liczby zmiennoprzecinkowe. Tablice są sortowane przez wywołanie <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metody, a posortowana tablica jest dostarczana jako argument <xref:System.String> do konstruktora klasy. Ten nowo utworzony ciąg jest następnie zwracany przez `WordScramble` metodę. Wzorzec `\w+` wyrażenia regularnego dopasowuje jeden lub więcej znaków wyrazu; aparat wyrażeń regularnych będzie nadal dodawać znaki do dopasowania, dopóki nie napotka znaku niebędącego znakiem słowa, takiego jak znak odstępu. Wywołanie <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> metody `\w+  # Matches all the characters in a word.` obejmuje opcję, dzięki czemu komentarz we wzorcu wyrażenia regularnego jest ignorowany przez aparat wyrażeń regularnych. <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową bitową kombinacją <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  
  
—lub— 
 <paramref name="matchTimeout" />jest ujemna, równa zero lub większa niż około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Zalecamy ustawienie <paramref name="matchTimeout" /> parametru na odpowiednią wartość, na przykład dwie sekundy. Jeśli wyłączysz limity czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych oferuje nieco lepszą wydajność. Należy jednak wyłączyć limity czasu tylko w następujących warunkach: 
— Gdy dane wejściowe przetwarzane przez wyrażenie regularne pochodzą od znanego i zaufanego źródła lub zawierają tekst statyczny. Wyklucza to tekst, który jest dynamicznie wprowadzany przez użytkowników.  
  
-Kiedy wzorzec wyrażenia regularnego został dokładnie przetestowany w celu zapewnienia, że wydajnie obsługuje dopasowania, nie są dopasowań i blisko dopasowań.  
  
-Kiedy wzorzec wyrażenia regularnego nie zawiera elementów języka, które są znane, aby spowodować nadmierne wycofywanie podczas przetwarzania blisko dopasowania.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Nawracanie</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Najlepsze praktyki dotyczące prawidłowych wyrażeń w .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wyrażenie regularne przeszukuje od prawej do lewej.</summary>
        <value><see langword="true" />Jeśli wyrażenie regularne przeszukuje od prawej do lewej; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A>jest `true` Jeśli<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> wystąpienie zostało utworzone przy użyciu opcji. <xref:System.Text.RegularExpressions.Regex>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używany przez <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt wygenerowany <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> przez metodę.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dzieli ciąg wejściowy na tablicę podciągów w pozycjach zdefiniowanych przez dopasowanie wyrażenia regularnego.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do podzielenia.</param>
        <summary>Dzieli ciąg wejściowy na tablicę podciągów w pozycjach zdefiniowanych przez wzorzec wyrażenia regularnego określony w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktorze.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody są podobne <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> do metody, z tą różnicą <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> , że dzieli ciąg na ogranicznik określony przez wyrażenie regularne zamiast zestawu znaków. <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ciąg jest dzielony dowolną liczbę razy. Jeśli nie zostanie znaleziony ogranicznik, wartość zwracana zawiera jeden element, którego wartość jest pierwotnym ciągiem wejściowym.  
  
 Jeśli wiele dopasowań przylegają do siebie, pusty ciąg zostanie wstawiony do tablicy. Na przykład dzielenie ciągu na pojedynczym łączniku powoduje, że zwracana tablica zawiera pusty ciąg w pozycji, w której znajdują się dwa sąsiednie łączniki, jak pokazano w poniższym kodzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Jeśli dopasowanie zostanie znalezione na początku lub na końcu ciągu wejściowego, pusty ciąg jest uwzględniany na początku lub na końcu zwróconej tablicy. Poniższy przykład używa wzorca `\d+` wyrażenia regularnego, aby podzielić ciąg wejściowy na znaki numeryczne. Ponieważ ciąg rozpoczyna się i kończą się pasującymi znakami liczbowymi, wartość pierwszego i ostatniego elementu zwracanej tablicy to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 W przypadku użycia nawiasów przechwytujących w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażeniu wszystkie przechwycone teksty są uwzględniane w zwracanej tablicy ciągów. Na przykład w przypadku podzielenia ciągu "śliwe-gruszk" na łączniku umieszczonym w nawiasach przechwytywania zwracana tablica zawiera element String zawierający łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Jeśli jednak wzorzec wyrażenia regularnego zawiera wiele zestawów w nawiasach przechwytywania, zachowanie tej metody zależy od wersji .NET Framework. W .NET Framework 1,0 i 1,1, jeśli dopasowanie nie zostanie znalezione w pierwszym zestawie nawiasów przechwytywania, przechwycony tekst z dodatkowych nawiasów przechwytywania nie jest uwzględniony w zwracanej tablicy. Począwszy od .NET Framework 2,0, cały przechwycony tekst zostanie również dodany do zwróconej tablicy. Na przykład poniższy kod używa dwóch zestawów przechwytywania w celu wyodrębnienia elementów daty, w tym ograniczników dat, z ciągu daty. Pierwszy zestaw w nawiasach przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod jest kompilowany i uruchamiany pod .NET Framework 1,0 lub 1,1, wyklucza znaki ukośnika; Jeśli zostanie skompilowany i uruchomiona w .NET Framework 2,0 lub nowszej wersji, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Jeśli wyrażenie regularne może pasować do pustego ciągu, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> program podzieli ciąg na tablicę ciągów z pojedynczym znakiem, ponieważ w każdej lokalizacji można znaleźć pusty ogranicznik ciągu. Na przykład:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Zwróć uwagę, że zwracana tablica zawiera również pusty ciąg na początku i na końcu tablicy.  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji Split przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub w przypadku <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartości limitu czasu, nie jest zgłaszany żaden wyjątek  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do podzielenia.</param>
        <param name="count">Maksymalna liczba przypadków, w których może wystąpić podział.</param>
        <summary>Dzieli ciąg wejściowy określoną maksymalną liczbę razy na tablicę podciągów w pozycjach zdefiniowanych przez wyrażenie regularne określone w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktorze.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody są podobne <xref:System.String.Split%2A?displayProperty=nameWithType> do metody, z tą różnicą <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> , że dzieli ciąg na ogranicznik określony przez wyrażenie regularne zamiast zestawu znaków. <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Parametr określa maksymalną liczbę podciągów, w `input` których można podzielić ciąg; ostatni ciąg zawiera niepodzielony resztę ciągu. `count` `count` Wartość zero zapewnia domyślne zachowanie dzielenia, ile razy jest to możliwe.  
  
 Jeśli wiele dopasowania przylegają do siebie lub jeśli dopasowanie zostanie znalezione na początku lub na `input`końcu, a liczba znalezionych dopasowań jest co najmniej dwa mniejsze niż `count`, pusty ciąg jest wstawiany do tablicy. Oznacza to, że puste ciągi, które wynikają z sąsiednich dopasowań lub dopasowań na początku lub na końcu ciągu wejściowego, są zliczane w określaniu, czy liczba `count`dopasowanych podciągów jest równa. W poniższym przykładzie wyrażenie `/d+` regularne służy do dzielenia ciągu wejściowego, który zawiera co najmniej jedną cyfrę dziesiętną do maksymalnie trzech podciągów. Ponieważ początek ciągu wejściowego pasuje do wzorca wyrażenia regularnego, pierwszy element tablicy zawiera <xref:System.String.Empty?displayProperty=nameWithType>, drugi zawiera pierwszy zestaw znaków alfabetycznych w ciągu wejściowym, a trzecia zawiera resztę ciągu jest to zgodne z trzecim dopasowaniem.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 W przypadku używania nawiasów do przechwytywania w wyrażeniu regularnym wszystkie przechwycone teksty są uwzględniane w tablicy podziałów ciągów. Jednak żadne elementy tablicy, które zawierają przechwycony tekst, nie są zliczane podczas określania, czy osiągnięto `count`liczbę dopasowań. Na przykład dzielenie ciągu "Apple-morele-śliwe-gruszka" na maksymalnie cztery podciągi powoduje umieszczenie w tablicy siedmiu elementów, jak pokazano w poniższym kodzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Jeśli jednak wzorzec wyrażenia regularnego zawiera wiele zestawów w nawiasach przechwytywania, zachowanie tej metody zależy od wersji .NET Framework. W .NET Framework 1,0 i 1,1 tylko przechwycony tekst z pierwszego zestawu nawiasów przechwytywania jest zawarty w zwracanej tablicy. Począwszy od .NET Framework 2,0, cały przechwycony tekst zostanie dodany do zwróconej tablicy. Jednak elementy w tablicy zwracanej, które zawierają przechwycony tekst, nie są zliczane podczas określania, czy liczba dopasowanych podciągów jest równa `count`. Na przykład, w poniższym kodzie wyrażenie regularne używa dwóch zestawów przechwytywania w celu wyodrębnienia elementów daty z ciągu daty. Pierwszy zestaw w nawiasach przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Wywołanie <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> metody następnie określa maksymalnie dwa elementy w zwróconej tablicy. Jeśli przykładowy kod jest kompilowany i uruchamiany pod .NET Framework 1,0 lub 1,1, metoda zwraca tablicę ciągów z dwoma elementami. Jeśli jest kompilowany i uruchamiany w .NET Framework 2,0 lub nowszych wersjach, metoda zwraca tablicę ciągów z trzema elementami.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Jeśli wyrażenie regularne może pasować do pustego ciągu, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> program podzieli ciąg na tablicę ciągów z pojedynczym znakiem, ponieważ w każdej lokalizacji można znaleźć pusty ogranicznik ciągu. W poniższym przykładzie ciąg znaków "characters" jest dzielony na dowolną liczbę elementów w ciągu wejściowym. Ponieważ ciąg o wartości null pasuje do początku ciągu wejściowego, na początku zwróconej tablicy zostanie wstawiony ciąg o wartości null. Powoduje to, że dziesiąty element składa się z dwóch znaków na końcu ciągu wejściowego.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji Split przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub w przypadku <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartości limitu czasu, nie jest zgłaszany żaden wyjątek  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do podzielenia.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Dzieli ciąg wejściowy na tablicę podciągów w pozycjach zdefiniowanych przez wzorzec wyrażenia regularnego.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody są podobne <xref:System.String.Split%2A?displayProperty=nameWithType> do metody, z tą różnicą <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> , że dzieli ciąg na ogranicznik określony przez wyrażenie regularne zamiast zestawu znaków. <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> `input` Ciąg jest dzielony dowolną liczbę razy. Jeśli `pattern` nie odnaleziono `input` w ciągu, wartość zwracana zawiera jeden element, którego wartość jest pierwotnym `input` ciągiem.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Skompilowane wyrażenia regularne używane w wywołaniach <xref:System.Text.RegularExpressions.Regex.Split%2A> metod statycznych są automatycznie buforowane. Aby samodzielnie zarządzać okresem istnienia skompilowanych wyrażeń regularnych, użyj <xref:System.Text.RegularExpressions.Regex.Split%2A> metod wystąpienia.  
  
 Jeśli wiele dopasowań przylegają do siebie, pusty ciąg zostanie wstawiony do tablicy. Na przykład dzielenie ciągu na pojedynczym łączniku powoduje, że zwracana tablica zawiera pusty ciąg w pozycji, w której znajdują się dwa sąsiednie łączniki, jak pokazano w poniższym kodzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Jeśli dopasowanie zostanie znalezione na początku lub na końcu ciągu wejściowego, pusty ciąg jest uwzględniany na początku lub na końcu zwróconej tablicy. Poniższy przykład używa wzorca `\d+` wyrażenia regularnego, aby podzielić ciąg wejściowy na znaki numeryczne. Ponieważ ciąg rozpoczyna się i kończą się pasującymi znakami liczbowymi, wartość pierwszego i ostatniego elementu zwracanej tablicy to <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 W przypadku użycia nawiasów przechwytujących w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażeniu wszystkie przechwycone teksty są uwzględniane w zwracanej tablicy ciągów. Na przykład w przypadku podzielenia ciągu "śliwe-gruszk" na łączniku umieszczonym w nawiasach przechwytywania zwracana tablica zawiera element String zawierający łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Jeśli jednak wzorzec wyrażenia regularnego zawiera wiele zestawów w nawiasach przechwytywania, zachowanie tej metody zależy od wersji .NET Framework. W .NET Framework 1,0 i 1,1, jeśli dopasowanie nie zostanie znalezione w pierwszym zestawie nawiasów przechwytywania, przechwycony tekst z dodatkowych nawiasów przechwytywania nie jest uwzględniony w zwracanej tablicy. Począwszy od .NET Framework 2,0, cały przechwycony tekst zostanie również dodany do zwróconej tablicy. Na przykład poniższy kod używa dwóch zestawów przechwytywania w celu wyodrębnienia elementów daty, w tym ograniczników dat, z ciągu daty. Pierwszy zestaw w nawiasach przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod jest kompilowany i uruchamiany pod .NET Framework 1,0 lub 1,1, wyklucza znaki ukośnika; Jeśli zostanie skompilowany i uruchomiona w .NET Framework 2,0 lub nowszej wersji, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Jeśli wyrażenie regularne może pasować do pustego ciągu, <xref:System.Text.RegularExpressions.Regex.Split%2A> program podzieli ciąg na tablicę ciągów z pojedynczym znakiem, ponieważ w każdej lokalizacji można znaleźć pusty ogranicznik ciągu. Przykład:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Zwróć uwagę, że zwracana tablica zawiera również pusty ciąg na początku i na końcu tablicy.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest zgłaszany, jeśli czas wykonywania operacji podziału przekracza limit czasu określony dla domeny aplikacji, w której wywoływana jest metoda. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji lub limit czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartością, nie jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekracza interwał, który jest równy domyślnej wartości limitu czasu domeny aplikacji, w której wywoływana jest metoda. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną do dzielenia tekstu na dopasowanie wzorca jest <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która umożliwia ustawienie interwału limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do podzielenia.</param>
        <param name="count">Maksymalna liczba przypadków, w których może wystąpić podział.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowym, w którym rozpocznie się wyszukiwanie.</param>
        <summary>Dzieli ciąg wejściowy określoną maksymalną liczbę razy na tablicę podciągów w pozycjach zdefiniowanych przez wyrażenie regularne określone w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktorze. Wyszukiwanie wzorca wyrażenia regularnego zaczyna się od określonej pozycji znaku w ciągu wejściowym.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody są podobne <xref:System.String.Split%2A?displayProperty=nameWithType> do metody, z tą różnicą <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> , że dzieli ciąg na ogranicznik określony przez wyrażenie regularne zamiast zestawu znaków. <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Parametr określa maksymalną liczbę podciągów, w `input` których ciąg jest dzielony; ostatni ciąg zawiera niepodzielony resztę ciągu. `count` `count` Wartość zero zapewnia domyślne zachowanie dzielenia, ile razy jest to możliwe. `startat` Parametr definiuje punkt, w którym rozpoczyna się wyszukiwanie pierwszego ogranicznika (może być używany do pomijania wiodących białych znaków).  
  
 Jeśli nie znaleziono żadnych dopasowań z `count`pozycji + 1 w ciągu, metoda zwraca tablicę jednoelementową, która `input` zawiera ciąg. W przypadku znalezienia co najmniej jednej dopasowań pierwszy element zwracanej tablicy zawiera pierwszą część ciągu od pierwszego znaku do jednego znaku przed dopasowaniem.  
  
 Jeśli wiele dopasowań jest sąsiadujących ze sobą, a liczba znalezionych dopasowań wynosi co najmniej dwa `count`mniejsze niż, pusty ciąg zostanie wstawiony do tablicy. Podobnie w przypadku znalezienia dopasowania w `startat`, który jest pierwszym znakiem w ciągu, pierwszy element zwróconej tablicy jest pustym ciągiem. Oznacza to, że puste ciągi, które wynikają z sąsiednich dopasowań, są zliczane przy określaniu, czy `count`liczba dopasowanych podciągów jest równa. W poniższym przykładzie wyrażenie `\d+` regularne służy do wyszukiwania pozycji początkowej pierwszego podciągu znaków liczbowych w ciągu, a następnie do dzielenia ciągu maksymalnie trzy razy, rozpoczynając od tej pozycji. Ponieważ wzorzec wyrażenia regularnego pasuje do początku ciągu wejściowego, zwracana tablica ciągów składa się z pustego ciągu, ciągu alfabetycznego o wartości pięciu znaków oraz pozostałej części ciągu.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 W przypadku używania nawiasów do przechwytywania w wyrażeniu regularnym wszystkie przechwycone teksty są uwzględniane w tablicy podziałów ciągów. Jednak żadne elementy tablicy, które zawierają przechwycony tekst, nie są zliczane podczas określania, czy osiągnięto `count`liczbę dopasowań. Na przykład dzielenie ciągu "" Apple-morela-śliwe-grusz-Pomegranate-ananass-brzoskwini "na maksymalnie cztery podciągi zaczynające się od znaku 15 w ciągu powoduje umieszczenie siedmiu elementów tablicy, jak pokazano w poniższym kodzie.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Jeśli jednak wzorzec wyrażenia regularnego zawiera wiele zestawów w nawiasach przechwytywania, zachowanie tej metody zależy od wersji .NET Framework. W .NET Framework 1,0 i 1,1, jeśli dopasowanie nie zostanie znalezione w pierwszym zestawie nawiasów przechwytywania, przechwycony tekst z dodatkowych nawiasów przechwytywania nie jest uwzględniony w zwracanej tablicy. Począwszy od .NET Framework 2,0, cały przechwycony tekst zostanie również dodany do zwróconej tablicy. Na przykład poniższy kod używa dwa zestawy nawiasów przechwytywania w celu wyodrębnienia pojedynczych wyrazów w ciągu. Pierwszy zestaw w nawiasach przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje pionowy pasek. Jeśli przykładowy kod jest kompilowany i uruchamiany pod .NET Framework 1,0 lub 1,1, wyklucza pionowe znaki paska; Jeśli zostanie skompilowany i uruchomiona w .NET Framework 2,0 lub nowszej wersji, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Jeśli wyrażenie regularne może pasować do pustego ciągu, <xref:System.Text.RegularExpressions.Regex.Split%2A> program podzieli ciąg na tablicę ciągów z pojedynczym znakiem, ponieważ w każdej lokalizacji można znaleźć pusty ogranicznik ciągu. Poniższy przykład dzieli ciąg "znaków" na dowolną liczbę elementów jako ciąg wejściowy, rozpoczynając od znaku "a". Ponieważ ciąg o wartości null pasuje do końca ciągu wejściowego, na końcu zwróconej tablicy zostanie wstawiony ciąg o wartości null.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 Wyjątek jest zgłaszany, jeśli czas wykonywania operacji Split przekracza interwał limitu czasu określony <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> przez konstruktora. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Jeśli nie ustawisz interwału limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy limit czasu ustanowiony dla domeny aplikacji, w której <xref:System.Text.RegularExpressions.Regex> tworzony jest obiekt. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołaniu konstruktora lub we właściwościach domeny aplikacji lub w przypadku <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartości limitu czasu, nie jest zgłaszany żaden wyjątek  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do podzielenia.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <summary>Dzieli ciąg wejściowy na tablicę podciągów w pozycjach zdefiniowanych przez określony wzorzec wyrażenia regularnego. Określone opcje modyfikują operację dopasowywania.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody są podobne <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> do metody, z tą różnicą <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> , że dzieli ciąg na ogranicznik określony przez wyrażenie regularne zamiast zestawu znaków. <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ciąg jest dzielony dowolną liczbę razy. Jeśli nie zostanie znaleziony ogranicznik, wartość zwracana zawiera jeden element, którego wartość jest pierwotnym `input` ciągiem.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Skompilowane wyrażenia regularne używane w wywołaniach <xref:System.Text.RegularExpressions.Regex.Split%2A> metod statycznych są automatycznie buforowane. Aby samodzielnie zarządzać okresem istnienia skompilowanych wyrażeń regularnych, użyj <xref:System.Text.RegularExpressions.Regex.Split%2A> metod wystąpienia.  
  
 Jeśli wiele dopasowań przylegają do siebie, pusty ciąg zostanie wstawiony do tablicy. Na przykład dzielenie ciągu na pojedynczym łączniku powoduje, że zwracana tablica zawiera pusty ciąg w pozycji, w której znajdują się dwa sąsiednie łączniki.  
  
 Jeśli dopasowanie zostanie znalezione na początku lub na końcu ciągu wejściowego, pusty ciąg jest uwzględniany na początku lub na końcu zwróconej tablicy. Poniższy przykład używa wzorca `[a-z]+` wyrażenia regularnego, aby podzielić ciąg wejściowy na dowolny wielkie lub małe litery alfabetu. Ponieważ ciąg rozpoczyna się i zaczyna się od pasujących znaków alfabetycznych, wartość pierwszego i ostatniego elementu tablicy zwracanej jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 W przypadku użycia nawiasów przechwytujących w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażeniu wszystkie przechwycone teksty są uwzględniane w zwracanej tablicy ciągów. Na przykład w przypadku podzielenia ciągu "śliwe-gruszk" na łączniku umieszczonym w nawiasach przechwytywania zwracana tablica zawiera element String zawierający łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Jeśli jednak wzorzec wyrażenia regularnego zawiera wiele zestawów w nawiasach przechwytywania, zachowanie tej metody zależy od wersji .NET Framework. W .NET Framework 1,0 i 1,1, jeśli dopasowanie nie zostanie znalezione w pierwszym zestawie nawiasów przechwytywania, przechwycony tekst z dodatkowych nawiasów przechwytywania nie jest uwzględniony w zwracanej tablicy. Począwszy od .NET Framework 2,0, cały przechwycony tekst zostanie również dodany do zwróconej tablicy. Na przykład poniższy kod używa dwóch zestawów przechwytywania w celu wyodrębnienia elementów daty, w tym ograniczników dat, z ciągu daty. Pierwszy zestaw w nawiasach przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod jest kompilowany i uruchamiany pod .NET Framework 1,0 lub 1,1, wyklucza znaki ukośnika; Jeśli zostanie skompilowany i uruchomiona w .NET Framework 2,0 lub nowszej wersji, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Jeśli wyrażenie regularne może pasować do pustego ciągu, <xref:System.Text.RegularExpressions.Regex.Split%2A> program podzieli ciąg na tablicę ciągów z pojedynczym znakiem, ponieważ w każdej lokalizacji można znaleźć pusty ogranicznik ciągu.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest zgłaszany, jeśli czas wykonywania operacji podziału przekracza limit czasu określony dla domeny aplikacji, w której wywoływana jest metoda. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji lub limit czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>wartością, nie jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową bitową kombinacją <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda przekracza interwał, który jest równy domyślnej wartości limitu czasu domeny aplikacji, w której wywoływana jest metoda. Jeśli wartość limitu czasu dla domeny aplikacji nie została zdefiniowana, wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, która uniemożliwia metodę z przekroczenia limitu czasu, jest używana. Zalecaną metodą statyczną do dzielenia tekstu na dopasowanie wzorca jest <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która umożliwia ustawienie interwału limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do podzielenia.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> wskazuje, że metoda nie powinna przekroczyć limitu czasu.</param>
        <summary>Dzieli ciąg wejściowy na tablicę podciągów w pozycjach zdefiniowanych przez określony wzorzec wyrażenia regularnego. Dodatkowe parametry określają opcje modyfikujące pasującą operację i interwał limitu czasu, jeśli nie znaleziono dopasowania.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody są podobne <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> do metody, z tą różnicą <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> , że dzieli ciąg na ogranicznik określony przez wyrażenie regularne zamiast zestawu znaków. <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ciąg jest dzielony dowolną liczbę razy. Jeśli nie zostanie znaleziony ogranicznik, wartość zwracana zawiera jeden element, którego wartość jest pierwotnym `input` ciągiem.  
  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Skompilowane wyrażenia regularne używane w wywołaniach <xref:System.Text.RegularExpressions.Regex.Split%2A> metod statycznych są automatycznie buforowane. Aby samodzielnie zarządzać okresem istnienia skompilowanych wyrażeń regularnych, użyj <xref:System.Text.RegularExpressions.Regex.Split%2A> metod wystąpienia.  
  
 Jeśli wiele dopasowań przylegają do siebie, pusty ciąg zostanie wstawiony do tablicy. Na przykład dzielenie ciągu na pojedynczym łączniku powoduje, że zwracana tablica zawiera pusty ciąg w pozycji, w której znajdują się dwa sąsiednie łączniki.  
  
 Jeśli dopasowanie zostanie znalezione na początku lub na końcu ciągu wejściowego, pusty ciąg jest uwzględniany na początku lub na końcu zwróconej tablicy. Poniższy przykład używa wzorca `[a-z]+` wyrażenia regularnego, aby podzielić ciąg wejściowy na dowolny wielkie lub małe litery alfabetu. Ponieważ ciąg rozpoczyna się i zaczyna się od pasujących znaków alfabetycznych, wartość pierwszego i ostatniego elementu tablicy zwracanej jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 W przypadku użycia nawiasów przechwytujących w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażeniu wszystkie przechwycone teksty są uwzględniane w zwracanej tablicy ciągów. Na przykład w przypadku podzielenia ciągu "śliwe-gruszk" na łączniku umieszczonym w nawiasach przechwytywania zwracana tablica zawiera element String zawierający łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Jeśli jednak wzorzec wyrażenia regularnego zawiera wiele zestawów w nawiasach przechwytywania, zachowanie tej metody zależy od wersji .NET Framework. W .NET Framework 1,0 i 1,1, jeśli dopasowanie nie zostanie znalezione w pierwszym zestawie nawiasów przechwytywania, przechwycony tekst z dodatkowych nawiasów przechwytywania nie jest uwzględniony w zwracanej tablicy. Począwszy od .NET Framework 2,0, cały przechwycony tekst zostanie również dodany do zwróconej tablicy. Na przykład poniższy kod używa dwóch zestawów przechwytywania w celu wyodrębnienia elementów daty, w tym ograniczników dat, z ciągu daty. Pierwszy zestaw w nawiasach przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod jest kompilowany i uruchamiany pod .NET Framework 1,0 lub 1,1, wyklucza znaki ukośnika; Jeśli zostanie skompilowany i uruchomiona w .NET Framework 2,0 lub nowszej wersji, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Jeśli wyrażenie regularne może pasować do pustego ciągu, <xref:System.Text.RegularExpressions.Regex.Split%2A> program podzieli ciąg na tablicę ciągów z pojedynczym znakiem, ponieważ w każdej lokalizacji można znaleźć pusty ogranicznik ciągu.  
  
 `matchTimeout` Parametr określa, jak długo Metoda dopasowywania wzorców powinna próbować znaleźć dopasowanie przed upływem limitu czasu. Ustawienie interwału limitu czasu uniemożliwia wyrażenia regularne, które opierają się na nadmiernym wycofywaniu z wyświetlania, aby przestać odpowiadać podczas przetwarzania danych wejściowych zawierających blisko dopasowań. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) [i wycofywania](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli żadne dopasowanie nie zostanie znalezione w tym interwale czasu, metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek. `matchTimeout`zastępuje wszystkie domyślne wartości limitu czasu zdefiniowane dla domeny aplikacji, w której jest wykonywana metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd podczas analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />nie jest prawidłową bitową kombinacją <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  
  
—lub— 
 <paramref name="matchTimeout" />jest ujemna, równa zero lub większa niż około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Przekroczono limit czasu. Aby uzyskać więcej informacji na temat limitów czasu, zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Zalecamy ustawienie <paramref name="matchTimeout" /> parametru na odpowiednią wartość, na przykład dwie sekundy. Jeśli wyłączysz limity czasu przez określenie <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych oferuje nieco lepszą wydajność. Należy jednak wyłączyć limity czasu tylko w następujących warunkach: 
— Gdy dane wejściowe przetwarzane przez wyrażenie regularne pochodzą od znanego i zaufanego źródła lub zawierają tekst statyczny. Wyklucza to tekst, który jest dynamicznie wprowadzany przez użytkowników.  
  
-Kiedy wzorzec wyrażenia regularnego został dokładnie przetestowany w celu zapewnienia, że wydajnie obsługuje dopasowania, nie są dopasowań i blisko dopasowań.  
  
-Kiedy wzorzec wyrażenia regularnego nie zawiera elementów języka, które są znane, aby spowodować nadmierne wycofywanie podczas przetwarzania blisko dopasowania.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="si">Obiekt do wypełnienia informacjami o serializacji.</param>
        <param name="context">Miejsce, w którym mają być przechowywane i pobierane dane serializowane. Ten parametr jest zarezerwowany do użytku w przyszłości.</param>
        <summary>Wypełnia obiekt danymi niezbędnymi do deserializacji bieżącego <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu. <see cref="T:System.Runtime.Serialization.SerializationInfo" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wzorzec wyrażenia regularnego, który został przekazano <see langword="Regex" /> do konstruktora.</summary>
        <returns>Parametr, który został przekazano <see langword="Regex" /> do konstruktora. <paramref name="pattern" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementów języka wyrażenia regularnego, które tworzą symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [.NET Framework wyrażeń regularnych](~/docs/standard/base-types/regular-expressions.md) i [języka wyrażeń regularnych — skrócone informacje](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" />jest klasą bazową wyrażeń regularnych utworzonych przez <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metodę. Te skompilowane wyrażenia regularne używają <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> implementacji klasy bazowej. Jeśli wywoływana z klasy pochodnej, <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> Metoda zwraca ciąg, który został przekazano <paramref name="pattern" /> do parametru <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> konstruktora klasy, który został użyty do zdefiniowania wyrażenia regularnego.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg wejściowy zawierający tekst do przekonwertowania.</param>
        <summary>Konwertuje wszystkie znaki ucieczki w ciągu wejściowym.</summary>
        <returns>Ciąg znaków z dowolnym znakiem ucieczki konwertowanym na ich niezmieniony formularz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Metoda wykonuje jedną z następujących dwóch transformacji:  
  
-   Odwraca transformację wykonywaną przez <xref:System.Text.RegularExpressions.Regex.Escape%2A> metodę przez usunięcie znaku ucieczki ("\\") z każdego znaku, który został zmieniony przez metodę. Należą do \\nich znaki, *, +,? &#124;,, {, [,,,), ^, $,., # i białych znaków. Ponadto <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Metoda nie wyprowadza nawiasu zamykającego (]) i zamykającego nawiasu klamrowego (}).  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A>nie można całkowicie odwrócić ciągu ucieczki, ponieważ nie można ustalić, które znaki zostały zmienione.  
  
-   Zastępuje wartości szesnastkowe w literałach ciągu Verbatim z rzeczywistymi drukowanymi znakami. Na przykład zastępuje wyrażenie @"\x07" "\a" lub @"\x0A" "\n". Konwertuje ona na obsługiwane znaki ucieczki, takie jak \a, \b, \e, \n, \r, \f, \t, \v i znaki alfanumeryczne.
  
 Jeśli metoda napotka inne sekwencje ucieczki, których nie można przekonwertować, takich jak \w lub \s, <xref:System.ArgumentException>zgłasza. <xref:System.Text.RegularExpressions.Regex.Unescape%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" />zawiera nierozpoznaną sekwencję ucieczki.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używany przez <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt wygenerowany <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> przez metodę.</summary>
        <returns><see langword="true" />Jeśli właściwość zawiera opcję; w przeciwnym razie <see langword="false" />. <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> <see cref="P:System.Text.RegularExpressions.Regex.Options" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używany przez <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt wygenerowany <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> przez metodę.</summary>
        <returns><see langword="true" />Jeśli właściwość zawiera opcję; w przeciwnym razie <see langword="false" />. <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> <see cref="P:System.Text.RegularExpressions.Regex.Options" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Interwał przekroczenia limitu czasu.</param>
        <summary>Sprawdza, czy limit czasu mieści się w dopuszczalnym zakresie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określony limit czasu nie należy do prawidłowego zakresu.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="26b6e3e6ad44db4a25f71289e07f95f0bbd7071b" /><Meta Name="ms.sourcegitcommit" Value="3efce15f3841385ee3ba24bd71ff0c0cf9a47815" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="04/03/2019" /><Meta Name="ms.locfileid" Value="58875453" /></Metadata><TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje niezmienne wyrażenie regularne.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Klasa reprezentuje aparat wyrażeń regularnych programu .NET Framework. Może służyć do szybkiego analizowania dużych ilości tekstu, aby znaleźć wzory znaków specyficznych; Aby wyodrębnić, Edytuj, zastępowania lub usuwania podciągów tekstu; i dodawać wyodrębnione ciągi do kolekcji, aby wygenerować raport.  
  
> [!NOTE]
>  W przypadku zainteresowanie podstawowego do sprawdzania ciągu przy określaniu, czy jest zgodny z określonym wzorcem, można użyć <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> klasy.  
  
 Aby użyć wyrażeń regularnych, należy zdefiniować wzorzec, który chcesz zidentyfikować w strumieniu tekstu przy użyciu składni udokumentowane w artykule [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Następnie można opcjonalnie utworzyć wystąpienie <xref:System.Text.RegularExpressions.Regex> obiektu. Na koniec należy wywołać metodę, która wykonuje pewne operacje, takie jak zastępowanie tekstu, który pasuje do wzorca wyrażenia regularnego lub identyfikowanie dopasowania do wzorca.  
  
> [!NOTE]
>  Aby uzyskać niektóre typowe wzorce wyrażeń regularnych, zobacz [przykłady wyrażeń regularnych](~/docs/standard/base-types/regular-expression-examples.md). Dostępne są także szereg online biblioteki wzorców wyrażeń regularnych, takiego jak w [Expressions.info zwykłych](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Aby uzyskać więcej informacji o używaniu <xref:System.Text.RegularExpressions.Regex> klasy, zobacz następujące sekcje w tym temacie:  
  
-   [Wyrażenie regularne programu vs. Parametry metody](#regex_vs_string)  
  
-   [Statycznej. Metody wystąpienia](#static_vs_instance)  
  
-   [Wykonywanie operacji na wyrażeniach regularnych](#regex_ops)  
  
-   [Definiowanie wartości limitu czasu](#define_timeout)  
  
 Aby uzyskać więcej informacji na temat języka wyrażeń regularnych, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) lub pobrać i wydrukować jedną z tych broszury:  
  
 [Krótki przewodnik w formacie programu Word (.docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Krótki przewodnik w formacie PDF (PDF)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Wyrażenie regularne programu vs. Parametry metody  
 <xref:System.String?displayProperty=nameWithType> Klasa zawiera kilka wyszukiwania i porównanie metod, których można użyć do wykonania dopasowania z tekstem do wzorca. Na przykład <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, i <xref:System.String.StartsWith%2A?displayProperty=nameWithType> metody ustalić, czy wystąpienie ciągu zawiera określony podciąg; i <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, i <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> metody zwracają początkowy Pozycja określony podciąg w ciągu. Należy użyć metod <xref:System.String?displayProperty=nameWithType> klasy podczas wyszukiwania określonego ciągu. Użyj <xref:System.Text.RegularExpressions.Regex> klasy podczas wyszukiwania określonego wzorca w ciągu. Aby uzyskać więcej informacji i przykładów, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Powrót do uwagi](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Statycznej. Metody wystąpienia  
 Po zdefiniowaniu wzorzec wyrażenia regularnego, można zapewnić aparat wyrażeń regularnych w jeden z dwóch sposobów:  
  
-   Przez utworzenie wystąpienia <xref:System.Text.RegularExpressions.Regex> obiekt, który reprezentuje wyrażenie regularne. W tym celu należy przekazać wzorzec wyrażenia regularnego do <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> konstruktora. A <xref:System.Text.RegularExpressions.Regex> obiekt jest niezmienialny; podczas tworzenia wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu z wyrażeniem regularnym, że nie można zmienić obiektu wyrażenia regularnego.  
  
-   Podając wyrażeń regularnych i tekst do wyszukania do `static` (`Shared` w języku Visual Basic) <xref:System.Text.RegularExpressions.Regex> metody. Dzięki temu można użyć wyrażenia regularnego, bez konieczności jawnego tworzenia <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 Wszystkie <xref:System.Text.RegularExpressions.Regex> metod identyfikacji wzorca obejmują statycznych i wystąpienia przeciążenia.  
  
 Aparat wyrażeń regularnych, należy skompilować wzorcowi, przed użyciem wzorca. Ponieważ <xref:System.Text.RegularExpressions.Regex> obiekty są niezmienne, jest to jednorazowa procedury, która występuje podczas <xref:System.Text.RegularExpressions.Regex> konstruktora klasy lub metody statycznej jest wywoływana. Aby wyeliminować konieczność wielokrotnego skompilować pojedynczego wyrażenia regularnego, aparat wyrażeń regularnych buforuje skompilowane wyrażenia regularne użyte w wywołaniach metody statycznej. W rezultacie metod dopasowania do wzorca wyrażenia regularnego oferują porównywalne wydajność statyczne i metody wystąpień.  
  
> [!IMPORTANT]
>  W .NET Framework w wersji 1.0 i 1.1, wszystkich skompilowanych wyrażeń regularnych czy zostały użyte w wystąpieniu lub statycznej metody wywołania, były buforowane. Począwszy od programu .NET Framework 2.0, tylko wyrażenia regularne użyte w wywołaniach metody statycznej są buforowane.  
  
 Jednakże buforowanie może niekorzystnie wpłynąć na wydajność w dwóch przypadkach:  
  
-   Kiedy używasz wywołaniach metody statycznej z dużą liczbą wyrażeń regularnych. Domyślnie aparat wyrażenia regularnego buforuje 15 ostatnio używanych statycznych wyrażeń regularnych. Jeśli aplikacja korzysta z więcej niż 15 statycznych wyrażeń regularnych, niektóre wyrażenia regularnego należy kompilować podczas. Aby zapobiec ponownej kompilacji na tym, można zwiększyć <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> właściwości.  
  
-   Podczas tworzenia wystąpienia nowego <xref:System.Text.RegularExpressions.Regex> obiektów za pomocą wyrażeń regularnych, które wcześniej zostały skompilowane. Na przykład poniższy kod definiuje wyrażenie regularne, aby zlokalizować zduplikowanych słów w strumieniu tekstu. Chociaż w przykładzie użyto pojedynczego wyrażenia regularnego, tworzy nową <xref:System.Text.RegularExpressions.Regex> obiekt, aby przetworzyć każdy wiersz tekstu. Skutkuje to ponownej kompilacji wyrażeń regularnych, z każdą iteracją pętli.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Aby zapobiec ponownej kompilacji, należy utworzyć wystąpienie jednego <xref:System.Text.RegularExpressions.Regex> obiekt, który jest dostępny dla całego kodu, który wymaga, jak pokazano w poniższym przykładzie nowych.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Powrót do uwagi](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Wykonywanie operacji na wyrażeniach regularnych  
 Czy podjęta została decyzja do utworzenia wystąpienia <xref:System.Text.RegularExpressions.Regex> obiektu i wywołać jego metody lub wywołania metody statyczne, <xref:System.Text.RegularExpressions.Regex> klasy oferują następujące funkcje, dopasowanie wzorca:  
  
-   Sprawdzanie poprawności dopasowania. Należy wywołać <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> metodę pozwala ustalić, czy dopasowanie jest obecny.  
  
-   Pobieranie pojedynczego dopasowania. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Match%2A> metodę, która pobierze <xref:System.Text.RegularExpressions.Match> obiekt, który reprezentuje pierwsze dopasowanie w ciągu lub w części ciągu. Kolejne dopasowania mogą być pobierane przez wywołanie metody <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody.  
  
-   Pobieranie wszystkie dopasowania. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Matches%2A> metodę, która pobierze <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> obiekt, który reprezentuje wszystkie dopasowania w ciągu lub w części ciągu.  
  
-   Zastąpienie dopasowany tekst. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Replace%2A> metodę, aby zastąpić dopasowany tekst. Tekst zastępczy można zdefiniować w taki sposób, przez wyrażenia regularne. Ponadto niektóre <xref:System.Text.RegularExpressions.Regex.Replace%2A> metody obejmują <xref:System.Text.RegularExpressions.MatchEvaluator> parametr, który umożliwia programowane Definiowanie tekst zastępczy.  
  
-   Tworzenie tablica ciągu, który jest tworzony na podstawie części ciągu wejściowego. Należy wywołać <xref:System.Text.RegularExpressions.Regex.Split%2A> metodę, aby podzielić ciąg wejściowy w pozycjach, które są zdefiniowane przez wyrażenia regularne.  
  
 Oprócz jego metod dopasowania do wzorca <xref:System.Text.RegularExpressions.Regex> klasy zawiera kilka metod specjalnego przeznaczenia:  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A> Metoda zmienia znaczenie znaków, które mogą być interpretowane jako operatory wyrażeń regularnych, wyrażenia regularnego lub ciągu wejściowego.  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Metoda usuwa te znaki ucieczki.  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Metoda tworzy zestaw, który zawiera wstępnie zdefiniowanych wyrażeń regularnych. .NET Framework zawiera przykłady tych zestawów specjalnych w <xref:System.Web.RegularExpressions?displayProperty=nameWithType> przestrzeni nazw.  
  
 [Powrót do uwagi](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definiowanie wartości limitu czasu  
 .NET Framework obsługuje język wyrażeń regularnych w pełni funkcjonalne, który zapewnia znaczące możliwości i elastyczność w dopasowywania do wzorca. Jednak możliwości i elastyczność pochodzą kosztów: ryzyka pogorszenia wydajności. Wyrażenia regularne, które niskiej wydajności są zaskakująco można łatwo utworzyć. W niektórych przypadkach operacji na wyrażeniach regularnych, które zależą od nadmierne używanie wycofywania może znajdować się może przestać odpowiadać podczas przetwarzania tekstu, który prawie pasuje do wzorca wyrażenia regularnego. Aby uzyskać więcej informacji na temat aparatu wyrażeń regularnych systemu .NET Framework, zobacz [szczegóły zachowania wyrażeń regularnych](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Aby uzyskać więcej informacji na temat nadmiernego wycofywania, zobacz [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], można zdefiniować interwał limitu czasu wyrażenia regularnego dopasowania. Jeśli aparat wyrażeń regularnych nie może zidentyfikować dopasowania, w tym przedziale czasu, zgłasza operacji dopasowywania <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. W większości przypadków uniemożliwia to aparatowi wyrażeń regularnych marnowania mocy obliczeniowej, próbując dopasować tekst, który prawie pasuje do wzorca wyrażenia regularnego. Również może wskazywać, jednak, że interwał limitu czasu ustawiono zbyt mała lub czy bieżące obciążenie maszyny spowodowała spadku ogólnej wydajności.  
  
 Jak obsłużyć wyjątek, zależy od przyczyną wyjątku. Jeśli wystąpi wyjątek, ponieważ interwał limitu czasu jest ustawiony na zbyt niską lub ze względu na maszynie nadmiernego obciążenia, możesz zwiększyć interwał limitu czasu i ponów próbę wykonania operacji dopasowywania. Jeśli wystąpi wyjątek, ponieważ wyrażenie regularne opiera się na nadmierne używanie wycofywania, możesz założono, że dopasowanie nie istnieje i ewentualnie możesz rejestrować informacje, które pomogą Ci modyfikować wzorzec wyrażenia regularnego.  
  
 Możesz ustawić interwał limitu czasu, przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor podczas tworzenia wystąpienia obiektu wyrażenia regularnego. Dla metod statycznych, można ustawić interwał limitu czasu przez wywołanie przeciążenia metody dopasowania, który ma `matchTimeout` parametru. Jeśli nie jawnie ustawiona wartość limitu czasu, domyślną wartość limitu czasu jest określany w następujący sposób:  
  
-   Przy użyciu limitu czasu całej aplikacji wartości, jeśli taki istnieje. To może być dowolną wartością limitu czasu, która ma zastosowanie do domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> jest tworzone wystąpienie obiektu lub wykonywane wywołanie metody statycznej. Można ustawić wartość limitu czasu w całej aplikacji, wywołując <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> metodę, aby przypisać reprezentację ciągu <xref:System.TimeSpan> wartość właściwości "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Przy użyciu wartości <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, jeśli została ustawiona żadna wartość limitu czasu w całej aplikacji.  
  
> [!IMPORTANT]
>  Firma Microsoft zaleca, ustaw wartość limitu czasu we wszystkich operacjach dopasowania do wzorca wyrażenia regularnego. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md).  
  
 [Powrót do uwagi](#remarks)  
  
   
  
## Examples  
 W poniższym przykładzie użyto wyrażenia regularnego, aby sprawdzić, czy są powtarzane wystąpień słowa w ciągu. Wyrażenie regularne `\b(?<word>\w+)\s+(\k<word>)\b` mogą być interpretowane, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczęcie dopasowywania na granicy wyrazu.|  
|`(?<word>\w+)`|Dopasowuje co najmniej jeden znak słowa do granicy wyrazu. Nazwij tę przechwyconą grupę `word`.|  
|`\s+`|Dopasowuje co najmniej jeden znak odstępu.|  
|`(\k<word>)`|Pasuje do przechwyconej grupy, który nosi nazwę `word`.|  
|`\b`|Dopasowuje granicę wyrazu.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 Poniższy przykład ilustruje użycie wyrażenia regularnego, aby sprawdzić, czy ciąg reprezentuje wartość waluty lub ma poprawny format do reprezentowania wartości waluty. W tym przypadku wyrażenia regularnego jest tworzony dynamicznie z <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości dla bieżącej kultury użytkownika. Jeśli bieżący system kulturą jest en US, wynikowe wyrażenie regularne jest `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Mogą być interpretowane tego wyrażenia regularnego, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpocznij od początku ciągu.|  
|`\s*`|Dopasowanie do zera lub większej liczby znaków odstępu.|  
|`[\+-]?`|Dopasowanie zera lub jednego wystąpienia znaku dodatniego lub znaku minus.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`\$?`|Dopasowuje znak dolara zera lub jednego wystąpienia.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`\d*`|Dopasowanie do zera lub większej liczby cyfr dziesiętnych.|  
|`\.?`|Dopasowuje zero lub jeden symbol separatora dziesiętnego.|  
|`\d{2}?`|Dopasowuje dwie cyfry dziesiętne zero lub jeden raz.|  
|`(\d*\.?\d{2}?){1}`|Dopasowuje wzorzec zaokrągleń cyfry oddzielone symbol dziesiętny co najmniej jeden raz.|  
|`$`|Dopasowuje koniec ciągu.|  
  
 W tym przypadku wyrażenia regularnego zakłada waluty prawidłowy ciąg nie zawiera symbole separatorów grup i że ma nie cyfr ułamkowych, jaka lub liczba cyfr ułamkowych, zdefiniowane przez bieżącą kulturę <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> właściwości.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Ponieważ wyrażenia regularnego, w tym przykładzie jest tworzona dynamicznie, firma Microsoft nie jest znany w czasie projektowania czy symbol waluty bieżącej kultury, znaku dziesiętnego lub znaków pozytywnych i negatywnych może zostać błędnie zinterpretowane przez aparat wyrażeń regularnych jako regularne Operatory języka wyrażeń. Aby zapobiec błędnej, przykład przekazuje każdego dynamicznie generowanym ciąg <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody.  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Text.RegularExpressions.Regex" /> Klasy jest niezmienny (tylko do odczytu) i bezpieczne dla wątków. <see cref="T:System.Text.RegularExpressions.Regex" /> obiekty można tworzyć na żadnym z wątków i udostępniane między wątkami. Aby uzyskać więcej informacji, zobacz [bezpieczeństwa wątków](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">.NET Framework — Wyrażenia regularne</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.docx">Wyrażeń regularnych — podręczny wykaz (do pobrania w formacie programu Word)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.pdf">Wyrażeń regularnych — podręczny wykaz (do pobrania w formacie PDF)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że ten konstruktor jest chronione. może być wywoływany tylko przez klasy pochodne <xref:System.Text.RegularExpressions.Regex> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy dla określonego wyrażenia regularnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tematów.  
  
 Wywoływanie <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> Konstruktor jest równoważne z wywoływaniem <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> konstruktora o wartości <xref:System.Text.RegularExpressions.RegexOptions.None> dla `options` argumentu.  
  
 Element <xref:System.Text.RegularExpressions.Regex> obiektu jest niezmienny, co oznacza, że mogą być używane tylko w przypadku wzorzec dopasowywania, można zdefiniować podczas jego tworzenia. Jednak może być dowolną liczbę razy określono jest ponownie kompilowana.  
  
 Ten konstruktor tworzy wystąpienie obiektu wyrażenia regularnego, który próbuje dopasowanie uwzględniające znaki alfabetyczne zdefiniowane w `pattern`. Dopasowanie bez uwzględniania wielkości liter, należy użyć <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób używania tego konstruktora do utworzenia wystąpienia wyrażeń regularnych, które jest dopasowywany dowolny wyraz rozpoczynający się od liter "a" lub "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Należy pamiętać, że wzorzec wyrażenia regularnego nie może być zgodna słowo "" na początku tekstu, ponieważ porównania uwzględniają wielkość liter domyślnie. Na przykład porównanie bez uwzględniania wielkości liter zobacz <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Ten konstruktor tworzy <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt, który używa domyślnej wartości limitu czasu domeny aplikacji, w którym zostanie utworzona. Jeśli nie określono wartości limitu czasu dla domeny aplikacji <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu używa wartości <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia operację z przekroczeniem limitu czasu. Zalecane Konstruktor do tworzenia <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt jest <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt, który zawiera Zserializowany wzorca i <see cref="T:System.Text.RegularExpressions.RegexOptions" /> informacji.</param>
        <param name="context">Miejsce docelowe dla serializacji. (Ten parametr nie jest używany; określ <see langword="null" />.)</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> przy użyciu danych serializowanych na fragmenty.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException">Wzorzec, <paramref name="info" /> zawiera jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" /> zawiera nieprawidłową <see cref="T:System.Text.RegularExpressions.RegexOptions" /> flagi.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które modyfikują wyrażenie regularne.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy dla określonego wyrażenia regularnego z opcjami, które modyfikują wzorzec.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tematów.  
  
 Element <xref:System.Text.RegularExpressions.Regex> obiektu jest niezmienny, co oznacza, że mogą być używane tylko dla parametrów dopasowania, można zdefiniować podczas jego tworzenia. Jednak może być dowolną liczbę razy określono jest ponownie kompilowana.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób używania tego konstruktora do utworzenia wystąpienia wyrażeń regularnych, które jest dopasowywany dowolny wyraz rozpoczynający się od liter "a" lub "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Należy pamiętać, że kolekcja dopasowania zawiera wyraz, "", który zaczyna się tekstem, ponieważ `options` parametru został zdefiniowany porównania bez uwzględniania wielkości liter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> zawiera nieprawidłową flagą.</exception>
        <block subset="none" type="usage"><para>Ten konstruktor tworzy <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt, który używa domyślnej wartości limitu czasu domeny aplikacji, w którym zostanie utworzona. Jeśli nie określono wartości limitu czasu dla domeny aplikacji <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu używa wartości <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia operację z przekroczeniem limitu czasu. Zalecane Konstruktor do tworzenia <see cref="T:System.Text.RegularExpressions.Regex" /> obiekt jest <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które modyfikują wyrażenie regularne.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> do wskazania, że metoda powinna nie przekraczają limit czasu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.Regex" /> klasy dla określonego wyrażenia regularnego z opcjami, które modyfikują wzorzec i wartość, która określa, jak długo metody dopasowania do wzorca powinien podejmować próbę dopasowania, przed upływem limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) tematów.  
  
 Element <xref:System.Text.RegularExpressions.Regex> obiektu jest niezmienny, co oznacza, że mogą być używane tylko w przypadku wzorzec dopasowywania, należy zdefiniować podczas tworzenia. Jednak może być dowolną liczbę razy określono jest ponownie kompilowana.  
  
 `matchTimeout` Parametr określa, jak długo dopasowania do wzorca metody prób znalezienia dopasowania, przed upływem limitu czasu. Jeśli nie zostanie znalezione dopasowanie w tym przedziale czasu, metoda dopasowania do wzorca zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie domyślną wartość limitu czasu, który jest zdefiniowany dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Metody dopasowania do wzorca wystąpienia, które obserwować `matchTimeout` interwał limitu czasu obejmują następujące elementy:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Ustawienie interwału limitu czasu zapobiega wyrażeń regularnych, które są nadmiernie używać wycofywania pojawianiu się może przestać odpowiadać podczas przetwarzania danych wejściowych zawiera dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Aby ustawić interwał limitu czasu uzasadnione, należy wziąć pod uwagę następujące czynniki:  
  
-   Długość i złożoność wzorca wyrażenia regularnego. Dłużej i bardziej złożonych wyrażeń regularnych wymagają więcej czasu niż te krótsze i łatwiejsze.  
  
-   Maszyny oczekiwanego obciążenia. Przetwarzanie zajmuje więcej czasu na komputerach wyposażonych wysokie wykorzystanie procesora CPU i pamięci.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor do tworzenia wystąpienia <xref:System.Text.RegularExpressions.Regex> obiekt z wartością limitu czasu równą jedną sekundę. Definicję wzorca wyrażenia regularnego `(a+)+$`, który dopasowuje co najmniej jeden sekwencje co najmniej jeden znaki "a" na końcu wiersza, podlega nadmiernemu wycofywaniu. Jeśli <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> jest zgłaszany, przykład zwiększa wartość limitu czasu, aż wartość maksymalna trzy sekundy. W przeciwnym razie porzuca próby dopasowania do wzorca.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłowym <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartość.  
  
—lub— 
 <paramref name="matchTimeout" /> ma wartość ujemną, zerowego, lub większa od około 24 dni.</exception>
        <block subset="none" type="usage"><para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwóch sekund. Jeśli wyłączysz limity czasu, określając <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednakże należy wyłączyć limity czasu tylko w następujących warunkach: 
— W przypadku danych wejściowych, przetwarzane przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub zawiera tekst statyczny. Nie obejmuje to tekst, który znajduje się dynamicznie danych wprowadzonych przez użytkowników.  
  
— Jeśli wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że umożliwia ona efektywne obsługę, bez dopasowania i wkrótce.  
  
— W przypadku wzorca wyrażenia regularnego nie zawiera żadnych elementów języka, które są znane, aby spowodować, że nadmierne używanie wycofywania podczas przetwarzania niemal dopasowania.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Nawracanie</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę wpisów w bieżącym statycznej pamięci podręcznej skompilowanych wyrażeń regularnych.</summary>
        <value>Maksymalna liczba wpisów w statycznej pamięci podręcznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Klasy utrzymuje wewnętrzną pamięć podręczną skompilowanych wyrażeń regularnych, używanym w wywołaniach metody statycznej. Jeśli wartość określona w operacji zestawu jest mniejsza niż bieżący rozmiar pamięci podręcznej, wpisy w pamięci podręcznej są odrzucane, dopóki rozmiar pamięci podręcznej jest równa określonej wartości.  
  
 Domyślnie pamięć podręczna przechowuje 15 skompilowanych wyrażeń regularnych statyczne. Aplikacja zazwyczaj nie będzie można zmienić rozmiar pamięci podręcznej. Użyj <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> właściwości tylko wtedy, gdy chcesz wyłączyć buforowanie lub przypadku nietypowo dużej pamięci podręcznej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość w operacji zestawu jest mniejsza od zera.</exception>
        <block subset="none" type="usage"><para>W .NET Framework w wersjach wcześniejszych niż [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], wyrażenia regularne użyte w statycznych i wywołaniach metod wystąpień są buforowane. Począwszy od [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], tylko regularne wyrażenia używane w wywołaniach metody statycznej są buforowane.</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowane przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia słownik mapujący nazwanych grup przechwytywania, ich wartości indeksu.</summary>
        <value>Słownik, który mapuje nazwę grupy przechwytywania, ich wartości indeksu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że ta właściwość jest chroniony; może zostać oceniony jedynie z klasą pochodną <xref:System.Text.RegularExpressions.Regex> klasy.  
  
 Operację stara się przekonwertować wartość przypisana do właściwości do <xref:System.Collections.Hashtable> obiektu; Jeśli ta konwersja nie powiedzie się, wywołuje metodę <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość przypisana do <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> właściwości w operacji zestawu jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowane przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia słownik mapujący numerowanych grup przechwytywania, ich wartości indeksu.</summary>
        <value>Słownik mapujący numerowanych grup przechwytywania, ich wartości indeksu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że ta właściwość jest chroniony; może zostać oceniony jedynie z klasą pochodną <xref:System.Text.RegularExpressions.Regex> klasy.  
  
 Operację stara się przekonwertować wartość przypisana do właściwości do <xref:System.Collections.Hashtable> obiektu; Jeśli ta konwersja nie powiedzie się, wywołuje metodę <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość przypisana do <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> właściwości w operacji zestawu jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowane przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowane przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kompiluje wyrażeń regularnych i zapisuje je na dysku w jednym zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Na platformie .NET Core wywołania `Regex.CompileToAssembly` throw metoda <xref:System.PlatformNotSupportedException>; wypisywanie zestawu nie jest obsługiwane.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tablica, która opisuje wyrażeń regularnych do skompilowania.</param>
        <param name="assemblyname">Nazwa pliku zestawu.</param>
        <summary>Kompiluje co najmniej jeden określony <see cref="T:System.Text.RegularExpressions.Regex" /> obiektów w zestawie o nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> Metoda generuje zestaw .NET Framework, w której każde wyrażenie regularne zdefiniowane w `regexinfos` tablicy jest reprezentowane przez klasę. Zazwyczaj <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> metoda jest wywoływana z innej aplikacji, która generuje zestaw skompilowanych wyrażeń regularnych. Każde wyrażenie regularne, które zostały zawarte w zestawie ma następującą charakterystykę:  
  
-   Jest pochodną <xref:System.Text.RegularExpressions.Regex> klasy.  
  
-   Jest ona przypisana pełną nazwę, która jest zdefiniowana przez `fullnamespace` i `name` parametrów odpowiadającymi mu dostawcami <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu.  
  
-   Ma ona domyślnej (lub bezparametrowego) konstruktora.  
  
 Normalnie kodu, który tworzy i wykorzystuje skompilowane wyrażenie regularne znajduje się w zestawie lub aplikacji, który jest oddzielony od kodu, który tworzy zestaw.  
  
   
  
## Examples  
 Poniższy przykład tworzy zestaw o nazwie RegexLib.dll. Zestaw zawiera dwa skompilowanych wyrażeń regularnych. Pierwsza strona, `Utilities.RegularExpressions.DuplicatedString`, dopasowuje dwa identyczne wyrazy ciągłych. Druga Strona, `Utilities.RegularExpressions.EmailAddress`, sprawdza, czy ciąg ma niepoprawny format adresu e-mail.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 Wyrażenie regularne, które sprawdza ciąg zduplikowane wyrazy, następnie jest tworzone i używane w poniższym przykładzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Pomyślne kompilacji w drugim przykładzie wymaga odwołania do RegexLib.dll (zestawu utworzonego w pierwszym przykładzie) mają zostać dodane do projektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="assemblyname" /> parametru <see cref="P:System.Reflection.AssemblyName.Name" /> właściwość to ciąg pusty lub ma wartość null.  
  
—lub— 
Definicję wzorca wyrażenia regularnego jeden lub więcej obiektów w <paramref name="regexinfos" /> ma nieprawidłową składnię.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> lub <paramref name="regexinfos" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET core: Tworzenie zestawu skompilowane wyrażenia regularne nie jest obsługiwane.</exception>
        <block subset="none" type="usage"><para>Jeśli tworzysz w systemie, który ma [!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub jego wydania punktowe zainstalowane, platformą docelową jest program [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], używasz <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> metodę w celu utworzenia zestawu zawierającego skompilowane wyrażenia regularne. Próba użycia jednego z wyrażeń regularnych, w tym zestawie w systemie, który ma [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] zgłasza wyjątek. Aby obejść ten problem, wykonaj jedną z następujących czynności: 
— Tworzenie zestawu zawierającego skompilowane wyrażenia regularne w systemie, który ma [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] zamiast nowszy zainstalowany.  
  
-Zamiast z wywołaniem <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> i pobieranie skompilowanego wyrażenia regularnego z zestawu, użyj statycznych lub wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> metod z <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opcji podczas tworzenia wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu lub wywołań wyrażeń regularnych metody dopasowania do wzorca.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilacja i ponowne użycie</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tablica, która opisuje wyrażeń regularnych do skompilowania.</param>
        <param name="assemblyname">Nazwa pliku zestawu.</param>
        <param name="attributes">Tablica, która definiuje atrybutów, które mają zastosowanie do zestawu.</param>
        <summary>Kompiluje co najmniej jeden określony <see cref="T:System.Text.RegularExpressions.Regex" /> obiekty do nazwanych zestawów przy użyciu określonych atrybutów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> Metoda generuje zestaw .NET Framework, w której każde wyrażenie regularne zdefiniowane w `regexinfos` tablicy jest reprezentowane przez klasę. Zazwyczaj <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> metoda jest wywoływana z innej aplikacji, która generuje zestaw skompilowanych wyrażeń regularnych. Każde wyrażenie regularne, które zostały zawarte w zestawie ma następującą charakterystykę:  
  
-   Jest pochodną <xref:System.Text.RegularExpressions.Regex> klasy.  
  
-   Jest ona przypisana pełną nazwę, która jest zdefiniowana przez `fullnamespace` i `name` parametrów odpowiadającymi mu dostawcami <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu.  
  
-   Ma ona domyślnej (lub bezparametrowego) konstruktora.  
  
 Normalnie kodu, który tworzy i wykorzystuje skompilowane wyrażenie regularne znajduje się w zestawie lub aplikacji, który jest oddzielony od kodu, który tworzy zestaw.  
  
 Ponieważ <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> metoda generuje zestaw .NET Framework z wywołania metody, zamiast korzystać z danego języka definicji class, słowo kluczowe (takie jak `class` w języku C# lub `Class`...`End Class` w języku Visual Basic) nie zezwala się atrybutów .NET Framework, które mają być przypisane do zestawu przy użyciu Składnia atrybutu standardowego języka programowania. `attributes` Parametr oferuje alternatywną metodę określania atrybutów, które są stosowane do zestawu. Dla każdego atrybutu, który chcesz zastosować do zestawu należy wykonać następujące czynności:  
  
1.  Utwórz tablicę <xref:System.Type> obiektów reprezentujących typy parametrów konstruktora atrybutu, która ma zostać wywołana.  
  
2.  Pobieranie <xref:System.Type> obiekt reprezentujący klasy atrybutu, który chcesz zastosować do nowego zestawu.  
  
3.  Wywołaj <xref:System.Type.GetConstructor%2A> metody atrybutu <xref:System.Type> obiektu do pobrania <xref:System.Reflection.ConstructorInfo> obiekt reprezentujący konstruktora atrybutu, który ma zostać wywołana. Przekaż <xref:System.Type.GetConstructor%2A> Metoda tablicy o <xref:System.Type> obiektów, które reprezentuje typy parametrów konstruktora.  
  
4.  Utwórz <xref:System.Object> tablica, która definiuje parametry do przekazania do konstruktora atrybutu.  
  
5.  Utwórz wystąpienie <xref:System.Reflection.Emit.CustomAttributeBuilder> obiektu przez przekazanie jego konstruktorowi <xref:System.Reflection.ConstructorInfo> obiektu pobranego w kroku 3 i <xref:System.Object> tablicy utworzonej w kroku 4.  
  
 Możesz następnie przekazać tablicę te <xref:System.Reflection.Emit.CustomAttributeBuilder> obiekty zamiast `attributes` parametr <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy zestaw o nazwie RegexLib.dll i stosuje <xref:System.Reflection.AssemblyTitleAttribute> atrybutu do niego. Zestaw zawiera dwa skompilowanych wyrażeń regularnych. Pierwsza strona, `Utilities.RegularExpressions.DuplicatedString`, dopasowuje dwa identyczne wyrazy ciągłych. Druga Strona, `Utilities.RegularExpressions.EmailAddress`, sprawdza, czy ciąg ma niepoprawny format adresu e-mail.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Sprawdź, czy <xref:System.Reflection.AssemblyTitleAttribute> zastosowano atrybut do zestawu, sprawdzając jego manifestu za pomocą narzędzia odbicia, takich jak ILDasm.  
  
 Wyrażenie regularne, które sprawdza ciąg zduplikowane wyrazy, następnie jest tworzone i używane w poniższym przykładzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Pomyślne kompilacji w drugim przykładzie wymaga odwołania do RegexLib.dll (zestawu utworzonego w pierwszym przykładzie) mają zostać dodane do projektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="assemblyname" /> parametru <see cref="P:System.Reflection.AssemblyName.Name" /> właściwość to ciąg pusty lub ma wartość null.  
  
—lub— 
Definicję wzorca wyrażenia regularnego jeden lub więcej obiektów w <paramref name="regexinfos" /> ma nieprawidłową składnię.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> lub <paramref name="regexinfos" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET core: Tworzenie zestawu skompilowane wyrażenia regularne nie jest obsługiwane.</exception>
        <block subset="none" type="usage"><para>Jeśli tworzysz w systemie, który ma [!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub jego wydania punktowe zainstalowane, platformą docelową jest program [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], używasz <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> metodę w celu utworzenia zestawu zawierającego skompilowane wyrażenia regularne. Próba użycia jednego z wyrażeń regularnych, w tym zestawie w systemie, który ma [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] zgłasza wyjątek. Aby obejść ten problem, wykonaj jedną z następujących czynności: 
— Tworzenie zestawu zawierającego skompilowane wyrażenia regularne w systemie, który ma [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] zamiast nowszy zainstalowany.  
  
-Zamiast z wywołaniem <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> i pobieranie skompilowanego wyrażenia regularnego z zestawu, użyj statycznych lub wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> metod z <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opcji podczas tworzenia wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu lub wywołań wyrażeń regularnych metody dopasowania do wzorca.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilacja i ponowne użycie</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="resourceFile" Type="System.String" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tablica, która opisuje wyrażeń regularnych do skompilowania.</param>
        <param name="assemblyname">Nazwa pliku zestawu.</param>
        <param name="attributes">Tablica, która definiuje atrybutów, które mają zastosowanie do zestawu.</param>
        <param name="resourceFile">Nazwa pliku zasobów Win32, aby uwzględnić w zestawie.</param>
        <summary>Kompiluje co najmniej jeden określony <see cref="T:System.Text.RegularExpressions.Regex" /> obiektów i plik określony zasób do nazwanego zestawu przy użyciu określonych atrybutów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method generates a .NET Framework assembly in which each regular expression defined in the `regexinfos` array is represented by a class. Typically, the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method is called from a separate application that generates an assembly of compiled regular expressions. Każde wyrażenie regularne, które zostały zawarte w zestawie ma następującą charakterystykę:  
  
-   Jest pochodną <xref:System.Text.RegularExpressions.Regex> klasy.  
  
-   Jest ona przypisana pełną nazwę, która jest zdefiniowana przez `fullnamespace` i `name` parametrów odpowiadającymi mu dostawcami <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu.  
  
-   Ma ona domyślnej (lub bezparametrowego) konstruktora.  
  
 Normalnie kodu, który tworzy i wykorzystuje skompilowane wyrażenie regularne znajduje się w zestawie lub aplikacji, który jest oddzielony od kodu, który tworzy zestaw.  
  
 Ponieważ <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> metoda generuje zestaw .NET Framework z wywołania metody, zamiast korzystać z danego języka definicji class, słowo kluczowe (takie jak `class` w języku C# lub `Class`...`End Class` w języku Visual Basic) nie zezwala się atrybutów .NET Framework, które mają być przypisane do zestawu przy użyciu Składnia atrybutu standardowego języka programowania. `attributes` Parametr oferuje alternatywną metodę określania atrybutów, które są stosowane do zestawu. Dla każdego atrybutu, który chcesz zastosować do zestawu należy wykonać następujące czynności:  
  
1.  Utwórz tablicę <xref:System.Type> obiektów reprezentujących typy parametrów konstruktora atrybutu, która ma zostać wywołana.  
  
2.  Pobieranie <xref:System.Type> obiekt reprezentujący klasy atrybutu, który chcesz zastosować do nowego zestawu.  
  
3.  Wywołaj <xref:System.Type.GetConstructor%2A> metody atrybutu <xref:System.Type> obiektu do pobrania <xref:System.Reflection.ConstructorInfo> obiekt reprezentujący konstruktora atrybutu, który ma zostać wywołana. Przekaż <xref:System.Type.GetConstructor%2A> Metoda tablicy o <xref:System.Type> obiektów, które reprezentuje typy parametrów Konstruktora  
  
4.  Utwórz <xref:System.Object> tablica, która definiuje parametry do przekazania do konstruktora atrybutu.  
  
5.  Utwórz wystąpienie <xref:System.Reflection.Emit.CustomAttributeBuilder> obiektu przez przekazanie jego konstruktorowi <xref:System.Reflection.ConstructorInfo> obiektu pobranego w kroku 3 i <xref:System.Object> tablicy utworzonej w kroku 4.  
  
 You can then pass an array of these <xref:System.Reflection.Emit.CustomAttributeBuilder> objects instead of the `attributes` parameter to the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="assemblyname" /> parametru <see cref="P:System.Reflection.AssemblyName.Name" /> właściwość to ciąg pusty lub ma wartość null.  
  
—lub— 
Definicję wzorca wyrażenia regularnego jeden lub więcej obiektów w <paramref name="regexinfos" /> ma nieprawidłową składnię.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> lub <paramref name="regexinfos" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="resourceFile" /> Parametru wyznacza nieprawidłowym plikiem zasobów Win32.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Pliku określonego przez <paramref name="resourceFile" /> nie można odnaleźć parametru.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET core: Tworzenie zestawu skompilowane wyrażenia regularne nie jest obsługiwane.</exception>
        <block subset="none" type="usage"><para>Jeśli tworzysz w systemie, który ma [!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub jego wydania punktowe zainstalowane, platformą docelową jest program [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], używasz <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> metodę w celu utworzenia zestawu zawierającego skompilowane wyrażenia regularne. Próba użycia jednego z wyrażeń regularnych, w tym zestawie w systemie, który ma [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] zgłasza wyjątek. Aby obejść ten problem, wykonaj jedną z następujących czynności: 
— Tworzenie zestawu zawierającego skompilowane wyrażenia regularne w systemie, który ma [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] zamiast nowszy zainstalowany.  
  
-Zamiast z wywołaniem <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> i pobieranie skompilowanego wyrażenia regularnego z zestawu, użyj statycznych lub wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> metod z <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opcji podczas tworzenia wystąpienia <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu lub wywołań wyrażeń regularnych metody dopasowania do wzorca.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilacja i ponowne użycie</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg wejściowy zawiera tekst do przekształcenia.</param>
        <summary>Minimalny zbiór znaki specjalne (\\, *, +,?, |, {, [, (,), ^, $,., # i biały znak) przez zamianę ich kodów wyjścia. To powoduje, że aparat wyrażeń regularnych do interpretacji tych znaków, dosłownie, a nie jako metaznaki.</summary>
        <returns>Ciąg znaków za pomocą metaznaki przekonwertowany do postaci o zmienionym znaczeniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Konwertuje ciąg, tak aby aparat wyrażeń regularnych będzie interpretować wszystkie metaznaki, które mogą zawierać jako literały znakowe. Rozważmy na przykład wyrażenie regularne, które zaprojektowano w celu wyodrębnienia komentarze, które są rozdzielane przez proste otwierające i zamykające nawiasy kwadratowe ([i]) z pliku tekstowego. W poniższym przykładzie, wyrażenie regularne "[(.*?)]" jest interpretowany jako klasę znaków. Zamiast dopasowywania komentarze osadzone w tekście wejściowym, wyrażenie regularne dopasowuje każdy otwierania lub nawias zamykający, okres, gwiazdka lub znak zapytania.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Jednak jeśli otwierający nawias kwadratowy została zmieniona przez przekazanie jej do <xref:System.Text.RegularExpressions.Regex.Escape%2A> metodę, wyrażenie regularne zakończy się pomyślnie w dopasowywanie komentarze, które są osadzone w ciągu wejściowym. Ilustruje to poniższy przykład.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 W wyrażeniu regularnym, która jest zdefiniowana za pomocą tekst statyczny, może być udało znaków, które mają być interpretowany dosłownie, a nie jako metaznaki, poprzedzając symbolem kreski ułamkowej odwróconej (\\) oraz przez wywołanie <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody. W wyrażeniu regularnym, która jest zdefiniowana, dynamicznie przy użyciu znaków, które nie są znane w czasie projektowania podczas wywoływania <xref:System.Text.RegularExpressions.Regex.Escape%2A> metoda jest szczególnie ważne upewnić się, że aparat wyrażeń regularnych interpretuje pojedynczych znaków jako literały zamiast niż jako metaznaki.  
  
> [!NOTE]
>  Jeśli wzorzec wyrażenia regularnego zawiera znak numeru (#) lub znaki spacji literału, należy zmienić je, jeśli tekst wejściowy jest analizowany przy użyciu <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> po włączeniu opcji.  
  
 Podczas <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody specjalne proste otwierający nawias kwadratowy ([) i otwieranie znaki nawiasu klamrowego ({), jego nie escape odpowiednie zamknięcia znaków (] i}). W większości przypadków te anulowania zapewnianego element nie jest konieczne. Zamykający nawias kwadratowy lub nawiasu klamrowego nie jest poprzedzony przez jego odpowiedniego znaku otwierającego, aparat wyrażeń regularnych interpretuje ją bezpośrednio. Otwierający nawias kwadratowy lub nawiasu klamrowego, jest interpretowany jako metaznak, aparat wyrażeń regularnych interpretuje pierwszego odpowiedniego zamykającego znaku jak metaznak. Jeśli nie jest to żądane zachowanie zamykający nawias kwadratowy lub nawiasu klamrowego powinno być poprzedzone jawnie poprzedzona ukośnika odwrotnego (\\) znaków. Ilustracja znajduje się w sekcji przykład.  
  
   
  
## Examples  
 Poniższy przykład wyodrębnia komentarze w tekście. Przyjęto założenie, że komentarze są rozdzielane znakami symbolu komentarza begin i end symbolu komentarza, wybranej przez użytkownika. Ponieważ symbole komentarza mają być interpretowany literalnie, są przekazywane do <xref:System.Text.RegularExpressions.Regex.Escape%2A> metodę, aby upewnić się, że ich nie może być błędnie zinterpretowana jako metaznaki. Ponadto przykład jawnie sprawdza, czy symbol komentarza zakończenia wprowadzonej przez użytkownika zamykającego nawiasu (]) lub nawiasów klamrowych (}). Jeśli tak jest, znak ukośnika odwrotnego (\\) jest dołączany na początku nawias kwadratowy lub nawiasu klamrowego, aby był interpretowany dosłownie. Należy zauważyć, że w przykładzie użyto również <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> kolekcję, aby wyświetlić tylko komentarz zamiast komentarz wraz z jego otwierający i zamykający symbole komentarza.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">Znaki specjalne w wyrażeniach regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowane przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten element członkowski przesłania element <see cref="M:System.Object.Finalize" />, a dokładniejsza dokumentacja może być dostępna w tym temacie.

Umożliwia <see cref="T:System.Object" /> próby zwolnienie zasobów i wykonywać inne operacje oczyszczania przed <see cref="T:System.Object" /> jest odzyskiwane przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę nazw grup dla wyrażenia regularnego przechwytywania.</summary>
        <returns>Tablica ciągu, nazw grup.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja nazw grup zawiera zbiór ciągi tekstowe używane do nazwy grupy przechwytywania w wyrażeniu. Nawet wtedy, gdy grupy przechwytywania nie są jawnie nazwane, są automatycznie przypisywane nazwy wartości liczbowych ("0", "1", "2", "3" i tak dalej). "0" o nazwie grupy reprezentuje cały tekst pasuje wzorzec wyrażenia regularnego. Numerowanej grupy poprzedzają jawnie nazwane grupy w kolekcji i nazwanych grup są wyświetlane w kolejności, w której są zdefiniowane we wzorcu wyrażenia regularnego.  
  
 Możesz użyć <xref:System.Array.Length%2A> właściwość tablica zwrócona przez tę metodę w celu określenia liczby grup w wyrażeniu regularnym.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano ogólnego przeznaczenia `ShowMatches` metodę, która wyświetla nazwy grup wyrażenia regularnego i ich dopasowany tekst.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 W tym przypadku wzorzec wyrażenia regularnego `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` jest przeznaczony do analizowania prostym zdaniu i określ jej pierwszy wyraz, ostatni wyraz i końcowy znak interpunkcyjny. W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany:  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`(?<FirstWord>\w+)`|Dopasowuje co najmniej jeden znak słowa. Jest to `FirstWord` o nazwie grupy.|  
|\s?|Dopasowanie do zera lub jednego znaku odstępu.|  
|(\w+)|Dopasowuje co najmniej jeden znak słowa. Jest to druga grupa przechwytywania.|  
|\s|Dopasowuje znak odstępu.|  
|((\w+)\s)*|Dopasowuje zero lub więcej wystąpień jednego lub więcej znaków słowa, następuje biały. Jest to pierwsza grupa przechwytywania.|  
|(? \<LastWord > \w+)?|Dopasowanie zera lub jednego wystąpienia co najmniej jeden znak słowa. Jest to `LastWord` o nazwie grupy.|  
|(? \<Znaków interpunkcyjnych > \p{Po})|Dopasowuje znak, w których kategorii Unicode jest znak interpunkcyjny, inne. Jest to `Punctuation` o nazwie grupy.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Konstrukcje grupujące w wyrażeniach regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę przechwytywania numery grupy, które odpowiadają nazwom grupy w tablicy.</summary>
        <returns>Liczba całkowita tablicę grupy liczb.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwane i nienazwane grupy przechwytywania jest możliwy przez liczbę. Nienazwane grupy są numerowane od lewej do prawej, począwszy 1. (Grupa przechwytywania w indeksie 0 (zero) reprezentuje dopasowanie całego).  Nazwane grupy następnie są numerowane od lewej do prawej, począwszy liczbę, która jest większa o jeden niż liczba nienazwane grupy przechwytywania.  
  
 Odwoływanie się do grupy przy użyciu numeru zamiast według nazwy ciągu może zapewnić szybszy dostęp.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenie regularne `\b((?<word>\w+)\s*)+(?<end>[.?!])`, który odpowiada zdania. Wyrażenie regularne zawiera trzy grupy przechwytywania: nienazwanej grupy, która przechwytuje pojedynczego wyrazu wraz ze znakiem spacji, który może wykonać; Grupa o nazwie `word` , przechwytuje poszczególnych wyrazów w zdaniu; i nazwie grupy `end` znajdują się znaki interpunkcyjne, która kończy się zdanie. Przykład wywołuje <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> metodę, aby uzyskać numery przechwytywania wszystkich grup, a następnie wyświetla ich przechwyconych ciągu. Ponadto <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> metoda jest używany do wskazania, czy określonego numerowanej grupy odnosi się do nazwanej grupy.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Wzorzec wyrażenia regularnego jest interpretowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`(?<word>\w+)`|Dopasowuje co najmniej jeden znak słowa i przypisać grupę o nazwie podciągów `word`.|  
|`\s*`|Dopasowanie do zera lub większej liczby znaków odstępu.|  
|`((?<word>\w+)\s*)`|Przypisz `word` przechwyconej grupy, a następnie według dowolnej przechwycone znaki białych pól do pierwszej przechwyconej grupy.|  
|`((?<word>\w+)\s*)+`|Dopasowuje wzorzec jednego lub więcej znaków słowa, następuje znaków odstępu jeden lub więcej razy.|  
|`(?<end>[.?!])`|Dopasowanie do kropki, znaku zapytania lub wykrzyknika. Przypisz dopasowany znak `end` grupa przechwytywania.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Konstrukcje grupujące w wyrażeniach regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Numer grupy do przekonwertowania na nazwę odpowiedniej grupy.</param>
        <summary>Pobiera nazwę grupy, która odpowiada numerowi określonej grupy.</summary>
        <returns>Ciąg, który zawiera nazwę grupy skojarzone z liczbą określonej grupy. Jeśli nazwa grupy, nie odpowiada <paramref name="i" />, metoda zwraca <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wzorzec wyrażenia regularnego może zawierać nazwana lub ponumerowana grup przechwytywania, które odróżnić podwyrażenia w ciągu dopasowania do wzorca. Numerowanej grupy są rozdzielane znakami składni (*Podwyrażenie*) i są przypisane numery w oparciu o ich kolejność w wyrażeniu regularnym. Nazwane grupy są rozdzielane znakami składni (?`<` *nazwa*`>`*Podwyrażenie*) lub (? " *nazwa*"*Podwyrażenie*), gdzie *nazwa* jest nazwa identyfikująca Podwyrażenie. (Aby uzyskać więcej informacji, zobacz [Grouping Constructs](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Metoda identyfikuje nazwanych grup i numerowanej grupy według ich położenia numer porządkowy w wyrażeniu regularnym. Porządkowym zero zawsze odzwierciedla całego wyrażenia regularnego. Wszystkie numerowanej grupy uwzględniane są następnie przed nazwane grupy, niezależnie od ich rzeczywistego pozycji we wzorcu wyrażenia regularnego.  
  
 Jeśli `i` jest numerem grupy o nazwie, metoda zwraca nazwę grupy. Jeśli `i` jest numerem grupy bez nazwy, metoda zwraca ciąg reprezentujący liczbę. Na przykład jeśli `i` wynosi 1, metoda zwraca wartość "1". Jeśli `i` nie jest liczba grupę przechwytywania, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Jeśli zostanie znalezione dopasowanie wzorca, wartość zwracana przez tę metodę można pobrać <xref:System.Text.RegularExpressions.Group> obiekt, który reprezentuje przechwyconej grupy z <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> właściwości. <xref:System.Text.RegularExpressions.GroupCollection> Obiekt jest zwracany przez <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wzorzec wyrażenia regularnego odpowiadającego wiersza adresu zawierające nazwy miasta w Stanach Zjednoczonych, Nazwa stanu i kod pocztowy. W przykładzie użyto <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> metody do pobierania nazwy grupy przechwytywania. Następnie używa tych nazw można pobrać odpowiadających im grup przechwyconych w celu dopasowania.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Definicję wzorca wyrażenia regularnego jest zdefiniowany przez następujące wyrażenie:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Dopasowuje co najmniej jeden znak alfabetycznym czy odstępu. Przypisz tę przechwyconą grupę nazwę `city`.|  
|`,`|Dopasowuje przecinek (,), następuje znak odstępu.|  
|`(?<state>[A-Za-z]{2})`|Dopasowuje dwa znaki alfabetu. Przypisz tę przechwyconą grupę nazwę `state`. Ta grupa powinna następować znak odstępu.|  
|`(?<zip>\d{5}(-\d{4})?)`|Dopasowuje pięć cyfr następuje zero lub wystąpienie łącznik i cztery cyfry. Przypisz tę przechwyconą grupę nazwę `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Konstrukty grupujące</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa grupy do przekonwertowania na odpowiedni numer grupy.</param>
        <summary>Zwraca numer grupy, która odnosi się do nazwy określonej grupy.</summary>
        <returns>Numer grupy, która odnosi się do określonej nazwy grupy lub wartość -1, jeśli <paramref name="name" /> nie jest nazwą prawidłowej grupy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wzorzec wyrażenia regularnego może zawierać nazwana lub ponumerowana grup przechwytywania, które odróżnić podwyrażenia w ciągu dopasowania do wzorca. Numerowanej grupy są rozdzielane znakami składni (*Podwyrażenie*) i są przypisane numery w oparciu o ich kolejność w wyrażeniu regularnym. Nazwane grupy są rozdzielane znakami składni (?`<` *nazwa*`>`*Podwyrażenie*) lub (? " *nazwa*"*Podwyrażenie*), gdzie *nazwa* jest nazwa identyfikująca Podwyrażenie. (Aby uzyskać więcej informacji, zobacz [Grouping Constructs](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> Metoda identyfikuje nazwanych grup i numerowanej grupy według ich położenia numer porządkowy w wyrażeniu regularnym. Porządkowym zero zawsze odzwierciedla całego wyrażenia regularnego. Wszystkie numerowanej grupy uwzględniane są następnie przed nazwane grupy, niezależnie od ich rzeczywistego pozycji we wzorcu wyrażenia regularnego.  
  
 Jeśli `name` jest ciąg reprezentujący numer grupy, który znajduje się we wzorcu wyrażenia regularnego, metoda zwraca, które numer. Jeśli `name` odpowiada nazwane przechwytywania grupy, który znajduje się we wzorcu wyrażenia regularnego, metoda zwraca odpowiadającym im numerem. Porównanie `name` z grupą nazwa jest rozróżniana wielkość liter. Jeśli `name` nie odnoszą się do nazwy grupy przechwytywania, lub na ciąg reprezentujący liczbę grupę przechwytywania, metoda zwraca wartość -1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Konstrukty grupujące</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że to operacja dopasowania do wzorca powinien nie przekraczają limit czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Klasy Konstruktor i liczba statyczne użycia metod dopasowania <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> stałą, aby wskazać, że próba znalezienia dopasowania do wzorca, jeżeli nie przekraczają limit czasu.  
  
> [!WARNING]
>  Ustawiając wartość limitu czasu aparatu wyrażeń regularnych <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> może spowodować, że wyrażeń regularnych, które są nadmiernie używać wycofywania, aby pozornie przestać odpowiadać podczas przetwarzania tekstu, który prawie pasuje do wzorca wyrażenia regularnego. Jeśli wyłączysz limity czasu, należy upewnić się, że wyrażenie regularne nie polega na nadmierne używanie wycofywania i obsługi tekstu, który prawie pasuje do wzorca wyrażenia regularnego.  
>   
>  Aby uzyskać więcej informacji na temat obsługi wycofywania, zobacz [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> Stałej może być podany jako wartość `matchTimeout` argument następujące elementy członkowskie:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowane przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Już zainicjowano odwołania.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Limit czasu maksymalną ilość czasu, jaki może upłynąć dopasowania do wzorca operacji przed wykonaniem operacji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy wyrażenie regularne znalezienia dopasowania w ciągu wejściowym.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <summary>Wskazuje, czy wyrażenie regularne określony w <see cref="T:System.Text.RegularExpressions.Regex" /> Konstruktor znalezienia dopasowania określonego ciągu wejściowego.</summary>
        <returns><see langword="true" /> Jeśli wyrażenie regularne znajdzie dopasowanie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Metoda jest zwykle używane do sprawdzania ciągu lub zapewnienie zgodny ciąg do określonego wzorca bez pobierania tego ciągu do kolejnych manipulacji. Jeśli chcesz określić, czy jeden lub więcej ciągów pasują do wzorca wyrażenia regularnego, a następnie pobrać ich dla kolejnych manipulowanie, wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> lub <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeśli czas wykonywania operacji dopasowywania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> metodę pozwala ustalić, czy ciąg jest prawidłowy numer. Wyrażenie regularne przyjęto założenie, że numer części ma określonym formacie, który składa się z trzech zestawów znaków oddzielonych łącznikami. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znak alfanumeryczny następują dwa znaki numeryczne, następuje znak alfanumeryczny. Drugi zestaw składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestaw, który składa się z czterech znaków, musi mieć trzy znaki numeryczne, następuje znak alfanumeryczny.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Definicję wzorca wyrażenia regularnego jest:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpoczyna dopasowanie na początku wiersza.|  
|`[a-zA-Z0-9]`|Dopasuj jeden znak alfabetu (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znak numeryczny.|  
|`\d{2}`|Dopasowuje dwa znaki numeryczne.|  
|`[a-zA-Z0-9]`|Dopasuj jeden znak alfabetu (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znak numeryczny.|  
|`-`|Dopasowuje łącznik.|  
|`\d{3}`|Dopasowuje dokładnie trzy znaki numeryczne.|  
|`(-\d{3}){2}`|Znajdź łącznik następują trzy znaki numeryczne i dopasowanie do dwóch wystąpień tego wzorca.|  
|`[a-zA-Z0-9]`|Dopasuj jeden znak alfabetu (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znak numeryczny.|  
|`$`|Dopasowywanie kończy się na końcu wiersza.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="startat">Pozycja znaku, od którego należy rozpocząć wyszukiwanie.</param>
        <summary>Wskazuje, czy wyrażenie regularne określony w <see cref="T:System.Text.RegularExpressions.Regex" /> Konstruktor znalezienia dopasowania w określonym ciągu wejściowym, zaczynając od określonej pozycji początkowej w ciągu.</summary>
        <returns><see langword="true" /> Jeśli wyrażenie regularne znajdzie dopasowanie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Metoda jest zwykle używane do sprawdzania ciągu lub zapewnienie zgodny ciąg do określonego wzorca bez pobierania tego ciągu do kolejnych manipulacji. Jeśli chcesz określić, czy jeden lub więcej ciągów pasują do wzorca wyrażenia regularnego, a następnie pobrać ich dla kolejnych manipulowanie, wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> lub <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeśli czas wykonywania operacji dopasowywania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> metodę pozwala ustalić, czy ciąg jest prawidłowy numer. Wyszukuje ona numer części, który następuje znak dwukropka (:) w ciągu. <xref:System.String.IndexOf%28System.Char%29> Metoda jest używana do określenia pozycji znak dwukropka, który jest następnie przekazywany do <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> metody. Wyrażenie regularne przyjęto założenie, że numer części ma określonym formacie, który składa się z trzech zestawów znaków oddzielonych łącznikami. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znak alfanumeryczny następują dwa znaki numeryczne, następuje znak alfanumeryczny. Drugi zestaw składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestaw, który składa się z czterech znaków, musi mieć trzy znaki numeryczne, następuje znak alfanumeryczny.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Definicję wzorca wyrażenia regularnego jest:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Dopasuj jeden znak alfabetu (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znak numeryczny.|  
|`\d{2}`|Dopasowuje dwa znaki numeryczne.|  
|`[a-zA-Z0-9]`|Dopasuj jeden znak alfabetu (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znak numeryczny.|  
|`-`|Dopasowuje łącznik.|  
|`\d{3}`|Dopasowuje dokładnie trzy znaki numeryczne.|  
|`(-\d{3}){2}`|Znajdź łącznik następują trzy znaki numeryczne i dopasowanie do dwóch wystąpień tego wzorca.|  
|`[a-zA-Z0-9]`|Dopasuj jeden znak alfabetu (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znak numeryczny.|  
|`$`|Dopasowywanie kończy się na końcu wiersza.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Wskazuje, czy określonemu wyrażeniu regularnemu znalezienia dopasowania do określonego ciągu wejściowego.</summary>
        <returns><see langword="true" /> Jeśli wyrażenie regularne znajdzie dopasowanie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Metoda jest zwykle używane do sprawdzania ciągu lub zapewnienie zgodny ciąg do określonego wzorca bez pobierania tego ciągu do kolejnych manipulacji. Jeśli chcesz określić, czy jeden lub więcej ciągów pasują do wzorca wyrażenia regularnego, a następnie pobrać ich dla kolejnych manipulowanie, wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> lub <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody.  
  
 Statyczne <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metoda jest równoważna konstruowanie <xref:System.Text.RegularExpressions.Regex> obiektu z wzorcem wyrażenia regularnego określone przez `pattern` i wywoływać metodę <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> metodę wystąpienia. Ten wzorzec wyrażenia regularnego jest buforowany do szybkiego pobierania przez aparat wyrażeń regularnych.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeśli czas wykonywania operacji dopasowywania przekroczy limit czasu określony dla domeny aplikacji, w którym metoda jest wywoływana. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metodę pozwala ustalić, czy ciąg jest prawidłowy numer. Wyrażenie regularne przyjęto założenie, że numer części ma określonym formacie, który składa się z trzech zestawów znaków oddzielonych łącznikami. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znak alfanumeryczny następują dwa znaki numeryczne, następuje znak alfanumeryczny. Drugi zestaw składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestaw, który składa się z czterech znaków, musi mieć trzy znaki numeryczne, następuje znak alfanumeryczny.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Definicję wzorca wyrażenia regularnego jest:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpoczyna dopasowanie na początku wiersza.|  
|`[a-zA-Z0-9]`|Dopasuj jeden znak alfabetu (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znak numeryczny.|  
|`\d{2}`|Dopasowuje dwa znaki numeryczne.|  
|`[a-zA-Z0-9]`|Dopasuj jeden znak alfabetu (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znak numeryczny.|  
|`-`|Dopasowuje łącznik.|  
|`\d{3}`|Dopasowuje dokładnie trzy znaki numeryczne.|  
|`(-\d{3}){2}`|Znajdź łącznik następują trzy znaki numeryczne i dopasowanie do dwóch wystąpień tego wzorca.|  
|`[a-zA-Z0-9]`|Dopasuj jeden znak alfabetu (`a` za pośrednictwem `z` lub `A` za pośrednictwem `Z`) lub znak numeryczny.|  
|`$`|Dopasowywanie kończy się na końcu wiersza.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym metoda jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecana metoda statyczna w celu sprawdzenia dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <summary>Wskazuje, czy określonemu wyrażeniu regularnemu znalezienia dopasowania w określonym ciągu wejściowym, przy użyciu określonych opcji dopasowania.</summary>
        <returns><see langword="true" /> Jeśli wyrażenie regularne znajdzie dopasowanie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Metoda jest zwykle używane do sprawdzania ciągu lub zapewnienie zgodny ciąg do określonego wzorca bez pobierania tego ciągu do kolejnych manipulacji. Jeśli chcesz określić, czy jeden lub więcej ciągów pasują do wzorca wyrażenia regularnego, a następnie pobrać ich dla kolejnych manipulowanie, wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> lub <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody.  
  
 Statyczne <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metoda jest równoważna konstruowanie <xref:System.Text.RegularExpressions.Regex> obiektu z wzorcem wyrażenia regularnego określone przez `pattern` i opcje wyrażeń regularnych, określony przez `options` i wywoływać metodę <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> wystąpienia Metoda. Ten wzorzec wyrażenia regularnego jest buforowany do szybkiego pobierania przez aparat wyrażeń regularnych.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeśli czas wykonywania operacji dopasowywania przekroczy limit czasu określony dla domeny aplikacji, w którym metoda jest wywoływana. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metodę pozwala ustalić, czy ciąg jest prawidłowy numer. Wyrażenie regularne przyjęto założenie, że numer części ma określonym formacie, który składa się z trzech zestawów znaków oddzielonych łącznikami. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znak alfanumeryczny następują dwa znaki numeryczne, następuje znak alfanumeryczny. Drugi zestaw składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestaw, który składa się z czterech znaków, musi mieć trzy znaki numeryczne, następuje znak alfanumeryczny.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Definicję wzorca wyrażenia regularnego jest:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpoczyna dopasowanie na początku ciągu.|  
|`[A-Z0-9]`|Dopasuj dowolny znaku alfabetyczny jednego z `A` za pośrednictwem `Z`, lub dowolną cyfrę.|  
|`\d{2}`|Dopasowuje dwa znaki numeryczne.|  
|`[A-Z0-9]`|Dopasuj dowolny znaku alfabetyczny jednego z `A` za pośrednictwem `Z`, lub dowolną cyfrę.|  
|`-`|Dopasowuje łącznik.|  
|`\d{3}`|Dopasowuje dokładnie trzy znaki numeryczne.|  
|`(-\d{3}){2}`|Znajdź łącznik następują trzy znaki numeryczne i dopasowanie do dwóch wystąpień tego wzorca...|  
|`[A-Z0-9]`|Dopasuj dowolny znaku alfabetyczny jednego z `A` za pośrednictwem `Z`, lub dowolną cyfrę.|  
|`$`|Dopasowywanie kończy się na końcu ciągu.|  
  
 Wywoływanie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metody z `options` parametr <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> jest odpowiednikiem następujące wyrażenie regularne określające:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Dla porównania, zobacz przykład <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłowym <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartość.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecana metoda statyczna w celu sprawdzenia dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> do wskazania, że metoda powinna nie przekraczają limit czasu.</param>
        <summary>Wskazuje, czy określonemu wyrażeniu regularnemu znalezienia dopasowania w określonym ciągu wejściowym, przy użyciu określonego dopasowania interwał opcje i limitu czasu.</summary>
        <returns><see langword="true" /> Jeśli wyrażenie regularne znajdzie dopasowanie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Metoda jest zwykle używane do sprawdzania ciągu lub zapewnienie zgodny ciąg do określonego wzorca bez pobierania tego ciągu do kolejnych manipulacji. Jeśli chcesz określić, czy jeden lub więcej ciągów pasują do wzorca wyrażenia regularnego, a następnie pobrać ich dla kolejnych manipulowanie, wywołanie <xref:System.Text.RegularExpressions.Regex.Match%2A> lub <xref:System.Text.RegularExpressions.Regex.Matches%2A> metody.  
  
 Statyczne <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metoda jest równoważna konstruowanie <xref:System.Text.RegularExpressions.Regex> obiektu z wzorcem wyrażenia regularnego określone przez `pattern` i opcje wyrażeń regularnych, określony przez `options` i wywoływać metodę <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> wystąpienia Metoda. Ten wzorzec wyrażenia regularnego jest buforowany do szybkiego pobierania przez aparat wyrażeń regularnych.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `matchTimeout` Parametr określa, jak długo dopasowywanie do wzorców metody prób znalezienia dopasowania, przed upływem limitu czasu. Ustawienie interwału limitu czasu zapobiega wyrażeń regularnych, które są nadmiernie używać wycofywania pojawianiu się może przestać odpowiadać podczas przetwarzania danych wejściowych zawiera dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli nie zostanie znalezione dopasowanie w tym przedziale czasu, metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie domyślną wartość limitu czasu, który jest zdefiniowany dla domeny aplikacji, w którym metoda jest wykonywana.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodę pozwala ustalić, czy ciąg jest prawidłowy numer. Wyrażenie regularne przyjęto założenie, że numer części ma określonym formacie, który składa się z trzech zestawów znaków oddzielonych łącznikami. Pierwszy zestaw, który zawiera cztery znaki, musi zawierać znak alfanumeryczny następują dwa znaki numeryczne, następuje znak alfanumeryczny. Drugi zestaw składa się z trzech znaków, musi być wartością numeryczną. Trzeci zestaw, który składa się z czterech znaków, musi mieć trzy znaki numeryczne, następuje znak alfanumeryczny. Dopasowania wzorca wyrażenia regularnego należy zaangażować w minimalnym przeszukiwanie ciągu wejściowego, więc metoda ustawia interwał limitu czasu 500 milisekund.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Definicję wzorca wyrażenia regularnego jest:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Rozpoczyna dopasowanie na początku ciągu.|  
|`[A-Z0-9]`|Dopasuj dowolny znaku alfabetyczny jednego z `A` za pośrednictwem `Z`, lub dowolną cyfrę.|  
|`\d{2}`|Dopasowuje dwa znaki numeryczne.|  
|`[A-Z0-9]`|Dopasuj dowolny znaku alfabetyczny jednego z `A` za pośrednictwem `Z`, lub dowolną cyfrę.|  
|`-`|Dopasowuje łącznik.|  
|`\d{3}`|Dopasowuje dokładnie trzy znaki numeryczne.|  
|`(-\d{3}){2}`|Znajdź łącznik następują trzy znaki numeryczne i dopasowanie do dwóch wystąpień tego wzorca.|  
|`[A-Z0-9]`|Dopasuj dowolny znaku alfabetyczny jednego z `A` za pośrednictwem `Z`, lub dowolną cyfrę.|  
|`$`|Dopasowywanie kończy się na końcu ciągu.|  
  
 Wywoływanie <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metody z `options` parametr <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> jest odpowiednikiem następujące wyrażenie regularne określające:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Dla porównania, zobacz przykład <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłowym <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartość.  
  
—lub— 
 <paramref name="matchTimeout" /> ma wartość ujemną, zerowego, lub większa od około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu.</exception>
        <block subset="none" type="usage"><para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwóch sekund. Jeśli wyłączysz limity czasu, określając <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednakże należy wyłączyć limity czasu tylko w następujących warunkach: 
— W przypadku danych wejściowych, przetwarzane przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub zawiera tekst statyczny. Nie obejmuje to tekst, który znajduje się dynamicznie danych wprowadzonych przez użytkowników.  
  
— Jeśli wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że umożliwia ona efektywne obsługę, bez dopasowania i wkrótce.  
  
— W przypadku wzorca wyrażenia regularnego nie zawiera żadnych elementów języka, które są znane, aby spowodować, że nadmierne używanie wycofywania podczas przetwarzania niemal dopasowania.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje w ciągu wejściowym, podciągu, który jest zgodny ze wzorcem wyrażenia regularnego i zwraca pierwsze wystąpienie jako pojedynczy <see cref="T:System.Text.RegularExpressions.Match" /> obiektu.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <summary>Wyszukuje określony ciągu wejściowym, aby pierwsze wystąpienie z wyrażeniem regularnym określonym w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora.</summary>
        <returns>Obiekt, który zawiera informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Metoda zwraca wartość pierwszego podciągu, który jest zgodny ze wzorcem wyrażenia regularnego w ciągu wejściowym. Aby uzyskać informacji na temat elementów języka, używany do tworzenia wzorca wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wykryto wzorzec wyrażenia regularnego do ciągu wejściowego, sprawdzając wartość zwracanej <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znalezione dopasowanie, zwrócony <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg z `input` który pasuje do wzorca wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca wartość pierwszego podciągu w `input` który pasuje do wzorca wyrażenia regularnego. Możesz pobrać kolejnych dopasowań, wywołując wielokrotnie zwracanego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody. Możesz również pobrać wszystkich dopasowań w pojedynczym wywołaniu metody, wywołując <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeśli czas wykonywania operacji dopasowywania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie wzorzec wyrażenia regularnego pasuje do ciągu, a następnie wyświetla dopasowanej grupy przechwytywania i pozycji przechwytywania.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Definicję wzorca wyrażenia regularnego `(\w+)\s+(car)` dopasowuje wystąpienia słowa "samochód" wraz z programu word, poprzedzającym go. Jest interpretowane zgodnie z poniższą tabelą.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(\w+)`|Dopasowuje co najmniej jeden znak słowa. Jest to pierwsza grupa przechwytywania.|  
|`\s+`|Dopasowuje co najmniej jeden znak odstępu.|  
|(samochód)|Jest zgodny z ciągiem literału "samochód". Jest to druga grupa przechwytywania.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="startat">Pozycja od zera znaku, w którym ma zostać rozpoczęte wyszukiwanie.</param>
        <summary>Wyszukuje w ciągu wejściowym, aby pierwsze wystąpienie wyrażenia regularnego, zaczynając od określonej pozycji początkowej w ciągu.</summary>
        <returns>Obiekt, który zawiera informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Pierwszego podciągu, który jest zgodny ze wzorcem wyrażenia regularnego, uruchamiania na lub po powrocie z metody `startat` znak pozycja w ciągu wejściowym. Aby uzyskać informacji na temat elementów języka, używany do tworzenia wzorca wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> metoda wyszukiwania jest definiowany przez wywołanie jednej z <xref:System.Text.RegularExpressions.Regex> klasy konstruktorów. Aby uzyskać więcej informacji na temat elementy tworzące wzorzec wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Opcjonalnie można określić pozycję początkową w ciągu przy użyciu `startat` parametru. Gdy aparat wyrażeń regularnych analizuje od lewej do prawej (ustawienie domyślne), dopasowanie i skanowania przenieść rightward, zaczynając od na znak określony we `startat`. Kiedy aparat wyrażeń regularnych analizuje od prawej do lewej (gdy wzorzec wyrażenia regularnego jest zbudowany z <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opcja), dopasowanie i skanowanie przejść w odwrotnym kierunku i zaczynają się od znaku w `startat` -1. Jeśli nie określisz pozycja początkowa, wyszukiwanie rozpoczyna się od domyślnie `startat` pozycji. Jeśli wyrażenia regularnego przeszukuje od lewej do prawej, domyślnie `startat` położenie jest na końcu po lewej stronie `input`; Jeśli przeszukuje od prawej do lewej, domyślnie `startat` położenie jest na prawym końcu `input`.  
  
 Jeśli chcesz ograniczyć dopasowanie rozpoczyna się go w położeniu określonego znaku w ciągu, a aparat wyrażeń regularnych nie skanuje pod kątem dopasowania w pozostałej części ciągu zakotwiczyć wyrażenia regularnego z `\G` (po lewej stronie dla od lewej do prawej wzorzec, lub po prawej dla wzorca od prawej do lewej). Ogranicza dopasowanie, więc musi zaczynać się dokładnie od `startat`.  
  
 Można określić, czy wykryto wzorzec wyrażenia regularnego do ciągu wejściowego, sprawdzając wartość zwracanej <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znalezione dopasowanie, zwrócony <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg z `input` który pasuje do wzorca wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca podciąg pierwszego znaleziono na lub po `startat` znak na pozycji w `input` który pasuje do wzorca wyrażenia regularnego. Możesz pobrać kolejnych dopasowań, wywołując wielokrotnie zwracanego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody. Możesz również pobrać wszystkich dopasowań w pojedynczym wywołaniu metody, wywołując <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeśli czas wykonywania operacji dopasowywania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Wyszukuje określony ciągu wejściowym, aby pierwsze wystąpienie określonego wyrażenia regularnego.</summary>
        <returns>Obiekt, który zawiera informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Metoda zwraca wartość pierwszego podciągu, który jest zgodny ze wzorcem wyrażenia regularnego w ciągu wejściowym. Aby uzyskać informacji na temat elementów języka, używany do tworzenia wzorca wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Statyczne <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> metoda jest równoważna konstruowanie <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywoływać metodę wystąpienia <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metody. W tym przypadku aparat wyrażeń regularnych zapisuje w pamięci podręcznej do wzorca wyrażenia regularnego.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wykryto wzorzec wyrażenia regularnego do ciągu wejściowego, sprawdzając wartość zwracanej <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znalezione dopasowanie, zwrócony <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg z `input` który pasuje do wzorca wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca wartość pierwszego podciągu w `input` który pasuje do wzorca wyrażenia regularnego. Możesz pobrać kolejnych dopasowań, wywołując wielokrotnie zwracanego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody. Możesz również pobrać wszystkich dopasowań w pojedynczym wywołaniu metody, wywołując <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeśli czas wykonywania operacji dopasowywania przekroczy limit czasu określony dla domeny aplikacji, w którym metoda jest wywoływana. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> metody do znalezienia pierwszy wyraz, który zawiera co najmniej jeden `z` znaku, a następnie wywołania <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody do znalezienia dopasowań dodatkowe.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Definicję wzorca wyrażenia regularnego `\b\w*z+\w*\b` jest interpretowane tak jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w*`|Dopasowuje zero, jeden lub więcej znaków słowa.|  
|`z+`|Dopasowuje jeden lub więcej wystąpień `z` znaków.|  
|`\w*`|Dopasowuje zero, jeden lub więcej znaków słowa.|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecana metoda statyczna pobierania dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="beginning">Pozycja od zera znaku w ciągu wejściowym, który definiuje skrajnie po lewej stronie położenie do wyszukania.</param>
        <param name="length">Liczba znaków w podciąg, który należy uwzględnić w wyszukiwaniu.</param>
        <summary>Wyszukuje w ciągu wejściowym, aby pierwsze wystąpienie wyrażenia regularnego, zaczynając od określonej pozycji początkowej i wyszukiwanie tylko określoną liczbę znaków.</summary>
        <returns>Obiekt, który zawiera informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda zwraca wartość pierwszego podciągu, który jest zgodny ze wzorcem wyrażenia regularnego, w części ciągu wejściowego. Aby uzyskać informacji na temat elementów języka, używany do tworzenia wzorca wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> metoda wyszukiwania jest definiowany przez wywołanie jednej z <xref:System.Text.RegularExpressions.Regex> klasy konstruktorów. Aby uzyskać więcej informacji na temat elementy tworzące wzorzec wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda wyszukuje część `input` definicją `beginning` i `length` parametrów dla wzorca wyrażenia regularnego. `beginning` zawsze definiuje indeks skrajnie po lewej stronie znaku do uwzględnienia w wyszukiwaniu, i `length` określa maksymalną liczbę znaków do wyszukania. Definiują one zakres wyszukiwania. Jeśli wyszukiwanie rozpoczynające się od lewej do prawej (ustawienie domyślne), aparat wyrażeń regularnych przeszukuje od znaku o indeksie `beginning` do znaku w indeksie `beginning`  +  `length` - 1. Jeśli aparat wyrażeń regularnych zostało utworzone przy użyciu <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opcji wyszukiwanie rozpoczynające się od prawej do pozostałych wyszukiwania aparatu wyrażenia regularnego od znaku o indeksie `beginning`  +  `length` - 1 do znak w indeksie `beginning`. Ta metoda zwraca pierwsze dopasowanie, które znajdzie się w tym zakresie. Możesz pobrać kolejnych dopasowań, wywołując wielokrotnie zwracanego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metody.  
  
 Można określić, czy wykryto wzorzec wyrażenia regularnego do ciągu wejściowego, sprawdzając wartość zwracanej <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znalezione dopasowanie, zwrócony <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg z `input` który pasuje do wzorca wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeśli czas wykonywania operacji dopasowywania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz wartość limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="beginning" /> jest mniejsza od zera lub większa niż długość <paramref name="input" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza od zera lub większa niż długość <paramref name="input" />.  
  
—lub— 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" /> Określa położenie, który jest poza zakresem <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <summary>Wyszukuje w ciągu wejściowym, aby pierwsze wystąpienie określonego wyrażenia regularnego przy użyciu określonych opcji dopasowania.</summary>
        <returns>Obiekt, który zawiera informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Metoda zwraca wartość pierwszego podciągu, który jest zgodny ze wzorcem wyrażenia regularnego w ciągu wejściowym. Aby uzyskać informacji na temat elementów języka, używany do tworzenia wzorca wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Statyczne <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metoda jest równoważna konstruowanie <xref:System.Text.RegularExpressions.Regex> obiekt z <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Konstruktor i wywoływać metodę wystąpienia <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metody.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wykryto wzorzec wyrażenia regularnego do ciągu wejściowego, sprawdzając wartość zwracanej <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znalezione dopasowanie, zwrócony <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg z `input` który pasuje do wzorca wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca wartość pierwszego podciągu w `input` który pasuje do wzorca wyrażenia regularnego. Możesz pobrać kolejnych dopasowań, wywołując wielokrotnie zwracanego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A> metody. Możesz również pobrać wszystkich dopasowań w pojedynczym wywołaniu metody, wywołując <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metody.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeśli czas wykonywania operacji dopasowywania przekroczy limit czasu określony dla domeny aplikacji, w którym metoda jest wywoływana. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenie regularne dopasowuje słowa rozpoczynające się od litery "". Używa ona <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opcję, aby upewnić się, że wyrażenie regularne lokalizuje słów z zarówno wielką małe "a" i "".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Definicję wzorca wyrażenia regularnego `\ba\w*\b` jest interpretowane tak jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`a`|Dopasowuje znak "".|  
|`\w*`|Dopasowuje zero, jeden lub więcej znaków słowa.|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecana metoda statyczna pobierania dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> do wskazania, że metoda powinna nie przekraczają limit czasu.</param>
        <summary>Wyszukuje w ciągu wejściowym, aby pierwsze wystąpienie określonego wyrażenia regularnego przy użyciu określonego dopasowania interwał opcje i limitu czasu.</summary>
        <returns>Obiekt, który zawiera informacje o zgodności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Metoda zwraca wartość pierwszego podciągu, który jest zgodny ze wzorcem wyrażenia regularnego w ciągu wejściowym. Aby uzyskać informacji na temat elementów języka, używany do tworzenia wzorca wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Statyczne <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metoda jest równoważna konstruowanie <xref:System.Text.RegularExpressions.Regex> obiekt z <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor i wywoływać metodę wystąpienia <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metody.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Można określić, czy wykryto wzorzec wyrażenia regularnego do ciągu wejściowego, sprawdzając wartość zwracanej <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Group.Success%2A> właściwości. Jeśli zostanie znalezione dopasowanie, zwrócony <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Capture.Value%2A> właściwość zawiera podciąg z `input` który pasuje do wzorca wyrażenia regularnego. Jeśli nie zostanie znalezione dopasowanie, jego wartość jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Ta metoda zwraca wartość pierwszego podciągu w `input` który pasuje do wzorca wyrażenia regularnego. Możesz pobrać kolejnych dopasowań, wywołując wielokrotnie zwracanego <xref:System.Text.RegularExpressions.Match> obiektu <xref:System.Text.RegularExpressions.Match.NextMatch%2A> metody. Możesz również pobrać wszystkich dopasowań w pojedynczym wywołaniu metody, wywołując <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metody.  
  
 `matchTimeout` Parametr określa, jak długo dopasowywanie do wzorców metody prób znalezienia dopasowania, przed upływem limitu czasu. Ustawienie interwału limitu czasu zapobiega wyrażeń regularnych, które są nadmiernie używać wycofywania pojawianiu się może przestać odpowiadać podczas przetwarzania danych wejściowych zawiera dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli nie zostanie znalezione dopasowanie w tym przedziale czasu, metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie domyślną wartość limitu czasu, który jest zdefiniowany dla domeny aplikacji, w którym metoda jest wykonywana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  
  
—lub— 
 <paramref name="matchTimeout" /> ma wartość ujemną, zerowego, lub większa od około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwóch sekund. Jeśli wyłączysz limity czasu, określając <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednakże należy wyłączyć limity czasu tylko w następujących warunkach: 
— W przypadku danych wejściowych, przetwarzane przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub zawiera tekst statyczny. Nie obejmuje to tekst, który znajduje się dynamicznie danych wprowadzonych przez użytkowników.  
  
— Jeśli wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że umożliwia ona efektywne obsługę, bez dopasowania i wkrótce.  
  
— W przypadku wzorca wyrażenia regularnego nie zawiera żadnych elementów języka, które są znane, aby spowodować, że nadmierne używanie wycofywania podczas przetwarzania niemal dopasowania.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje ciąg wejściowy dla wszystkich wystąpień elementu wyrażenia regularnego i zwraca wszystkie dopasowania.</summary>
        <block subset="none" type="usage"><para>Podczas próby dopasowania jest powtarzany, wywołując <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> metody, aparat wyrażeń regularnych zapewnia pusty dopasowania specjalnego traktowania. Zazwyczaj aparat wyrażeń regularnych rozpocznie się wyszukiwanie następnego dopasowania dokładnie tam, gdzie poprzednie dopasowanie przerwaliśmy. Jednak po dopasowaniu pusty, aparat wyrażeń regularnych jest przesuwany o jeden znak przed podjęciem próby następnego dopasowania. Takie zachowanie gwarantuje, że aparat wyrażeń regularnych będzie postęp za pomocą ciągu. W przeciwnym razie dopasowanie pusty, nie powoduje żadnych przenoszenia do przodu, następnego dopasowania zaczyna się w tym samym miejscu, co poprzednie dopasowanie dlatego byłby on zgodny z tym samym pustym ciągiem wielokrotnie.  
  
W poniższym przykładzie wzorzec wyrażenia regularnego <c>*</c> wyszukuje zero lub więcej wystąpień litery "a" w ciągu "abaabb". Jak wynika z przykładzie wynikowy <see cref="T:System.Text.RegularExpressions.MatchCollection" /> obiekt zawiera sześć <see cref="T:System.Text.RegularExpressions.Match" /> obiektów. Pierwsza próba dopasowania znajdzie pierwszy "". Drugi rozpoczyna się dopasowanie, gdzie pierwszy identyczne kończy się przed pierwszym b; znajdzie zero wystąpienia znaku "a" i zwraca pusty ciąg. Trzeci dopasowanie nie rozpoczyna się dokładnie gdzie drugi dopasowanie zakończyło się, ponieważ drugi dopasowanie zwrócił pusty ciąg. Zamiast tego należy go rozpoczyna się o jeden znak później, po pierwszym "b". Trzeci dopasowanie znajduje dwa wystąpienia znaku "a" i zwraca "aa". Czwarty próby dopasowania rozpoczyna się, gdzie trzeci dopasowanie zakończyło się przed drugim "b" i zwraca pusty ciąg. Piąty próby dopasowania ponownie przechodzi jeden znak, który rozpoczyna się przed trzeci "b" i zwraca pusty ciąg. Szósty dopasowanie rozpoczyna się po ostatnim "b" i ponownie zwraca pusty ciąg.  
  
[!code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [!code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <summary>Wyszukuje określony ciągu wejściowym, aby wszystkie wystąpienia wyrażeń regularnych.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> obiekty znalezione przez wyszukiwanie. Jeśli nie znaleziono żadnych dopasowań, metoda zwraca obiekt pustą kolekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Metoda jest podobna do <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> znaleziono metody, z wyjątkiem, że zwraca informacje na temat wszystkie dopasowania w ciągu wejściowym, a nie pojedyncze dopasowanie. Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 Kolekcja zawiera tylko zgodności i kończy się na pierwszym bez dopasowania.  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> metoda wyszukiwania jest definiowany przez wywołanie jednej z <xref:System.Text.RegularExpressions.Regex> klasy konstruktorów. Aby uzyskać więcej informacji na temat elementy tworzące wzorzec wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda użyje obliczanie z opóźnieniem, aby wypełnić zwracanego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Uzyskiwanie dostępu do członków tej kolekcji, takie jak <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> powoduje, że kolekcja wypełniona natychmiast. Aby móc korzystać z opóźnieniem, powinien iteracji kolekcji za pomocą konstrukcji, takich jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic.  
  
 Ze względu na jego obliczanie leniwe wywoływania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. Jednak wyjątek jest zgłaszany, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> obiektu zwróconego przez tę metodę, jeśli <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> właściwość nie jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> i operacji dopasowywania przekroczy ten interwał limitu czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> metodę identyfikowania wyrazów w zdaniu, które kończą się na "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Definicję wzorca wyrażenia regularnego `\b\w+es\b` jest zdefiniowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Jest zgodny z ciągiem literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowym, od którego należy rozpocząć wyszukiwanie.</param>
        <summary>Wyszukuje określony ciągu wejściowym, aby wszystkie wystąpienia wyrażeń regularnych, zaczynając od określonej pozycji początkowej w ciągu.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> obiekty znalezione przez wyszukiwanie. Jeśli nie znaleziono żadnych dopasowań, metoda zwraca obiekt pustą kolekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Metoda jest podobna do <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> znaleziono metody, z wyjątkiem, że zwraca informacje na temat wszystkie dopasowania w ciągu wejściowym, a nie pojedyncze dopasowanie. Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Wzorzec wyrażenia regularnego, dla którego <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> metoda wyszukiwania jest definiowany przez wywołanie jednej z <xref:System.Text.RegularExpressions.Regex> klasy konstruktorów. Aby uzyskać więcej informacji na temat elementy tworzące wzorzec wyrażenia regularnego, zobacz [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda użyje obliczanie z opóźnieniem, aby wypełnić zwracanego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Uzyskiwanie dostępu do członków tej kolekcji, takie jak <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> powoduje, że kolekcja wypełniona natychmiast. Aby móc korzystać z opóźnieniem, powinien iteracji kolekcji za pomocą konstrukcji, takich jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic.  
  
 Ze względu na jego obliczanie leniwe wywoływania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. Jednak wyjątek jest zgłaszany, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> obiektu zwróconego przez tę metodę, jeśli <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> właściwość nie jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> i operacji dopasowywania przekroczy ten interwał limitu czasu. 
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metody do znalezienia pierwszego wyrazu w zdaniu, który kończy się na "es", a następnie wywołuje <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> metodę, aby zidentyfikować dodatkowe słowa, które kończą się na "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Definicję wzorca wyrażenia regularnego `\b\w+es\b` jest zdefiniowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Jest zgodny z ciągiem literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Wyszukuje określony ciągu wejściowym, aby wszystkie wystąpienia określonego wyrażenia regularnego.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> obiekty znalezione przez wyszukiwanie. Jeśli nie znaleziono żadnych dopasowań, metoda zwraca obiekt pustą kolekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Metoda jest podobna do <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> znaleziono metody, z wyjątkiem, że zwraca informacje na temat wszystkie dopasowania w ciągu wejściowym, a nie pojedyncze dopasowanie. Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Statyczne `Matches` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Matches`.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda użyje obliczanie z opóźnieniem, aby wypełnić zwracanego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Uzyskiwanie dostępu do członków tej kolekcji, takie jak <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> powoduje, że kolekcja wypełniona natychmiast. Aby móc korzystać z opóźnieniem, powinien iteracji kolekcji za pomocą konstrukcji, takich jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic.  
  
 Ze względu na jego obliczanie leniwe wywoływania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. Jednak wyjątek jest zgłaszany, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> obiektu zwróconego przez tę metodę, jeśli interwał limitu czasu jest definiowany przez właściwość "REGEX_DEFAULT_MATCH_TIMEOUT" w bieżącej domenie aplikacji i operacji dopasowywania przekroczy ten interwał limitu czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metodę, aby zidentyfikować wszelkie wyrazu w zdaniu, który kończy się na "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Definicję wzorca wyrażenia regularnego `\b\w+es\b` jest zdefiniowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Jest zgodny z ciągiem literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecaną metodą statycznego jest zgodna z Pobieranie wielu wzorzec jest <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, które pozwalają określić interwał limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które określają opcje do dopasowania.</param>
        <summary>Wyszukuje określony ciągu wejściowym, aby wszystkie wystąpienia określonego wyrażenia regularnego, przy użyciu określonych opcji dopasowania.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> obiekty znalezione przez wyszukiwanie. Jeśli nie znaleziono żadnych dopasowań, metoda zwraca obiekt pustą kolekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Metoda jest podobna do <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> znaleziono metody, z wyjątkiem, że zwraca informacje na temat wszystkie dopasowania w ciągu wejściowym, a nie pojedyncze dopasowanie. Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Statyczne `Matches` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Matches`.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda użyje obliczanie z opóźnieniem, aby wypełnić zwracanego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Uzyskiwanie dostępu do członków tej kolekcji, takie jak <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> powoduje, że kolekcja wypełniona natychmiast. Aby móc korzystać z opóźnieniem, powinien iteracji kolekcji za pomocą konstrukcji, takich jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic.  
  
 Ze względu na jego obliczanie leniwe wywoływania <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. Jednak wyjątek jest zgłaszany, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> obiektu zwróconego przez tę metodę, jeśli interwał limitu czasu jest definiowany przez właściwość "REGEX_DEFAULT_MATCH_TIMEOUT" w bieżącej domenie aplikacji i operacji dopasowywania przekroczy ten interwał limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metodę identyfikowania dowolny wyraz w zdaniu, który kończy się na "es", a następnie wywołuje <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodę w celu porównania bez uwzględniania wielkości wzorzec ciągu wejściowego. Dane wyjściowe pokazują, te dwie metody zwracają różne wyniki.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Definicję wzorca wyrażenia regularnego `\b\w+es\b` jest zdefiniowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Jest zgodny z ciągiem literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecaną metodą statycznego jest zgodna z Pobieranie wielu wzorzec jest <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które określają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> do wskazania, że metoda powinna nie przekraczają limit czasu.</param>
        <summary>Wyszukuje określony ciągu wejściowym, aby wszystkie wystąpienia określonego wyrażenia regularnego, przy użyciu określonego dopasowania interwał opcje i limitu czasu.</summary>
        <returns>Kolekcja <see cref="T:System.Text.RegularExpressions.Match" /> obiekty znalezione przez wyszukiwanie. Jeśli nie znaleziono żadnych dopasowań, metoda zwraca obiekt pustą kolekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Metoda jest podobna do <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> znaleziono metody, z wyjątkiem, że zwraca informacje na temat wszystkie dopasowania w ciągu wejściowym, a nie pojedyncze dopasowanie. Odpowiada to następującemu kodowi:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Statyczne `Matches` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Matches`.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Metoda użyje obliczanie z opóźnieniem, aby wypełnić zwracanego <xref:System.Text.RegularExpressions.MatchCollection> obiektu. Uzyskiwanie dostępu do członków tej kolekcji, takie jak <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> i <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> powoduje, że kolekcja wypełniona natychmiast. Aby móc korzystać z opóźnieniem, powinien iteracji kolekcji za pomocą konstrukcji, takich jak `foreach` w języku C# i `For Each`...`Next` w języku Visual Basic.  
  
 Ze względu na jego obliczanie leniwe wywoływania <xref:System.Text.RegularExpressions.Regex.Matches%2A> metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. Jednak wyjątek jest zgłaszany, gdy operacja jest wykonywana na <xref:System.Text.RegularExpressions.MatchCollection> obiektu zwróconego przez tę metodę, jeśli operacja przekroczy ten interwał limitu czasu określonego przez`matchTimeout` parametru.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodę w celu porównania uwzględniającego wielkość liter, która jest dopasowywany dowolny wyraz w zdaniu, który kończy się na "es". Następnie wywołuje <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodę w celu porównania bez uwzględniania wielkości wzorzec ciągu wejściowego. W obu przypadkach interwał limitu czasu jest równa 1 sekundy. Dane wyjściowe pokazują, te dwie metody zwracają różne wyniki.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Definicję wzorca wyrażenia regularnego `\b\w+es\b` jest zdefiniowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\b`|Rozpoczyna dopasowanie na granicy wyrazu.|  
|`\w+`|Dopasowuje co najmniej jeden znak słowa.|  
|`es`|Jest zgodny z ciągiem literału "es".|  
|`\b`|Kończy dopasowanie na granicy wyrazu.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  
  
—lub— 
 <paramref name="matchTimeout" /> ma wartość ujemną, zerowego, lub większa od około 24 dni.</exception>
        <block subset="none" type="usage"><para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwóch sekund. Jeśli wyłączysz limity czasu, określając <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednakże należy wyłączyć limity czasu tylko w następujących warunkach: 
— W przypadku danych wejściowych, przetwarzane przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub zawiera tekst statyczny. Nie obejmuje to tekst, który znajduje się dynamicznie danych wprowadzonych przez użytkowników.  
  
— Jeśli wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że umożliwia ona efektywne obsługę, bez dopasowania i wkrótce.  
  
— W przypadku wzorca wyrażenia regularnego nie zawiera żadnych elementów języka, które są znane, aby spowodować, że nadmierne używanie wycofywania podczas przetwarzania niemal dopasowania.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera interwał limitu czasu bieżącego wystąpienia.</summary>
        <value>Interwał maksymalny czas, jaki może upłynąć dopasowania do wzorca operacji przed <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> jest zgłaszany, lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> wyłączenie przekroczeń limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Właściwość definiuje przybliżony czas maksymalny interwał <xref:System.Text.RegularExpressions.Regex> wystąpienia do wykonywania pojedynczej operacji dopasowywania, zanim upłynie limit czasu operacji. Aparat wyrażeń regularnych zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątek podczas jego następnego sprawdzania czasu, po upływie limitu czasu. Zapobiega to przetwarzanie ciągów wejściowych, które wymagają nadmierne używanie wycofywania przez aparat wyrażeń regularnych. Aby uzyskać więcej informacji, zobacz [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md) i [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md).  
  
 Ta właściwość jest tylko do odczytu. Jej wartość można ustawić jawnie dla poszczególnych <xref:System.Text.RegularExpressions.Regex> obiektu przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor; i ustawić jej wartość dla wszystkich <xref:System.Text.RegularExpressions.Regex> pasujących operacji w domenie aplikacji, wywołując <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> metody i zapewniając <xref:System.TimeSpan> wartości dla właściwości "REGEX_DEFAULT_MATCH_TIMEOUT", tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Jeśli nie zostanie jawnie zdefiniowany interwał limitu czasu, wartością domyślną <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> jest używany i zgodnych operacji nie mają limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opcje, które zostały przekazane do <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora.</summary>
        <value>Jeden lub więcej członków <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wyliczenie, które reprezentują opcje, które zostały przekazane do <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Text.RegularExpressions.Regex.Options%2A> właściwość składa się z co najmniej jednego członka z <xref:System.Text.RegularExpressions.RegexOptions> wyliczenia. Jeśli zostały zdefiniowane żadne opcje <xref:System.Text.RegularExpressions.Regex> konstruktora klasy, jego wartość wynosi <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Dostępne opcje są szczegółowo omówione w [Regular Expression Options](~/docs/standard/base-types/regular-expression-options.md) tematu.  
  
 Należy pamiętać, że <xref:System.Text.RegularExpressions.Regex.Options%2A> właściwość nie będzie odzwierciedlał opcje określane w tekście zdefiniowane w wyrażeniu regularnym wzorca sam.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> jest klasą bazową wyrażeń regularnych, utworzone przez <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody. Te skompilowane wyrażenia regularne używać implementacji klasy podstawowej <see cref="P:System.Text.RegularExpressions.Regex.Options" /> właściwości. Jeśli jest wywoływany z klasy pochodnej, <see cref="P:System.Text.RegularExpressions.Regex.Options" /> właściwość zwraca opcje, które zostały przekazane do <paramref name="options" /> parametru <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> konstruktora klasy, który był używany do definiowania wyrażeń regularnych.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">Opcje wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowane przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W określonym ciągu wejściowym zastępuje ciągów, które pasują do wzorca wyrażenia regularnego przy użyciu określony ciąg zastępczy.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do wzorca wyrażenia regularnego przy użyciu określony ciąg zastępczy.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj dopasowań, który rozpoczyna się na początku `input` ciągu. Wyrażenie regularne to wzorzec zdefiniowany przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `replacement` Parametr określa ciąg, który jest aby zamieniał każde dopasowanie w `input`. `replacement` może zawierać dowolną kombinację tekst dosłowny i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zamieniania `a*${test}b` wstawia ciąg "*" następuje podciąg dopasowany przez `test` grupa przechwytywania — Jeśli istnieje, następuje ciąg "b". * Znak nie jest rozpoznawany jako metaznak we wzorcu zamieniania.  
  
> [!NOTE]
>  Podstawienia są elementami języka wyrażeń regularnych tylko, które są rozpoznawane we wzorcu zamieniania. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znak ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone w tylko wzorce wyrażeń regularnych i nie są rozpoznawane we wzorcach zamieniania.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji zastępowania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenie regularne `\s+`, który dopasowuje co najmniej jeden znak odstępu. Ciąg zastępujący "", zastępuje pojedynczy znak.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 W poniższym przykładzie zdefiniowano wyrażenie regularne `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`i wzorzec zamieniania `$2`, który usuwa wiodące lub końcowe symbol waluty z wartością liczbową.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 Wyrażenie regularne jest interpretowane tak jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\p{Sc}`|Dopasowuje symbolu waluty. `{Sc}` Wskazuje, że dowolny znak, który jest elementem członkowskim symboli Unicode w kategorii Waluta.|  
|`\s?`|Dopasowuje zero lub jeden znak odstępu.|  
|`(\p{Sc}\s?)?`|Dopasowuje zero lub jeden wystąpienie kombinacji symbolu waluty, w którym następuje zero lub jeden znak odstępu. Jest to pierwsza grupa przechwytywania.|  
|`\d+`|Dopasowanie do co najmniej jednej cyfry dziesiętnej.|  
|`\.?`|Dopasowanie zera lub jednego wystąpienia kropki (używany jako znak separatora dziesiętnego).|  
|`((?<=\.)\d+)?`|Jeśli okres jest poprzedni znak, Dopasuj do jednego lub więcej cyfr dziesiętnych. Ten wzorzec można dopasować wartość zero lub jeden raz.|  
|`(\d+\.?((?<=\.)\d+)?)`|Dopasowuje wzorzec jednego lub więcej cyfr dziesiętnych, następuje opcjonalna kropka i dodatkowe cyfry dziesiętne. Jest to druga grupa przechwytywania. Wywołanie <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> metoda zastępuje całe dopasowanie z wartością tę przechwyconą grupę.|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|Jeśli istnieje pierwszej przechwyconej grupy, odpowiadać pustemu ciągowi. W przeciwnym razie dopasowania zero lub jeden znak odstępu, następuje symbol waluty.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdego dopasowania i zwraca oryginalny ciąg dopasowane lub ciąg zastępujący.</param>
        <summary>W określonym ciągu wejściowym, zastępuje wszystkie ciągi, które pasują do podanego wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegować.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowanie wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Ciąg zamienny nie można określić łatwo przez wzorzec zamieniania wyrażenia regularnego.  
  
-   Ciąg zastępujący wynika z jakieś operacje przetwarzania wykonywane na dopasowany ciąg.  
  
-   Ciąg zastępczy wyniki przetwarzania warunkowego.  
  
 Metoda jest równoważne z wywoływaniem <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> metody i przekazanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconym elemencie <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegować.  
  
 Wyrażenie regularne to wzorzec zdefiniowany przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `evaluator` Parametrem jest delegat dla niestandardowej metody, który zdefiniujesz i które analizuje każdego dopasowania. Metoda niestandardowe musi mieć następujący podpis, aby dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegować.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metoda zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji zastępowania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład kodu Wyświetla oryginalny ciąg, pasuje do każdego wyrazu w oryginalnym ciągu, konwertuje pierwszym znakiem każdego dopasowania na wielkie litery, następnie wyświetla ciąg przekonwertowany.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="count">Maksymalna liczba przypadków, gdy jest możliwe zastąpienie.</param>
        <summary>W określonym ciągu wejściowym zastępuje określoną maksymalną liczbę ciągów, które pasują do wzorca wyrażenia regularnego przy użyciu określony ciąg zastępczy.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj dopasowań, który rozpoczyna się na początku `input` ciągu. Wyrażenie regularne to wzorzec, który jest zdefiniowany przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu. Jeśli `count` jest ujemna, zamiany w dalszym ciągu końca ciągu. Jeśli `count` przekracza liczbę dopasowań, wszystkie dopasowania są zastępowane.  
  
 `replacement` Parametr określa ciąg, który ma zastąpić pierwszy `count` podanej w `input`. `replacement` może zawierać dowolną kombinację tekst dosłowny i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zamieniania `a*${test}b` wstawia ciąg "*" następuje podciąg dopasowany przez `test` grupa przechwytywania — Jeśli istnieje, następuje ciąg "b". * Znak nie jest rozpoznawany jako metaznak we wzorcu zamieniania.  
  
> [!NOTE]
>  Podstawienia są elementami języka wyrażeń regularnych tylko, które są rozpoznawane we wzorcu zamieniania. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znak ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone w tylko wzorce wyrażeń regularnych i nie są rozpoznawane we wzorcach zamieniania.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji zastępowania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład zastępuje pierwszych pięć wystąpień zduplikowane znaki pojedynczy znak. Definicję wzorca wyrażenia regularnego `(\w)\1` uwzględnia kolejnych wystąpień pojedynczy znak, a następnie przypisuje pierwsze wystąpienie do pierwszej grupy przechwytywania. Wzorzec zamieniania `$1` zastępuje całe dopasowanie pierwszej przechwyconej grupy.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego z ciągiem określonym zastąpienie.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statyczne `Replace` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Replace`.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Wyszukaj dopasowań, który rozpoczyna się na początku `input` ciągu.  
  
 `replacement` Parametr określa ciąg, który jest aby zamieniał każde dopasowanie w `input`. `replacement` może zawierać dowolną kombinację tekst dosłowny i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zamieniania `a*${test}b` wstawia ciąg "*" następuje podciąg dopasowany przez `test` grupa przechwytywania — Jeśli istnieje, następuje ciąg "b". * Znak nie jest rozpoznawany jako metaznak we wzorcu zamieniania.  
  
> [!NOTE]
>  Podstawienia są elementami języka wyrażeń regularnych tylko, które są rozpoznawane we wzorcu zamieniania. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znak ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone w tylko wzorce wyrażeń regularnych i nie są rozpoznawane we wzorcach zamieniania.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji zastępowania przekroczy limit czasu określony dla domeny aplikacji, w którym metoda jest wywoływana. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano wyrażenie regularne `\s+`, który dopasowuje co najmniej jeden znak odstępu. Ciąg zastępujący "", zastępuje pojedynczy znak.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> metodę, aby zastąpić nazwy komputera i dysku lokalne w ścieżce UNC z lokalną ścieżką pliku. Używa wyrażenia regularnego <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby zawierał on nazwę komputera lokalnego i <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> metodę, aby dołączyć nazwy dysków logicznych. Aby pomyślnie uruchomić przykład, ciąg literału "MojKomputer" należy zastąpić nazwą komputera lokalnego.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Definicję wzorca wyrażenia regularnego jest zdefiniowany przez następujące wyrażenie:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\\\\`|Dopasowanie dwóch następujących po sobie kreski ułamkowej odwróconej (`\`) znaków. Ponieważ znak ukośnika odwrotnego jest interpretowany jako znak ucieczki, każdy ukośnik odwrotny należy użyć znaków ucieczki, używając innego ukośnika odwrotnego.|  
|`(?i:" + Environment.MachineName + ")`|Wykonać dopasowanie bez uwzględniania wielkości liter ciągu, który jest zwracany przez <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości.|  
|`(?:\.\w+)*`|Odpowiada okres (`.`) znak następuje jeden lub więcej znaków słowa. To dopasowanie, może wystąpić zero lub więcej razy. Dopasowane Podwyrażenie nie są przechwytywane.|  
|`\\`|Odpowiada kreski ułamkowej odwróconej (`\`) znaków.|  
|`((?i:[" + driveNames + "]))`|Wykonuje dopasowanie bez uwzględniania wielkości liter klasy znaków, która składa się z liter poszczególnych dysków. To dopasowanie jest pierwsze przechwycone Podwyrażenie.|  
|`\$`|Dopasowania literałów znak dolara (`$`) znaków.|  
  
 Wzorzec zamieniania `$1` zastępuje całe dopasowanie pierwszego przechwyconego podwyrażenia. Oznacza to zastępuje Nazwa UNC komputera i dysk z literą dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecana metoda statyczna do zastępowania dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdego dopasowania i zwraca oryginalny ciąg dopasowane lub ciąg zastępujący.</param>
        <summary>W określonym ciągu wejściowym, zastępuje wszystkie ciągi, które pasują do podanego wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegować.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowanie wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Ciąg zamienny nie można określić łatwo przez wzorzec zamieniania wyrażenia regularnego.  
  
-   Ciąg zastępujący wynika z jakieś operacje przetwarzania wykonywane na dopasowany ciąg.  
  
-   Ciąg zastępczy wyniki przetwarzania warunkowego.  
  
 Metoda jest równoważne z wywoływaniem <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> metody i przekazanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconym elemencie <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegować.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Parametrem jest delegat dla niestandardowej metody, który zdefiniujesz i które analizuje każdego dopasowania. Metoda niestandardowe musi mieć następujący podpis, aby dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegować.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metoda zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji zastępowania przekroczy limit czasu określony dla domeny aplikacji, w którym metoda jest wywoływana. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład używa wyrażeń regularnych do wyodrębniania poszczególnych wyrazów z ciągu, a następnie używa <xref:System.Text.RegularExpressions.MatchEvaluator> pełnomocnika do wywołania metody o nazwie `WordScramble` , zaszyfrowanie pojedynczych liter w wyrazie. Aby to zrobić, `WordScramble` metoda tworzy tablicę, która zawiera znaki w dopasowaniu. Tworzy również równoległe tablicy, która wypełnia go za pomocą losowych liczb zmiennoprzecinkowych. Tablice są posortowane według wywoływania <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metoda i posortowaną tablicę jest dostarczana jako argument do <xref:System.String> konstruktora klasy. Ten ciąg nowo utworzony jest następnie zwracany przez `WordScramble` metody. Definicję wzorca wyrażenia regularnego `\w+` dopasowuje jeden lub więcej znaków wyrazu; aparat wyrażeń regularnych będzie w dalszym ciągu dodawać znaki do dopasowania, aż do napotkania niebędący znakiem słowa, takie jak znak odstępu.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecana metoda statyczna oceniania i zastępując dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdego dopasowania i zwraca oryginalny ciąg dopasowane lub ciąg zastępujący.</param>
        <param name="count">Maksymalna liczba przypadków, gdy nastąpi zastąpienie.</param>
        <summary>W określonym ciągu wejściowym, zastępuje określoną maksymalną liczbę ciągów, które pasują do wzorca wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegować.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowanie wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Ciąg zamienny nie można określić łatwo przez wzorzec zamieniania wyrażenia regularnego.  
  
-   Ciąg zastępujący wynika z jakieś operacje przetwarzania wykonywane na dopasowany ciąg.  
  
-   Ciąg zastępczy wyniki przetwarzania warunkowego.  
  
 Metoda jest równoważne z wywoływaniem <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> metody i przekazywanie pierwszego `count`<xref:System.Text.RegularExpressions.Match> obiektów w zwróconym elemencie <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegować.  
  
 Wyrażenie regularne to wzorzec zdefiniowany przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `evaluator` Parametrem jest delegat dla niestandardowej metody, który zdefiniujesz i które analizuje każdego dopasowania. Metoda niestandardowe musi mieć następujący podpis, aby dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegować.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metoda zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji zastępowania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wyrażenia regularnego, aby celowo błędnie połowę słów na liście. Używa wyrażenia regularnego `\w*(ie|ei)\w*` do dopasowania słów, które zawierają znaki "ie" lub "ei". Przekazuje pierwsza połowa dopasowania słów `ReverseLetter` metody, która z kolei używa <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodę, aby odwrócić "i" i "e" in dopasowany ciąg. Pozostałe słowa pozostaną bez zmian.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 Wyrażenie regularne `\w*(ie|ei)\w*` jest zdefiniowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\w*`|Dopasowuje zero lub więcej znaków słowa.|  
|<code>(ie&#124;ei)</code>|Dopasowuje "ie" lub "ei".|  
|`\w*`|Dopasowuje zero lub więcej znaków słowa.|  
  
 Definicję wzorca wyrażenia regularnego `([ie])([ie])` w `ReverseLetter` metoda pasuje pierwszym "i" lub "e" w diphthong "ie" lub "ei" i przypisuje literę pierwszą grupę przechwytywania. On pasuje do drugiej "i" lub "e" i przypisuje literę druga grupa przechwytywania. Dwa znaki są następnie wycofać przez wywołanie metody <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> metody z wzorzec zamieniania `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="count">Maksymalna liczba przypadków, gdy jest możliwe zastąpienie.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowym, gdzie rozpoczyna się wyszukiwanie.</param>
        <summary>W podanym podciągiem danych wejściowych zastępuje określoną maksymalną liczbę ciągów, które pasują do wzorca wyrażenia regularnego przy użyciu określony ciąg zastępczy.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj dopasowań, który rozpoczyna się `input` ciągu w położeniu określonego przez `startat` parametru. Wyrażenie regularne to wzorzec zdefiniowany przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu. Jeśli `count` jest ujemna, zamiany w dalszym ciągu końca ciągu. Jeśli `count` przekracza liczbę dopasowań, wszystkie dopasowania są zastępowane.  
  
 `replacement` Parametr określa ciąg, który jest aby zamieniał każde dopasowanie w `input`. `replacement` może zawierać dowolną kombinację tekst dosłowny i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zamieniania `a*${test}b` wstawia ciąg "*" następuje podciąg dopasowany przez `test` grupa przechwytywania — Jeśli istnieje, następuje ciąg "b". * Znak nie jest rozpoznawany jako metaznak we wzorcu zamieniania.  
  
> [!NOTE]
>  Podstawienia są elementami języka wyrażeń regularnych tylko, które są rozpoznawane we wzorcu zamieniania. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znak ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone w tylko wzorce wyrażeń regularnych i nie są rozpoznawane we wzorcach zamieniania.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji zastępowania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład double-spaces wszystkie oprócz pierwszego wiersza w ciągu. Definiuje wzorzec wyrażenia regularnego `^.*$`, wiersza tekstu, wywołania, które odpowiadają <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metodę, aby dopasować pierwszy wiersz w ciągu i używa `Match.Index` i `Match.Count` właściwości w celu określenia pozycji początkowej drugiej wiersz.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Definicję wzorca wyrażenia regularnego `^.*$` jest zdefiniowany jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`^`|Dopasowuje początek wiersza. (Należy pamiętać, że <xref:System.Text.RegularExpressions.Regex> za pomocą wystąpienia obiektu <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opcja; w przeciwnym razie ta klasa znaków spowoduje dopasowanie tylko początek ciągu wejściowego.)|  
|`.*`|Dopasowuje dowolny znak zero lub więcej razy.|  
|`$`|Dopasowuje koniec linii. (Należy pamiętać, że <xref:System.Text.RegularExpressions.Regex> za pomocą wystąpienia obiektu <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opcja; w przeciwnym razie ta klasa znaków spowoduje dopasowanie tylko początek ciągu wejściowego.)|  
  
 Ciąg zastępujący (`vbCrLf + "$&"` w języku Visual Basic `"\n$&"` w języku C#) umożliwia dodanie nowego wiersza przed dopasowany ciąg. Należy pamiętać, że `\n` w języku C# przykład jest interpretowany jako znak nowego wiersza za pomocą kompilatora C#; nie reprezentuje wyrażenia regularnego znak ucieczki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego z ciągiem określonym zastąpienie. Określone opcje modyfikować operacji dopasowywania.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statyczne `Replace` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Replace`.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> dla `options` parametru wyszukiwania dopasowania rozpoczyna się od końca ciągu wejściowego i przenosi lewej; w przeciwnym razie wyszukiwanie rozpoczyna się od początku ciągu wejściowego i przechodzi bezpośrednio.  
  
 `replacement` Parametr określa ciąg, który jest aby zamieniał każde dopasowanie w `input`. `replacement` może zawierać dowolną kombinację tekst dosłowny i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zamieniania `a*${test}b` wstawia ciąg "*" następuje podciąg dopasowany przez `test` grupa przechwytywania — Jeśli istnieje, następuje ciąg "b". * Znak nie jest rozpoznawany jako metaznak we wzorcu zamieniania.  
  
> [!NOTE]
>  Podstawienia są elementami języka wyrażeń regularnych tylko, które są rozpoznawane we wzorcu zamieniania. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znak ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone w tylko wzorce wyrażeń regularnych i nie są rozpoznawane we wzorcach zamieniania.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji zastępowania przekroczy limit czasu określony dla domeny aplikacji, w którym metoda jest wywoływana. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodę, aby zastąpić nazwy komputera i dysku lokalne w ścieżce UNC z lokalną ścieżką pliku. Używa wyrażenia regularnego <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby zawierał on nazwę komputera lokalnego i <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> metodę, aby dołączyć nazwy dysków logicznych. Wszystkie porównania ciągu wyrażenia regularnego jest rozróżniana wielkość liter. Aby pomyślnie uruchomić przykład, ciąg literału "MojKomputer" należy zastąpić nazwą komputera lokalnego.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Definicję wzorca wyrażenia regularnego jest zdefiniowany przez następujące wyrażenie:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\\\\`|Dopasowanie dwóch następujących po sobie kreski ułamkowej odwróconej (`\`) znaków. Ponieważ znak ukośnika odwrotnego jest interpretowany jako znak ucieczki, każdy ukośnik odwrotny należy użyć znaków ucieczki, używając innego ukośnika odwrotnego.|  
|`+ Environment.MachineName +`|Pasuje do ciągu, który jest zwracany przez <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości.|  
|`(?:\.\w+)*`|Odpowiada okres (`.`) znak następuje jeden lub więcej znaków słowa. To dopasowanie, może wystąpić zero lub więcej razy. Dopasowane Podwyrażenie nie są przechwytywane.|  
|`\\`|Odpowiada kreski ułamkowej odwróconej (`\`) znaków.|  
|`([" + driveNames + "])`|Zgodne klasy znaku, który składa się z liter poszczególnych dysków. To dopasowanie jest pierwsze przechwycone Podwyrażenie.|  
|`\$`|Dopasowania literałów znak dolara (`$`) znaków.|  
  
 Wzorzec zamieniania `$1` zastępuje całe dopasowanie pierwszego przechwyconego podwyrażenia. Oznacza to zastępuje Nazwa UNC komputera i dysk z literą dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecana metoda statyczna do zastępowania dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdego dopasowania i zwraca oryginalny ciąg dopasowane lub ciąg zastępujący.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <summary>W określonym ciągu wejściowym, zastępuje wszystkie ciągi, które pasują do podanego wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegować. Określone opcje modyfikować operacji dopasowywania.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowania wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Ciąg zamienny nie można określić łatwo przez wzorzec zamieniania wyrażenia regularnego.  
  
-   Ciąg zastępujący wynika z jakieś operacje przetwarzania wykonywane na dopasowany ciąg.  
  
-   Ciąg zastępczy wyniki przetwarzania warunkowego.  
  
 Metoda jest równoważne z wywoływaniem <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metody i przekazanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconym elemencie <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegować.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Parametrem jest delegat dla niestandardowej metody, który zdefiniujesz i które analizuje każdego dopasowania. Metoda niestandardowe musi mieć następujący podpis, aby dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegować.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metoda zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> dla `options` parametru wyszukiwania dopasowania rozpoczyna się od końca ciągu wejściowego i przenosi lewej; w przeciwnym razie wyszukiwanie rozpoczyna się od początku ciągu wejściowego i przechodzi bezpośrednio.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji zastępowania przekroczy limit czasu określony dla domeny aplikacji, w którym metoda jest wywoływana. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład używa wyrażeń regularnych do wyodrębniania poszczególnych wyrazów z ciągu, a następnie używa <xref:System.Text.RegularExpressions.MatchEvaluator> pełnomocnika do wywołania metody o nazwie `WordScramble` , zaszyfrowanie pojedynczych liter w wyrazie. Aby to zrobić, `WordScramble` metoda tworzy tablicę, która zawiera znaki w dopasowaniu. Tworzy również równoległe tablicy, która wypełnia go za pomocą losowych liczb zmiennoprzecinkowych. Tablice są posortowane według wywoływania <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metoda i posortowaną tablicę jest dostarczana jako argument do <xref:System.String> konstruktora klasy. Ten ciąg nowo utworzony jest następnie zwracany przez `WordScramble` metody. Definicję wzorca wyrażenia regularnego `\w+` dopasowuje jeden lub więcej znaków wyrazu; aparat wyrażeń regularnych będzie w dalszym ciągu dodawać znaki do dopasowania, aż do napotkania niebędący znakiem słowa, takie jak znak odstępu. Wywołanie <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> metoda zawiera <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opcję Tak, aby komentarz we wzorcu wyrażenia regularnego `\w+  # Matches all the characters in a word.` jest ignorowana przez aparat wyrażeń regularnych.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdego dopasowania i zwraca oryginalny ciąg dopasowane lub ciąg zastępujący.</param>
        <param name="count">Maksymalna liczba przypadków, gdy nastąpi zastąpienie.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowym, gdzie rozpoczyna się wyszukiwanie.</param>
        <summary>W podanym podciągiem danych wejściowych, zastępuje określoną maksymalną liczbę ciągów, które pasują do wzorca wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegować.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli wzorzec wyrażenia regularnego nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowanie wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Ciąg zamienny nie można określić łatwo przez wzorzec zamieniania wyrażenia regularnego.  
  
-   Ciąg zastępujący wynika z jakieś operacje przetwarzania wykonywane na dopasowany ciąg.  
  
-   Ciąg zastępczy wyniki przetwarzania warunkowego.  
  
 Metoda jest równoważne z wywoływaniem <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metody i przekazywanie pierwszego `count`<xref:System.Text.RegularExpressions.Match> obiektów w zwróconym elemencie <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegować.  
  
 Wyrażenie regularne to wzorzec zdefiniowany przez konstruktora dla bieżącego <xref:System.Text.RegularExpressions.Regex> obiektu.  
  
 `evaluator` Parametrem jest delegat dla niestandardowej metody, który zdefiniujesz i które analizuje każdego dopasowania. Metoda niestandardowe musi mieć następujący podpis, aby dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegować.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metoda zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji zastępowania przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="replacement" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="replacement">Ciąg zastępujący.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> do wskazania, że metoda powinna nie przekraczają limit czasu.</param>
        <summary>W określonym ciągu wejściowym zastępuje wszystkie ciągi, które pasują do określonego wyrażenia regularnego z ciągiem określonym zastąpienie. Dodatkowe parametry, określ opcje modyfikujące operacji dopasowywania i interwał limitu czasu, jeśli nie zostanie znalezione dopasowanie.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statyczne `Replace` metody są równoważne do konstruowania <xref:System.Text.RegularExpressions.Regex> obiektu za pomocą wzorca określonego wyrażenia regularnego i wywołanie metody wystąpienia `Replace`.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> dla `options` parametru wyszukiwania dopasowania rozpoczyna się od końca ciągu wejściowego i przenosi lewej; w przeciwnym razie wyszukiwanie rozpoczyna się od początku ciągu wejściowego i przechodzi bezpośrednio.  
  
 `replacement` Parametr określa ciąg, który jest aby zamieniał każde dopasowanie w `input`. `replacement` może zawierać dowolną kombinację tekst dosłowny i [podstawienia](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Na przykład wzorzec zamieniania `a*${test}b` wstawia ciąg "*" następuje podciąg dopasowany przez `test` grupa przechwytywania — Jeśli istnieje, następuje ciąg "b". * Znak nie jest rozpoznawany jako metaznak we wzorcu zamieniania.  
  
> [!NOTE]
>  Podstawienia są elementami języka wyrażeń regularnych tylko, które są rozpoznawane we wzorcu zamieniania. Wszystkie inne elementy języka wyrażeń regularnych, w tym [znak ucieczki](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), są dozwolone w tylko wzorce wyrażeń regularnych i nie są rozpoznawane we wzorcach zamieniania.  
  
 `matchTimeout` Parametr określa, jak długo dopasowywanie do wzorców metody prób znalezienia dopasowania, przed upływem limitu czasu. Ustawienie interwału limitu czasu zapobiega wyrażeń regularnych, które są nadmiernie używać wycofywania pojawianiu się może przestać odpowiadać podczas przetwarzania danych wejściowych zawiera dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli nie zostanie znalezione dopasowanie w tym przedziale czasu, metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie domyślną wartość limitu czasu, który jest zdefiniowany dla domeny aplikacji, w którym metoda jest wykonywana.  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodę, aby zastąpić nazwy komputera i dysku lokalne w ścieżce UNC z lokalną ścieżką pliku. Używa wyrażenia regularnego <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby zawierał on nazwę komputera lokalnego i <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> metodę, aby dołączyć nazwy dysków logicznych. Wszystkie porównania ciągu wyrażenia regularnego jest rozróżniana wielkość liter, a wszelkie jednego zastąpienia upłynie limit czasu operacji, jeśli nie można odnaleźć dopasowania w ciągu sekundy 0,5. Aby pomyślnie uruchomić przykład, ciąg literału "MojKomputer" należy zastąpić nazwą komputera lokalnego.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Definicję wzorca wyrażenia regularnego jest zdefiniowany przez następujące wyrażenie:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 W poniższej tabeli przedstawiono, jak wzorzec wyrażenia regularnego jest interpretowany.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`\\\\`|Dopasowanie dwóch następujących po sobie kreski ułamkowej odwróconej (`\`) znaków. Ponieważ znak ukośnika odwrotnego jest interpretowany jako znak ucieczki, każdy ukośnik odwrotny należy użyć znaków ucieczki, używając innego ukośnika odwrotnego.|  
|`+ Environment.MachineName +`|Pasuje do ciągu, który jest zwracany przez <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości.|  
|`(?:\.\w+)*`|Odpowiada okres (`.`) znak następuje jeden lub więcej znaków słowa. To dopasowanie, może wystąpić zero lub więcej razy. Dopasowane Podwyrażenie nie są przechwytywane.|  
|`\\`|Odpowiada kreski ułamkowej odwróconej (`\`) znaków.|  
|`([" + driveNames + "])`|Zgodne klasy znaku, który składa się z liter poszczególnych dysków. To dopasowanie jest pierwsze przechwycone Podwyrażenie.|  
|`\$`|Dopasowania literałów znak dolara (`$`) znaków.|  
  
 Wzorzec zamieniania `$1` zastępuje całe dopasowanie pierwszego przechwyconego podwyrażenia. Oznacza to zastępuje Nazwa UNC komputera i dysk z literą dysku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="replacement" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  
  
—lub— 
 <paramref name="matchTimeout" /> ma wartość ujemną, zerowego, lub większa od około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwóch sekund. Jeśli wyłączysz limity czasu, określając <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednakże należy wyłączyć limity czasu tylko w następujących warunkach: 
— W przypadku danych wejściowych, przetwarzane przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub zawiera tekst statyczny. Nie obejmuje to tekst, który znajduje się dynamicznie danych wprowadzonych przez użytkowników.  
  
— Jeśli wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że umożliwia ona efektywne obsługę, bez dopasowania i wkrótce.  
  
— W przypadku wzorca wyrażenia regularnego nie zawiera żadnych elementów języka, które są znane, aby spowodować, że nadmierne używanie wycofywania podczas przetwarzania niemal dopasowania.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Nawracanie</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Najlepsze praktyki dotyczące prawidłowych wyrażeń w .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do wyszukania pod kątem dopasowania.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="evaluator">Niestandardowe metody, która sprawdza każdego dopasowania i zwraca oryginalny ciąg dopasowane lub ciąg zastępujący.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> do wskazania, że metoda powinna nie przekraczają limit czasu.</param>
        <summary>W określonym ciągu wejściowym, zastępuje wszystkie podciągi, które pasują do podanego wyrażenia regularnego z ciągiem, który został zwrócony przez <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegować. Dodatkowe parametry, określ opcje modyfikujące operacji dopasowywania i interwał limitu czasu, jeśli nie zostanie znalezione dopasowanie.</summary>
        <returns>Nowy ciąg, który jest taka sama jak ciąg wejściowy, z tą różnicą, że ciąg zastępujący zajmuje miejsce każdego dopasowanego ciągu. Jeśli <paramref name="pattern" /> nie jest dopasowywany w bieżącym wystąpieniu, metoda zwraca bieżące wystąpienie bez zmian.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Metoda jest przydatna do zastępowania dopasowanie wyrażenia regularnego, jeśli spełniony jest dowolny z następujących warunków:  
  
-   Jeśli nie można łatwo określony ciąg zastępczy w przez wzorzec zamieniania wyrażenia regularnego.  
  
-   Jeśli ciąg zastępujący powstały na skutek niektóre przetwarzanie jest realizowane na dopasowany ciąg.  
  
-   Jeśli ciąg zastępujący powstały na skutek przetwarzania warunkowego.  
  
 Metoda jest równoważne z wywoływaniem <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metody i przekazanie każdego <xref:System.Text.RegularExpressions.Match> obiektu w zwróconym elemencie <xref:System.Text.RegularExpressions.MatchCollection> kolekcji `evaluator` delegować.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Parametrem jest delegat dla niestandardowej metody, który zdefiniujesz i które analizuje każdego dopasowania. Metoda niestandardowe musi mieć następujący podpis, aby dopasować <xref:System.Text.RegularExpressions.MatchEvaluator> delegować.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Niestandardowe metoda zwraca ciąg, który zastępuje dopasowanych danych wejściowych.  
  
 Jeśli określisz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> dla `options` parametru wyszukiwania dopasowania rozpoczyna się od końca ciągu wejściowego i przenosi lewej; w przeciwnym razie wyszukiwanie rozpoczyna się od początku ciągu wejściowego i przechodzi bezpośrednio.  
  
 `matchTimeout` Parametr określa, jak długo dopasowywanie do wzorców metody prób znalezienia dopasowania, przed upływem limitu czasu. Ustawienie interwału limitu czasu zapobiega wyrażeń regularnych, które są nadmiernie używać wycofywania pojawianiu się na "przestać odpowiadać podczas przetwarzania danych wejściowych zawiera dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli nie zostanie znalezione dopasowanie w tym przedziale czasu, metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie domyślną wartość limitu czasu, który jest zdefiniowany dla domeny aplikacji, w którym metoda jest wykonywana.  
  
 Ponieważ metoda ta zwraca `input` bez zmian, jeśli nie zostanie odnaleziony odpowiednik, możesz użyć <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda podejścia biznesowego uczyniło wszelkie wymiany do ciągu wejściowego.  
  
   
  
## Examples  
 Poniższy przykład używa wyrażeń regularnych do wyodrębniania poszczególnych wyrazów z ciągu, a następnie używa <xref:System.Text.RegularExpressions.MatchEvaluator> pełnomocnika do wywołania metody o nazwie `WordScramble` , zaszyfrowanie pojedynczych liter w wyrazie. Aby to zrobić, `WordScramble` metoda tworzy tablicę, która zawiera znaki w dopasowaniu. Tworzy również równoległe tablicy, która wypełnia go za pomocą losowych liczb zmiennoprzecinkowych. Tablice są posortowane według wywoływania <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metoda i posortowaną tablicę jest dostarczana jako argument do <xref:System.String> konstruktora klasy. Ten ciąg nowo utworzony jest następnie zwracany przez `WordScramble` metody. Definicję wzorca wyrażenia regularnego `\w+` dopasowuje jeden lub więcej znaków wyrazu; aparat wyrażeń regularnych będzie w dalszym ciągu dodawać znaki do dopasowania, aż do napotkania niebędący znakiem słowa, takie jak znak odstępu. Wywołanie <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> metoda zawiera <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opcję Tak, aby komentarz we wzorcu wyrażenia regularnego `\w+  # Matches all the characters in a word.` jest ignorowana przez aparat wyrażeń regularnych.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" />, lub <paramref name="evaluator" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  
  
—lub— 
 <paramref name="matchTimeout" /> ma wartość ujemną, zerowego, lub większa od około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwóch sekund. Jeśli wyłączysz limity czasu, określając <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednakże należy wyłączyć limity czasu tylko w następujących warunkach: 
— W przypadku danych wejściowych, przetwarzane przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub zawiera tekst statyczny. Nie obejmuje to tekst, który znajduje się dynamicznie danych wprowadzonych przez użytkowników.  
  
— Jeśli wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że umożliwia ona efektywne obsługę, bez dopasowania i wkrótce.  
  
— W przypadku wzorca wyrażenia regularnego nie zawiera żadnych elementów języka, które są znane, aby spowodować, że nadmierne używanie wycofywania podczas przetwarzania niemal dopasowania.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Zastępstwa</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Nawracanie</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Najlepsze praktyki dotyczące prawidłowych wyrażeń w .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wyrażenia regularnego przeszukuje od prawej do lewej.</summary>
        <value><see langword="true" /> Jeśli wyrażenia regularnego przeszukuje od prawej do lewej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> jest `true` Jeśli <xref:System.Text.RegularExpressions.Regex> wystąpienie utworzono z <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> opcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowane przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dzieli ciąg wejściowy na tabelę podciągów w pozycjach zdefiniowane przez dopasowanie wyrażenia regularnego.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciągu do podzielenia.</param>
        <summary>Dzieli ciąg wejściowy na tabelę podciągów w pozycjach zdefiniowane przez wzorzec wyrażenia regularnego określone w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metody, chyba że <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg na ogranicznik ustalany na podstawie wyrażenia regularnego zamiast z zestawu znaków. Ten ciąg jest dzielony na dowolną liczbę razy. Jeśli nie było ogranicznika zostanie znaleziony, wartość zwracana zawiera jeden element, którego wartością jest oryginalnego ciągu wejściowego.  
  
 Jeśli wiele dopasowań sąsiadują ze sobą, pusty ciąg jest wstawiany do tablicy. Na przykład ciąg jest na pojedynczy łącznik powoduje, że zwróconej tablicy uwzględnić pustego ciągu w miejscu, w którym zostaną znalezione dwóch sąsiadujących ze sobą łącznikach, co ilustruje poniższy kod.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Jeśli zostanie znalezione dopasowanie na początku lub końcu ciągu wejściowego, pusty ciąg jest dołączony na początku lub końcu zwróconej tablicy. W poniższym przykładzie użyto wzorca wyrażenia regularnego `\d+` do dzielenia ciągu wejściowego na znaki numeryczne. Ponieważ ciąg rozpoczyna się i kończy dopasowanie znaków numerycznych, wartość elementu imię i nazwisko zwróconej tablicy jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Jeśli przechwytywanie nawiasy są używane w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażenie wszystkie przechwycone, tekst jest uwzględniany w wynikowej tablicy ciągów. Na przykład możesz podzielić ciąg "plum gruszki" na łącznik umieszczone wewnątrz nawiasów przechwytywania, zwracana tablica zawiera element ciągu, który zawiera łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego zawiera wiele zestawów nawiasów przechwytywania, zachowania tej metody zależy od wersji programu .NET Framework. W .NET Framework 1.0 i 1.1 Jeśli nie zostanie znalezione dopasowanie w ciągu pierwszy zestaw nawiasów, przechwytywania przechwytywany tekst z dodatkowych nawiasów przechwytywania nie są objęte zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest także dodawane do zwróconej tablicy. Na przykład poniższy kod używa nawiasów przechwytywania dwa zestawy do wyodrębnienia elementom daty, łącznie z ogranicznikami datę z ciągu daty. Pierwszy zestaw nawiasów przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod jest kompilowany i działać w ramach programu .NET Framework 1.0 i 1.1, nie obejmuje znaków ukośnika. Jeśli jest skompilowany i działać w ramach programu .NET Framework 2.0 lub nowszej wersji, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Jeśli wyrażenie regularne może odnosić się pustym ciągiem, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> zostanie podzielona ciągu na tablicę ciągów pojedynczych znaków, ponieważ ogranicznik pusty ciąg znaków można znaleźć w każdej lokalizacji. Na przykład:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Należy pamiętać, że zwróconej tablicy również zawiera pusty ciąg na początku i końca tablicy.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji podziału przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do podzielenia.</param>
        <param name="count">Maksymalna liczba przypadków, gdy może wystąpić podziału.</param>
        <summary>Ciąg wejściowy dzieli dane określoną maksymalną liczbę razy do tablicy podciągów w pozycjach definicją wyrażeniem regularnym określonym w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%2A?displayProperty=nameWithType> metody, chyba że <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg na ogranicznik ustalany na podstawie wyrażenia regularnego zamiast z zestawu znaków. `count` Parametr określa maksymalną liczbę podciągów, do którego `input` może zostać podzielony ciąg; ostatni ciąg zawiera sięgnąć końca ciągu. Element `count` o wartości zero zapewnia domyślne zachowanie podział tyle razy, jak to możliwe.  
  
 Jeśli wiele dopasowań sąsiadują ze sobą, lub jeśli zostanie znalezione dopasowanie na początku lub końcu `input`, a liczba dopasowań jest co najmniej dwa mniej niż `count`, pusty ciąg jest wstawiany do tablicy. Oznacza to, puste ciągi, które wynikają z sąsiadujących dopasowań lub dopasowuje początek lub koniec ciągu wejściowego są liczone w określeniu, czy liczba dopasowane podciągi equals `count`. W poniższym przykładzie, wyrażenie regularne `/d+` jest używany do dzielenia ciągu wejściowego, który zawiera jeden lub więcej cyfr dziesiętnych na maksymalnie trzy podciągów. Ponieważ początku ciągu wejściowego jest zgodna z wzorcem wyrażenia regularnego, pierwszy element tablicy zawiera <xref:System.String.Empty?displayProperty=nameWithType>, drugi zawiera pierwszy zestaw znaków alfabetu w ciągu wejściowym, a trzeci w pozostałej części ciągu następujący po dopasowaniu trzeciego.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Jeśli nawiasów przechwytywania są używane w wyrażeniu regularnym, dowolny tekst przechwycony znajduje się w tablicy ciągów podziału. Jednak wszystkie elementy tablicy, które zawierają tekst przechwycony nie są liczone w określeniu, czy liczba dopasowań osiągnęła `count`. Na przykład dzieleniu ciągu "apple — morela plum gruszki banany", która znajduje się na maksymalnie cztery wyniki podciągów w 7 elementowej tablicy, jak poniższy kod przedstawia.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego zawiera wiele zestawów nawiasów przechwytywania, zachowania tej metody zależy od wersji programu .NET Framework. W .NET Framework 1.0 i 1.1 tylko przechwytywany tekst z pierwszy zestaw nawiasów przechwytywania znajduje się w zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony zostanie dodany do zwróconej tablicy. Jednak zwróconej tablicy elementów, które zawierają tekst przechwycony nie są liczone w określeniu, czy liczba dopasowane podciągi equals `count`. Na przykład w poniższym kodzie wyrażeń regularnych używa dwóch zestawów nawiasów przechwytywania można wyodrębnić elementom daty z ciągu daty. Pierwszy zestaw nawiasów przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Wywołanie <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> metody określa więcej niż dwa elementy w zwróconej tablicy. Jeśli przykładowy kod jest kompilowany i działać w ramach programu .NET Framework 1.0 i 1.1, metoda zwraca tablicą dwuelementową ciągów. Jeśli jest skompilowany i działać w ramach programu .NET Framework 2.0 lub nowszej wersji, metoda zwraca tablicą ciągów trzech elementu.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Jeśli wyrażenie regularne może odnosić się pustym ciągiem, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> zostanie podzielona ciągu na tablicę ciągów pojedynczych znaków, ponieważ ogranicznik pusty ciąg znaków można znaleźć w każdej lokalizacji. Poniższy przykład dzieli na ciąg "znaki", tak jak jak istnienie wielu elementów w ciągu wejściowym. Ponieważ pusty ciąg pasuje do początku ciągu wejściowego, pusty ciąg jest wstawiany na początku zwróconej tablicy. To powoduje, że element dziesiąty składającej się ze dwa znaki końca ciągu wejściowego.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji podziału przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciągu do podzielenia.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <summary>Dzieli ciąg wejściowy na tabelę podciągów w pozycjach zdefiniowane przez wzorzec wyrażenia regularnego.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%2A?displayProperty=nameWithType> metody, chyba że <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg na ogranicznik ustalany na podstawie wyrażenia regularnego zamiast z zestawu znaków. `input` Ciąg jest dzielony na wiele razy, ile to możliwe. Jeśli `pattern` nie zostanie znaleziony w `input` ciąg, wartość zwracana zawiera jeden element, którego wartość jest oryginalne `input` ciągu.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Skompilowane wyrażenia regularne użyte w wywołaniach statyczną <xref:System.Text.RegularExpressions.Regex.Split%2A> metody są automatycznie buforowane. Aby zarządzać okresem istnienia skompilowanych wyrażeń regularnych, samodzielnie, należy użyć wystąpienia <xref:System.Text.RegularExpressions.Regex.Split%2A> metody.  
  
 Jeśli wiele dopasowań sąsiadują ze sobą, pusty ciąg jest wstawiany do tablicy. Na przykład ciąg jest na pojedynczy łącznik powoduje, że zwróconej tablicy uwzględnić pustego ciągu w miejscu, w którym zostaną znalezione dwóch sąsiadujących ze sobą łącznikach, co ilustruje poniższy kod.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Jeśli zostanie znalezione dopasowanie na początku lub końcu ciągu wejściowego, pusty ciąg jest dołączony na początku lub końcu zwróconej tablicy. W poniższym przykładzie użyto wzorca wyrażenia regularnego `\d+` do dzielenia ciągu wejściowego na znaki numeryczne. Ponieważ ciąg rozpoczyna się i kończy dopasowanie znaków numerycznych, wartość elementu imię i nazwisko zwróconej tablicy jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Jeśli przechwytywanie nawiasy są używane w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażenie wszystkie przechwycone, tekst jest uwzględniany w wynikowej tablicy ciągów. Na przykład możesz podzielić ciąg "plum gruszki" na łącznik umieszczone wewnątrz nawiasów przechwytywania, zwracana tablica zawiera element ciągu, który zawiera łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego zawiera wiele zestawów nawiasów przechwytywania, zachowania tej metody zależy od wersji programu .NET Framework. W .NET Framework 1.0 i 1.1 Jeśli nie zostanie znalezione dopasowanie w ciągu pierwszy zestaw nawiasów, przechwytywania przechwytywany tekst z dodatkowych nawiasów przechwytywania nie są objęte zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest także dodawane do zwróconej tablicy. Na przykład poniższy kod używa nawiasów przechwytywania dwa zestawy do wyodrębnienia elementom daty, łącznie z ogranicznikami datę z ciągu daty. Pierwszy zestaw nawiasów przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod jest kompilowany i działać w ramach programu .NET Framework 1.0 i 1.1, nie obejmuje znaków ukośnika. Jeśli jest skompilowany i działać w ramach programu .NET Framework 2.0 lub nowszej wersji, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Jeśli wyrażenie regularne może odnosić się pustym ciągiem, <xref:System.Text.RegularExpressions.Regex.Split%2A> zostanie podzielona ciągu na tablicę ciągów pojedynczych znaków, ponieważ ogranicznik pusty ciąg znaków można znaleźć w każdej lokalizacji. Na przykład:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Należy pamiętać, że zwróconej tablicy również zawiera pusty ciąg na początku i końca tablicy.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji podziału przekroczy limit czasu określony dla domeny aplikacji, w którym metoda jest wywoływana. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym metoda jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecana metoda statyczna do dzielenia tekstu dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do podzielenia.</param>
        <param name="count">Maksymalna liczba przypadków, gdy może wystąpić podziału.</param>
        <param name="startat">Pozycja znaku w ciągu wejściowym, gdy rozpocznie się wyszukiwanie.</param>
        <summary>Ciąg wejściowy dzieli dane określoną maksymalną liczbę razy do tablicy podciągów w pozycjach definicją wyrażeniem regularnym określonym w <see cref="T:System.Text.RegularExpressions.Regex" /> konstruktora. Wyszukiwanie wzorca wyrażenia regularnego rozpoczyna się od określonej pozycji znaku w ciągu wejściowym.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%2A?displayProperty=nameWithType> metody, chyba że <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg na ogranicznik ustalany na podstawie wyrażenia regularnego zamiast z zestawu znaków. `count` Parametr określa maksymalną liczbę podciągów, do którego `input` ciąg jest dzielony; ostatni ciąg zawiera sięgnąć końca ciągu. Element `count` o wartości zero zapewnia domyślne zachowanie podział tyle razy, jak to możliwe. `startat` Parametr określa punkt, od której rozpoczyna się wyszukiwania dla pierwszego ogranicznika (może to służyć do pomijania wiodących biały znak).  
  
 Jeśli nie znaleziono żadnych dopasowań z `count`+ 1 pozycji w ciągu, metoda zwraca jeden elementowej tablicy, która zawiera `input` ciągu. Jeśli jeden lub więcej dopasowań zostaną znalezione, pierwszy element zwróconej tablicy zawiera pierwszą część ciągu z pierwszym znakiem maksymalnie jeden znak przed dopasowaniem.  
  
 Jeśli wiele dopasowań sąsiadują ze sobą, a liczba dopasowań jest co najmniej dwa mniej niż `count`, pusty ciąg jest wstawiany do tablicy. Podobnie jeśli zostanie znalezione dopasowanie na `startat`pierwszego elementu obiektu zwróconej tablicy jest pusty ciąg, który jest pierwszy znak w ciągu. Oznacza to, puste ciągi, które wynikają z sąsiadujących dopasowania są uwzględniane w określająca, czy liczba dopasowane podciągi equals `count`. W poniższym przykładzie, wyrażenie regularne `\d+` jest używana do znajdowania pozycji początkowej pierwszego podciągu cyfr w ciągu, a następnie podzielenie ciągu maksymalnie trzy razy stawki rozpoczynają się od tej pozycji. Ponieważ wzorzec wyrażenia regularnego pasuje do początku ciągu wejściowego, tablica zwracanego ciągu składa się z pusty ciąg, ciąg alfabetyczne pięcioznakowe i końca ciągu  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Jeśli nawiasów przechwytywania są używane w wyrażeniu regularnym, dowolny tekst przechwycony znajduje się w tablicy ciągów podziału. Jednak wszystkie elementy tablicy, które zawierają tekst przechwycony nie są liczone w określeniu, czy liczba dopasowań osiągnęła `count`. Na przykład dzieleniu ciągu ""apple-apricot-plum-pear-pomegranate-pineapple-peach"na maksymalnie cztery podciągi rozpoczynający się od znaku 15 w wynikach ciągu w 7 elementowej tablicy, co ilustruje poniższy kod.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego zawiera wiele zestawów nawiasów przechwytywania, zachowania tej metody zależy od wersji programu .NET Framework. W programie .NET Framework 1.0 i 1.1 Jeśli nie zostanie znalezione dopasowanie w ciągu pierwszy zestaw nawiasów, przechwytywania przechwytywany tekst z dodatkowych nawiasów przechwytywania nie są objęte zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest także dodawane do zwróconej tablicy. Na przykład poniższy kod używa nawiasów przechwytywania dwa zestawy można wyodrębnić poszczególne wyrazy w ciągu. Pierwszy zestaw nawiasów przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje kreska pionowa. Jeśli przykładowy kod jest kompilowany i działać w ramach programu .NET Framework 1.0 i 1.1, nie obejmuje pionowy pasek znaków. Jeśli jest skompilowany i działać w ramach programu .NET Framework 2.0 lub nowszej wersji, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Jeśli wyrażenie regularne może odnosić się pustym ciągiem, <xref:System.Text.RegularExpressions.Regex.Split%2A> zostanie podzielona ciągu na tablicę ciągów pojedynczych znaków, ponieważ ogranicznik pusty ciąg znaków można znaleźć w każdej lokalizacji. Poniższy przykład dzieli ciąg "znaki" na tyle elementów, ponieważ ciąg wejściowy zawiera, począwszy od znaku "". Ponieważ pusty ciąg pasuje do końca ciągu wejściowego, pusty ciąg jest wstawiany na końcu zwróconej tablicy.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji podziału przekroczy limit czasu określony przez <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> konstruktora. Jeśli nie ustawisz interwał limitu czasu podczas wywoływania konstruktora, wyjątek jest zgłaszany, jeśli operacja przekroczy dowolną wartość limitu czasu ustanowione dla domeny aplikacji, w którym <xref:System.Text.RegularExpressions.Regex> obiekt zostanie utworzony. Jeśli limit czasu nie jest zdefiniowany w <xref:System.Text.RegularExpressions.Regex> wywołania konstruktora lub we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> jest mniejsza od zera lub większa niż długość <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Ciągu do podzielenia.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <summary>Dzieli ciąg wejściowy na tabelę podciągów w pozycjach zdefiniowane przez wzorzec określonemu wyrażeniu regularnemu. Określone opcje modyfikować operacji dopasowywania.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metody, chyba że <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg na ogranicznik ustalany na podstawie wyrażenia regularnego zamiast z zestawu znaków. Ten ciąg jest dzielony na dowolną liczbę razy. Jeśli nie było ogranicznika zostanie znaleziony, wartość zwracana zawiera jeden element, którego wartość jest oryginalne `input` ciągu.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Skompilowane wyrażenia regularne użyte w wywołaniach statyczną <xref:System.Text.RegularExpressions.Regex.Split%2A> metody są automatycznie buforowane. Aby zarządzać okresem istnienia skompilowanych wyrażeń regularnych, samodzielnie, należy użyć wystąpienia <xref:System.Text.RegularExpressions.Regex.Split%2A> metody.  
  
 Jeśli wiele dopasowań sąsiadują ze sobą, pusty ciąg jest wstawiany do tablicy. Na przykład ciąg jest na pojedynczy łącznik powoduje, że zwróconej tablicy dołączyć ciąg pusty w miejscu, w którym znajdują się dwóch sąsiadujących ze sobą łącznikach.  
  
 Jeśli zostanie znalezione dopasowanie na początku lub końcu ciągu wejściowego, pusty ciąg jest dołączony na początku lub końcu zwróconej tablicy. W poniższym przykładzie użyto wzorca wyrażenia regularnego `[a-z]+` do dzielenia ciągu wejściowego na dowolny znaku alfabetyczny wielkimi lub małymi literami. Ponieważ ciąg rozpoczyna się i kończy dopasowanie znaki alfabetyczne, wartość elementu imię i nazwisko zwróconej tablicy jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Jeśli przechwytywanie nawiasy są używane w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażenie wszystkie przechwycone, tekst jest uwzględniany w wynikowej tablicy ciągów. Na przykład możesz podzielić ciąg "plum gruszki" na łącznik umieszczone wewnątrz nawiasów przechwytywania, zwracana tablica zawiera element ciągu, który zawiera łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego zawiera wiele zestawów nawiasów przechwytywania, zachowania tej metody zależy od wersji programu .NET Framework. W .NET Framework 1.0 i 1.1 Jeśli nie zostanie znalezione dopasowanie w ciągu pierwszy zestaw nawiasów, przechwytywania przechwytywany tekst z dodatkowych nawiasów przechwytywania nie są objęte zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest także dodawane do zwróconej tablicy. Na przykład poniższy kod używa nawiasów przechwytywania dwa zestawy do wyodrębnienia elementom daty, łącznie z ogranicznikami datę z ciągu daty. Pierwszy zestaw nawiasów przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod jest kompilowany i działać w ramach programu .NET Framework 1.0 i 1.1, nie obejmuje znaków ukośnika. Jeśli jest skompilowany i działać w ramach programu .NET Framework 2.0 lub nowszej wersji, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Jeśli wyrażenie regularne może odnosić się pustym ciągiem, <xref:System.Text.RegularExpressions.Regex.Split%2A> zostanie podzielona ciągu na tablicę ciągów pojedynczych znaków, ponieważ ogranicznik pusty ciąg znaków można znaleźć w każdej lokalizacji.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Wyjątek jest generowany, jeżeli czas wykonania operacji podziału przekroczy limit czasu określony dla domeny aplikacji, w którym metoda jest wywoływana. Jeśli limit czasu nie jest zdefiniowany we właściwościach domeny aplikacji, czy wartość limitu czasu jest <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Ta metoda upłynie limit czasu po upływie interwału, który jest równa wartości limitu czasu domyślnej domeny aplikacji, w którym metoda jest wywoływana. Jeśli nie określono wartość limitu czasu dla domeny aplikacji, a wartość <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia z przekroczeniem limitu czasu, metoda jest używana. Zalecana metoda statyczna do dzielenia tekstu dopasowania do wzorca <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, która pozwala ustawić interwał limitu czasu.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Ciągu do podzielenia.</param>
        <param name="pattern">Wzorzec wyrażenia regularnego do dopasowania.</param>
        <param name="options">Bitowa kombinacja wartości wyliczenia, które udostępniają opcje do dopasowania.</param>
        <param name="matchTimeout">Interwał limitu czasu lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> do wskazania, że metoda powinna nie przekraczają limit czasu.</param>
        <summary>Dzieli ciąg wejściowy na tabelę podciągów w pozycjach zdefiniowane przez wzorzec określonemu wyrażeniu regularnemu. Dodatkowe parametry, określ opcje modyfikujące operacji dopasowywania i interwał limitu czasu, jeśli nie zostanie znalezione dopasowanie.</summary>
        <returns>Tablica ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Metody są podobne do <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metody, chyba że <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> dzieli ciąg na ogranicznik ustalany na podstawie wyrażenia regularnego zamiast z zestawu znaków. Ten ciąg jest dzielony na dowolną liczbę razy. Jeśli nie było ogranicznika zostanie znaleziony, wartość zwracana zawiera jeden element, którego wartość jest oryginalne `input` ciągu.  
  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Skompilowane wyrażenia regularne użyte w wywołaniach statyczną <xref:System.Text.RegularExpressions.Regex.Split%2A> metody są automatycznie buforowane. Aby zarządzać okresem istnienia skompilowanych wyrażeń regularnych, samodzielnie, należy użyć wystąpienia <xref:System.Text.RegularExpressions.Regex.Split%2A> metody.  
  
 Jeśli wiele dopasowań sąsiadują ze sobą, pusty ciąg jest wstawiany do tablicy. Na przykład ciąg jest na pojedynczy łącznik powoduje, że zwróconej tablicy dołączyć ciąg pusty w miejscu, w którym znajdują się dwóch sąsiadujących ze sobą łącznikach.  
  
 Jeśli zostanie znalezione dopasowanie na początku lub końcu ciągu wejściowego, pusty ciąg jest dołączony na początku lub końcu zwróconej tablicy. W poniższym przykładzie użyto wzorca wyrażenia regularnego `[a-z]+` do dzielenia ciągu wejściowego na dowolny znaku alfabetyczny wielkimi lub małymi literami. Ponieważ ciąg rozpoczyna się i kończy dopasowanie znaki alfabetyczne, wartość elementu imię i nazwisko zwróconej tablicy jest <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Jeśli przechwytywanie nawiasy są używane w <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> wyrażenie wszystkie przechwycone, tekst jest uwzględniany w wynikowej tablicy ciągów. Na przykład możesz podzielić ciąg "plum gruszki" na łącznik umieszczone wewnątrz nawiasów przechwytywania, zwracana tablica zawiera element ciągu, który zawiera łącznik.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Jednak jeśli wzorzec wyrażenia regularnego zawiera wiele zestawów nawiasów przechwytywania, zachowania tej metody zależy od wersji programu .NET Framework. W .NET Framework 1.0 i 1.1 Jeśli nie zostanie znalezione dopasowanie w ciągu pierwszy zestaw nawiasów, przechwytywania przechwytywany tekst z dodatkowych nawiasów przechwytywania nie są objęte zwróconej tablicy. Począwszy od programu .NET Framework 2.0, cały tekst przechwycony jest także dodawane do zwróconej tablicy. Na przykład poniższy kod używa nawiasów przechwytywania dwa zestawy do wyodrębnienia elementom daty, łącznie z ogranicznikami datę z ciągu daty. Pierwszy zestaw nawiasów przechwytywania przechwytuje łącznik, a drugi zestaw przechwytuje ukośnik. Jeśli przykładowy kod jest kompilowany i działać w ramach programu .NET Framework 1.0 i 1.1, nie obejmuje znaków ukośnika. Jeśli jest skompilowany i działać w ramach programu .NET Framework 2.0 lub nowszej wersji, zawiera je.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Jeśli wyrażenie regularne może odnosić się pustym ciągiem, <xref:System.Text.RegularExpressions.Regex.Split%2A> zostanie podzielona ciągu na tablicę ciągów pojedynczych znaków, ponieważ ogranicznik pusty ciąg znaków można znaleźć w każdej lokalizacji.  
  
 `matchTimeout` Parametr określa, jak długo dopasowywanie do wzorców metody prób znalezienia dopasowania, przed upływem limitu czasu. Ustawienie interwału limitu czasu zapobiega wyrażeń regularnych, które są nadmiernie używać wycofywania pojawianiu się może przestać odpowiadać podczas przetwarzania danych wejściowych zawiera dopasowania. Aby uzyskać więcej informacji, zobacz [najlepsze rozwiązania dotyczące wyrażeń regularnych](~/docs/standard/base-types/best-practices.md) i [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Jeśli nie zostanie znalezione dopasowanie w tym przedziale czasu, metoda zgłasza <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wyjątku. `matchTimeout` zastępuje wszelkie domyślną wartość limitu czasu, który jest zdefiniowany dla domeny aplikacji, w którym metoda jest wykonywana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wystąpił błąd analizowania wyrażenia regularnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> lub <paramref name="pattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> nie jest prawidłową kombinację bitowe <see cref="T:System.Text.RegularExpressions.RegexOptions" /> wartości.  
  
—lub— 
 <paramref name="matchTimeout" /> ma wartość ujemną, zerowego, lub większa od około 24 dni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Upłynął limit czasu. Aby uzyskać więcej informacji na temat limitów czasu Zobacz sekcję Uwagi.</exception>
        <block subset="none" type="usage"><para>Firma Microsoft zaleca, aby ustawić <paramref name="matchTimeout" /> parametru do odpowiedniej wartości, takich jak dwóch sekund. Jeśli wyłączysz limity czasu, określając <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, aparat wyrażeń regularnych zapewnia nieco większą wydajność. Jednakże należy wyłączyć limity czasu tylko w następujących warunkach: 
— W przypadku danych wejściowych, przetwarzane przez wyrażenie regularne jest pochodną znanego i zaufanego źródła lub zawiera tekst statyczny. Nie obejmuje to tekst, który znajduje się dynamicznie danych wprowadzonych przez użytkowników.  
  
— Jeśli wzorzec wyrażenia regularnego dokładnie przetestowano upewnij się, że umożliwia ona efektywne obsługę, bez dopasowania i wkrótce.  
  
— W przypadku wzorca wyrażenia regularnego nie zawiera żadnych elementów języka, które są znane, aby spowodować, że nadmierne używanie wycofywania podczas przetwarzania niemal dopasowania.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="si">Obiekt do wypełnienia informacjami o serializacji.</param>
        <param name="context">Miejsce do przechowywania i pobierania serializowane dane. Ten parametr jest zarezerwowana do użytku w przyszłości.</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu z danymi, które są niezbędne do deserializacji bieżącego <see cref="T:System.Text.RegularExpressions.Regex" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wzorzec wyrażenia regularnego, która została przekazana do <see langword="Regex" /> konstruktora.</summary>
        <returns><paramref name="pattern" /> Parametru, która została przekazana do <see langword="Regex" /> konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Parametr składa się z elementy języka wyrażeń regularnych, które opisują symbolicznie ciąg do dopasowania. Aby uzyskać więcej informacji na temat wyrażeń regularnych, zobacz [wyrażeń regularnych programu .NET Framework](~/docs/standard/base-types/regular-expressions.md) i [język wyrażeń regularnych — podręczny wykaz](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> jest klasą bazową wyrażeń regularnych, utworzone przez <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody. Te skompilowanych wyrażeń regularnych, użyj <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> implementacji klasy podstawowej. Jeśli jest wywoływany z klasy pochodnej, <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> metoda zwraca ciąg, który został przekazany do <paramref name="pattern" /> parametru <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> konstruktora klasy, który był używany do definiowania wyrażeń regularnych.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Wejściowy ciąg zawierający tekst do przekształcenia.</param>
        <summary>Konwertuje wszystkie znaki o zmienionym znaczeniu w ciągu wejściowym.</summary>
        <returns>Ciąg znaków za pomocą wszystkie znaki ucieczki przekonwertowany do postaci o niezmienionym znaczeniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Metoda wykonuje jedną z następujących dwóch przekształcenia:  
  
-   Odwraca ono przekształcenie wykonywane przez <xref:System.Text.RegularExpressions.Regex.Escape%2A> metody, usuwając znaku ucieczki ("\\") od każdego znaku ucieczki przez metodę. Obejmują one \\, *, +,?, &#124;, {, [, (,), ^, $,., # i znaki odstępu. Ponadto <xref:System.Text.RegularExpressions.Regex.Unescape%2A> metoda unescapes zamykającego nawiasu (]) i zamykający nawias klamrowy (}) znaków.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Nie można wycofać ciągiem o zmienionym znaczeniu doskonale ponieważ nie można wywnioskować, dokładnie zostały zmienione znaczenie znaków,  
  
-   Zastępuje wartości szesnastkowych w literałach ciąg verbatim rzeczywiste drukowalnych znaków. Na przykład zastępuje @"\x07" za pomocą "\a", lub @"\x0A" za pomocą "\n". Konwertuje znaki ucieczki obsługiwane, takich jak \a \b, \e, \n, \r, \f, \t, \v i znaki alfanumeryczne.
  
 Jeśli <xref:System.Text.RegularExpressions.Regex.Unescape%2A> metoda napotka inne sekwencje unikowe, które nie mogą być konwertowane, takich jak \w lub \s wyniku weryfikacji zgłasza wyjątek <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" /> obejmuje Nierozpoznana sekwencja ucieczki.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Język wyrażeń regularnych — podręczny wykaz</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowane przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.Text.RegularExpressions.Regex.Options" /> właściwość zawiera <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używane przez <see cref="T:System.Text.RegularExpressions.Regex" /> generowane przez obiekt <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> metody.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.Text.RegularExpressions.Regex.Options" /> właściwość zawiera <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> opcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Interwał limitu czasu, aby sprawdzić.</param>
        <summary>Sprawdza, czy interwał limitu czasu znajduje się w dopuszczalnym zakresie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
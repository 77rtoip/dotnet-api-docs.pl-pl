<Type Name="RegexCompilationInfo" FullName="System.Text.RegularExpressions.RegexCompilationInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="66cb2b80061414dbb96c693f1c9f21f27f84bf11" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69230862" /></Metadata><TypeSignature Language="C#" Value="public class RegexCompilationInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit RegexCompilationInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.RegexCompilationInfo" />
  <TypeSignature Language="VB.NET" Value="Public Class RegexCompilationInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegexCompilationInfo" />
  <TypeSignature Language="F#" Value="type RegexCompilationInfo = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera informacje na temat wyrażenia regularnego, które jest używane do kompilowania wyrażenia regularnego do zestawu autonomicznego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektów jest przenoszona <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> do metody w celu podania informacji o każdym wyrażeniu regularnym do uwzględnienia w zestawie. Każde skompilowane wyrażenie regularne zawarte w zestawie jest reprezentowane jako Klasa pochodna <xref:System.Text.RegularExpressions.Regex>. Właściwości <xref:System.Text.RegularExpressions.RegexCompilationInfo> typu definiują nazwę klasy wyrażenia regularnego, jego w pełni kwalifikowaną nazwę (czyli jego przestrzeń nazw i nazwę typu), jego wzorzec wyrażenia regularnego, wszelkie dodatkowe opcje (na przykład czy wyrażenie regularne jest bez uwzględniania wielkości liter i interwał czasu, który określa, jak długo aparat wyrażeń regularnych ma wyszukiwać dopasowanie.  
  
 Można utworzyć wystąpienie <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu przez wywołanie jego przeciążonego konstruktora klasy.  
  
 ]]></format>
    </remarks>
    <altmember cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />
    <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilacja i ponowne użycie</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> klasy.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegexCompilationInfo (string pattern, System.Text.RegularExpressions.RegexOptions options, string name, string fullnamespace, bool ispublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, string name, string fullnamespace, bool ispublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.RegexCompilationInfo.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, name As String, fullnamespace As String, ispublic As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegexCompilationInfo(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, System::String ^ name, System::String ^ fullnamespace, bool ispublic);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.RegexCompilationInfo : string * System.Text.RegularExpressions.RegexOptions * string * string * bool -&gt; System.Text.RegularExpressions.RegexCompilationInfo" Usage="new System.Text.RegularExpressions.RegexCompilationInfo (pattern, options, name, fullnamespace, ispublic)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fullnamespace" Type="System.String" />
        <Parameter Name="ispublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="pattern">Wyrażenie regularne do skompilowania.</param>
        <param name="options">Opcje wyrażeń regularnych, które mają być używane podczas kompilowania wyrażenia regularnego.</param>
        <param name="name">Nazwa typu, który reprezentuje skompilowane wyrażenie regularne.</param>
        <param name="fullnamespace">Przestrzeń nazw, do której należy nowy typ.</param>
        <param name="ispublic"><see langword="true" />Aby jawnie wyświetlić skompilowane wyrażenie regularne; w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> klasy zawierającej informacje o wyrażeniu regularnym do uwzględnienia w zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy parametr <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> konstruktora bezpośrednio odpowiada właściwości <xref:System.Text.RegularExpressions.RegexCompilationInfo> klasy. Ponieważ wszystkie właściwości są odczytywane i zapisywane, ich wartości można także przypisać bezpośrednio.  
  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Metoda generuje zestaw, który zawiera skompilowane wyrażenia regularne. W związku z tym nie należy <xref:System.Text.RegularExpressions.RegexOptions.Compiled> podawać jako jednej z `options`wartości.  
  
 Jeśli `ispublic` ma `true`wartość, skompilowana Klasa wyrażenia regularnego otrzymuje dostępność publiczną. Oznacza to, że można utworzyć wystąpienie z kodu, który jest wykonywany w dowolnym zestawie. Jeśli `ispublic` `internal` ma `false`wartość, zostanie określona skompilowana Klasa wyrażenia regularnego ( C#w) `Friend` lub (w Visual Basic) ułatwienia dostępu. Oznacza to, że można utworzyć wystąpienie tylko z kodu, który jest wykonywany w tym samym zestawie, co Klasa wyrażenia regularnego.  
  
   
  
## Examples  
 Poniższy przykład tworzy i używa skompilowanego wyrażenia regularnego w dwóch krokach.  
  
 W pierwszym kroku Skompiluj i wykonaj Poniższy przykład kodu. <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%2A> Konstruktor w przykładowym kodzie definiuje skompilowane wyrażenie regularne. Wynikiem wykonywania kodu jest zestaw o nazwie FishRegex. dll, który zawiera skompilowany typ wyrażenia regularnego o nazwie `FishRegex`.  
  
 [!code-csharp[sys.txt.rgxCompInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.rgxCompInfo/cs/genFishRegex.cs#1)]
 [!code-vb[sys.txt.rgxCompInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.rgxCompInfo/vb/genFishRegex.vb#1)]  
  
 W drugim kroku Skompiluj Poniższy przykład kodu przy użyciu odwołania do FishRegex. dll, a następnie uruchom utworzony plik wykonywalny. Plik wykonywalny jest zgodny z ciągiem docelowym przy użyciu `FishRegex` typu i wyświetla pozycję dopasowanie, grupowanie, Przechwyć grupę i indeks dopasowań w ciągu docelowym.  
  
 [!code-csharp[sys.txt.rgxCompInfo#2](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.rgxCompInfo/cs/useFishRegex.cs#2)]
 [!code-vb[sys.txt.rgxCompInfo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.rgxCompInfo/vb/useFishRegex.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="fullnamespace" />jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Ten konstruktor tworzy skompilowane wyrażenie regularne, które używa domyślnej wartości limitu czasu domeny aplikacji, w której została utworzona. Jeśli wartość limitu czasu jest zdefiniowana dla domeny aplikacji, skompilowane wyrażenie regularne używa wartości <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, co uniemożliwia wykonanie operacji dopasowania do wzorca przed upływem limitu czasu. Zalecany Konstruktor służący do tworzenia skompilowanego wyrażenia regularnego to <see cref="M:System.Text.RegularExpressions.RegexCompilationInfo.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.String,System.String,System.Boolean,System.TimeSpan)" />, co umożliwia ustawienie interwału limitu czasu.</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegexCompilationInfo (string pattern, System.Text.RegularExpressions.RegexOptions options, string name, string fullnamespace, bool ispublic, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, string name, string fullnamespace, bool ispublic, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.RegexCompilationInfo.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.String,System.String,System.Boolean,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, name As String, fullnamespace As String, ispublic As Boolean, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegexCompilationInfo(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, System::String ^ name, System::String ^ fullnamespace, bool ispublic, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.RegexCompilationInfo : string * System.Text.RegularExpressions.RegexOptions * string * string * bool * TimeSpan -&gt; System.Text.RegularExpressions.RegexCompilationInfo" Usage="new System.Text.RegularExpressions.RegexCompilationInfo (pattern, options, name, fullnamespace, ispublic, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fullnamespace" Type="System.String" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ispublic" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">Wyrażenie regularne do skompilowania.</param>
        <param name="options">Opcje wyrażeń regularnych, które mają być używane podczas kompilowania wyrażenia regularnego.</param>
        <param name="name">Nazwa typu, który reprezentuje skompilowane wyrażenie regularne.</param>
        <param name="fullnamespace">Przestrzeń nazw, do której należy nowy typ.</param>
        <param name="ispublic"><see langword="true" />Aby jawnie wyświetlić skompilowane wyrażenie regularne; w przeciwnym razie. <see langword="false" /></param>
        <param name="matchTimeout">Domyślny interwał limitu czasu dla wyrażenia regularnego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> klasy zawierającej informacje o wyrażeniu regularnym z określoną wartością limitu czasu, która ma zostać uwzględniona w zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy parametr <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> konstruktora bezpośrednio odpowiada właściwości <xref:System.Text.RegularExpressions.RegexCompilationInfo> klasy. Ponieważ wszystkie właściwości są odczytywane i zapisywane, ich wartości można także przypisać bezpośrednio.  
  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Metoda generuje zestaw, który zawiera skompilowane wyrażenia regularne. W związku z tym nie należy <xref:System.Text.RegularExpressions.RegexOptions.Compiled> podawać jako jednej z `options`wartości.  
  
 Jeśli `ispublic` ma `true`wartość, skompilowana Klasa wyrażenia regularnego otrzymuje dostępność publiczną. Oznacza to, że można utworzyć wystąpienie z kodu, który jest wykonywany w dowolnym zestawie. Jeśli `ispublic` `internal` ma `false`wartość, zostanie określona skompilowana Klasa wyrażenia regularnego ( C#w) `Friend` lub (w Visual Basic) ułatwienia dostępu. Oznacza to, że można utworzyć wystąpienie tylko z kodu, który jest wykonywany w tym samym zestawie, co Klasa wyrażenia regularnego.  
  
 `matchTimeout` Parametr definiuje domyślny interwał limitu czasu dla skompilowanego wyrażenia regularnego. Ta wartość reprezentuje przybliżoną ilość czasu, przez który skompilowany obiekt wyrażenia regularnego będzie wykonywał pojedynczą operację dopasowywania, zanim operacja przekroczy limit czasu, a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> aparat wyrażeń regularnych zgłosi wyjątek podczas kolejnego sprawdzania czasu . Aby uzyskać dodatkowe informacje na temat wartości limitu czasu, zobacz <xref:System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout%2A> właściwość.  
  
> [!IMPORTANT]
>  Zalecamy, aby zawsze ustawić domyślną wartość limitu czasu dla skompilowanego wyrażenia regularnego. Konsumenci biblioteki wyrażeń regularnych mogą przesłonić tę wartość limitu czasu, przekazując <xref:System.TimeSpan> wartość reprezentującą nowy interwał limitu czasu do tego przeciążenia konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano pojedyncze skompilowane wyrażenie regularne `DuplicateChars` o nazwie, które identyfikuje dwa lub więcej wystąpień tego samego znaku w ciągu wejściowym. Skompilowane wyrażenie regularne ma domyślny limit czasu wynoszący 2 sekundy. Podczas wykonywania przykładu tworzy się bibliotekę klas o nazwie RegexLib. dll, która zawiera skompilowane wyrażenie regularne.  
  
 [!code-csharp[System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regexcompilationinfo.matchtimeout/cs/example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regexcompilationinfo.matchtimeout/vb/example1.vb#1)]  
  
 Wzorzec `(\w)\1+` wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(\w)`|Dopasowuje dowolny znak słowa i przypisuje go do pierwszej grupy przechwytywania.|  
|`\1+`|Dopasowuje jedno lub więcej wystąpień wartości pierwszej przechwyconej grupy.|  
  
 W poniższym przykładzie użyto `DuplicatedChars` wyrażenia regularnego do identyfikowania zduplikowanych znaków w tablicy ciągów. Gdy wywołuje `DuplicatedChars` konstruktora, zmienia interwał limitu czasu na 5 sekund.  
  
 [!code-csharp[System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regexcompilationinfo.matchtimeout/cs/example1a.cs#2)]
 [!code-vb[System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regexcompilationinfo.matchtimeout/vb/example1a.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />jest <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="fullnamespace" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="matchTimeout" />jest ujemna, równa zero lub większa niż około 24 dni.</exception>
        <altmember cref="P:System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.RegexCompilationInfo.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool with get, set" Usage="System.Text.RegularExpressions.RegexCompilationInfo.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy skompilowane wyrażenie regularne ma widoczność publiczną.</summary>
        <value><see langword="true" />Jeśli wyrażenie regularne ma widoczność publiczną; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość to `false`, Klasa wyrażenia regularnego zdefiniowana przez bieżące wystąpienie może być tworzona tylko przez kod, który jest wykonywany w zestawie, który zawiera klasę. <xref:System.Text.RegularExpressions.RegexCompilationInfo.IsPublic%2A> Jednak ponieważ <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> Metoda generuje zestaw, który zawiera tylko skompilowane wyrażenia regularne i nie zezwala na dodanie dodatkowego kodu, zazwyczaj nie ma powodu przypisania tej właściwości `false`wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan with get, set" Usage="System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślny interwał limitu czasu dla wyrażenia regularnego.</summary>
        <value>Domyślny maksymalny przedział czasu, który może upłynąć w operacji dopasowania do wzorca przed <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> zgłoszeniem lub <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> w przypadku wyłączenia limitów czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout%2A> Właściwość definiuje domyślny interwał limitu czasu dla skompilowanego wyrażenia regularnego. Ta wartość reprezentuje przybliżoną ilość czasu, przez który skompilowane wyrażenie regularne wykona jedną operację dopasowywania, zanim operacja przekroczy limit czasu, a aparat wyrażeń <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> regularnych zgłosi wyjątek podczas kolejnego sprawdzania czasu.  
  
> [!IMPORTANT]
>  Zalecamy, aby zawsze ustawić domyślną wartość limitu czasu dla skompilowanego wyrażenia regularnego. Konsumenci biblioteki wyrażeń regularnych mogą przesłonić tę wartość limitu czasu, przekazując <xref:System.TimeSpan> wartość reprezentującą nowy interwał limitu czasu do konstruktora klasy skompilowanego wyrażenia regularnego.  
  
 Domyślną wartość limitu czasu można przypisać do <xref:System.Text.RegularExpressions.RegexCompilationInfo> obiektu w dowolny z następujących sposobów:  
  
-   Wywołując <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> metodę i dostarczając ciąg reprezentujący <xref:System.TimeSpan> wartość właściwości "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Przez wywołanie <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29> konstruktora i podanie wartości `matchTimeout` parametru.  
  
-   Ustawiając wartość tej właściwości.  
  
 Aby ustawić rozsądny limit czasu, należy wziąć pod uwagę następujące czynniki:  
  
-   Długość i złożoność wzorca wyrażenia regularnego. Dłuższe i bardziej złożone wyrażenia regularne wymagają więcej czasu niż krótsze i prostsze.  
  
-   Oczekiwane obciążenie maszynowe. Przetwarzanie zajmuje więcej czasu na komputerach z wysokim użyciem procesora CPU i pamięci.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano pojedyncze skompilowane wyrażenie regularne `DuplicateChars` o nazwie, które identyfikuje dwa lub więcej wystąpień tego samego znaku w ciągu wejściowym. Skompilowane wyrażenie regularne ma domyślny limit czasu wynoszący 2 sekundy. Podczas wykonywania przykładu tworzy się bibliotekę klas o nazwie RegexLib. dll, która zawiera skompilowane wyrażenie regularne.  
  
 [!code-csharp[System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regexcompilationinfo.matchtimeout/cs/example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regexcompilationinfo.matchtimeout/vb/example1.vb#1)]  
  
 Wzorzec `(\w)\1+` wyrażenia regularnego jest zdefiniowany, jak pokazano w poniższej tabeli.  
  
|Wzorzec|Opis|  
|-------------|-----------------|  
|`(\w)`|Dopasowuje dowolny znak słowa i przypisuje go do pierwszej grupy przechwytywania.|  
|`\1+`|Dopasowuje jedno lub więcej wystąpień wartości pierwszej przechwyconej grupy.|  
  
 W poniższym przykładzie użyto `DuplicatedChars` wyrażenia regularnego do identyfikowania zduplikowanych znaków w tablicy ciągów. Gdy wywołuje `DuplicatedChars` konstruktora, zmienia interwał limitu czasu na 5 sekund.  
  
 [!code-csharp[System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regexcompilationinfo.matchtimeout/cs/example1a.cs#2)]
 [!code-vb[System.Text.RegularExpressions.RegexCompilationInfo.MatchTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regexcompilationinfo.matchtimeout/vb/example1a.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.RegularExpressions.RegexCompilationInfo.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.String,System.String,System.Boolean,System.TimeSpan)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.RegexCompilationInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Text.RegularExpressions.RegexCompilationInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę typu, który reprezentuje skompilowane wyrażenie regularne.</summary>
        <value>Nazwa nowego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa jest używana do definiowania skompilowanego wyrażenia regularnego, które jest reprezentowane jako Klasa <xref:System.Text.RegularExpressions.Regex>pochodna. <xref:System.Text.RegularExpressions.RegexCompilationInfo> Właściwość definiuje nazwę klasy typu wyrażenia regularnego, <xref:System.Text.RegularExpressions.RegexCompilationInfo.Namespace%2A> a właściwości i razem definiują <xref:System.Text.RegularExpressions.RegexCompilationInfo.Name%2A> swoją w pełni kwalifikowaną nazwę. <xref:System.Text.RegularExpressions.RegexCompilationInfo.Name%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość tej właściwości to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość tej właściwości jest pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.RegexCompilationInfo.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Text.RegularExpressions.RegexCompilationInfo.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przestrzeń nazw, do której należy nowy typ.</summary>
        <value>Przestrzeń nazw nowego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa jest używana do definiowania skompilowanego wyrażenia regularnego, które jest reprezentowane jako Klasa <xref:System.Text.RegularExpressions.Regex>pochodna. <xref:System.Text.RegularExpressions.RegexCompilationInfo> Właściwość definiuje przestrzeń nazw, która zawiera skompilowany typ wyrażenia regularnego, <xref:System.Text.RegularExpressions.RegexCompilationInfo.Namespace%2A> a właściwości <xref:System.Text.RegularExpressions.RegexCompilationInfo.Name%2A> i razem definiują swoją w pełni kwalifikowaną nazwę. <xref:System.Text.RegularExpressions.RegexCompilationInfo.Namespace%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość tej właściwości to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.RegexCompilationInfo.Options" />
      <MemberSignature Language="VB.NET" Value="Public Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); void set(System::Text::RegularExpressions::RegexOptions value); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions with get, set" Usage="System.Text.RegularExpressions.RegexCompilationInfo.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia opcje do użycia podczas kompilowania wyrażenia regularnego.</summary>
        <value>Bitowe połączenie wartości wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Metoda generuje zestaw, który zawiera skompilowane wyrażenia regularne. W związku z tym nie trzeba określać <xref:System.Text.RegularExpressions.RegexOptions.Compiled> jako jednej z wartości tej właściwości. Jeśli jest obecny, <xref:System.Text.RegularExpressions.RegexOptions.Compiled> opcja jest ignorowana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pattern">
      <MemberSignature Language="C#" Value="public string Pattern { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Pattern" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.RegexCompilationInfo.Pattern" />
      <MemberSignature Language="VB.NET" Value="Public Property Pattern As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Pattern { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Pattern : string with get, set" Usage="System.Text.RegularExpressions.RegexCompilationInfo.Pattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wyrażenie regularne do skompilowania.</summary>
        <value>Wyrażenie regularne do skompilowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.RegexCompilationInfo.Pattern%2A> Właściwość może zawierać dowolne prawidłowe wyrażenie regularne. Jeśli wartość <xref:System.Text.RegularExpressions.RegexCompilationInfo.Pattern%2A> właściwości nie jest składniowo prawidłowym wzorcem wyrażenia regularnego, wywołanie <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> metody zgłasza <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość tej właściwości to <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">.NET Framework — Wyrażenia regularne</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementy języka wyrażeń regularnych</related>
      </Docs>
    </Member>
  </Members>
</Type>

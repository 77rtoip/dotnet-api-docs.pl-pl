<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6ae5ac708ed9c03e90259aa11dc3fd96557d5c21" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36488971" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zawiera klasę podstawową w celu określenia dynamicznego zachowania w czasie wykonywania. Ta klasa musi być dziedziczone z; nie możesz utworzyć wystąpienia go bezpośrednio.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DynamicObject` Klasa umożliwia zdefiniowanie operacje mogą być wykonywane na obiekty dynamiczne i wykonać te operacje. Na przykład można zdefiniować, co się dzieje, gdy próbuje pobrać lub ustawić właściwości obiektu, wywołanie metody lub wykonywania standardowych operacji matematycznych, takich jak dodawanie i mnożenie.  
  
 Ta klasa może być przydatne, jeśli chcesz utworzyć wygodniejsze protokołu dla biblioteki. Na przykład, jeśli użytkownicy biblioteki muszą używać składni, takich jak `Scriptobj.SetProperty("Count", 1)`, zapewniają możliwość używania tak samo, jak dużo prostsze składni `scriptobj.Count = 1`.  
  
 Nie można bezpośrednio utworzyć wystąpienia `DynamicObject` klasy. Aby zaimplementować dynamicznego zachowania, może zajść potrzeba dziedziczyć `DynamicObject` klasy i zastąpić metody niezbędne. Na przykład, jeśli potrzebujesz tylko operacje do ustawiania i pobierania właściwości, można zastąpić tylko <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody.  
  
 W języku C#, aby włączyć dynamiczne zachowanie dla wystąpień klas pochodnych `DynamicObject` klasy, należy użyć `dynamic` — słowo kluczowe. Aby uzyskać więcej informacji, zobacz [przy użyciu typu dynamicznego](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 W języku Visual Basic operacji dynamicznych, są obsługiwane przez późne wiązanie. Aby uzyskać więcej informacji, zobacz [wczesnego i późne wiązanie](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 Poniższy przykładowy kod przedstawia sposób tworzenia wystąpienia klasy, która jest pochodną `DynamicObject` klasy.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 Możesz także dodać własne elementy członkowskie do klas pochodnych `DynamicObject` klasy. Jeśli klasa definiuje właściwości i zastępuje również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metoda, środowisko uruchomieniowe języka dynamicznego (DLR) najpierw używa integratora języka do wyszukania statycznych definicji właściwości w klasie. Jeśli nie ma takich właściwości, wywołuje metodę DLR <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metody.  
  
 `DynamicObject` Klasa implementuje interfejs DLR <xref:System.Dynamic.IDynamicMetaObjectProvider>, co umożliwia udostępnianie wystąpienia `DynamicObject` klasy między języków, które obsługują modelu współdziałanie Runtime. Na przykład można utworzyć wystąpienia `DynamicObject` klasy w języku C#, a następnie przekazać do funkcji IronPython. Aby uzyskać więcej informacji, zobacz [Przegląd środowiska uruchomieniowego języka dynamicznego](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md).  
  
> [!NOTE]
>  Jeśli masz Prosty scenariusz, w którym wymagany jest obiekt, który można tylko dodawać i usuwać elementy członkowskie w czasie wykonywania, ale wymagające zdefiniować określonych operacji i nie mieć statyczne elementy członkowskie, skorzystaj <xref:System.Dynamic.ExpandoObject> klasy.  
>   
>  Jeśli masz bardziej zaawansowanym scenariuszu, w którym należy zdefiniować sposób dynamiczne obiekty uczestniczyć w protokole współdziałania lub trzeba zarządzać Runtime fast dynamicznej alokacji pamięci podręcznej, utworzyć własną implementację <xref:System.Dynamic.IDynamicMetaObjectProvider> interfejsu.  
  
   
  
## Examples  
 Załóżmy chcesz zapewnić alternatywne składni do uzyskiwania dostępu do wartości w słowniku, więc to zamiast elementu zapisu `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` w języku Visual Basic), można napisać `sampleDictionary.Text = "Sample text"`. Ponadto chcesz tej składni, aby uwzględniać wielkości liter, tak aby `sampleDictionary.Text` jest odpowiednikiem `sampleDictionary.text`.  
  
 Poniższy przykład kodu pokazuje `DynamicDictionary` klasy, która jest pochodną `DynamicObject` klasy. `DynamicDictionary` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość i zastąpienia <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody służące do obsługi nowej składni. Zapewnia także `Count` zawiera właściwość, która zawiera słownik ile właściwości dynamicznych.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 Aby uzyskać więcej przykładów, zobacz [tworzenia otoki z klasy DynamicObject](http://go.microsoft.com/fwlink/?LinkId=169008) na blogu C# — często zadawane pytania.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Typy zainicjować nowe wystąpienie klasy pochodne umożliwia <see cref="T:System.Dynamic.DynamicObject" /> typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można bezpośrednio utworzyć wystąpienia <xref:System.Dynamic.DynamicObject> klasy. Aby zaimplementować dynamicznego zachowania, muszą dziedziczyć <xref:System.Dynamic.DynamicObject> klasy i zastąpić metody niezbędne.  
  
 W języku C#, aby włączyć dynamiczne zachowanie dla wystąpienia klas pochodnych <xref:System.Dynamic.DynamicObject> klasy, należy użyć `dynamic` — słowo kluczowe. Aby uzyskać więcej informacji, zobacz [przy użyciu typu dynamicznego](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 W języku Visual Basic operacji dynamicznych, są obsługiwane przez późne wiązanie. Aby uzyskać więcej informacji, zobacz [wczesnego i późne wiązanie](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wystąpienia klasy, które są pochodnymi <xref:System.Dynamic.DynamicObject> klasy.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczenie wszystkich nazw dynamicznego elementu członkowskiego.</summary>
        <returns>Sekwencja zawierającej nazwy dynamicznego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy tylko do celów debugowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">Wyrażenie, które reprezentuje <see cref="T:System.Dynamic.DynamicMetaObject" /> do wysłania do metod dynamicznych wirtualnych.</param>
        <summary>Udostępnia <see cref="T:System.Dynamic.DynamicMetaObject" /> który wywołuje dynamicznych metod wirtualnych. Obiekt może być hermetyzowany wewnątrz innego <see cref="T:System.Dynamic.DynamicMetaObject" /> zapewniające niestandardowych dla poszczególnych działań. Ta metoda obsługuje infrastrukturę środowiska Dynamic Language Runtime dla obiektów implementujących języka i nie jest on przeznaczony do użycia bezpośrednio w kodzie.</summary>
        <returns>Obiekt <see cref="T:System.Dynamic.DynamicMetaObject" /> typu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje o operację binarną. <c>Integratora. Operacja</c> zwraca właściwość <see cref="T:System.Linq.Expressions.ExpressionType" /> obiektu. Na przykład w przypadku <c>Suma = najpierw + drugi</c> instrukcji, gdzie <c>pierwszy</c> i <c>drugi</c> pochodne <see langword="DynamicObject" /> klasy, <c>integratora. Operacja</c> zwraca <c>ExpressionType.Add</c>.</param>
        <param name="arg">Prawy operand operację binarną. Na przykład w przypadku <c>Suma = najpierw + drugi</c> instrukcji, gdzie <c>pierwszy</c> i <c>drugi</c> pochodne <see langword="DynamicObject" /> klasy, <c>arg</c>jest równa <c>drugi</c>.</param>
        <param name="result">Wynik operacji danych binarnych.</param>
        <summary>Udostępnia implementację dla operacji binarnych. Klasy wyprowadzone z <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak dodawanie i mnożenie.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić realizację operacji binarnych dla obiekt dynamiczny. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)  
  
 Ta metoda jest wywoływana, gdy masz operacji binarnych, takich jak dodawanie lub mnożenie. Na przykład jeśli <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> metoda zostanie przesłonięta, jest wywoływana automatycznie dla instrukcji, takich jak `sum = first + second` lub `multiply = first*second`, gdzie `first` jest pochodną `DynamicObject` klasy.  
  
 Informacje o typie operację binarną można uzyskać za pomocą `Operation` właściwość `binder` parametru.  
  
 Jeśli obiekt dynamiczny jest używana tylko w języku C# i Visual Basic, `binder.Operation` właściwości może mieć jeden z następujących wartości z <xref:System.Linq.Expressions.ExpressionType> wyliczenia. Jednak w innych językach takich jak IronPython lub IronRuby może mieć inne wartości.
  
|Wartość|Opis|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|Operacja dodawania bez sprawdzanie przepełnienia dla argumentów operacji liczbowych.|`a + b`|`a + b`|  
|`AddAssign`|Operacja przydział złożony dodawania bez sprawdzanie przepełnienia dla argumentów operacji liczbowych.|`a += b`|Nieobsługiwane.|  
|`And`|Bitowej `AND` operacji.|`a & b`|`a And b`|  
|`AndAssign`|Bitowej `AND` złożone operacji przypisania.|`a &= b`|Nieobsługiwane.|  
|`Divide`|Operacja arytmetycznego dzielenia.|`a / b`|`a / b`|  
|`DivideAssign`|Przydział złożony arytmetycznego dzielenia operacji.|`a /= b`|Nieobsługiwane.|  
|`ExclusiveOr`|Bitowej `XOR` operacji.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|Bitowej `XOR` złożone operacji przypisania.|`a ^= b`|Nieobsługiwane.|  
|`GreaterThan`|Porównanie "większe niż".|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|Porównanie "większe lub równe".|`a >= b`|Nieobsługiwane.|  
|`LeftShift`|Operacja bitowa przesunięcia w lewo.|`a << b`|`a << b`|  
|`LeftShiftAssign`|Operacja bitowe przesunięcia w lewo przydział złożony.|`a <<= b`|Nieobsługiwane.|  
|`LessThan`|Porównanie "mniejsze niż".|`a < b`|`a < b`|  
|`LessThanOrEqual`|Porównanie "mniejsza niż lub równa".|`a <= b`|Nieobsługiwane.|  
|`Modulo`|Operacji arytmetycznych resztę.|`a % b`|`a Mod b`|  
|`ModuloAssign`|Przydział złożony arytmetyczne pozostałej operacji.|`a %= b`|Nieobsługiwane.|  
|`Multiply`|Mnożenie bez sprawdzanie przepełnienia dla argumentów operacji liczbowych.|`a * b`|`a * b`|  
|`MultiplyAssign`|Przydział złożony mnożenie bez sprawdzanie przepełnienia dla argumentów operacji liczbowych.|`a *= b`|Nieobsługiwane.|  
|`NotEqual`|Porównanie nierówności.|`a != b`|`a <> b`|  
|`Or`|A bitowe lub logicznej `OR` operacji.|`a &#124; b`|`a Or b`|  
|`OrAssign`|A bitowe lub logicznej `OR` przydział złożony.|`a &#124;= b`|Nieobsługiwane.|  
|`Power`|Matematyczne działanie podniesienia liczby do potęgi.|Nieobsługiwane.|`a ^ b`|  
|`RightShift`|Operacja bitowa przesunięcia w prawo.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|Operacja bitowe przydział złożony przesunięcia w prawo.|`a >>= b`|Nieobsługiwane.|  
|`Subtract`|Operacja odejmowania bez sprawdzanie przepełnienia dla argumentów operacji liczbowych.|`a - b`|`a - b`|  
|`SubtractAssign`|Operacja przydział złożony odejmowania bez sprawdzanie przepełnienia dla argumentów operacji liczbowych.|`a -= b`|Nieobsługiwane.|  
  
> [!NOTE]
>  Aby zaimplementować `OrElse` (`a || b`) i `AndAlso` (`a && b`) operacji dynamicznej obiektów w języku C#, można zaimplementować zarówno <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> — metoda i <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> — metoda.  
>   
>  `OrElse` Operacja obejmuje jednoargumentowego `IsTrue` operacji i plik binarny `Or` operacji. `Or` Jest wykonywane tylko wtedy, gdy wynik `IsTrue` operacji `false`.  
>   
>  `AndAlso` Operacja obejmuje jednoargumentowego `IsFalse` operacji i plik binarny `And` operacji. `And` Jest wykonywane tylko wtedy, gdy wynik `IsFalse` operacji `false`.  
  
   
  
## Examples  
 Założono, że należy to struktura danych do przechowywania numerycznych i tekstowych reprezentacji liczb, i chcesz zdefiniować podstawowych operacji matematycznych, takich jak dodawanie i odejmowanie dla tych danych.  
  
 Poniższy przykład kodu pokazuje `DynamicNumber` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicNumber` zastępuje <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> metody w celu umożliwienia operacji matematycznych. Zastępuje ona również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody w celu umożliwienia dostępu do elementów.  
  
 W tym przykładzie tylko operacje dodawania i odejmowania są obsługiwane. Próba zapisu instrukcję, takich jak `resultNumber = firstNumber*secondNumber`, jest zgłaszany wyjątek czasu wykonywania.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Udostępnia informacje na temat operacji konwersji. <c>Integratora. Typ</c> właściwość zawiera typ, do którego można przekonwertować obiektu. Na przykład dla instrukcji <c>sampleObject (ciąg)</c> w języku C# (<c>CType (sampleObject, typ)</c> w języku Visual Basic), gdzie <c>sampleObject</c> jest wystąpieniem klasy pochodnej z <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>integratora. Typ</c> zwraca <see cref="T:System.String" /> typu. <c>Integratora. Jawne</c> właściwość zawiera informacje o rodzaj konwersji, która występuje. Zwraca <see langword="true" /> dla jawnej konwersji i <see langword="false" /> dla niejawnej konwersji.</param>
        <param name="result">Wynik operacji konwersji typu.</param>
        <summary>Udostępnia implementację dla typu operacji konwersji. Klasy wyprowadzone z <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, które przekonwertować obiektu typu.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak dla obiekt dynamiczny, w którym powinien można przeprowadzić konwersji typu. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)  
  
 W języku C# Jeśli ta metoda zostanie przesłonięta, jest automatycznie wywoływana, gdy masz konwersji jawnych ani niejawnych, jak pokazano w poniższym przykładzie kodu.  
  
 W języku Visual Basic jest obsługiwana tylko jawnej konwersji. Jeśli przesłonięcia tej metody należy wywołać przy użyciu <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> lub <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> funkcji.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 Założono, że należy to struktura danych do przechowywania tekstową i numeryczne liczbami w postaci i chcesz zdefiniować konwersje tej struktury danych do ciągów i liczb całkowitych.  
  
 Poniższy przykład kodu pokazuje `DynamicNumber` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicNumber` zastępuje <xref:System.Dynamic.DynamicObject.TryConvert%2A> metody w celu umożliwienia przeprowadzenia konwersji typu. Zastępuje ona również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody w celu umożliwienia dostępu do elementów danych.  
  
 W tym przykładzie jest obsługiwana tylko konwersja do ciągów i liczb całkowitych. Jeśli zostanie podjęta próba konwersji obiektu do innego typu, zwracany jest wyjątek czasu wykonywania.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Udostępnia informacje na temat operacji inicjowania.</param>
        <param name="args">Argumenty, które są przekazywane do obiektu podczas inicjowania. Na przykład w przypadku <c>nowe SampleType(100)</c> operacji, gdzie <c>SampleType</c> jest typ jest pochodną <see cref="T:System.Dynamic.DynamicObject" /> klasy, <c>argumentów [0]</c> jest równa 100.</param>
        <param name="result">Wynik inicjowania.</param>
        <summary>Udostępnia implementację dla operacji, które inicjuje nowe wystąpienie obiektu dynamicznego. Ta metoda nie jest przeznaczony do użycia w języku C# lub Visual Basic.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak można zainicjować nowego wystąpienia obiektu dynamicznego. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)  
  
 C# i Visual Basic kompilatory nigdy nie Emituj kod, aby użyć tej metody, ponieważ nie obsługują typów najwyższej jakości. Ta metoda jest przeznaczona dla języków, które obsługuje inicjowania obiekty dynamiczne przy użyciu składni, takich jak `dynamic new`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje dotyczące usuwania.</param>
        <param name="indexes">Indeksy, które mają zostać usunięte.</param>
        <summary>Udostępnia implementację dla operacji, które usuwanie według indeksu obiektu. Ta metoda nie jest przeznaczony do użycia w języku C# lub Visual Basic.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak wartość, która ma określony indeks powinien zostać usunięty. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)  
  
 C# i Visual Basic kompilatory nigdy nie Emituj kod, aby użyć tej metody, ponieważ nie obsługują tego rodzaju operacji. Ta metoda jest przeznaczona dla języków, które obsługuje składni usuwania obiektów przez indeks, takich jak `del sampleObject[1,2]` w języku Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje dotyczące usuwania.</param>
        <summary>Udostępnia implementację dla operacji, które usunąć elemencie członkowskim obiektu. Ta metoda nie jest przeznaczony do użycia w języku C# lub Visual Basic.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak można usunąć elementu członkowskiego obiektu. W przypadku tej metody nie jest przesłonięcia integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)  
  
 C# i Visual Basic kompilatory nigdy nie Emituj kod, aby użyć tej metody, ponieważ nie obsługują tego rodzaju operacji. Ta metoda jest przeznaczona dla języków, które obsługuje składni związanych z usuwaniem elementów członkowskich, takich jak `del sampleObject.SampleMember` w języku Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Udostępnia informacje na temat operacji.</param>
        <param name="indexes">Indeksy, które są używane w ramach operacji. Na przykład w przypadku <c>sampleObject [3]</c> operacji w języku C# (<c>sampleObject(3)</c> w języku Visual Basic), gdzie <c>sampleObject</c> jest pochodną <see langword="DynamicObject" /> klasy, <c>indeksy [0]</c> ma wartość 3.</param>
        <param name="result">Wynik operacji indeksowania.</param>
        <summary>Udostępnia implementację dla operacji, które uzyskują wartości według indeksu. Klasy wyprowadzone z <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji indeksowania.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków czasu wykonywania jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić sposób uzyskiwania wartości według indeksu należy wykonać dla obiekt dynamiczny. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków czasu wykonywania jest wyjątek.)  
  
 Jeśli ta metoda zostanie przesłonięta, jest automatycznie wywoływana, gdy masz operacji, takich jak `sampleObject[3]` w języku C# lub `sampleObject(3)` w Visual Basic, gdzie `sampleObject` jest pochodną <xref:System.Dynamic.DynamicObject> klasy.  
  
   
  
## Examples  
 Założono chcesz utworzyć obiekt, w którym właściwości mogą być dostępne przez nazw takich jak `Property0`, `Property1`i tak dalej lub według indeksu, dzięki czemu, na przykład `sampleObject.Property0` jest odpowiednikiem `sampleObject[0]` w języku C# lub `sampleObject(0)` w języku Visual Basic.  
  
 Poniższy przykład kodu pokazuje `SampleDynamicObject` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `SampleDynamicObject` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość. `SampleDynamicObject` zastępuje <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> i <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> metody, aby umożliwić dostęp przez indeks. Zastępuje on <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody w celu umożliwienia dostępu przez właściwość name.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje o obiekcie, który wywołał operację dynamiczną. <c>Integratora. Nazwa</c> właściwość zawiera nazwę elementu członkowskiego, na których jest wykonywana operacji dynamicznej. Na przykład w przypadku <c>Console.WriteLine(sampleObject.SampleProperty)</c> instrukcji, gdzie <c>sampleObject</c> jest wystąpienie klasy pochodnej z <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>integratora . Nazwa</c> zwraca "SampleProperty". <c>Integratora. IgnoreCase</c> właściwość określa, czy nazwa elementu członkowskiego jest rozróżniana wielkość liter.</param>
        <param name="result">Wynik operacji get. Na przykład, jeśli metoda jest wywoływana dla właściwości, można przypisać wartości właściwości do <c>wynik</c>.</param>
        <summary>Udostępnia implementację dla operacji, które uzyskują wartości elementu. Klasy wyprowadzone z <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak pobierania wartości właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków czasu wykonywania jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić realizację operacji, które uzyskują wartości elementu członkowskiego dla obiekt dynamiczny. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków czasu wykonywania jest wyjątek.)  
  
 Ta metoda jest wywoływana, gdy masz instrukcje, takie jak `Console.WriteLine(sampleObject.SampleProperty)`, gdzie `sampleObject` jest wystąpienie klasy pochodnej z <xref:System.Dynamic.DynamicObject> klasy.  
  
 Możesz także dodać własne elementy członkowskie do klas pochodnych `DynamicObject` klasy. Jeśli klasa definiuje właściwości i zastępuje również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metoda, środowisko uruchomieniowe języka dynamicznego (DLR) najpierw używa integratora języka do wyszukania statycznych definicji właściwości w klasie. Jeśli nie ma takich właściwości, wywołuje metodę DLR <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metody.  
  
   
  
## Examples  
 Załóżmy chcesz zapewnić alternatywne składni do uzyskiwania dostępu do wartości w słowniku, więc to zamiast elementu zapisu `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` w języku Visual Basic), można napisać `sampleDictionary.Text = "Sample text"`. Ponadto ta Składnia musi być bez uwzględniania wielkości liter, tak aby `sampleDictionary.Text` jest odpowiednikiem `sampleDictionary.text`.  
  
 Poniższy przykład kodu pokazuje `DynamicDictionary` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicDictionary` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość i zastąpienia <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody służące do obsługi nowej składni. Zapewnia także `Count` zawiera właściwość, która zawiera słownik ile właściwości dynamicznych.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Udostępnia informacje na temat operacji invoke.</param>
        <param name="args">Argumenty, które są przekazywane do obiektu podczas operacji wywoływania. Na przykład w przypadku <c>sampleObject(100)</c> operacji, gdy <c>sampleObject</c> jest pochodną <see cref="T:System.Dynamic.DynamicObject" /> klasy, <c>argumentów [0]</c> jest równa 100.</param>
        <param name="result">Wynik wywołania obiektu.</param>
        <summary>Udostępnia implementację dla operacji, które wywołują obiektu. Klasy wyprowadzone z <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak wywoływanie obiektu lub delegata.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków, jest zgłaszany wyjątek czasu wykonywania specyficzny dla języka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić realizację operacji, które wywołują obiektu dla obiekt dynamiczny. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków czasu wykonywania jest wyjątek.)  
  
 Jeśli ta metoda zostanie przesłonięta, jest automatycznie wywoływana, gdy masz operacji, takich jak `sampleObject(100)`, gdzie `sampleObject` jest pochodną <xref:System.Dynamic.DynamicObject> klasy.  
  
 Operacja do wywoływania obiektu jest obsługiwana w języku C#, ale nie w języku Visual Basic. Kompilator Visual Basic nigdy nie emituje kod, aby użyć tej metody i języka Visual Basic nie obsługuje składnię `sampleObject(100)`.  
  
   
  
## Examples  
 Załóżmy, należy to struktura danych do przechowywania tekstową i numeryczne liczbami w postaci. Chcesz można było określić wartość dla każdej właściwości pojedynczo, a także do zainicjowania wszystkich właściwości w jednej instrukcji.  
  
 Poniższy przykład kodu pokazuje `DynamicNumber` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicNumber` zastępuje <xref:System.Dynamic.DynamicObject.TryInvoke%2A> metody, aby umożliwić inicjowanie wszystkich właściwości w tym samym czasie. Zastępuje ona również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody w celu umożliwienia dostępu do właściwości pojedynczego obiektu.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Informacje na temat operacji dynamicznej. <c>Integratora. Nazwa</c> właściwość zawiera nazwę elementu członkowskiego, na których jest wykonywana operacji dynamicznej. Na przykład dla instrukcji <c>sampleObject.SampleMethod(100)</c>, gdzie <c>sampleObject</c> jest wystąpienie klasy pochodnej z <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>integratora. Nazwa</c> zwraca "SampleMethod". <c>Integratora. IgnoreCase</c> właściwość określa, czy nazwa elementu członkowskiego jest rozróżniana wielkość liter.</param>
        <param name="args">Argumenty, które są przekazywane do elementu obiektu podczas operacji wywoływania. Na przykład dla instrukcji <c>sampleObject.SampleMethod(100)</c>, gdzie <c>sampleObject</c> jest pochodną <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>argumentów [0]</c> jest równa 100.</param>
        <param name="result">Wynik wywołania elementu.</param>
        <summary>Udostępnia implementację dla operacji, które wywołują element. Klasy wyprowadzone z <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak wywołanie metody.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić realizację operacji, które wywołują element członkowski obiektu dla obiekt dynamiczny. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)  
  
 Jeśli ta metoda zostanie przesłonięta, automatycznie jest wywoływana podczas wykonywania operacji, takich jak `sampleObject.SampleMethod(100)`, gdzie `sampleObject` jest pochodną `DynamicObject` klasy.  
  
 Można również dodać własne metody do klasy, które są pochodnymi <xref:System.Dynamic.DynamicObject> klasy. Na przykład, jeśli można zastąpić <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> metody dynamicznej alokacji system najpierw próbuje określić, czy określona metoda istnieje w klasie. Jeśli metoda nie zostanie znaleziona, używa <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> implementacji.  
  
 Ta metoda nie obsługuje `ref` i `out` parametrów. Wszystkie parametry w `args` tablicy są przekazywane przez wartość.  
  
   
  
## Examples  
 Załóżmy chcesz zapewnić alternatywne składni do uzyskiwania dostępu do wartości w słowniku, więc to zamiast elementu zapisu `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` w języku Visual Basic), można napisać `sampleDictionary.Text = "Sample text"`. Ponadto chcesz można wywołać metody standardowe słownika dla tego słownika.  
  
 Poniższy przykład kodu pokazuje `DynamicDictionary` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicDictionary` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość. Zastępuje on <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> metody do obsługi metod <xref:System.Collections.Generic.Dictionary%602> klasy i zastąpień <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody służące do obsługi nowej składni. Zapewnia także `Print` metodę, która wyświetla wszystkie słownik kluczy i wartości.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Udostępnia informacje na temat operacji.</param>
        <param name="indexes">Indeksy, które są używane w ramach operacji. Na przykład w przypadku <c>sampleObject [3] = 10</c> operacji w języku C# (<c>sampleObject(3) = 10</c> w języku Visual Basic), gdzie <c>sampleObject</c> jest pochodną <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>indeksy [0]</c> ma wartość 3.</param>
        <param name="value">Wartość do ustawienia do obiektu, który ma określony indeks. Na przykład w przypadku <c>sampleObject [3] = 10</c> operacji w języku C# (<c>sampleObject(3) = 10</c> w języku Visual Basic), gdzie <c>sampleObject</c> jest pochodną <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>wartość</c> jest równa 10.</param>
        <summary>Udostępnia implementację dla operacji, które ustalają wartości według indeksu. Klasy wyprowadzone z <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, które uzyskują dostęp do obiektów przy określonym indeksie.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków, jest zgłaszany wyjątek czasu wykonywania specyficzny dla języka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić realizację operacje, które uzyskują dostęp do obiektu przez indeks dla obiekt dynamiczny. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)  
  
 Jeśli ta metoda zostanie przesłonięta, jest automatycznie wywoływana, gdy masz operacji, takich jak `sampleObject[3] = 10` w języku C# lub `sampleObject(3) = 10` w Visual Basic, gdzie `sampleObject` jest pochodną <xref:System.Dynamic.DynamicObject> klasy.  
  
   
  
## Examples  
 Założono chcesz utworzyć obiekt, w którym właściwości mogą być dostępne przez nazw takich jak `Property0`, `Property1`i tak dalej lub według indeksu, dzięki czemu, na przykład `sampleObject.Property0` jest odpowiednikiem `sampleObject[0]` w języku C# lub `sampleObject(0)` w języku Visual Basic.  
  
 Poniższy przykład kodu pokazuje `SampleDynamicObject` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `SampleDynamicObject` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość. `SampleDynamicObject` zastępuje <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> i <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> metody, aby umożliwić dostęp przez indeks. Zastępuje on <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody w celu umożliwienia dostępu przez właściwość name.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje o obiekcie, który wywołał operację dynamiczną. <c>Integratora. Nazwa</c> właściwość zawiera nazwę elementu członkowskiego, do którego jest przypisana wartość. Na przykład dla instrukcji <c>sampleObject.SampleProperty = "Test"</c>, gdzie <c>sampleObject</c> jest wystąpienie klasy pochodnej z <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>integratora. Nazwa</c> zwraca "SampleProperty". <c>Integratora. IgnoreCase</c> właściwość określa, czy nazwa elementu członkowskiego jest rozróżniana wielkość liter.</param>
        <param name="value">Wartość do ustawienia do elementu członkowskiego. Na przykład w przypadku <c>sampleObject.SampleProperty = "Test"</c>, gdzie <c>sampleObject</c> jest wystąpienie klasy pochodnej z <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>wartość</c> jest " Test".</param>
        <summary>Udostępnia implementację dla operacji, które ustalają wartości członka. Klasy wyprowadzone z <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak ustawienie wartości dla właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić realizację operacji, które ustalają wartości do elementu członkowskiego dla obiekt dynamiczny. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)  
  
 Ta metoda jest wywoływana, gdy masz instrukcje, takie jak `sampleObject.SampleProperty = "Test"`, gdzie `sampleObject` jest wystąpieniem klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy.  
  
 Możesz także dodać własne elementy członkowskie do klas pochodnych `DynamicObject` klasy. Jeśli klasa definiuje właściwości i zastępuje również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metoda, środowisko uruchomieniowe języka dynamicznego (DLR) najpierw używa integratora języka do wyszukania statycznych definicji właściwości w klasie. Jeśli nie ma takich właściwości, wywołuje metodę DLR <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metody.  
  
   
  
## Examples  
 Załóżmy chcesz zapewnić alternatywne składni do uzyskiwania dostępu do wartości w słowniku, więc to zamiast elementu zapisu `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` w języku Visual Basic), można napisać `sampleDictionary.Text = "Sample text"`. Ponadto ta Składnia musi być bez uwzględniania wielkości liter, tak aby `sampleDictionary.Text` jest odpowiednikiem `sampleDictionary.text`.  
  
 Poniższy przykład kodu pokazuje `DynamicDictionary` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicDictionary` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość i zastąpienia <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody służące do obsługi nowej składni. Zapewnia także `Count` zawiera właściwość, która zawiera słownik ile właściwości dynamicznych.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje o operację jednoargumentową. <c>Integratora. Operacja</c> zwraca właściwość <see cref="T:System.Linq.Expressions.ExpressionType" /> obiektu. Na przykład w przypadku <c>negativeNumber = - numer</c> instrukcji, gdzie <c>numer</c> jest pochodną <see langword="DynamicObject" /> klasy, <c>integratora. Operacja</c> zwraca "Negate".</param>
        <param name="result">Wynik operację jednoargumentową.</param>
        <summary>Udostępnia implementację dla operacji jednoargumentowy. Klasy wyprowadzone z <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak negacji, przyrost lub zmniejszenie.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończy się pomyślnie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wyprowadzone z <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić realizację jednoargumentowy operacje dla obiekt dynamiczny. Gdy metoda nie jest zastępowany, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka czasu wykonywania jest wyjątek.)  
  
 Ta metoda jest wywoływana, gdy mają jednoargumentowy operacji, takich jak negacji, przyrost lub zmniejszenie. Na przykład jeśli <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> metoda zostanie przesłonięta, ta metoda jest wywoływana automatycznie dla instrukcji, takich jak `negativeNumber = -number`, gdzie `number` jest pochodną <xref:System.Dynamic.DynamicObject> klasy.  
  
 Informacje o typie operację jednoargumentową można uzyskać za pomocą `Operation` właściwość `binder` parametru.  
  
 Jeśli obiekt dynamiczny jest używana tylko w języku C# i Visual Basic, `binder.Operation` właściwości może mieć jeden z następujących wartości z <xref:System.Linq.Expressions.ExpressionType> wyliczenia. Jednak w innych językach takich jak IronPython lub IronRuby może mieć inne wartości.
  
|Wartość|Opis|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|Zmniejszenie operację jednoargumentową.|`a--`|Nieobsługiwane.|  
|`Increment`|Operację jednoargumentową przyrostu.|`a++`|Nieobsługiwane.|  
|`Negate`|Negacja arytmetyczne.|`-a`|`-a`|  
|`Not`|Logiczna negacja.|`!a`|`Not a`|  
|`OnesComplement`|Te dopełnienia.|`~a`|Nieobsługiwane.|  
|`IsFalse`|Wartość fałszywego warunku.|`a && b`|Nieobsługiwane.|  
|`IsTrue`|Wartość warunek o wartości true.|`a &#124;&#124; b`|Nieobsługiwane.|  
|`UnaryPlus`|Jednoargumentowe plus.|`+a`|`+a`|  
  
> [!NOTE]
>  Aby zaimplementować `OrElse` (`a || b`) i `AndAlso` (`a && b`) operacji dynamicznej obiektów w języku C#, można zaimplementować zarówno <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> — metoda i <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> — metoda.  
>   
>  `OrElse` Operacja obejmuje jednoargumentowego `IsTrue` operacji i plik binarny `Or` operacji. `Or` Jest wykonywane tylko wtedy, gdy wynik `IsTrue` operacji `false`.  
>   
>  `AndAlso` Operacja obejmuje jednoargumentowego `IsFalse` operacji i plik binarny `And` operacji. `And` Jest wykonywane tylko wtedy, gdy wynik `IsFalse` operacji `false`.  
  
   
  
## Examples  
 Założono, że należy to struktura danych do przechowywania tekstową i numeryczne liczbami w postaci i chcesz zdefiniować operacji matematycznych negacji dla tych danych.  
  
 Poniższy przykład kodu pokazuje `DynamicNumber` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicNumber` zastępuje <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> metodę, aby umożliwić wykonanie operacji matematycznych negacji. Jest również zastąpienia <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody w celu umożliwienia dostępu do elementów.  
  
 W tym przykładzie jest obsługiwana tylko operacja negacji matematycznych. Próba zapisu instrukcję, takich jak `negativeNumber = +number`, wystąpi wyjątek czasu wykonywania.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
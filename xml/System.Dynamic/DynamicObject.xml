<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c5bc7b7a2907aab3912eeac3fba27db4bf120c40" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52217098" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia klasę bazową do określania dynamiczne zachowanie w czasie wykonywania. Ta klasa musi być dziedziczony z; nie tworzy je bezpośrednio.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DynamicObject` Klasy umożliwia określenie, jakie operacje mogą być wykonywane na obiektów dynamicznych i sposobu wykonywania tych operacji. Na przykład można zdefiniować, co się stanie, gdy próbują uzyskać lub ustawić właściwości obiektu, wywołanie metody lub wykonać standardowe operacje matematyczne, takie jak dodawanie i mnożenie.  
  
 Ta klasa może być przydatne, jeśli chcesz tworzyć bardziej wygodne protokołu dla biblioteki. Na przykład, jeśli użytkownicy biblioteki muszą używać składni `Scriptobj.SetProperty("Count", 1)`, może zapewnić możliwość używania dużo prostsze składni, takie jak `scriptobj.Count = 1`.  
  
 Nie można bezpośrednio utworzyć wystąpienie `DynamicObject` klasy. Aby zaimplementować to zachowanie dynamicznych, możesz chcieć dziedziczyć `DynamicObject` klasy, a także Przesłoń metody niezbędne. Na przykład, jeśli potrzebujesz tylko operacje do ustawiania i pobierania właściwości można zastąpić tylko <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody.  
  
 W języku C#, aby włączyć dynamiczne zachowanie dla wystąpień klas pochodnych `DynamicObject` klasy, należy użyć `dynamic` — słowo kluczowe. Aby uzyskać więcej informacji, zobacz [przy użyciu typu dynamicznego](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 W języku Visual Basic operacji dynamicznych są obsługiwane przez późnym wiązaniu. Aby uzyskać więcej informacji, zobacz [wczesnego a późne wiązanie](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 Poniższy przykład kodu demonstruje sposób tworzenia wystąpienia klasy, która jest pochodną `DynamicObject` klasy.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 Można również dodać własne elementy członkowskie do klasy pochodne `DynamicObject` klasy. Jeśli klasa definiuje właściwości i zastępuje również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metody, środowisko uruchomieniowe języka dynamicznego (DLR) najpierw zastosowano integratorów modeli języka do wyszukania statyczne definicji właściwości w klasie. Jeśli nie ma takich właściwości, wywołuje metodę DLR <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metody.  
  
 `DynamicObject` Klasa implementuje interfejs DLR <xref:System.Dynamic.IDynamicMetaObjectProvider>, która umożliwia udostępnianie wystąpień `DynamicObject` klas między językami, które obsługują DLR współdziałania modelu. Na przykład można utworzyć wystąpienia `DynamicObject` klasy w języku C#, a następnie przekazać go do funkcji Ironpythonu. Aby uzyskać więcej informacji, zobacz [dynamiczny przegląd środowiska uruchomieniowego języka](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md).  
  
> [!NOTE]
>  Jeśli masz Prosty scenariusz, w którym wymagany jest obiekt, który można tylko dodawać i usuwać elementy członkowskie w czasie wykonywania, ale wymagające zdefiniować określonych operacji i nie ma statyczne elementy członkowskie, użyj <xref:System.Dynamic.ExpandoObject> klasy.  
>   
>  W przypadku bardziej zaawansowanym scenariuszu, w którym należy zdefiniować, jak dynamiczna obiektów uczestniczyć w protokole współdziałania lub musisz zarządzać buforowania szybko dynamicznej alokacji DLR utworzyć własną implementację <xref:System.Dynamic.IDynamicMetaObjectProvider> interfejsu.  
  
   
  
## Examples  
 Przyjęto założenie, chcesz zapewniają składnię alternatywne do uzyskiwania dostępu do wartości w słowniku, tak, to zamiast pisania tego `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` w języku Visual Basic), można napisać `sampleDictionary.Text = "Sample text"`. Ponadto należy ta składnia jest rozróżniana wielkość liter, tak aby `sampleDictionary.Text` jest odpowiednikiem `sampleDictionary.text`.  
  
 Poniższy przykład kodu demonstruje `DynamicDictionary` klasy, która jest pochodną `DynamicObject` klasy. `DynamicDictionary` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość i zastąpień <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody służące do obsługi nowej składni. Zapewnia także `Count` zawiera właściwość, która pokazuje, ile właściwości dynamicznego słownika.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 Aby uzyskać więcej przykładów, zobacz [tworzenie otok za pomocą klasy](https://go.microsoft.com/fwlink/?LinkId=169008) na blogu języka C# — często zadawane pytania.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Typy, aby zainicjować nowe wystąpienie klasy pochodne umożliwia <see cref="T:System.Dynamic.DynamicObject" /> typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można bezpośrednio utworzyć wystąpienie <xref:System.Dynamic.DynamicObject> klasy. Aby zaimplementować dynamiczne zachowanie, trzeba dziedziczyć z <xref:System.Dynamic.DynamicObject> klasy, a także Przesłoń metody niezbędne.  
  
 W języku C#, aby włączyć dynamiczne zachowanie dla wystąpienia klas pochodnych <xref:System.Dynamic.DynamicObject> klasy, należy użyć `dynamic` — słowo kluczowe. Aby uzyskać więcej informacji, zobacz [przy użyciu typu dynamicznego](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 W języku Visual Basic operacji dynamicznych są obsługiwane przez późnym wiązaniu. Aby uzyskać więcej informacji, zobacz [wczesnego a późne wiązanie](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób tworzenia wystąpienia klasy, które są uzyskiwane z <xref:System.Dynamic.DynamicObject> klasy.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczenie wszystkich nazw dynamicznego elementu członkowskiego.</summary>
        <returns>Sekwencja, w której w nazwach dynamicznego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda istnieje tylko do celów debugowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">Wyrażenie, które reprezentuje <see cref="T:System.Dynamic.DynamicMetaObject" /> do wysłania do dynamicznych metod wirtualnych.</param>
        <summary>Udostępnia <see cref="T:System.Dynamic.DynamicMetaObject" /> , wysyła do dynamicznych metod wirtualnych. Obiekt może być zhermetyzowany wewnątrz innego <see cref="T:System.Dynamic.DynamicMetaObject" /> aby zapewnić zachowanie niestandardowe do wykonywania poszczególnych czynności. Ta metoda obsługuje infrastrukturę środowiska Dynamic Language Runtime dotyczące implementacji języka i nie jest on przeznaczony do użycia bezpośrednio w kodzie.</summary>
        <returns>Obiekt <see cref="T:System.Dynamic.DynamicMetaObject" /> typu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje dotyczące operacji binarnej. <c>Integratorów modeli. Operacja</c> właściwość zwraca <see cref="T:System.Linq.Expressions.ExpressionType" /> obiektu. Na przykład w przypadku <c>Suma = pierwszy i drugi</c> instrukcji, gdzie <c>pierwszy</c> i <c>drugi</c> są uzyskiwane z <see langword="DynamicObject" /> klasy <c>integratorów modeli. Operacja</c> zwraca <c>ExpressionType.Add</c>.</param>
        <param name="arg">Prawy operand operację binarną. Na przykład w przypadku <c>Suma = pierwszy i drugi</c> instrukcji, gdzie <c>pierwszy</c> i <c>drugi</c> są uzyskiwane z <see langword="DynamicObject" /> klasy <paramref name="arg" /> jest równa <c>drugi</c>.</param>
        <param name="result">Wynik operacji binarnej.</param>
        <summary>Udostępnia implementację dla operacji binarnych. Klasy pochodne <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak dodawanie i mnożenie.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak należy przeprowadzić operacji binarnych obiekt dynamiczny. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)  
  
 Ta metoda jest wywoływana, gdy masz operacji binarnych, takich jak dodawanie i mnożenie. Na przykład jeśli <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> metoda zostanie przesłonięta, jest wywoływana automatycznie dla instrukcji, takich jak `sum = first + second` lub `multiply = first*second`, gdzie `first` jest tworzony na podstawie `DynamicObject` klasy.  
  
 Informacje o typie operacji binarnej można uzyskać za pomocą `Operation` właściwość `binder` parametru.  
  
 Jeśli obiekt dynamiczny jest używany tylko w języku C# i Visual Basic `binder.Operation` właściwość może mieć jedną z następujących wartości z <xref:System.Linq.Expressions.ExpressionType> wyliczenia. Jednak w innych językach, takich jak IronPython i IronRuby, może mieć inne wartości.
  
|Wartość|Opis|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|Operacja dodawania sprawdzeniem przepełnienia, liczbową argumentów operacji.|`a + b`|`a + b`|  
|`AddAssign`|Dodanie złożoną operacją przypisania sprawdzeniem przepełnienia, liczbową argumentów operacji.|`a += b`|Nieobsługiwane.|  
|`And`|Logiczny `AND` operacji.|`a & b`|`a And b`|  
|`AndAssign`|Logiczny `AND` złożonych operacji przypisania.|`a &= b`|Nieobsługiwane.|  
|`Divide`|Operacja arytmetycznego dzielenia.|`a / b`|`a / b`|  
|`DivideAssign`|Arytmetycznego dzielenia złożoną operacją przypisania.|`a /= b`|Nieobsługiwane.|  
|`ExclusiveOr`|Logiczny `XOR` operacji.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|Logiczny `XOR` złożonych operacji przypisania.|`a ^= b`|Nieobsługiwane.|  
|`GreaterThan`|Porównanie "większe niż".|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|Porównanie "większe niż lub równe".|`a >= b`|Nieobsługiwane.|  
|`LeftShift`|Operacja bitowa przesunięcia w lewo.|`a << b`|`a << b`|  
|`LeftShiftAssign`|Bitowe przesunięcia w lewo złożoną operacją przypisania.|`a <<= b`|Nieobsługiwane.|  
|`LessThan`|Porównanie "poniżej".|`a < b`|`a < b`|  
|`LessThanOrEqual`|Porównanie "mniejsze niż lub równe".|`a <= b`|Nieobsługiwane.|  
|`Modulo`|Operacja Reminder arytmetyczne.|`a % b`|`a Mod b`|  
|`ModuloAssign`|Arytmetyczny resztę złożoną operacją przypisania.|`a %= b`|Nieobsługiwane.|  
|`Multiply`|Mnożenie sprawdzeniem przepełnienia, liczbową argumentów operacji.|`a * b`|`a * b`|  
|`MultiplyAssign`|Mnożenie złożoną operacją przypisania sprawdzeniem przepełnienia, liczbową argumentów operacji.|`a *= b`|Nieobsługiwane.|  
|`NotEqual`|Porównanie nierówności.|`a != b`|`a <> b`|  
|`Or`|Bitowe lub logicznej `OR` operacji.|`a &#124; b`|`a Or b`|  
|`OrAssign`|Bitowe lub logicznej `OR` przydział złożony.|`a &#124;= b`|Nieobsługiwane.|  
|`Power`|Operacja matematyczna zwiększenia liczby do potęgi.|Nieobsługiwane.|`a ^ b`|  
|`RightShift`|Operacja bitowa przesunięcia w prawo.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|Bitowe przesunięcia w prawo złożoną operacją przypisania.|`a >>= b`|Nieobsługiwane.|  
|`Subtract`|Operacja odejmowania bez sprawdzanie przepełnienia, w przypadku argumentów operacji liczbowych.|`a - b`|`a - b`|  
|`SubtractAssign`|Odejmowanie złożoną operacją przypisania sprawdzeniem przepełnienia, liczbową argumentów operacji.|`a -= b`|Nieobsługiwane.|  
  
> [!NOTE]
>  Aby zaimplementować `OrElse` (`a || b`) i `AndAlso` (`a && b`) operacji dla obiektów dynamicznych w języku C#, można zaimplementować obu <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> — metoda i <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> metody.  
>   
>  `OrElse` Operacja obejmuje jednoargumentowe `IsTrue` operacji i plik binarny `Or` operacji. `Or` Operacja jest wykonywana tylko wtedy, gdy wynikiem `IsTrue` operacji `false`.  
>   
>  `AndAlso` Operacja obejmuje jednoargumentowe `IsFalse` operacji i plik binarny `And` operacji. `And` Operacja jest wykonywana tylko wtedy, gdy wynikiem `IsFalse` operacji `false`.  
  
   
  
## Examples  
 Przyjęto założenie, że wymagane jest strukturą danych do przechowywania tekstowe i liczbowe liczbami w postaci, a chcesz zdefiniować podstawowe operacje matematyczne, takie jak dodawanie i odejmowanie dla tych danych.  
  
 Poniższy przykład kodu demonstruje `DynamicNumber` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicNumber` zastępuje <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> metodę umożliwiającą włączenie operacje matematyczne. Zastępuje ona również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody w celu umożliwienia dostępu do elementów.  
  
 W tym przykładzie tylko operacje dodawania i odejmowania są obsługiwane. Jeśli zostanie podjęta próba Napisze instrukcję, takich jak `resultNumber = firstNumber*secondNumber`, jest zgłaszany wyjątek czasu wykonywania.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje na temat operacji konwersji. <c>Integratorów modeli. Typ</c> właściwości zawiera typ, do którego można przekonwertować obiektu. Na przykład instrukcja <c>sampleObject (ciąg)</c> w języku C# (<c>CType (sampleObject, typ)</c> w języku Visual Basic), gdzie <c>sampleObject</c> jest wystąpieniem klasy pochodne z <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>integratorów modeli. Typ</c> zwraca <see cref="T:System.String" /> typu. <c>Integratorów modeli. Jawne</c> właściwość zawiera informacje dotyczące rodzaj konwersji, która występuje. Zwraca <see langword="true" /> dla jawnej konwersji i <see langword="false" /> niejawną konwersję.</param>
        <param name="result">Wynik operacji konwersji typu.</param>
        <summary>Udostępnia implementację dla typu operacje konwersji. Klasy pochodne <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, które Konwertowanie obiektu z jednego typu.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak należy przeprowadzić konwersję typu obiekt dynamiczny. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)  
  
 W języku C# Jeśli ta metoda zostanie przesłonięta, jest automatycznie wywoływana, gdy masz jawnych lub niejawnych konwersji, jak pokazano w poniższym przykładzie kodu.  
  
 W języku Visual Basic jest obsługiwana tylko jawnej konwersji. Jeśli zastąpisz tę metodę można wywoływać przy użyciu <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> lub <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> funkcji.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 Przyjęto założenie, że wymagane jest strukturą danych do przechowywania tekstowe i liczbowe liczbami w postaci, a chcesz zdefiniować konwersje to struktura danych na ciągi i liczby całkowite.  
  
 Poniższy przykład kodu demonstruje `DynamicNumber` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicNumber` zastępuje <xref:System.Dynamic.DynamicObject.TryConvert%2A> metodę umożliwiającą włączenie konwersji typu. Zastępuje ona również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody, aby umożliwić dostęp do elementów danych.  
  
 W tym przykładzie jest obsługiwany tylko konwersji na ciągi i liczby całkowite. Jeśli zostanie podjęta próba konwersji obiektu do jakichkolwiek innych typów, zwracany jest wyjątek czasu wykonywania.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje na temat operacji inicjowania.</param>
        <param name="args">Argumenty, które są przekazywane do obiektu podczas inicjowania. Na przykład w przypadku <c>nowe SampleType(100)</c> operacji, gdzie <c>SampleType</c> jest tworzony typ na podstawie <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>argumenty [0]</c> jest równa 100.</param>
        <param name="result">Wynik inicjowania.</param>
        <summary>Udostępnia implementację dla operacji, które inicjuje nowe wystąpienie obiektu dynamicznego. Ta metoda nie jest przeznaczona do użycia w języku C# lub Visual Basic.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak można zainicjować nowe wystąpienie obiektu dynamicznego. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)  
  
 Kompilatory języka Visual Basic C# i nigdy nie emitują kod, aby użyć tej metody, ponieważ nie obsługują typy najwyższej jakości. Ta metoda jest przeznaczona dla języków, które obsługują inicjowania obiektów dynamicznych przy użyciu składni `dynamic new`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje dotyczące usuwania.</param>
        <param name="indexes">Indeksy, które mają zostać usunięte.</param>
        <summary>Udostępnia implementację dla operacji, które usuwanie obiektu za pomocą indeksu. Ta metoda nie jest przeznaczona do użycia w języku C# lub Visual Basic.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak wartość, która ma określony indeks powinien zostać usunięty. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)  
  
 Kompilatory języka Visual Basic C# i nigdy nie emitują kod, aby użyć tej metody, ponieważ nie obsługują tego rodzaju działania. Ta metoda jest przeznaczona dla języków, które obsługuje składni związanych z usuwaniem obiektów za pomocą indeksu, takich jak `del sampleObject[1,2]` w języku Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje dotyczące usuwania.</param>
        <summary>Udostępnia implementację dla operacji, które usuwa elemencie członkowskim obiektu. Ta metoda nie jest przeznaczona do użycia w języku C# lub Visual Basic.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak można usunąć elementu członkowskiego obiektu. Gdy ta metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)  
  
 Kompilatory języka Visual Basic C# i nigdy nie emitują kod, aby użyć tej metody, ponieważ nie obsługują tego rodzaju działania. Ta metoda jest przeznaczona dla języków, które obsługuje składni związanych z usuwaniem elementów członkowskich, takich jak `del sampleObject.SampleMember` w języku Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje na temat operacji.</param>
        <param name="indexes">Indeksy, które są używane w ramach operacji. Na przykład w przypadku <c>sampleObject [3]</c> operacji C# (<c>sampleObject(3)</c> w języku Visual Basic), gdzie <c>sampleObject</c> jest tworzony na podstawie <see langword="DynamicObject" /> Klasa <c>indeksy [0]</c> jest równa 3.</param>
        <param name="result">Wynik operacji indeksowania.</param>
        <summary>Udostępnia implementację dla operacji, które uzyskują wartości według indeksu. Klasy pochodne <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji indeksowania.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków środowiska wykonawczego jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić sposób pobierania wartości za pomocą indeksu należy przeprowadzić obiekt dynamiczny. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków środowiska wykonawczego jest wyjątek.)  
  
 Jeśli ta metoda zostanie przesłonięta, automatycznie jest wywoływany w przypadku operacji, takiej jak `sampleObject[3]` w języku C# lub `sampleObject(3)` w Visual Basic, gdzie `sampleObject` jest tworzony na podstawie <xref:System.Dynamic.DynamicObject> klasy.  
  
   
  
## Examples  
 Przyjęto założenie, czy chcesz utworzyć obiekt, w którym są one dostęp do dowolnego według nazw takich jak `Property0`, `Property1`i tak dalej lub za pomocą indeksu, tak, aby, na przykład `sampleObject.Property0` jest odpowiednikiem `sampleObject[0]` w języku C# lub `sampleObject(0)` w języku Visual Basic.  
  
 Poniższy przykład kodu demonstruje `SampleDynamicObject` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `SampleDynamicObject` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość. `SampleDynamicObject` zastępuje <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> i <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> metody, aby umożliwić dostęp przez indeks. Zastępuje ona <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody w celu umożliwienia dostępu według nazw właściwości.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje o obiekcie, który wywołał operację dynamiczną. <c>Integratorów modeli. Nazwa</c> właściwość zawiera nazwę elementu członkowskiego, na którym jest wykonywane dynamicznych. Na przykład w przypadku <c>Console.WriteLine(sampleObject.SampleProperty)</c> instrukcji, gdzie <c>sampleObject</c> jest wystąpieniem obiektu klasy pochodzącej od <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>integratorów modeli . Nazwa</c> zwraca "SampleProperty". <c>Integratorów modeli. IgnoreCase</c> właściwość określa, czy nazwa elementu członkowskiego jest rozróżniana wielkość liter.</param>
        <param name="result">Wynik operacji pobierania. Na przykład, jeśli metoda jest wywoływana dla właściwości, można przypisać wartość właściwości <paramref name="result" />.</param>
        <summary>Udostępnia implementację dla operacji, które uzyskują wartości elementu. Klasy pochodne <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak wprowadzenie wartości dla właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków środowiska wykonawczego jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak obiekt dynamiczny należy przeprowadzić operacji, które uzyskują wartości elementu. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków środowiska wykonawczego jest wyjątek.)  
  
 Ta metoda jest wywoływana w przypadku instrukcji takich jak `Console.WriteLine(sampleObject.SampleProperty)`, gdzie `sampleObject` jest wystąpieniem obiektu klasy pochodzącej od <xref:System.Dynamic.DynamicObject> klasy.  
  
 Można również dodać własne elementy członkowskie do klasy pochodne `DynamicObject` klasy. Jeśli klasa definiuje właściwości i zastępuje również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metody, środowisko uruchomieniowe języka dynamicznego (DLR) najpierw zastosowano integratorów modeli języka do wyszukania statyczne definicji właściwości w klasie. Jeśli nie ma takich właściwości, wywołuje metodę DLR <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metody.  
  
   
  
## Examples  
 Przyjęto założenie, chcesz zapewniają składnię alternatywne do uzyskiwania dostępu do wartości w słowniku, tak, to zamiast pisania tego `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` w języku Visual Basic), można napisać `sampleDictionary.Text = "Sample text"`. Ponadto ta Składnia musi być bez uwzględniania wielkości liter, tak aby `sampleDictionary.Text` jest odpowiednikiem `sampleDictionary.text`.  
  
 Poniższy przykład kodu demonstruje `DynamicDictionary` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicDictionary` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość i zastąpień <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody służące do obsługi nowej składni. Zapewnia także `Count` zawiera właściwość, która pokazuje, ile właściwości dynamicznego słownika.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje dotyczące operacji wywoływania.</param>
        <param name="args">Argumenty, które są przekazywane do obiektu podczas operacji wywoływania. Na przykład w przypadku <c>sampleObject(100)</c> operacji, gdzie <c>sampleObject</c> jest tworzony na podstawie <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>argumenty [0]</c> jest równa 100.</param>
        <param name="result">Wynik wywołania obiektu.</param>
        <summary>Udostępnia implementację dla operacji, które wywołują obiektu. Klasy pochodne <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak wywoływanie obiekt lub obiekt delegowany.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków jest zgłaszany wyjątek czasu wykonywania specyficzny dla języka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak należy przeprowadzić operacji, które wywołują obiekt to obiekt dynamiczny. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków środowiska wykonawczego jest wyjątek.)  
  
 Jeśli ta metoda zostanie przesłonięta, automatycznie jest wywoływany w przypadku operacji, takiej jak `sampleObject(100)`, gdzie `sampleObject` jest tworzony na podstawie <xref:System.Dynamic.DynamicObject> klasy.  
  
 Operacja do wywoływania obiektu jest obsługiwane w języku C#, ale nie w języku Visual Basic. Kompilator Visual Basic nie emituje kod, aby użyć tej metody, a język Visual Basic nie obsługuje składni `sampleObject(100)`.  
  
   
  
## Examples  
 Przyjęto założenie, że wymagane jest strukturą danych do przechowywania tekstowe i liczbowe liczbami w postaci. Chcesz można było określić wartość dla każdej właściwości indywidualnie, a także do zainicjowania wszystkich właściwości w pojedynczej instrukcji.  
  
 Poniższy przykład kodu demonstruje `DynamicNumber` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicNumber` zastępuje <xref:System.Dynamic.DynamicObject.TryInvoke%2A> umożliwiają inicjowanie wszystkich właściwości w tym samym czasie. Zastępuje ona również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody, aby umożliwić dostęp do właściwości poszczególnych obiektów.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Informacje na temat operacji dynamicznej. <c>Integratorów modeli. Nazwa</c> właściwość zawiera nazwę elementu członkowskiego, na którym jest wykonywane dynamicznych. Na przykład instrukcja <c>sampleObject.SampleMethod(100)</c>, gdzie <c>sampleObject</c> jest wystąpieniem obiektu klasy pochodzącej od <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>integratorów modeli. Nazwa</c> zwraca "SampleMethod". <c>Integratorów modeli. IgnoreCase</c> właściwość określa, czy nazwa elementu członkowskiego jest rozróżniana wielkość liter.</param>
        <param name="args">Argumenty, które są przekazywane do elementu obiektu podczas operacji wywoływania. Na przykład instrukcja <c>sampleObject.SampleMethod(100)</c>, gdzie <c>sampleObject</c> jest tworzony na podstawie <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>argumenty [0]</c> jest równa 100.</param>
        <param name="result">Wynik wywołania elementu.</param>
        <summary>Udostępnia implementację dla operacji, które wywołują element. Klasy pochodne <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak wywołanie metody.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak obiekt dynamiczny należy przeprowadzić operacji, które wywołują elemencie członkowskim obiektu. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)  
  
 Jeśli ta metoda zostanie przesłonięta, automatycznie jest wywoływana podczas wykonywania operacji, takiej jak `sampleObject.SampleMethod(100)`, gdzie `sampleObject` jest tworzony na podstawie `DynamicObject` klasy.  
  
 Można również dodać swoje własne metody do klasy, które są uzyskiwane z <xref:System.Dynamic.DynamicObject> klasy. Na przykład, jeśli zastąpisz <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> metody dynamicznej alokacji system najpierw próbuje określić, czy podana metoda istnieje w klasie. Jeśli metoda nie zostanie znaleziona, zostanie użyta <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> implementacji.  
  
 Ta metoda nie obsługuje `ref` i `out` parametrów. Wszystkie parametry w `args` tablicy są przekazywane przez wartość.  
  
   
  
## Examples  
 Przyjęto założenie, chcesz zapewniają składnię alternatywne do uzyskiwania dostępu do wartości w słowniku, tak, to zamiast pisania tego `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` w języku Visual Basic), można napisać `sampleDictionary.Text = "Sample text"`. Ponadto chcesz mieć możliwość wywoływania metod standardowych słownika w tym słowniku.  
  
 Poniższy przykład kodu demonstruje `DynamicDictionary` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicDictionary` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość. Zastępuje ona <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> metody w celu obsługi metod <xref:System.Collections.Generic.Dictionary%602> klasy i zastąpień <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody służące do obsługi nowej składni. Zapewnia także `Print` metody, która wyświetla wszystkie klucze słownikowe i wartości.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje na temat operacji.</param>
        <param name="indexes">Indeksy, które są używane w ramach operacji. Na przykład w przypadku <c>sampleObject [3] = 10</c> operacji C# (<c>sampleObject(3) = 10</c> w języku Visual Basic), gdzie <c>sampleObject</c> jest tworzony na podstawie <see cref="T:System.Dynamic.DynamicObject" />klasy <c>indeksy [0]</c> jest równa 3.</param>
        <param name="value">Wartość do ustawienia do obiektu, który ma określony indeks. Na przykład w przypadku <c>sampleObject [3] = 10</c> operacji C# (<c>sampleObject(3) = 10</c> w języku Visual Basic), gdzie <c>sampleObject</c> jest tworzony na podstawie <see cref="T:System.Dynamic.DynamicObject" />klasy <paramref name="value" /> jest równy 10.</param>
        <summary>Udostępnia implementację dla operacji, które ustalają wartości według indeksu. Klasy pochodne <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, które uzyskiwanie dostępu do obiektów przez określony indeks.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków jest zgłaszany wyjątek czasu wykonywania specyficzny dla języka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak należy przeprowadzić operacje dostępu do obiektu za pomocą indeksu obiekt dynamiczny. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)  
  
 Jeśli ta metoda zostanie przesłonięta, automatycznie jest wywoływany w przypadku operacji, takiej jak `sampleObject[3] = 10` w języku C# lub `sampleObject(3) = 10` w Visual Basic, gdzie `sampleObject` jest tworzony na podstawie <xref:System.Dynamic.DynamicObject> klasy.  
  
   
  
## Examples  
 Przyjęto założenie, czy chcesz utworzyć obiekt, w którym są one dostęp do dowolnego według nazw takich jak `Property0`, `Property1`i tak dalej lub za pomocą indeksu, tak, aby, na przykład `sampleObject.Property0` jest odpowiednikiem `sampleObject[0]` w języku C# lub `sampleObject(0)` w języku Visual Basic.  
  
 Poniższy przykład kodu demonstruje `SampleDynamicObject` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `SampleDynamicObject` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość. `SampleDynamicObject` zastępuje <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> i <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> metody, aby umożliwić dostęp przez indeks. Zastępuje ona <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody w celu umożliwienia dostępu według nazw właściwości.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje o obiekcie, który wywołał operację dynamiczną. <c>Integratorów modeli. Nazwa</c> właściwość zawiera nazwę elementu członkowskiego, do której przypisany jest wartość. Na przykład instrukcja <c>sampleObject.SampleProperty = "Test"</c>, gdzie <c>sampleObject</c> jest wystąpieniem obiektu klasy pochodzącej od <see cref="T:System.Dynamic.DynamicObject" /> klasy <c>integratorów modeli. Nazwa</c> zwraca "SampleProperty". <c>Integratorów modeli. IgnoreCase</c> właściwość określa, czy nazwa elementu członkowskiego jest rozróżniana wielkość liter.</param>
        <param name="value">Wartość do ustawienia elementu członkowskiego. Na przykład w przypadku <c>sampleObject.SampleProperty = "Test"</c>, gdzie <c>sampleObject</c> jest wystąpieniem obiektu klasy pochodzącej od <see cref="T:System.Dynamic.DynamicObject" /> klasy <paramref name="value" /> jest "Test".</param>
        <summary>Udostępnia implementację dla operacji, które ustalają wartości członka. Klasy pochodne <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak ustawienie wartości dla właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak obiekt dynamiczny należy przeprowadzić operacji, które ustalają wartości członka. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)  
  
 Ta metoda jest wywoływana w przypadku instrukcji takich jak `sampleObject.SampleProperty = "Test"`, gdzie `sampleObject` jest wystąpieniem klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy.  
  
 Można również dodać własne elementy członkowskie do klasy pochodne `DynamicObject` klasy. Jeśli klasa definiuje właściwości i zastępuje również <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metody, środowisko uruchomieniowe języka dynamicznego (DLR) najpierw zastosowano integratorów modeli języka do wyszukania statyczne definicji właściwości w klasie. Jeśli nie ma takich właściwości, wywołuje metodę DLR <xref:System.Dynamic.DynamicObject.TrySetMember%2A> metody.  
  
   
  
## Examples  
 Przyjęto założenie, chcesz zapewniają składnię alternatywne do uzyskiwania dostępu do wartości w słowniku, tak, to zamiast pisania tego `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` w języku Visual Basic), można napisać `sampleDictionary.Text = "Sample text"`. Ponadto ta Składnia musi być bez uwzględniania wielkości liter, tak aby `sampleDictionary.Text` jest odpowiednikiem `sampleDictionary.text`.  
  
 Poniższy przykład kodu demonstruje `DynamicDictionary` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicDictionary` Klasa zawiera obiekt `Dictionary<string, object>` typu (`Dictionary(Of String, Object)` w języku Visual Basic) do przechowywania par klucz wartość i zastąpień <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody służące do obsługi nowej składni. Zapewnia także `Count` zawiera właściwość, która pokazuje, ile właściwości dynamicznego słownika.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Zawiera informacje dotyczące operację jednoargumentową. <c>Integratorów modeli. Operacja</c> właściwość zwraca <see cref="T:System.Linq.Expressions.ExpressionType" /> obiektu. Na przykład w przypadku <c>negativeNumber = - number</c> instrukcji, gdzie <c>numer</c> jest tworzony na podstawie <see langword="DynamicObject" /> klasy <c>integratorów modeli. Operacja</c> zwraca "Negate".</param>
        <param name="result">Wynik operację jednoargumentową.</param>
        <summary>Udostępnia implementację dla operacji jednoargumentowy. Klasy pochodne <see cref="T:System.Dynamic.DynamicObject" /> klasy mogą przesłaniać tę metodę, aby określić zachowanie dynamicznych dla operacji, takich jak Negacja, przyrost lub dekrementacji.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />. Jeśli ta metoda zwraca <see langword="false" />, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne <xref:System.Dynamic.DynamicObject> klasy mogą przesłaniać tę metodę, aby określić, jak należy przeprowadzić operacje jednoargumentowe obiekt dynamiczny. Gdy metoda nie zostanie zastąpiona, integratora środowiska wykonawczego języka określa zachowanie. (W większości przypadków specyficzny dla języka środowiska wykonawczego jest wyjątek.)  
  
 Ta metoda jest wywoływana, gdy masz jednoargumentowe operacje, takie jak Negacja, przyrost lub zmniejszyć. Na przykład jeśli <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> metoda zostanie przesłonięta, ta metoda jest wywoływana automatycznie, takich jak instrukcje `negativeNumber = -number`, gdzie `number` jest tworzony na podstawie <xref:System.Dynamic.DynamicObject> klasy.  
  
 Informacje o typie operację jednoargumentową można uzyskać za pomocą `Operation` właściwość `binder` parametru.  
  
 Jeśli obiekt dynamiczny jest używany tylko w języku C# i Visual Basic `binder.Operation` właściwość może mieć jedną z następujących wartości z <xref:System.Linq.Expressions.ExpressionType> wyliczenia. Jednak w innych językach, takich jak IronPython i IronRuby, może mieć inne wartości.
  
|Wartość|Opis|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|Operacja dekrementacji jednoargumentowy.|`a--`|Nieobsługiwane.|  
|`Increment`|Operację jednoargumentową przyrostu.|`a++`|Nieobsługiwane.|  
|`Negate`|Arytmetyczny negacji.|`-a`|`-a`|  
|`Not`|Negacja logiczna.|`!a`|`Not a`|  
|`OnesComplement`|Te dopełnienia.|`~a`|Nieobsługiwane.|  
|`IsFalse`|Wartość false warunku.|`a && b`|Nieobsługiwane.|  
|`IsTrue`|Wartość warunek jest prawdziwy.|`a &#124;&#124; b`|Nieobsługiwane.|  
|`UnaryPlus`|Plus jednoargumentowy.|`+a`|`+a`|  
  
> [!NOTE]
>  Aby zaimplementować `OrElse` (`a || b`) i `AndAlso` (`a && b`) operacji dla obiektów dynamicznych w języku C#, można zaimplementować obu <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> — metoda i <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> metody.  
>   
>  `OrElse` Operacja obejmuje jednoargumentowe `IsTrue` operacji i plik binarny `Or` operacji. `Or` Operacja jest wykonywana tylko wtedy, gdy wynikiem `IsTrue` operacji `false`.  
>   
>  `AndAlso` Operacja obejmuje jednoargumentowe `IsFalse` operacji i plik binarny `And` operacji. `And` Operacja jest wykonywana tylko wtedy, gdy wynikiem `IsFalse` operacji `false`.  
  
   
  
## Examples  
 Przyjęto założenie, że wymagane jest strukturą danych do przechowywania tekstowe i liczbowe liczbami w postaci, a chcesz zdefiniować operacji matematycznych Negacja, dla tych danych.  
  
 Poniższy przykład kodu demonstruje `DynamicNumber` klasy, która jest pochodną <xref:System.Dynamic.DynamicObject> klasy. `DynamicNumber` zastępuje <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> metodę umożliwiającą włączenie operacji matematycznych negacji. Jest również zastąpienia <xref:System.Dynamic.DynamicObject.TrySetMember%2A> i <xref:System.Dynamic.DynamicObject.TryGetMember%2A> metody w celu umożliwienia dostępu do elementów.  
  
 W tym przykładzie tylko operacja matematyczna negacji jest obsługiwana. Jeśli zostanie podjęta próba Napisze instrukcję, takich jak `negativeNumber = +number`, wystąpi wyjątek czasu wykonywania.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
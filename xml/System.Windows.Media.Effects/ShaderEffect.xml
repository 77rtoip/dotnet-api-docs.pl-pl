<Type Name="ShaderEffect" FullName="System.Windows.Media.Effects.ShaderEffect">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6e56e17a4be59e38901f9a9c8ec0a1d057d18b02" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53477209" /></Metadata><TypeSignature Language="C#" Value="public abstract class ShaderEffect : System.Windows.Media.Effects.Effect" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ShaderEffect extends System.Windows.Media.Effects.Effect" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Effects.ShaderEffect" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ShaderEffect&#xA;Inherits Effect" />
  <TypeSignature Language="C++ CLI" Value="public ref class ShaderEffect abstract : System::Windows::Media::Effects::Effect" />
  <TypeSignature Language="F#" Value="type ShaderEffect = class&#xA;    inherit Effect" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Effects.Effect</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera efekt niestandardowej mapy bitowej przy użyciu <see cref="T:System.Windows.Media.Effects.PixelShader" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pochodzi od <xref:System.Windows.Media.Effects.ShaderEffect> klasę, aby wdrożyć niestandardowy efekt oparciu o program do cieniowania pikseli jednego.  
  
 Poniższe kroki pokazują jak utworzyć niestandardowy efekt.  
  
1.  Obciążenia <xref:System.Windows.Media.Effects.PixelShader> z wstępnie skompilowanym kodu bajtowego High Level cieniowanie Language (HLSL).  
  
2.  Zdefiniuj właściwości zależności, które reprezentują parametry efekt i <xref:System.Windows.Media.Brush>— na podstawie danych wejściowych powierzchni. Użyj jednej z <xref:System.Windows.Media.Effects.ShaderEffect.RegisterPixelShaderSamplerProperty%2A> przeciążenia, aby skojarzyć te dane wejściowe z zarejestrować numery, które są określone w kodu bajtowego języka HLSL.  
  
 Liczba próbników jest ograniczony do 4.  
  
 Korzystając z programu do cieniowania PS 3.0, obowiązują następujące ograniczenia.  
  
-   Po przypisaniu cieniowania PS 3.0 liczba próbników wzrasta do 8. Przypisz programu do cieniowania PS 3.0 przed innymi programów do cieniowania, aby włączyć rejestrowanie próbników 8.  
  
-   Limit rejestru stałych pełnego programu do cieniowania 224 dla wartości zmiennoprzecinkowe jest używany. Aby uzyskać więcej informacji, zobacz [ps_3_0](https://go.microsoft.com/fwlink/?LinkId=166292).  
  
-   Następujące typy danych są obsługiwane w tylko programów do cieniowania PS 3.0. Wyjątek jest generowany, jeśli są one używane w niższych wersjach programu do cieniowania.  
  
    -   `int` i typy możliwe do przekonwertowania na `int`: `uint`, `byte`, `sbyte`, `long`, `ulong`, `short`, `ushort`, `char`  
  
    -   `bool`  
  
-   Jeśli prawidłowy cieniowania PS 3.0 jest ładowany na komputerze, który nie ma sprzętu Obsługa PS 3.0, programu do cieniowania jest ignorowana. Jeśli moduł cieniujący jest nieprawidłowa, jest zgłaszany żaden wyjątek.  
  
-   Jeśli komputer ma więcej niż jednej karty wideo, zachowanie jest definiowany przez najmniejsze karty wideo. Na przykład jeśli komputer ma dwie karty wideo, w jednym z nich nie jest jednym z nich obsługuje PS 3.0 oraz zachowanie jest taka sama jak, jeśli komputer nie obsługuje PS 3.0.  
  
-   Jeśli komputer obsługuje renderowanie PS 3.0 w sprzęt, ale nieprawidłowy cieniowania PS 3.0 jest przypisany, <xref:System.Windows.Media.Effects.PixelShader.InvalidPixelShaderEncountered> zdarzenie jest wywoływane. Przykład nieprawidłowy cieniowania PS 3.0 jest skompilowany przy użyciu `ps_3_sw` flagi. <xref:System.Windows.Media.Effects.ShaderEffect> Klasy akceptuje tylko cieniowania PS 3.0, które są kompilowane przy użyciu `ps_3_0` flagi przekazywane do fxc.exe. Aby uzyskać więcej informacji, zobacz [narzędzie kompilatora efekt](https://go.microsoft.com/fwlink/?LinkId=166293).  
  
> [!NOTE]
>  PS 2.0 programy do cieniowania uruchamiane podczas renderowania w oprogramowaniu. Jednak nawet jeśli PS 3.0 jest obsługiwany przez sprzętu, programów do cieniowania PS 3.0 nie należy uruchamiać podczas renderowania oprogramowania.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak dziedziczyć <xref:System.Windows.Media.Effects.ShaderEffect> klasy.  
  
 [!code-csharp[System.Windows.Media.Effects.ShaderEffect#1](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Media.Effects.ShaderEffect/CS/ThresholdEffect.cs#1)]  
  
 Poniższy przykład kodu pokazuje modułem cieniującym, który odnosi się do poprzedniego <xref:System.Windows.Media.Effects.ShaderEffect> klasy.  
  
 [!code-csharp[System.Windows.Media.Effects.ShaderEffect#10](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Media.Effects.ShaderEffect/CS/Threshold.fx#10)]  
  
 Następujące XAML pokazuje, jak za pomocą efektu niestandardowego modułu cieniującego.  
  
 [!code-xaml[System.Windows.Media.Effects.ShaderEffect#1000](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Media.Effects.ShaderEffect/CS/Window1.xaml#1000)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać pełny dostęp do zasobów interfejsu użytkownika. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
    <altmember cref="T:System.Windows.Media.Effects.Effect" />
    <altmember cref="T:System.Windows.Media.Effects.PixelShader" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ShaderEffect ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ShaderEffect();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Media.Effects.ShaderEffect" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.ShaderEffect Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Effects.ShaderEffect Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As ShaderEffect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Effects::ShaderEffect ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Effects.ShaderEffect" Usage="shaderEffect.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.ShaderEffect</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy klon można modyfikować tego <see cref="T:System.Windows.Media.Effects.ShaderEffect" /> obiektu, tworzenie kopii głębokiego wartości tego obiektu. Kopiowanie właściwości zależności tego obiektu, ta metoda kopiuje zasobów odwołania i powiązania danych (które mogą być już rozpoznawane), ale nie animacji lub ich bieżącymi wartościami.</summary>
        <returns>Można modyfikować klonowania tego wystąpienia. Zwrócone klonowania jest faktycznie głęboką kopię bieżącego obiektu. Klonu <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Effects.ShaderEffect.Clone%2A> Metoda może służyć do utworzenia kopii można modyfikować zamrożone <xref:System.Windows.Freezable> obiektów. Dla wygody, ta metoda zasłania dziedziczonego <xref:System.Windows.Freezable.Clone%2A> metody, aby udostępnić silnie typizowaną implementację.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="shaderEffect.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Sprawia, że wystąpienie klonowania (głęboka kopia) określonego <see cref="T:System.Windows.Freezable" /> przy użyciu wartości podstawowej (bez animowane) właściwości.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.ShaderEffect CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Effects.ShaderEffect CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As ShaderEffect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Effects::ShaderEffect ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.Media.Effects.ShaderEffect" Usage="shaderEffect.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.ShaderEffect</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy klon można modyfikować tego <see cref="T:System.Windows.Media.Effects.ShaderEffect" /> obiektu, tworzenie kopii głębokiego wartości bieżących tego obiektu. Odwołania do zasobów, powiązań danych i animacji nie są kopiowane, ale ich bieżącymi wartościami są kopiowane.</summary>
        <returns>Można modyfikować klonowania bieżącego obiektu. Sklonowany obiekt <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość będzie miała <see langword="false" /> nawet wtedy, gdy źródło <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana do tworzenia kopii można modyfikować zamrożone <xref:System.Windows.Freezable> obiektów (lub dowolnego <xref:System.Windows.Freezable> obiektu). Dla wygody ta metoda zasłania dziedziczone wersji z silnie typizowaną implementację.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="shaderEffect.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><see cref="T:System.Windows.Freezable" /> Można sklonować.</param>
        <summary>Sprawia, że wystąpienie można modyfikować klonowania (głęboka kopia) określonego <see cref="T:System.Windows.Freezable" /> przy użyciu bieżącej wartości właściwości.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="shaderEffect.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Windows.Freezable" /> klasy pochodnej.</summary>
        <returns>Nowe wystąpienie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DdxUvDdyUvRegisterIndex">
      <MemberSignature Language="C#" Value="protected int DdxUvDdyUvRegisterIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DdxUvDdyUvRegisterIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Effects.ShaderEffect.DdxUvDdyUvRegisterIndex" />
      <MemberSignature Language="VB.NET" Value="Protected Property DdxUvDdyUvRegisterIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int DdxUvDdyUvRegisterIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DdxUvDdyUvRegisterIndex : int with get, set" Usage="System.Windows.Media.Effects.ShaderEffect.DdxUvDdyUvRegisterIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, rejestr cieniowania do użytku pochodnych częściowego współrzędnych tekstury w odniesieniu do miejsca na ekranie.</summary>
        <value>Indeks rejestru, który zawiera pochodne częściowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Media.Effects.ShaderEffect.DdxUvDdyUvRegisterIndex%2A> właściwości w celu określenia rejestru programu do cieniowania, który zawiera pochodne częściowego tekstury koordynuje względem miejsce na ekranie. Na przykład jeśli <xref:System.Windows.Media.Effects.ShaderEffect.DdxUvDdyUvRegisterIndex%2A> jest ustawiony na 4, c4 rejestr programu do cieniowania jest używany. C4 Rejestr zawiera cztery pola float. Poniższy kod High Level cieniowanie Language (HLSL) pokazuje, jak ten rejestr jest używany. `nextPixelUV` Wartość reprezentuje pikseli dalej z prawej strony.  
  
```  
float4 ddxUvDdyUv : register(c4);  
SamplerState  sampler : register(S0);  
...  
float2 nextPixelUV;  
nextPixelUV.u = ddxUvDdyUv.x + u;  
nextPixelUV.v = ddxUvDdyUv.y + v;  
  
tex2D(sampler, nextPixelUV);  
```  
  
 W poniższej tabeli przedstawiono, jak rejestr określony dla <xref:System.Windows.Media.Effects.ShaderEffect.DdxUvDdyUvRegisterIndex%2A> jest wypełnione.  
  
|Rejestrowanie — stała|Wartości pochodnych|  
|-----------------------|----------------------|  
|x składnika|ddx(u)|  
|składnik y|ddx(v)|  
|składnik z|ddy(u)|  
|w części|ddy(v)|  
  
 Współrzędne tekstury są wskazywane jako `(u, v)`. `ddx(u)` jest stałe pochodnej częściowego składnika współrzędnych tekstury `u` względem współrzędną x miejsca na ekranie. `ddy(u)` jest pochodną częściowego współrzędnej tekstury `u` względem współrzędną y miejsca na ekranie. Podobnie `ddx(v)` i `ddy(v)` są odpowiednie pochodne miejsce na ekranie dla składnika współrzędnych tekstury `v`.  
  
> [!NOTE]
>  HLSL ma ddx i ddy instrukcje do obliczania tych wartości, ale te instrukcje nie są dostępne na cały sprzęt PixelShader w wersji 2.0.  
  
 Te stałe mogą traktować w następujący sposób. Jeśli znajdujesz się 1 piksel w prawo w miejsce na ekranie (w kierunku x), następnie `ddx(u)` to ilość, `u` zmiany w przestrzeni tekstury i `ddx(v)` to ilość, `v` zmiany w przestrzeni tekstury. Jeśli efekt jest osi wyrównany podczas jego renderowania, następnie `ddx(v)` wynosi 0. Jeśli efekt jest obracana, gdy jest on renderowany, następnie `ddx(v)` jest różna od zera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić <see cref="P:System.Windows.Media.Effects.ShaderEffect.DdxUvDdyUvRegisterIndex" /> właściwości więcej niż jeden raz lub po przetworzeniu początkowego efektu.</exception>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.PixelShader" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="shaderEffect.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Wystąpienie do skopiowania.</param>
        <summary>Sprawia, że wystąpienie zamrożone klonowania określonego <see cref="T:System.Windows.Freezable" /> przy użyciu wartości podstawowej (bez animowane) właściwości.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="shaderEffect.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><see cref="T:System.Windows.Freezable" /> Do skopiowania i blokowanie.</param>
        <summary>Sprawia, że bieżące wystąpienie zamrożone klonowania określonego <see cref="T:System.Windows.Freezable" />. Jeśli obiekt ma właściwości animowany zależności, są kopiowane ich bieżącymi wartościami animowany.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="PaddingBottom">
      <MemberSignature Language="C#" Value="protected double PaddingBottom { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 PaddingBottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Effects.ShaderEffect.PaddingBottom" />
      <MemberSignature Language="VB.NET" Value="Protected Property PaddingBottom As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property double PaddingBottom { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.PaddingBottom : double with get, set" Usage="System.Windows.Media.Effects.ShaderEffect.PaddingBottom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy efekt wyjściowy tekstury jest większa niż jego danych wejściowych teksturę wzdłuż dolnej krawędzi.</summary>
        <value>Dopełnienie wzdłuż dolnej krawędzi efekt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="PaddingLeft">
      <MemberSignature Language="C#" Value="protected double PaddingLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 PaddingLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Effects.ShaderEffect.PaddingLeft" />
      <MemberSignature Language="VB.NET" Value="Protected Property PaddingLeft As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property double PaddingLeft { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.PaddingLeft : double with get, set" Usage="System.Windows.Media.Effects.ShaderEffect.PaddingLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy efekt wyjściowy tekstury jest większa niż jego danych wejściowych teksturę wzdłuż lewej krawędzi.</summary>
        <value>Dopełnienie wzdłuż lewej krawędzi efekt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="PaddingRight">
      <MemberSignature Language="C#" Value="protected double PaddingRight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 PaddingRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Effects.ShaderEffect.PaddingRight" />
      <MemberSignature Language="VB.NET" Value="Protected Property PaddingRight As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property double PaddingRight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.PaddingRight : double with get, set" Usage="System.Windows.Media.Effects.ShaderEffect.PaddingRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy efekt wyjściowy tekstury jest większa niż jego danych wejściowych teksturę wzdłuż prawej krawędzi.</summary>
        <value>Dopełnienie wzdłuż prawej krawędzi efekt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="PaddingTop">
      <MemberSignature Language="C#" Value="protected double PaddingTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 PaddingTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Effects.ShaderEffect.PaddingTop" />
      <MemberSignature Language="VB.NET" Value="Protected Property PaddingTop As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property double PaddingTop { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.PaddingTop : double with get, set" Usage="System.Windows.Media.Effects.ShaderEffect.PaddingTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy efekt wyjściowy tekstury jest większa niż jego danych wejściowych teksturę wzdłuż górnej krawędzi.</summary>
        <value>Dopełnienie wzdłuż górnej krawędzi efekt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="PixelShader">
      <MemberSignature Language="C#" Value="protected System.Windows.Media.Effects.PixelShader PixelShader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.PixelShader PixelShader" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Effects.ShaderEffect.PixelShader" />
      <MemberSignature Language="VB.NET" Value="Protected Property PixelShader As PixelShader" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Media::Effects::PixelShader ^ PixelShader { System::Windows::Media::Effects::PixelShader ^ get(); void set(System::Windows::Media::Effects::PixelShader ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PixelShader : System.Windows.Media.Effects.PixelShader with get, set" Usage="System.Windows.Media.Effects.ShaderEffect.PixelShader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.PixelShader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Effects.PixelShader" /> do użycia dla efektu.</summary>
        <value><see cref="T:System.Windows.Media.Effects.PixelShader" /> Dla efektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PixelShader"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Media.Effects.ShaderEffect.PixelShaderProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.PixelShader" />
      </Docs>
    </Member>
    <Member MemberName="PixelShaderConstantCallback">
      <MemberSignature Language="C#" Value="protected static System.Windows.PropertyChangedCallback PixelShaderConstantCallback (int floatRegisterIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.PropertyChangedCallback PixelShaderConstantCallback(int32 floatRegisterIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.PixelShaderConstantCallback(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function PixelShaderConstantCallback (floatRegisterIndex As Integer) As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::PropertyChangedCallback ^ PixelShaderConstantCallback(int floatRegisterIndex);" />
      <MemberSignature Language="F#" Value="static member PixelShaderConstantCallback : int -&gt; System.Windows.PropertyChangedCallback" Usage="System.Windows.Media.Effects.ShaderEffect.PixelShaderConstantCallback floatRegisterIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="floatRegisterIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="floatRegisterIndex">Indeks rejestr cieniowania skojarzony z właściwością zależności.</param>
        <summary>Kojarzy wartość właściwości zależności z rejestrem stałych zmiennoprzecinkowych do cieniowania pikseli.</summary>
        <returns>A <see cref="T:System.Windows.PropertyChangedCallback" /> delegat, który kojarzy właściwości zależności i rejestrowanie stałej modułu cieniującego, określony przez <paramref name="floatRegisterIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Media.Effects.ShaderEffect.PixelShaderConstantCallback%2A> metody, gdy Zarejestruj właściwości zależności dla stałej programu do cieniowania. <xref:System.Windows.Media.Effects.ShaderEffect.PixelShaderConstantCallback%2A> Metoda konstrukcje <xref:System.Windows.PropertyChangedCallback> delegowanie, gdy wywoływany, tworzy skojarzenie między właściwości zależności i rejestrowanie stałej modułu cieniującego, określony przez `floatRegisterIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość zależności jest nieznanego typu.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="floatRegisterIndex" /> jest większa niż lub równy 32, lub <paramref name="floatRegisterIndex" /> jest mniejszy niż 0.</exception>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.PixelShader" />
      </Docs>
    </Member>
    <Member MemberName="PixelShaderProperty">
      <MemberSignature Language="C#" Value="protected static readonly System.Windows.DependencyProperty PixelShaderProperty;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly class System.Windows.DependencyProperty PixelShaderProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Effects.ShaderEffect.PixelShaderProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly PixelShaderProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly System::Windows::DependencyProperty ^ PixelShaderProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PixelShaderProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Effects.ShaderEffect.PixelShaderProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Media.Effects.ShaderEffect.PixelShader" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.PixelShader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PixelShaderSamplerCallback">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kojarzy wartość właściwości zależności z rejestrem próbnik do cieniowania pikseli.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PixelShaderSamplerCallback">
      <MemberSignature Language="C#" Value="protected static System.Windows.PropertyChangedCallback PixelShaderSamplerCallback (int samplerRegisterIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.PropertyChangedCallback PixelShaderSamplerCallback(int32 samplerRegisterIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.PixelShaderSamplerCallback(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function PixelShaderSamplerCallback (samplerRegisterIndex As Integer) As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::PropertyChangedCallback ^ PixelShaderSamplerCallback(int samplerRegisterIndex);" />
      <MemberSignature Language="F#" Value="static member PixelShaderSamplerCallback : int -&gt; System.Windows.PropertyChangedCallback" Usage="System.Windows.Media.Effects.ShaderEffect.PixelShaderSamplerCallback samplerRegisterIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="samplerRegisterIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="samplerRegisterIndex">Indeks próbnika programu do cieniowania skojarzony z właściwością zależności.</param>
        <summary>Kojarzy wartość właściwości zależności z rejestrem próbnik do cieniowania pikseli.</summary>
        <returns>A <see cref="T:System.Windows.PropertyChangedCallback" /> delegat, który kojarzy właściwości zależności i rejestrowanie próbnika programu do cieniowania, które są określone przez <paramref name="samplerRegisterIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Media.Effects.ShaderEffect.PixelShaderSamplerCallback%2A> metody, gdy zarejestrujesz <xref:System.Windows.Media.Brush>-zwracająca właściwość zależności dla próbnika programu do cieniowania. <xref:System.Windows.Media.Effects.ShaderEffect.PixelShaderSamplerCallback%2A> Metoda konstrukcje <xref:System.Windows.PropertyChangedCallback> delegowanie, gdy wywoływany, tworzy skojarzenie między właściwości zależności i rejestrowanie próbnika programu do cieniowania, które są określone przez `samplerRegisterIndex`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.PixelShader" />
      </Docs>
    </Member>
    <Member MemberName="PixelShaderSamplerCallback">
      <MemberSignature Language="C#" Value="protected static System.Windows.PropertyChangedCallback PixelShaderSamplerCallback (int samplerRegisterIndex, System.Windows.Media.Effects.SamplingMode samplingMode);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.PropertyChangedCallback PixelShaderSamplerCallback(int32 samplerRegisterIndex, valuetype System.Windows.Media.Effects.SamplingMode samplingMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.PixelShaderSamplerCallback(System.Int32,System.Windows.Media.Effects.SamplingMode)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::PropertyChangedCallback ^ PixelShaderSamplerCallback(int samplerRegisterIndex, System::Windows::Media::Effects::SamplingMode samplingMode);" />
      <MemberSignature Language="F#" Value="static member PixelShaderSamplerCallback : int * System.Windows.Media.Effects.SamplingMode -&gt; System.Windows.PropertyChangedCallback" Usage="System.Windows.Media.Effects.ShaderEffect.PixelShaderSamplerCallback (samplerRegisterIndex, samplingMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="samplerRegisterIndex" Type="System.Int32" />
        <Parameter Name="samplingMode" Type="System.Windows.Media.Effects.SamplingMode" />
      </Parameters>
      <Docs>
        <param name="samplerRegisterIndex">Indeks próbnika programu do cieniowania skojarzony z właściwością zależności.</param>
        <param name="samplingMode"><see cref="T:System.Windows.Media.Effects.SamplingMode" /> Do próbnika programu do cieniowania.</param>
        <summary>Kojarzy wartość właściwości zależności z rejestrem próbnik do cieniowania pikseli i <see cref="T:System.Windows.Media.Effects.SamplingMode" />.</summary>
        <returns>A <see cref="T:System.Windows.PropertyChangedCallback" /> delegat, który kojarzy właściwości zależności i rejestrowanie próbnika programu do cieniowania, które są określone przez <paramref name="samplerRegisterIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Media.Effects.ShaderEffect.RegisterPixelShaderSamplerProperty%2A> metody, gdy zarejestrujesz <xref:System.Windows.Media.Brush>-zwracająca właściwość zależności dla próbnika programu do cieniowania. <xref:System.Windows.Media.Effects.ShaderEffect.RegisterPixelShaderSamplerProperty%2A> Metoda konstrukcje <xref:System.Windows.PropertyChangedCallback> delegowanie, gdy wywoływany, tworzy skojarzenie między właściwości zależności i rejestrowanie próbnika programu do cieniowania, które są określone przez `samplerRegisterIndex`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.PixelShader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterPixelShaderSamplerProperty">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kojarzy właściwości zależności z rejestrem próbnika programu do cieniowania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterPixelShaderSamplerProperty">
      <MemberSignature Language="C#" Value="protected static System.Windows.DependencyProperty RegisterPixelShaderSamplerProperty (string dpName, Type ownerType, int samplerRegisterIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.DependencyProperty RegisterPixelShaderSamplerProperty(string dpName, class System.Type ownerType, int32 samplerRegisterIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.RegisterPixelShaderSamplerProperty(System.String,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function RegisterPixelShaderSamplerProperty (dpName As String, ownerType As Type, samplerRegisterIndex As Integer) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::DependencyProperty ^ RegisterPixelShaderSamplerProperty(System::String ^ dpName, Type ^ ownerType, int samplerRegisterIndex);" />
      <MemberSignature Language="F#" Value="static member RegisterPixelShaderSamplerProperty : string * Type * int -&gt; System.Windows.DependencyProperty" Usage="System.Windows.Media.Effects.ShaderEffect.RegisterPixelShaderSamplerProperty (dpName, ownerType, samplerRegisterIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dpName" Type="System.String" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="samplerRegisterIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dpName">Nazwa właściwości zależności.</param>
        <param name="ownerType">Typ wpływ, jaki ma właściwość zależności.</param>
        <param name="samplerRegisterIndex">Indeks próbnika programu do cieniowania skojarzony z właściwością zależności.</param>
        <summary>Kojarzy właściwości zależności z rejestrem próbnika programu do cieniowania.</summary>
        <returns>Właściwości zależności skojarzony z próbnikiem programu do cieniowania, określony przez <paramref name="samplerRegisterIndex" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.PixelShader" />
      </Docs>
    </Member>
    <Member MemberName="RegisterPixelShaderSamplerProperty">
      <MemberSignature Language="C#" Value="protected static System.Windows.DependencyProperty RegisterPixelShaderSamplerProperty (string dpName, Type ownerType, int samplerRegisterIndex, System.Windows.Media.Effects.SamplingMode samplingMode);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.DependencyProperty RegisterPixelShaderSamplerProperty(string dpName, class System.Type ownerType, int32 samplerRegisterIndex, valuetype System.Windows.Media.Effects.SamplingMode samplingMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.RegisterPixelShaderSamplerProperty(System.String,System.Type,System.Int32,System.Windows.Media.Effects.SamplingMode)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::DependencyProperty ^ RegisterPixelShaderSamplerProperty(System::String ^ dpName, Type ^ ownerType, int samplerRegisterIndex, System::Windows::Media::Effects::SamplingMode samplingMode);" />
      <MemberSignature Language="F#" Value="static member RegisterPixelShaderSamplerProperty : string * Type * int * System.Windows.Media.Effects.SamplingMode -&gt; System.Windows.DependencyProperty" Usage="System.Windows.Media.Effects.ShaderEffect.RegisterPixelShaderSamplerProperty (dpName, ownerType, samplerRegisterIndex, samplingMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dpName" Type="System.String" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="samplerRegisterIndex" Type="System.Int32" />
        <Parameter Name="samplingMode" Type="System.Windows.Media.Effects.SamplingMode" />
      </Parameters>
      <Docs>
        <param name="dpName">Nazwa właściwości zależności.</param>
        <param name="ownerType">Typ wpływ, jaki ma właściwość zależności.</param>
        <param name="samplerRegisterIndex">Indeks próbnika programu do cieniowania skojarzony z właściwością zależności.</param>
        <param name="samplingMode"><see cref="T:System.Windows.Media.Effects.SamplingMode" /> Do próbnika programu do cieniowania.</param>
        <summary>Kojarzy właściwości zależności z rejestrem próbnika programu do cieniowania i <see cref="T:System.Windows.Media.Effects.SamplingMode" />.</summary>
        <returns>Właściwości zależności skojarzony z próbnikiem programu do cieniowania, określony przez <paramref name="samplerRegisterIndex" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.PixelShader" />
      </Docs>
    </Member>
    <Member MemberName="UpdateShaderValue">
      <MemberSignature Language="C#" Value="protected void UpdateShaderValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateShaderValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Effects.ShaderEffect.UpdateShaderValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateShaderValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateShaderValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.UpdateShaderValue : System.Windows.DependencyProperty -&gt; unit" Usage="shaderEffect.UpdateShaderValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwości zależności do zaktualizowania.</param>
        <summary>Powiadamia efekt, że stała programu do cieniowania lub próbnika odpowiadającą właściwość określona zależność powinien zostać zaktualizowany.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.PixelShader" />
      </Docs>
    </Member>
  </Members>
</Type>
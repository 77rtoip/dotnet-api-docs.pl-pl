<Type Name="RSACryptoServiceProvider" FullName="System.Security.Cryptography.RSACryptoServiceProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bfe362923836f8d655205816ab48c0277ab4a988" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30570841" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RSACryptoServiceProvider : System.Security.Cryptography.RSA, System.Security.Cryptography.ICspAsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RSACryptoServiceProvider extends System.Security.Cryptography.RSA implements class System.Security.Cryptography.ICspAsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.RSACryptoServiceProvider" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RSACryptoServiceProvider&#xA;Inherits RSA&#xA;Implements ICspAsymmetricAlgorithm" />
  <TypeSignature Language="C++ CLI" Value="public ref class RSACryptoServiceProvider sealed : System::Security::Cryptography::RSA, System::Security::Cryptography::ICspAsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.RSA</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.Cryptography.ICspAsymmetricAlgorithm</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wykonuje szyfrowanie asymetryczne i odszyfrowywania przy użyciu implementacji <see cref="T:System.Security.Cryptography.RSA" /> algorytm dostarczonych przez dostawcę usług kryptograficznych (CSP). Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest domyślna implementacja <xref:System.Security.Cryptography.RSA>.  
  
 <xref:System.Security.Cryptography.RSACryptoServiceProvider> Obsługuje rozmiary kluczy z 384 bitów dla usługi bits 16384 w przyrostach 8 bitów, jeśli masz rozszerzony dostawca usług kryptograficznych Microsoft zainstalowane.  Obsługuje ona rozmiary kluczy z 384 bitów do 512 bitów w przyrostach 8 bitów Jeśli masz Microsoft Base Cryptographic Provider zainstalowane.  
  
 Prawidłowe rozmiary klucza są zależne od dostawcy usług kryptograficznych (CSP), który jest używany przez <xref:System.Security.Cryptography.RSACryptoServiceProvider> wystąpienia. Włącz dostawców usług kryptograficznych systemu Windows klucze rozmiary bitów 384 i 16384 dla wersji systemu Windows starszych niż [!INCLUDE[win81](~/includes/win81-md.md)]i rozmiary bitów 512 do 16384 dla klucza [!INCLUDE[win81](~/includes/win81-md.md)]. Aby uzyskać więcej informacji, zobacz [CryptGenKey](http://msdn.microsoft.com/library/aa379941\(v=vs.85\).aspx) funkcji w dokumentacji systemu Windows.  
  
## <a name="interoperation-with-the-microsoft-cryptographic-api-capi"></a>Współpraca z interfejsem Microsoft Cryptographic API (CAPI)  
 W odróżnieniu od implementacji RSA w niezarządzanych CAPI <xref:System.Security.Cryptography.RSACryptoServiceProvider> klasy Odwraca kolejność zaszyfrowanych tablicę bajtów po szyfrowania i przed odszyfrowywania.  Domyślnie dane są szyfrowane za pomocą <xref:System.Security.Cryptography.RSACryptoServiceProvider> klasy nie może odszyfrować CAPI `CryptDecrypt` funkcji i dane zaszyfrowane przy CAPI `CryptEncrypt` — metoda nie może odszyfrować <xref:System.Security.Cryptography.RSACryptoServiceProvider> klasy.  
  
 Jeśli nie kompensuje odwrotnej kolejności podczas współpracy między interfejsów API, <xref:System.Security.Cryptography.RSACryptoServiceProvider> klasy zgłasza <xref:System.Security.Cryptography.CryptographicException>.  
  
 Współdziałanie z CAPI, należy ręcznie odwracania kolejności bajtów zaszyfrowanego przed zaszyfrowanych danych współdziała z innego interfejsu API.  Można łatwo odwrócić kolejność tablicy bajtów z zarządzanego przez wywołanie metody <xref:System.Array.Reverse%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Security.Cryptography.RSACryptoServiceProvider> klasy do szyfrowania ciąg na tablicę bajtów i odszyfrować bajtów na ciąg.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/VB/sample.vb#1)]  
  
 Poniższy przykład kodu Eksportuje informacje o kluczu utworzone za pomocą <xref:System.Security.Cryptography.RSACryptoServiceProvider> do <xref:System.Security.Cryptography.RSAParameters> obiektu.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/VB/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RSACryptoServiceProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> przy użyciu domyślnego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zostanie znaleziony żaden klucz domyślny, tworzony jest nowy klucz.  
  
 Ten konstruktor tworzy <xref:System.Security.Cryptography.KeyNumber.Exchange> pary kluczy do szyfrowania sesji klucze, dzięki czemu można je bezpiecznie przechowywane i wymieniane z innymi użytkownikami.  Wygenerowany klucz odpowiada kluczowi wygenerowanych przy użyciu `AT_KEYEXCHANGE` wartość używana w niezarządzanych Microsoft kryptograficznego interfejsu API (CAPI).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Security.Cryptography.RSACryptoServiceProvider> klasy do szyfrowania ciąg na tablicę bajtów i odszyfrować bajtów na ciąg.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można uzyskać dostawcy usług kryptograficznych (CSP).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider (int dwKeySize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 dwKeySize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dwKeySize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RSACryptoServiceProvider(int dwKeySize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dwKeySize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dwKeySize">Rozmiar klucza w bitach.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> klasy z określonym rozmiarem klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zostanie znaleziony żaden klucz domyślny, tworzony jest nowy klucz.  
  
 Ten konstruktor tworzy <xref:System.Security.Cryptography.KeyNumber.Exchange> pary kluczy do szyfrowania sesji klucze, dzięki czemu można je bezpiecznie przechowywane i wymieniane z innymi użytkownikami.  Wygenerowany klucz odpowiada kluczowi wygenerowanych przy użyciu `AT_KEYEXCHANGE` wartość używana w niezarządzanych Microsoft kryptograficznego interfejsu API (CAPI).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Security.Cryptography.RSACryptoServiceProvider>, generuje nowy klucz i zapisze go w kontenerze kluczy.  
  
 [!code-cpp[Cryptography.RSACSP.ctor-int32-2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-2/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.ctor-int32-2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-2/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.ctor-int32-2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można uzyskać dostawcy usług kryptograficznych (CSP).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider (System.Security.Cryptography.CspParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.CspParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor(System.Security.Cryptography.CspParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parameters As CspParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RSACryptoServiceProvider(System::Security::Cryptography::CspParameters ^ parameters);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">Parametry do przekazania do dostawcy usług kryptograficznych (CSP).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> klasy z określonymi parametrami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy lub ponownie używa kontenera kluczy określona za pomocą <xref:System.Security.Cryptography.CspParameters.KeyContainerName> pole `parameters` parametru.  
  
 Domyślnie ten konstruktor tworzy <xref:System.Security.Cryptography.KeyNumber.Exchange> pary kluczy do szyfrowania sesji klucze, dzięki czemu można je bezpiecznie przechowywane i wymieniane z innymi użytkownikami.  Wygenerowany klucz odpowiada kluczowi wygenerowanych przy użyciu `AT_KEYEXCHANGE` wartość używana w niezarządzanych Microsoft kryptograficznego interfejsu API (CAPI).  
  
 Można utworzyć <xref:System.Security.Cryptography.KeyNumber.Signature> odpowiedniego uwierzytelniania wiadomości (podpisanych cyfrowo) lub plików przez ustawienie parę kluczy <xref:System.Security.Cryptography.CspParameters.KeyNumber> pole `parameters` parametr <xref:System.Security.Cryptography.KeyNumber.Signature> wartość. Ten typ klucza odpowiada `AT_SIGNATURE` wartość używana w CAPI.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiekt z <xref:System.Security.Cryptography.KeyNumber.Exchange> określona wartość, a następnie utworzyć inną <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiekt z <xref:System.Security.Cryptography.KeyNumber.Signature> określona wartość obydwu kluczy zostaną umieszczone w jeden kontener, jeśli oba obiekty określała tę samą nazwę kontenera kluczy .  
  
 Aby utworzyć klucz, który jest zgodny z nazwą stong podpisywanie przy użyciu <xref:System.Security.Cryptography.RSACryptoServiceProvider> klasy, należy utworzyć <xref:System.Security.Cryptography.KeyNumber.Signature> parę kluczy.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiektu, generuje nowy klucz i zapisuje go w klucz kontenera.  
  
 [!code-cpp[Cryptography.RSACSP.ctor-csp#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-csp/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.ctor-csp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-csp/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.ctor-csp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.ctor-csp/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można uzyskać dostawcy usług Kryptograficznych.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider (int dwKeySize, System.Security.Cryptography.CspParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 dwKeySize, class System.Security.Cryptography.CspParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor(System.Int32,System.Security.Cryptography.CspParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dwKeySize As Integer, parameters As CspParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RSACryptoServiceProvider(int dwKeySize, System::Security::Cryptography::CspParameters ^ parameters);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dwKeySize" Type="System.Int32" />
        <Parameter Name="parameters" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="dwKeySize">Rozmiar klucza w bitach.</param>
        <param name="parameters">Parametry do przekazania do dostawcy usług kryptograficznych (CSP).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> z określonego rozmiaru klucza i parametry.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy lub ponownie używa kontenera kluczy określona za pomocą <xref:System.Security.Cryptography.CspParameters.KeyContainerName> pole `parameters` parametru.  
  
 Domyślnie ten konstruktor tworzy <xref:System.Security.Cryptography.KeyNumber.Exchange> pary kluczy do szyfrowania sesji klucze, dzięki czemu można je bezpiecznie przechowywane i wymieniane z innymi użytkownikami.  Wygenerowany klucz odpowiada kluczowi wygenerowanych przy użyciu `AT_KEYEXCHANGE` wartość używana w niezarządzanych Microsoft kryptograficznego interfejsu API (CAPI).  
  
 Można utworzyć <xref:System.Security.Cryptography.KeyNumber.Signature> odpowiedniego uwierzytelniania wiadomości (podpisanych cyfrowo) lub plików przez ustawienie parę kluczy <xref:System.Security.Cryptography.CspParameters.KeyNumber> pole `parameters` parametr <xref:System.Security.Cryptography.KeyNumber.Signature> wartość. Ten typ klucza odpowiada `AT_SIGNATURE` wartość używana w CAPI.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiekt z <xref:System.Security.Cryptography.KeyNumber.Exchange> określona wartość, a następnie utworzyć inną <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiekt z <xref:System.Security.Cryptography.KeyNumber.Signature> określona wartość obydwu kluczy zostaną umieszczone w jeden kontener, jeśli oba obiekty określała tę samą nazwę kontenera kluczy .  
  
 Aby utworzyć klucz, który jest zgodny z nazwą stong podpisywanie przy użyciu <xref:System.Security.Cryptography.RSACryptoServiceProvider> klasy, należy utworzyć <xref:System.Security.Cryptography.KeyNumber.Signature> parę kluczy.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Security.Cryptography.RSACryptoServiceProvider>, generuje nowy klucz i zapisze go w kontenerze kluczy.  
  
 [!code-cpp[Cryptography.RSACSP.ctor-int32-csp#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-csp/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.ctor-int32-csp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-csp/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.ctor-int32-csp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-csp/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można uzyskać dostawcy usług Kryptograficznych.  
  
 —lub—  
  
 Nie można utworzyć klucza.</exception>
      </Docs>
    </Member>
    <Member MemberName="CspKeyContainerInfo">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CspKeyContainerInfo CspKeyContainerInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CspKeyContainerInfo CspKeyContainerInfo" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.CspKeyContainerInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CspKeyContainerInfo As CspKeyContainerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CspKeyContainerInfo ^ CspKeyContainerInfo { System::Security::Cryptography::CspKeyContainerInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Cryptography.ICspAsymmetricAlgorithm.CspKeyContainerInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CspKeyContainerInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.Cryptography.CspKeyContainerInfo" /> obiektu, który opisuje dodatkowe informacje na temat klucza kryptograficznego.</summary>
        <value>A <see cref="T:System.Security.Cryptography.CspKeyContainerInfo" /> obiektu, który opisuje dodatkowe informacje na temat klucza kryptograficznego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Security.Cryptography.RSACryptoServiceProvider.CspKeyContainerInfo%2A> właściwości można pobrać dodatkowe informacje na temat klucza kryptograficznego.  Zwrócona <xref:System.Security.Cryptography.CspKeyContainerInfo> obiektu opisuje czy można wyeksportować klucza i określa nazwę kontenera klucza, informacji o dostawcy i inne informacje.  
  
 W przypadkach, gdy losowy klucz jest generowany kontener kluczy nie zostaną utworzone do czasu wywołania metody, która używa klucza.  Niektóre właściwości <xref:System.Security.Cryptography.CspKeyContainerInfo> obiektu zwróconego przez <xref:System.Security.Cryptography.DSACryptoServiceProvider.CspKeyContainerInfo%2A> zgłosi właściwość <xref:System.Security.Cryptography.CryptographicException> , gdy kontener kluczy nie została utworzona.  Aby upewnić się, że utworzono kontener klucza, wywołanie metody takie jak <xref:System.Security.Cryptography.RSACryptoServiceProvider.Encrypt%2A>, <xref:System.Security.Cryptography.RSACryptoServiceProvider.Decrypt%2A>, <xref:System.Security.Cryptography.RSACryptoServiceProvider.SignData%2A>, <xref:System.Security.Cryptography.DSACryptoServiceProvider.SignHash%2A>i tak dalej przed wywołaniem <xref:System.Security.Cryptography.DSACryptoServiceProvider.CspKeyContainerInfo%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób wywoływania <xref:System.Security.Cryptography.CspKeyContainerInfo> właściwości.  
  
 [!code-cpp[Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo/CPP/sample.cpp#1)]
 [!code-csharp[Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo/CS/sample.cs#1)]
 [!code-vb[Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrypt">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odszyfrowuje dane, która została zaszyfrowana wcześniej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public byte[] Decrypt (byte[] rgb, bool fOAEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Decrypt(unsigned int8[] rgb, bool fOAEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Decrypt(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Decrypt (rgb As Byte(), fOAEP As Boolean) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Decrypt(cli::array &lt;System::Byte&gt; ^ rgb, bool fOAEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
        <Parameter Name="fOAEP" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rgb">Dane do odszyfrowania.</param>
        <param name="fOAEP">
          <see langword="true" /> Aby wykonać bezpośrednio <see cref="T:System.Security.Cryptography.RSA" /> odszyfrowywania przy użyciu uzupełniania OAEP (tylko dostępne na komputerze z systemem Microsoft Windows XP lub nowszy); w przeciwnym razie <see langword="false" /> umożliwia uzupełnienie 1.5 PKCS #1.</param>
        <summary>Odszyfrowuje dane z <see cref="T:System.Security.Cryptography.RSA" /> algorytmu.</summary>
        <returns>Odszyfrowane dane, która jest oryginalnym tekstem zwykłym przed szyfrowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Security.Cryptography.RSACryptoServiceProvider.Encrypt%2A> do szyfrowania danych do odszyfrowywania przy użyciu tej metody.  
  
   
  
## Examples  
 Poniższy przykład kodu szyfruje i odszyfrowuje dane.  
  
 W tym przykładzie użyto <xref:System.Text.ASCIIEncoding> klasy; jednak <xref:System.Text.UnicodeEncoding> klasy może być preferowana w operacjach dużej ilości danych. Zaszyfrowaną wartość mogą zostać zapisane jako `nvarchar` typ danych w programie Microsoft SQL Server 2005.  
  
 [!code-cpp[Cryptography.RSACSP.Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.Decrypt/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.Decrypt/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.Decrypt/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można uzyskać dostawcy usług kryptograficznych (CSP).  
  
 —lub—  
  
 <paramref name="fOAEP" /> Parametr jest <see langword="true" /> i długość <paramref name="rgb" /> parametru jest większa niż <see cref="P:System.Security.Cryptography.RSACryptoServiceProvider.KeySize" />.  
  
 —lub—  
  
 <paramref name="fOAEP" /> Parametr jest <see langword="true" /> i OAEP nie jest obsługiwany.  
  
 —lub—  
  
 Klucz jest niezgodny z zaszyfrowanych danych. Jednak treść wyjątku nie może być niedokładna. Na przykład może wskazywać <c>w magazynie brak dostępnych do przetworzenia tego polecenia</c>.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rgb" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">Aby uzyskać uprawnienia do odszyfrowania. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Decrypt" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public override byte[] Decrypt (byte[] data, System.Security.Cryptography.RSAEncryptionPadding padding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] Decrypt(unsigned int8[] data, class System.Security.Cryptography.RSAEncryptionPadding padding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Decrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Decrypt (data As Byte(), padding As RSAEncryptionPadding) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ Decrypt(cli::array &lt;System::Byte&gt; ^ data, System::Security::Cryptography::RSAEncryptionPadding ^ padding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="padding" Type="System.Security.Cryptography.RSAEncryptionPadding" />
      </Parameters>
      <Docs>
        <param name="data">Dane do odszyfrowania.</param>
        <param name="padding">Dopełnienie.</param>
        <summary>Odszyfrowuje dane, które wcześniej były zaszyfrowane za pomocą <see cref="T:System.Security.Cryptography.RSA" /> algorytm przy użyciu określonego dopełnienia.</summary>
        <returns>Odszyfrowane dane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `padding` musi być równa albo <xref:System.Security.Cryptography.RSAEncryptionPadding.Pkcs1%2A?displayProperty=nameWithType> lub <xref:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA1%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="data" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="padding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Tryb uzupełniania jest nieobsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecryptValue">
      <MemberSignature Language="C#" Value="public override byte[] DecryptValue (byte[] rgb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DecryptValue(unsigned int8[] rgb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.DecryptValue(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DecryptValue (rgb As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DecryptValue(cli::array &lt;System::Byte&gt; ^ rgb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgb">Dane do odszyfrowania.</param>
        <summary>Ta metoda nie jest obsługiwana w bieżącej wersji.</summary>
        <returns>Odszyfrowane dane, która jest oryginalnym tekstem zwykłym przed szyfrowania.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obsługiwana w bieżącej wersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Encrypt">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Szyfruje dane z <see cref="T:System.Security.Cryptography.RSA" /> algorytmu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public byte[] Encrypt (byte[] rgb, bool fOAEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Encrypt(unsigned int8[] rgb, bool fOAEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Encrypt(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Encrypt (rgb As Byte(), fOAEP As Boolean) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Encrypt(cli::array &lt;System::Byte&gt; ^ rgb, bool fOAEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
        <Parameter Name="fOAEP" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rgb">Do szyfrowania danych.</param>
        <param name="fOAEP">
          <see langword="true" /> Aby wykonać bezpośrednio <see cref="T:System.Security.Cryptography.RSA" /> szyfrowanie przy użyciu uzupełniania OAEP (tylko dostępne na komputerze z systemem Windows XP lub nowszy); w przeciwnym razie <see langword="false" /> umożliwia uzupełnienie 1.5 PKCS #1.</param>
        <summary>Szyfruje dane z <see cref="T:System.Security.Cryptography.RSA" /> algorytmu.</summary>
        <returns>Zaszyfrowanych danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli opisano uzupełnienie obsługiwanych przez różne wersje systemu Microsoft Windows, a maksymalna długość `rgb` dozwolone przez różne kombinacje systemów operacyjnych i wypełnieniem.  
  
|Dopełnienie|System operacyjny obsługiwany|Maksymalna długość parametru rgb|  
|-------------|--------------------------------|-------------------------------------|  
|Uzupełniania OAEP (PKCS #1 v2)|Windows XP lub nowszym.|Modulo rozmiaru -2-2 * hLen, gdzie hLen jest większy niż wartość skrótu.|  
|Bezpośrednie szyfrowania (PKCS #1 w wersji 1.5)|Microsoft Windows 2000 lub nowszym z zainstalowany pakiet silnego szyfrowania.|Rozmiar modulo - 11. (11 bajtów jest minimalnym uzupełnianie możliwe).|  
|Bezpośrednie szyfrowania i OAEP uzupełnienie nie jest obsługiwane|Microsoft Windows 98, Windows Millennium Edition lub Windows 2000 lub nowszym bez zainstalowany pakiet silnego szyfrowania.|Maksymalny rozmiar dozwolony dla klucza symetrycznego.|  
  
 Użyj <xref:System.Security.Cryptography.RSACryptoServiceProvider.Decrypt%2A> do odszyfrowania wyniki tej metody.  
  
   
  
## Examples  
 Poniższy kod przykładowy inicjuje <xref:System.Security.Cryptography.RSACryptoServiceProvider> generuje obiekt z wartością klucza publicznego (wysyłane przez inną firmę), sesji klucza przy użyciu <xref:System.Security.Cryptography.RijndaelManaged> algorytmu, a następnie są szyfrowane w sesji klucza przy użyciu <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiektu.  Zastosowanie tego schematu, klucz sesji mógł zostać wysłany do właściciela prywatnego klucza RSA i obie strony może użyć klucza sesji do wymiany zaszyfrowanych danych.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider.Encrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.Encrypt/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider.Encrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.Encrypt/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider.Encrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.Encrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można uzyskać dostawcy usług kryptograficznych (CSP).  
  
 —lub—  
  
 Długość <paramref name="rgb" /> parametru jest większa niż maksymalna dozwolona długość.  
  
 —lub—  
  
 <paramref name="fOAEP" /> Parametr jest <see langword="true" /> i uzupełniania OAEP nie jest obsługiwany.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rgb" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public override byte[] Encrypt (byte[] data, System.Security.Cryptography.RSAEncryptionPadding padding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] Encrypt(unsigned int8[] data, class System.Security.Cryptography.RSAEncryptionPadding padding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Encrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Encrypt (data As Byte(), padding As RSAEncryptionPadding) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ Encrypt(cli::array &lt;System::Byte&gt; ^ data, System::Security::Cryptography::RSAEncryptionPadding ^ padding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="padding" Type="System.Security.Cryptography.RSAEncryptionPadding" />
      </Parameters>
      <Docs>
        <param name="data">Dane do zaszyfrowania.</param>
        <param name="padding">Dopełnienie.</param>
        <summary>Szyfruje dane z <see cref="T:System.Security.Cryptography.RSA" /> algorytm za pomocą określonego wypełnienia.</summary>
        <returns>Zaszyfrowanych danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `padding` musi być równa albo <xref:System.Security.Cryptography.RSAEncryptionPadding.Pkcs1%2A?displayProperty=nameWithType> lub <xref:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA1%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="data" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="padding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Tryb uzupełniania jest nieobsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="EncryptValue">
      <MemberSignature Language="C#" Value="public override byte[] EncryptValue (byte[] rgb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] EncryptValue(unsigned int8[] rgb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.EncryptValue(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EncryptValue (rgb As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ EncryptValue(cli::array &lt;System::Byte&gt; ^ rgb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgb">Do szyfrowania danych.</param>
        <summary>Ta metoda nie jest obsługiwana w bieżącej wersji.</summary>
        <returns>Zaszyfrowanych danych.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obsługiwana w bieżącej wersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExportCspBlob">
      <MemberSignature Language="C#" Value="public byte[] ExportCspBlob (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportCspBlob(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.ExportCspBlob(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExportCspBlob (includePrivateParameters As Boolean) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportCspBlob(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.Cryptography.ICspAsymmetricAlgorithm.ExportCspBlob(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <see langword="true" /> Aby uwzględnić klucz prywatny; w przeciwnym razie <see langword="false" />.</param>
        <summary>Eksportuje obiektu blob zawierającego informacje o kluczu skojarzone z <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> obiektu.</summary>
        <returns>Tablica bajtów zawierająca informacje o kluczu skojarzone z <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.RSACryptoServiceProvider.ExportCspBlob%2A> Metoda zwraca obiekt blob zawierający informacje o kluczu, który jest zgodny z niezarządzanego Microsoft kryptograficznego interfejsu API (CAPI).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">uprawnienia dostępu do kontenera kluczy podczas eksportowania klucza prywatnego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Export" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.RSAParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Security.Cryptography.RSAParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ExportParameters (includePrivateParameters As Boolean) As RSAParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::RSAParameters ExportParameters(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.RSAParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <see langword="true" /> Aby uwzględnić parametry prywatny; w przeciwnym razie <see langword="false" />.</param>
        <summary>Eksporty <see cref="T:System.Security.Cryptography.RSAParameters" />.</summary>
        <returns>Parametry <see cref="T:System.Security.Cryptography.RSA" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu Eksportuje informacje o kluczu utworzone za pomocą <xref:System.Security.Cryptography.RSACryptoServiceProvider> do <xref:System.Security.Cryptography.RSAParameters> obiektu.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można wyeksportować klucza.</exception>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">Aby uzyskać uprawnienia do eksportowania klucza. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Export" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~RSACryptoServiceProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!RSACryptoServiceProvider ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashData">
      <MemberSignature Language="C#" Value="protected override byte[] HashData (System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance unsigned int8[] HashData(class System.IO.Stream data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HashData (data As Stream, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override cli::array &lt;System::Byte&gt; ^ HashData(System::IO::Stream ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="data">To be added.</param>
        <param name="hashAlgorithm">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashData">
      <MemberSignature Language="C#" Value="protected override byte[] HashData (byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance unsigned int8[] HashData(unsigned int8[] data, int32 offset, int32 count, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HashData (data As Byte(), offset As Integer, count As Integer, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override cli::array &lt;System::Byte&gt; ^ HashData(cli::array &lt;System::Byte&gt; ^ data, int offset, int count, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="data">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="hashAlgorithm">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportCspBlob">
      <MemberSignature Language="C#" Value="public void ImportCspBlob (byte[] keyBlob);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportCspBlob(unsigned int8[] keyBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.ImportCspBlob(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportCspBlob (keyBlob As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportCspBlob(cli::array &lt;System::Byte&gt; ^ keyBlob);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.Cryptography.ICspAsymmetricAlgorithm.ImportCspBlob(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="keyBlob">Tablica bajtów, który reprezentuje obiektu blob klucza RSA.</param>
        <summary>Importuje obiektu blob reprezentującą informacje klucza RSA.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.RSACryptoServiceProvider.ImportCspBlob%2A> Metoda inicjuje dane klucza z <xref:System.Security.Cryptography.RSACryptoServiceProvider> przy użyciu obiektu blob, który jest zgodny z niezarządzanego Microsoft kryptograficznego interfejsu API (CAPI).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">uprawnienia dostępu do kontenera kluczy podczas importowania klucza. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Import" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public override void ImportParameters (System.Security.Cryptography.RSAParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportParameters(valuetype System.Security.Cryptography.RSAParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters(System.Security.Cryptography.RSAParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportParameters (parameters As RSAParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportParameters(System::Security::Cryptography::RSAParameters parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.RSAParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">Parametry <see cref="T:System.Security.Cryptography.RSA" />.</param>
        <summary>Importuje określonego <see cref="T:System.Security.Cryptography.RSAParameters" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod importuje informacje o kluczu utworzone na podstawie <xref:System.Security.Cryptography.RSAParameters> obiekt do <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiektu.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ImportParameters/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ImportParameters/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ImportParameters/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można uzyskać dostawcy usług kryptograficznych (CSP).  
  
 —lub—  
  
 <paramref name="parameters" /> Parametr ma brakujące pola.</exception>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">Aby uzyskać uprawnienia do importowania klucza. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Import" /></permission>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property KeyExchangeAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyExchangeAlgorithm { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę dostępne Algorytm wymiany kluczy z tą implementacją elementu <see cref="T:System.Security.Cryptography.RSA" />.</summary>
        <value>Nazwa algorytmu wymiany kluczy, jeśli istnieje; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość wskazuje nazwę algorytmu, a nie typu. Na przykład RSA-PKCS1-KeyEx jest nazwa algorytmu wymiany kluczy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeySize">
      <MemberSignature Language="C#" Value="public override int KeySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeySize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.KeySize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property KeySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar bieżącego klucza.</summary>
        <value>Rozmiar klucza w bitach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.RSACryptoServiceProvider> Obsługuje rozmiary kluczy z 384 bitów dla usługi bits 16384 w przyrostach 8 bitów, jeśli masz rozszerzony dostawca usług kryptograficznych Microsoft zainstalowane.  Obsługuje ona rozmiary kluczy z 384 bitów do 512 bitów w przyrostach 8 bitów Jeśli masz Microsoft Base Cryptographic Provider zainstalowane.  
  
 Prawidłowe rozmiary klucza są zależne od dostawcy usług kryptograficznych (CSP), który jest używany przez <xref:System.Security.Cryptography.RSACryptoServiceProvider> wystąpienia. Dostawcy usług kryptograficznych systemu Windows Włącz klucze kryptograficzne bitów 384 i 16384 dla wersji systemu Windows starszych niż [!INCLUDE[win81](~/includes/win81-md.md)]i rozmiary bitów 512 do 16384 dla klucza [!INCLUDE[win81](~/includes/win81-md.md)]. Aby uzyskać więcej informacji, zobacz [CryptGenKey](http://msdn.microsoft.com/library/aa379941\(v=vs.85\).aspx) funkcji w dokumentacji systemu Windows.  
  
 <xref:System.Security.Cryptography.RSACryptoServiceProvider> Klasy nie umożliwiają zmianę rozmiar klucza przy użyciu <xref:System.Security.Cryptography.RSACryptoServiceProvider.KeySize%2A> właściwości.  Wartości zapisane do tej właściwości zakończy się niepowodzeniem zaktualizować właściwości bez błędów.  Aby zmienić rozmiar klucza, użyj jednego z przeciążeń konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LegalKeySizes">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.KeySizes[] LegalKeySizes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.KeySizes[] LegalKeySizes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.LegalKeySizes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LegalKeySizes As KeySizes()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalKeySizes { cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistKeyInCsp">
      <MemberSignature Language="C#" Value="public bool PersistKeyInCsp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PersistKeyInCsp" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.PersistKeyInCsp" />
      <MemberSignature Language="VB.NET" Value="Public Property PersistKeyInCsp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PersistKeyInCsp { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy klucz powinien być utrwalone w dostawcy usług kryptograficznych (CSP).</summary>
        <value>
          <see langword="true" /> Jeśli klucz powinien być utrwalone w dostawcy usług Kryptograficznych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do utrwalenia klucza w kontenerze kluczy.  
  
 <xref:System.Security.Cryptography.RSACryptoServiceProvider.PersistKeyInCsp%2A> Jest automatycznie ustawiana właściwość `true` po określeniu nazwy kontenera kluczy, w <xref:System.Security.Cryptography.CspParameters.KeyContainerName> pole <xref:System.Security.Cryptography.CspParameters> obiektu i użyj go, aby zainicjować <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiektu przez wywoływanie jednej z konstruktorów z `parameters`parametru.  
  
 <xref:System.Security.Cryptography.RSACryptoServiceProvider.PersistKeyInCsp%2A> Właściwość nie ma efektu Jeśli <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiekt jest tworzony z `null` nazwy kontenera kluczy.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiektów i będzie się powtarzał klucz do kontenera kluczy.  
  
 [!code-cpp[Cryptography.RSACSP.PersistKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.PersistKey/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.PersistKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.PersistKey/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.PersistKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.PersistKey/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">Aby uzyskać uprawnienia do usuwania klucza. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Delete" />  
  
 —lub—  
  
 Aby uzyskać uprawnienia do tworzenia klucza. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PublicOnly">
      <MemberSignature Language="C#" Value="public bool PublicOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PublicOnly" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.PublicOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PublicOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PublicOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> obiekt zawiera tylko klucz publiczny.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> obiekt zawiera tylko publiczną klucza; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.RSACryptoServiceProvider> Klasa może być zainicjowana albo, tylko klucz publiczny lub obu publicznego i prywatnego klucza.  Użyj <xref:System.Security.Cryptography.RSACryptoServiceProvider.PublicOnly%2A> właściwości w celu określenia, czy bieżące wystąpienie zawiera tylko klucz publiczny lub zarówno klucz publiczny i prywatny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SignatureAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SignatureAlgorithm { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę algorytmu podpisu dostępne z tą implementacją elementu <see cref="T:System.Security.Cryptography.RSA" />.</summary>
        <value>Nazwa algorytmu podpisu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana w klasach podpisu cyfrowego XML wskazująca algorytm identyfikatora URI. W tej implementacji, ta właściwość zawsze zwraca http://www.w3.org/2000/09/xmldsig#rsa-sha1.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignData">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza wartość skrótu określonych danych i podpisuje go.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (byte[] buffer, object halg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(unsigned int8[] buffer, object halg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.SignData(System.Byte[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function SignData (buffer As Byte(), halg As Object) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ SignData(cli::array &lt;System::Byte&gt; ^ buffer, System::Object ^ halg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="halg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Danych wejściowych, dla którego można obliczyć wartość skrótu.</param>
        <param name="halg">Algorytm wyznaczania wartości skrótu służące do tworzenia wartości skrótu.</param>
        <summary>Oblicza wartość skrótu określonej tablicy bajtów przy użyciu algorytmu wyznaczania wartości skrótu określonej i podpisuje wynikowej wartości skrótu.</summary>
        <returns>
          <see cref="T:System.Security.Cryptography.RSA" /> Podpisu dla określonych danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy podpis cyfrowy, który jest zweryfikowana przy użyciu <xref:System.Security.Cryptography.RSACryptoServiceProvider.VerifyData%2A> metody.  
  
 `halg` Parametr może zawierać <xref:System.String>, <xref:System.Security.Cryptography.HashAlgorithm>, lub <xref:System.Type>.  
  
   
  
## Examples  
 Poniższy przykład kodu podpisuje i weryfikuje danych.  
  
 [!code-cpp[Cryptography.RSACSP.SignData2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.SignData2/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.SignData2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.SignData2/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.SignData2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.SignData2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="halg" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="halg" /> Parametr nie jest prawidłowym typem.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (System.IO.Stream inputStream, object halg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(class System.IO.Stream inputStream, object halg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.SignData(System.IO.Stream,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function SignData (inputStream As Stream, halg As Object) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ SignData(System::IO::Stream ^ inputStream, System::Object ^ halg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputStream" Type="System.IO.Stream" />
        <Parameter Name="halg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputStream">Danych wejściowych, dla którego można obliczyć wartość skrótu.</param>
        <param name="halg">Algorytm wyznaczania wartości skrótu służące do tworzenia wartości skrótu.</param>
        <summary>Oblicza wartość skrótu określonego strumienia wejściowego przy użyciu algorytmu wyznaczania wartości skrótu określonej i podpisuje wynikowej wartości skrótu.</summary>
        <returns>
          <see cref="T:System.Security.Cryptography.RSA" /> Podpisu dla określonych danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `halg` Parametr może zawierać <xref:System.String>, <xref:System.Security.Cryptography.HashAlgorithm>, lub <xref:System.Type>.  
  
   
  
## Examples  
 Poniższy przykład kodu podpisuje i weryfikuje danych.  
  
 [!code-cpp[Cryptography.RSACSP.SignData3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.SignData3/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.SignData3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.SignData3/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.SignData3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.SignData3/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="halg" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="halg" /> Parametr nie jest prawidłowym typem.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (byte[] buffer, int offset, int count, object halg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(unsigned int8[] buffer, int32 offset, int32 count, object halg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.SignData(System.Byte[],System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function SignData (buffer As Byte(), offset As Integer, count As Integer, halg As Object) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ SignData(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Object ^ halg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="halg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Danych wejściowych, dla którego można obliczyć wartość skrótu.</param>
        <param name="offset">Przesunięcie w tablicy, z którego ma zostać rozpoczęta przy użyciu danych.</param>
        <param name="count">Liczba bajtów w tablicy, która ma być używana jako dane.</param>
        <param name="halg">Algorytm wyznaczania wartości skrótu służące do tworzenia wartości skrótu.</param>
        <summary>Oblicza wartość skrótu podzbiór określonej tablicy bajtów przy użyciu algorytmu wyznaczania wartości skrótu określonej i podpisuje wynikowej wartości skrótu.</summary>
        <returns>
          <see cref="T:System.Security.Cryptography.RSA" /> Podpisu dla określonych danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy podpis cyfrowy, który jest zweryfikowana przy użyciu <xref:System.Security.Cryptography.RSACryptoServiceProvider.VerifyData%2A> metody.  
  
 `halg` Parametr może zawierać <xref:System.String>, <xref:System.Security.Cryptography.HashAlgorithm>, lub <xref:System.Type>. Wartość ciągu może być jedną z następujących czynności:  
  
-   Identyfikator (OID) przyjazną nazwę obiektu algorytmu wyznaczania wartości skrótu do użycia, albo nazwę zarejestrowany w pliku konfiguracji usług kryptograficznych lub w innej tabeli OID interfejsu API kryptografii.  
  
-   Wartość identyfikatora OID. Identyfikator OID musi być rozpoznawana przez interfejsu API szyfrowania.  
  
 Na przykład można użyć SignData (nowego typu byte [5], "1.3.14.3.2.26") lub SignData (nowego typu byte [5], "sha1") lub SignData (nowego typu byte [5], "SHA1").  
  
   
  
## Examples  
 Poniższy przykład kodu podpisuje i weryfikuje danych.  
  
 [!code-cpp[Cryptography.RSACSP.SignData1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.SignData1/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.SignData1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.SignData1/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.SignData1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.SignData1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="halg" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="halg" /> Parametr nie jest prawidłowym typem.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignHash">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza podpis dla wartości skrótu określonej szyfrując z kluczem prywatnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignHash">
      <MemberSignature Language="C#" Value="public byte[] SignHash (byte[] rgbHash, string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignHash(unsigned int8[] rgbHash, string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.SignHash(System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SignHash (rgbHash As Byte(), str As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ SignHash(cli::array &lt;System::Byte&gt; ^ rgbHash, System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbHash" Type="System.Byte[]" />
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rgbHash">Wartość skrótu danych do podpisania.</param>
        <param name="str">Algorytm wyznaczania wartości skrótu identyfikator (OID) użyte do utworzenia wartość skrótu danych.</param>
        <summary>Oblicza podpis dla wartości skrótu określonej szyfrując z kluczem prywatnym.</summary>
        <returns>
          <see cref="T:System.Security.Cryptography.RSA" /> Podpis dla wartości skrótu określonej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy podpis cyfrowy, który jest zweryfikowana przy użyciu <xref:System.Security.Cryptography.RSACryptoServiceProvider.VerifyHash%2A> metody.  
  
 Algorytmy prawidłowy skrót <xref:System.Security.Cryptography.SHA1> i <xref:System.Security.Cryptography.MD5>. Identyfikator algorytmu mogą pochodzić z nazwy generowania skrótu za pomocą <xref:System.Security.Cryptography.CryptoConfig.MapNameToOID%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu szyfruje określone dane, tworzy skrót zaszyfrowanych danych i podpisuje następnie wyznaczania wartości skrótu podpisu cyfrowego.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CS/class1.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rgbHash" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można uzyskać dostawcy usług kryptograficznych (CSP).  
  
 —lub—  
  
 Klucz prywatny nie istnieje.</exception>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">Aby uzyskać uprawnienia do pliku przy użyciu klucza podpisywania. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Sign" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SignHash">
      <MemberSignature Language="C#" Value="public override byte[] SignHash (byte[] hash, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] SignHash(unsigned int8[] hash, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, class System.Security.Cryptography.RSASignaturePadding padding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.SignHash(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function SignHash (hash As Byte(), hashAlgorithm As HashAlgorithmName, padding As RSASignaturePadding) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ SignHash(cli::array &lt;System::Byte&gt; ^ hash, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::RSASignaturePadding ^ padding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="padding" Type="System.Security.Cryptography.RSASignaturePadding" />
      </Parameters>
      <Docs>
        <param name="hash">Wartość skrótu danych do podpisania.</param>
        <param name="hashAlgorithm">Nazwa algorytmu wyznaczania wartości skrótu używany do tworzenia wartości skrótu danych.</param>
        <param name="padding">Dopełnienie.</param>
        <summary>Oblicza podpis dla wartości skrótu określonej przez ich szyfrowanie przy użyciu klucza prywatnego za pomocą określonego wypełnienia.</summary>
        <returns>
          <see cref="T:System.Security.Cryptography.RSA" /> Podpis dla wartości skrótu określonej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hashAlgorithm" /> jest <see langword="null" /> lub <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hash" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="padding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="padding" /> nie równa się <see cref="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseMachineKeyStore">
      <MemberSignature Language="C#" Value="public static bool UseMachineKeyStore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseMachineKeyStore" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.UseMachineKeyStore" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseMachineKeyStore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseMachineKeyStore { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy klucz powinien utrwalone w magazynie kluczy komputera zamiast magazynie profilu użytkownika.</summary>
        <value>
          <see langword="true" /> Jeśli klucz powinien utrwalone w magazynie kluczy komputera; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości na `true` jest odpowiednikiem przekazywanie <xref:System.Security.Cryptography.CspProviderFlags.UseMachineKeyStore> flaga <xref:System.Security.Cryptography.CspParameters> obiektu. <xref:System.Security.Cryptography.RSACryptoServiceProvider.UseMachineKeyStore%2A> Właściwość ma zastosowanie do całego kodu w bieżącej domenie aplikacji, podczas gdy <xref:System.Security.Cryptography.CspParameters> obiekt ma zastosowanie tylko do klasy, które jawnie odwoływać. Te ustawienia są przydatne w przypadku personifikacji lub uruchomiony przy użyciu konta, którego profil użytkownika nie został załadowany. Ustawienie <xref:System.Security.Cryptography.RSACryptoServiceProvider.UseMachineKeyStore%2A> wpływa na magazynie kluczy lokalizacji tylko wtedy, gdy <xref:System.Security.Cryptography.RSACryptoServiceProvider> zainicjowano bez parametrów.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Security.Cryptography.RSACryptoServiceProvider> obiektu i ustawia statycznych <xref:System.Security.Cryptography.RSACryptoServiceProvider.UseMachineKeyStore%2A> właściwości do używania magazynu kluczy komputera zamiast magazynu kluczy profilu użytkownika.  
  
 [!code-cpp[Cryptography.RSACSP.UseMachineKey#2](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.UseMachineKey/CPP/example2.cpp#2)]
 [!code-csharp[Cryptography.RSACSP.UseMachineKey#2](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.UseMachineKey/CS/example2.cs#2)]
 [!code-vb[Cryptography.RSACSP.UseMachineKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.UseMachineKey/VB/example2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VerifyData">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza, czy podpis cyfrowy jest nieprawidłowy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public bool VerifyData (byte[] buffer, object halg, byte[] signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyData(unsigned int8[] buffer, object halg, unsigned int8[] signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.VerifyData(System.Byte[],System.Object,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyData (buffer As Byte(), halg As Object, signature As Byte()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyData(cli::array &lt;System::Byte&gt; ^ buffer, System::Object ^ halg, cli::array &lt;System::Byte&gt; ^ signature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="halg" Type="System.Object" />
        <Parameter Name="signature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Dane, który został podpisany.</param>
        <param name="halg">Nazwa algorytmu wyznaczania wartości skrótu używany do tworzenia wartości skrótu danych.</param>
        <param name="signature">Dane sygnatur do weryfikacji.</param>
        <summary>Sprawdza, czy podpis cyfrowy jest prawidłowy, określając skrót wartości w podpisie przy użyciu podanego klucza publicznego i porównanie z wartością skrótu podanych danych.</summary>
        <returns>
          <see langword="true" /> Jeśli podpis jest nieprawidłowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza <xref:System.Security.Cryptography.RSA> podpisu cyfrowego utworzonego przez <xref:System.Security.Cryptography.RSACryptoServiceProvider.SignData%2A> metody. Podpis jest weryfikowany przez uzyskiwania wartości skrótu podpisu za pomocą klucza publicznego został podpisany, i porównując tej wartości z wartością skrótu podanych danych.  
  
 `halg` Parametr może zawierać <xref:System.String>, <xref:System.Security.Cryptography.HashAlgorithm>, lub <xref:System.Type>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Security.Cryptography.RSACryptoServiceProvider.VerifyData%2A> metody do weryfikowania podpisu. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.Cryptography.RSACryptoServiceProvider.SignHash%2A> metody.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CPP/class1.cpp#2)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CS/class1.cs#2)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="halg" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="halg" /> Parametr nie jest prawidłowym typem.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VerifyHash">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza, czy podpis cyfrowy jest nieprawidłowy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VerifyHash">
      <MemberSignature Language="C#" Value="public bool VerifyHash (byte[] rgbHash, string str, byte[] rgbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyHash(unsigned int8[] rgbHash, string str, unsigned int8[] rgbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.VerifyHash(System.Byte[],System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyHash (rgbHash As Byte(), str As String, rgbSignature As Byte()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyHash(cli::array &lt;System::Byte&gt; ^ rgbHash, System::String ^ str, cli::array &lt;System::Byte&gt; ^ rgbSignature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbHash" Type="System.Byte[]" />
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="rgbSignature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgbHash">Wartość skrótu podpisanych danych.</param>
        <param name="str">Algorytm wyznaczania wartości skrótu identyfikator (OID) użyte do utworzenia wartość skrótu danych.</param>
        <param name="rgbSignature">Dane sygnatur do weryfikacji.</param>
        <summary>Sprawdza, czy podpis cyfrowy jest prawidłowy, określając skrót wartości w podpisie przy użyciu podanego klucza publicznego i porównanie z wartością skrótu dostarczonego.</summary>
        <returns>
          <see langword="true" /> Jeśli podpis jest nieprawidłowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza <xref:System.Security.Cryptography.RSA> podpisu cyfrowego utworzonego przez <xref:System.Security.Cryptography.RSACryptoServiceProvider.SignHash%2A> metody. Podpis jest weryfikowany przez uzyskiwania wartości skrótu podpisu za pomocą klucza publicznego został podpisany, i porównując tej wartości z wartością skrótu podanych danych.  
  
 Algorytmy prawidłowy skrót <xref:System.Security.Cryptography.SHA1> i <xref:System.Security.Cryptography.MD5>. Identyfikator algorytmu mogą pochodzić z nazwy generowania skrótu za pomocą <xref:System.Security.Cryptography.CryptoConfig.MapNameToOID%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Security.Cryptography.RSACryptoServiceProvider.VerifyHash%2A> metody do weryfikowania podpisu. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.Cryptography.RSACryptoServiceProvider.SignHash%2A> metody.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CPP/class1.cpp#2)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CS/class1.cs#2)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rgbHash" /> Parametr jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="rgbSignature" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można uzyskać dostawcy usług kryptograficznych (CSP).  
  
 —lub—  
  
 Nie można zweryfikować podpisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyHash">
      <MemberSignature Language="C#" Value="public override bool VerifyHash (byte[] hash, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool VerifyHash(unsigned int8[] hash, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, class System.Security.Cryptography.RSASignaturePadding padding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function VerifyHash (hash As Byte(), signature As Byte(), hashAlgorithm As HashAlgorithmName, padding As RSASignaturePadding) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool VerifyHash(cli::array &lt;System::Byte&gt; ^ hash, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::RSASignaturePadding ^ padding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.Byte[]" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="padding" Type="System.Security.Cryptography.RSASignaturePadding" />
      </Parameters>
      <Docs>
        <param name="hash">Wartość skrótu podpisanych danych.</param>
        <param name="signature">Dane sygnatur do weryfikacji.</param>
        <param name="hashAlgorithm">Nazwa algorytmu wyznaczania wartości skrótu używany do tworzenia wartości skrótu.</param>
        <param name="padding">Dopełnienie.</param>
        <summary>Sprawdza, czy podpis cyfrowy jest prawidłowy, określając wartość skrótu w sygnaturze przy użyciu określonego mieszania algorytmu uzupełnianie i porównanie z wartością skrótu dostarczonego.</summary>
        <returns>
          <see langword="true" /> Jeśli podpis jest nieprawidłowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hashAlgorithm" /> jest <see langword="null" /> lub <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hash" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="padding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="padding" /> nie równa się <see cref="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
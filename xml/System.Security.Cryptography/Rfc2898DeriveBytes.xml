<Type Name="Rfc2898DeriveBytes" FullName="System.Security.Cryptography.Rfc2898DeriveBytes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="33ee2fd66fc05f288789835988a052f4e50d1055" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51877141" /></Metadata><TypeSignature Language="C#" Value="public class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Rfc2898DeriveBytes extends System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Rfc2898DeriveBytes" />
  <TypeSignature Language="VB.NET" Value="Public Class Rfc2898DeriveBytes&#xA;Inherits DeriveBytes" />
  <TypeSignature Language="C++ CLI" Value="public ref class Rfc2898DeriveBytes : System::Security::Cryptography::DeriveBytes" />
  <TypeSignature Language="F#" Value="type Rfc2898DeriveBytes = class&#xA;    inherit DeriveBytes" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.DeriveBytes</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementuje opartego na hasłach klucza funkcji pochodnym, PBKDF2, za pomocą pseudolosowego generatora liczb na podstawie <see cref="T:System.Security.Cryptography.HMACSHA1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> przyjmuje hasło, ziarna i liczba iteracji, a następnie generuje klucze za pomocą wywołania <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> metody.  
  
 RFC 2898 zawiera metody do tworzenia klucza i wektora inicjowania (IV) na podstawie hasła i ziarna. PBKDF2, funkcja wyprowadzania klucza opartego na hasłach, można użyć do uzyskania kluczy przy użyciu pseudolosową funkcją, która umożliwia klucze o długości praktycznie nieograniczone miejsce do wygenerowania. <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasa może być używana w celu wygenerowania klucza pochodnego z klucza podstawowego i innych parametrów. W funkcji wyprowadzania klucza opartego na hasłach klucz podstawowy jest hasła i inne parametry są wartości zaburzającej i liczba iteracji.  
  
 Aby uzyskać więcej informacji na temat PBKDF2 zobacz RFC 2898 "PKCS #5: opartego na hasłach kryptografii specyfikacji w wersji 2.0," dostępne na [żądań dla witryny sieci Web komentarze](https://go.microsoft.com/fwlink/?LinkID=37119). W sekcji 5.2, "PBKDF2", aby uzyskać szczegółowe informacje.  
  
> [!IMPORTANT]
>  Nigdy nie trwale kodować a hasła w kodzie źródłowym.  Zakodowane hasła mogą być pobierane z zestawu, za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), za pomocą edytora szesnastkowym lub po prostu otwierając zestawów w edytorze tekstów, np. Notepad.exe.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Security.Cryptography.Rfc2898DeriveBytes> klasy, aby utworzyć dwa identyczne klucze dla <xref:System.Security.Cryptography.TripleDES> klasy.  Następnie szyfruje i odszyfrowuje dane przy użyciu kluczy.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="password">Hasło używane do uzyskania klucza.</param>
        <param name="salt">Ziarno klucza, użyty do wyprowadzenia klucza.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> przy użyciu hasła i ziarna do uzyskania klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar ziarna musi wynosić 8 bajtów lub większym.  
  
 RFC 2898 zawiera metody do tworzenia klucza i wektora inicjowania (IV) na podstawie hasła i ziarna. PBKDF2, funkcja wyprowadzania klucza opartego na hasłach, można użyć do uzyskania kluczy przy użyciu pseudolosową funkcją, która umożliwia klucze o długości praktycznie nieograniczone miejsce do wygenerowania. <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasa może być używana w celu wygenerowania klucza pochodnego z klucza podstawowego i innych parametrów. W funkcji wyprowadzania klucza opartego na hasłach klucz podstawowy jest hasła i inne parametry są wartości zaburzającej i liczba iteracji.  
  
 Aby uzyskać więcej informacji na temat PBKDF2 zobacz RFC 2898 "PKCS #5: opartego na hasłach kryptografii specyfikacji w wersji 2.0," dostępne na [żądań dla witryny sieci Web komentarze](https://go.microsoft.com/fwlink/?LinkID=37119). W sekcji 5.2, "PBKDF2", aby uzyskać szczegółowe informacje.  
  
> [!IMPORTANT]
>  Nigdy nie trwale kodować a hasła w kodzie źródłowym.  Zakodowane hasła mogą być pobierane z zestawu, za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), za pomocą edytora szesnastkowym lub po prostu otwierając zestawów w edytorze tekstów, np. Notepad.exe.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Security.Cryptography.Rfc2898DeriveBytes> klasy, aby utworzyć dwa identyczne klucze dla <xref:System.Security.Cryptography.TripleDES> klasy.  Następnie szyfruje i odszyfrowuje dane przy użyciu kluczy.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określony rozmiar ziarna jest mniejszy niż 8 bajtów lub liczba iteracji jest mniejszy niż 1.</exception>
        <exception cref="T:System.ArgumentNullException">Hasło lub ziarna jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Hasło używane do uzyskania klucza.</param>
        <param name="saltSize">Rozmiar ziarna losowego, który klasy do generowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> przy użyciu hasła i rozmiaru ziarna do uzyskania klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar ziarna musi wynosić 8 bajtów lub większym.  
  
 RFC 2898 zawiera metody do tworzenia klucza i wektora inicjowania (IV) na podstawie hasła i ziarna. PBKDF2, funkcja wyprowadzania klucza opartego na hasłach, można użyć do uzyskania kluczy przy użyciu pseudolosową funkcją, która umożliwia klucze o długości praktycznie nieograniczone miejsce do wygenerowania. <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasa może być używana w celu wygenerowania klucza pochodnego z klucza podstawowego i innych parametrów. W funkcji wyprowadzania klucza opartego na hasłach klucz podstawowy jest hasła i inne parametry są wartości zaburzającej i liczba iteracji.  
  
 Aby uzyskać więcej informacji na temat PBKDF2 zobacz RFC 2898 "PKCS #5: opartego na hasłach kryptografii specyfikacji w wersji 2.0," dostępne na [żądań dla witryny sieci Web komentarze](https://go.microsoft.com/fwlink/?LinkID=37119). W sekcji 5.2, "PBKDF2", aby uzyskać szczegółowe informacje.  
  
> [!IMPORTANT]
>  Nigdy nie trwale kodować a hasła w kodzie źródłowym.  Zakodowane hasła mogą być pobierane z zestawu, za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), za pomocą edytora szesnastkowym lub po prostu otwierając zestawów w edytorze tekstów, np. Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określony rozmiar ziarna jest mniejszy niż 8 bajtów.</exception>
        <exception cref="T:System.ArgumentNullException">Hasło lub ziarna jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Hasło używane do uzyskania klucza.</param>
        <param name="salt">Ziarno klucza, użyty do wyprowadzenia klucza.</param>
        <param name="iterations">Liczba iteracji dla tej operacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> przy użyciu hasła, ziarna i liczba iteracji do uzyskania klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar ziarna musi wynosić 8 bajtów lub większym i liczba iteracji musi być większa od zera. Minimalna zalecana liczba iteracji wynosi 1000.  
  
 RFC 2898 zawiera metody do tworzenia klucza i wektora inicjowania (IV) na podstawie hasła i ziarna. PBKDF2, funkcja wyprowadzania klucza opartego na hasłach, można użyć do uzyskania kluczy przy użyciu pseudolosową funkcją, która umożliwia klucze o długości praktycznie nieograniczone miejsce do wygenerowania. <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasa może być używana w celu wygenerowania klucza pochodnego z klucza podstawowego i innych parametrów. W funkcji wyprowadzania klucza opartego na hasłach klucz podstawowy jest hasła i inne parametry są wartości zaburzającej i liczba iteracji.  
  
 Aby uzyskać więcej informacji na temat PBKDF2 zobacz RFC 2898 "PKCS #5: opartego na hasłach kryptografii specyfikacji w wersji 2.0," dostępne na [żądań dla witryny sieci Web komentarze](https://go.microsoft.com/fwlink/?LinkID=37119). W sekcji 5.2, "PBKDF2", aby uzyskać szczegółowe informacje.  
  
> [!IMPORTANT]
>  Nigdy nie trwale kodować a hasła w kodzie źródłowym.  Zakodowane hasła mogą być pobierane z zestawu, za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), za pomocą edytora szesnastkowym lub po prostu otwierając zestawów w edytorze tekstów, np. Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określony rozmiar ziarna jest mniejszy niż 8 bajtów lub liczba iteracji jest mniejszy niż 1.</exception>
        <exception cref="T:System.ArgumentNullException">Hasło lub ziarna jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Hasło używane do uzyskania klucza.</param>
        <param name="salt">Ziarno klucza, użyty do wyprowadzenia klucza.</param>
        <param name="iterations">Liczba iteracji dla tej operacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> przy użyciu hasła, ziarna i liczba iteracji do uzyskania klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar ziarna musi wynosić 8 bajtów lub większym i liczba iteracji musi być większa od zera. Minimalna zalecana liczba iteracji wynosi 1000.  
  
 RFC 2898 zawiera metody do tworzenia klucza i wektora inicjowania (IV) na podstawie hasła i ziarna. PBKDF2, funkcja wyprowadzania klucza opartego na hasłach, można użyć do uzyskania kluczy przy użyciu pseudolosową funkcją, która umożliwia klucze o długości praktycznie nieograniczone miejsce do wygenerowania. <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasa może być używana w celu wygenerowania klucza pochodnego z klucza podstawowego i innych parametrów. W funkcji wyprowadzania klucza opartego na hasłach klucz podstawowy jest hasła i inne parametry są wartości zaburzającej i liczba iteracji.  
  
 Aby uzyskać więcej informacji na temat PBKDF2 zobacz RFC 2898 "PKCS #5: opartego na hasłach kryptografii specyfikacji w wersji 2.0," dostępne na [żądań dla witryny sieci Web komentarze](https://go.microsoft.com/fwlink/?LinkID=37119). W sekcji 5.2, "PBKDF2", aby uzyskać szczegółowe informacje.  
  
> [!IMPORTANT]
>  Nigdy nie trwale kodować a hasła w kodzie źródłowym.  Zakodowane hasła mogą być pobierane z zestawu, za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), za pomocą edytora szesnastkowym lub po prostu otwierając zestawów w edytorze tekstów, np. Notepad.exe.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Security.Cryptography.Rfc2898DeriveBytes> klasy, aby utworzyć dwa identyczne klucze dla <xref:System.Security.Cryptography.TripleDES> klasy.  Następnie szyfruje i odszyfrowuje dane przy użyciu kluczy.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określony rozmiar ziarna jest mniejszy niż 8 bajtów lub liczba iteracji jest mniejszy niż 1.</exception>
        <exception cref="T:System.ArgumentNullException">Hasło lub ziarna jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Hasło używane do uzyskania klucza.</param>
        <param name="saltSize">Rozmiar ziarna losowego, który klasy do generowania.</param>
        <param name="iterations">Liczba iteracji dla tej operacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> przy użyciu hasła, rozmiaru ziarna i liczba iteracji do uzyskania klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar ziarna musi wynosić 8 bajtów lub większym i liczba iteracji musi być większa od zera. Minimalna zalecana liczba iteracji wynosi 1000.  
  
 RFC 2898 zawiera metody do tworzenia klucza i wektora inicjowania (IV) na podstawie hasła i ziarna. PBKDF2, funkcja wyprowadzania klucza opartego na hasłach, można użyć do uzyskania kluczy przy użyciu pseudolosową funkcją, która umożliwia klucze o długości praktycznie nieograniczone miejsce do wygenerowania. <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasa może być używana w celu wygenerowania klucza pochodnego z klucza podstawowego i innych parametrów. W funkcji wyprowadzania klucza opartego na hasłach klucz podstawowy jest hasła i inne parametry są wartości zaburzającej i liczba iteracji.  
  
 Aby uzyskać więcej informacji na temat PBKDF2, zobacz RFC 2898 "PKCS nr 5: opartego na hasłach kryptografii specyfikacji w wersji 2.0," dostępne na [żądań dla witryny sieci Web komentarze](https://go.microsoft.com/fwlink/?LinkID=37119). W sekcji 5.2, "PBKDF2", aby uzyskać szczegółowe informacje.  
  
> [!IMPORTANT]
>  Nigdy nie trwale kodować a hasła w kodzie źródłowym.  Zakodowane hasła mogą być pobierane z zestawu, za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), za pomocą edytora szesnastkowym lub po prostu otwierając zestawów w edytorze tekstów, np. Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określony rozmiar ziarna jest mniejszy niż 8 bajtów lub liczba iteracji jest mniejszy niż 1.</exception>
        <exception cref="T:System.ArgumentNullException">Hasło lub ziarna jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="iterations" /> jest poza zakresem. Ten parametr wymaga podania liczby nieujemnej wartości.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">Hasło używane do uzyskania klucza.</param>
        <param name="salt">Ziarno klucza na potrzeby uzyskania klucza.</param>
        <param name="iterations">Liczba iteracji dla tej operacji.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu do użycia do uzyskania klucza.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> przy użyciu określonego hasła, ziarna, liczba iteracji i nazwa algorytmu wyznaczania wartości skrótu do uzyskania klucza.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="saltSize" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> Właściwość <paramref name="hashAlgorithm" /> jest <see langword="null" /> lub <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nazwa algorytmu wyznaczania wartości skrótu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">Hasło używane do uzyskania klucza.</param>
        <param name="salt">Ziarno klucza na potrzeby uzyskania klucza.</param>
        <param name="iterations">Liczba iteracji dla tej operacji.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu do użycia do uzyskania klucza.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> przy użyciu określonego hasła, ziarna, liczba iteracji i nazwa algorytmu wyznaczania wartości skrótu do uzyskania klucza.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> Właściwość <paramref name="hashAlgorithm" /> jest <see langword="null" /> lub <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nazwa algorytmu wyznaczania wartości skrótu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">Hasło używane do uzyskania klucza.</param>
        <param name="saltSize">Rozmiar ziarna losowego, który klasy do generowania.</param>
        <param name="iterations">Liczba iteracji dla tej operacji.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu do użycia do uzyskania klucza.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> przy użyciu określonego hasła, rozmiaru ziarna, liczba iteracji i nazwa algorytmu wyznaczania wartości skrótu do uzyskania klucza.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="saltSize" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> Właściwość <paramref name="hashAlgorithm" /> jest <see langword="null" /> lub <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nazwa algorytmu wyznaczania wartości skrótu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CryptDeriveKey">
      <MemberSignature Language="C#" Value="public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] CryptDeriveKey(string algname, string alghashname, int32 keySize, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CryptDeriveKey (algname As String, alghashname As String, keySize As Integer, rgbIV As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ CryptDeriveKey(System::String ^ algname, System::String ^ alghashname, int keySize, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberSignature Language="F#" Value="member this.CryptDeriveKey : string * string * int * byte[] -&gt; byte[]" Usage="rfc2898DeriveBytes.CryptDeriveKey (algname, alghashname, keySize, rgbIV)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algname" Type="System.String" />
        <Parameter Name="alghashname" Type="System.String" />
        <Parameter Name="keySize" Type="System.Int32" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="algname">Nazwa algorytmu, dla którego ma zostać uzyskania klucza.</param>
        <param name="alghashname">Nazwa algorytmu wyznaczania wartości skrótu do użycia do uzyskania klucza.</param>
        <param name="keySize">Rozmiar klucza w bitach, aby utworzyć pochodny.</param>
        <param name="rgbIV">Wektor inicjalizacji (IV) na potrzeby uzyskania klucza.</param>
        <summary>Wywodzi się z klucza kryptograficznego <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> obiektu.</summary>
        <returns>Klucza pochodnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta funkcja jest otoką dla funkcji interfejsu API szyfrowania CryptDeriveKey() i jest przeznaczona do zaoferowania współdziałanie z aplikacjami korzystającymi z interfejsu API szyfrowania.  
  
 Jeśli `keySize` parametr ma wartość bitów 0, używany jest domyślny rozmiar klucza dla określonego algorytmu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="keySize" /> Parametr jest nieprawidłowy.  
  
—lub— 
Nie można uzyskać dostawcy usług kryptograficznych (CSP).  
  
—lub— 
<paramref name="algname" /> Parametr nie jest nazwą prawidłową algorytmu.  
  
—lub— 
<paramref name="alghashname" /> Parametr nie jest nazwa algorytmu prawidłowy skrót.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="rfc2898DeriveBytes.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> klasy i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną `Dispose()` metody i `Finalize` metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` parametr `true`. `Finalize` wywołuje `Dispose` z `disposing` równa `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.Security.Cryptography.Rfc2898DeriveBytes> odwołania. Ta metoda wywołuje `Dispose()` metoda każdego obiektu, do którego istnieje odwołanie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see langword="Dispose(Boolean)" />, nie należy odwoływać się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see langword="Dispose" />. Aby uzyskać więcej informacji o sposobie wdrażania <see langword="Dispose(Boolean)" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see langword="Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (cb As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(int cb);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int -&gt; byte[]" Usage="rfc2898DeriveBytes.GetBytes cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">Liczbę pseudolosową klucza bajtów do wygenerowania.</param>
        <summary>Zwraca klucz pseudolosową dla tego obiektu.</summary>
        <returns>Tablica bajtów wypełniony pseudolosową bajty klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasa implementuje funkcje PBKDF2 przy użyciu pseudolosowych generator liczb na podstawie <xref:System.Security.Cryptography.HMACSHA1>. <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasy, przyjmuje hasło, ziarna i liczba iteracji, a następnie generuje klucze za pomocą wywołania <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> metody. Wielokrotnego wywołania tej metody nie wygeneruje ten sam klucz; Zamiast tego dodanie dwóch wywołań <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> metody z `cb` wartość parametru `20` jest odpowiednikiem wywołania metody <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> metody raz z `cb` wartość parametru `40`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> metodę, aby uzyskać klucz dla wystąpienia <xref:System.Security.Cryptography.Rfc2898DeriveBytes>. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Security.Cryptography.Rfc2898DeriveBytes> klasy.  
  
 [!code-cpp[rfc28981#2](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#2)]
 [!code-csharp[rfc28981#2](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#2)]
 [!code-vb[rfc28981#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="cb" /> jest poza zakresem. Ten parametr wymaga podania liczby nieujemnej wartości.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.HashAlgorithmName HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.HashAlgorithmName HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HashAlgorithm As HashAlgorithmName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::HashAlgorithmName HashAlgorithm { System::Security::Cryptography::HashAlgorithmName get(); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Security.Cryptography.HashAlgorithmName" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithmName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IterationCount">
      <MemberSignature Language="C#" Value="public int IterationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IterationCount" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property IterationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IterationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IterationCount : int with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę iteracji dla tej operacji.</summary>
        <value>Liczba iteracji dla tej operacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba iteracji jest liczba przypadków, gdy jest wykonywana operacja. W przypadku tej metody liczba powinna być większa od zera. Minimalna zalecana liczba iteracji wynosi 1000.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A> właściwość, aby wyświetlić liczbę iteracji podczas generowania klucza. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Security.Cryptography.Rfc2898DeriveBytes> klasy.  
  
 [!code-cpp[rfc28981#3](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#3)]
 [!code-csharp[rfc28981#3](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#3)]
 [!code-vb[rfc28981#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba iteracji jest mniejszy niż 1.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberSignature Language="F#" Value="override this.Reset : unit -&gt; unit" Usage="rfc2898DeriveBytes.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje stan operacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana automatycznie, jeśli liczba ziarna lub iteracji jest modyfikowana.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A> metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Security.Cryptography.Rfc2898DeriveBytes> klasy.  
  
 [!code-cpp[rfc28981#5](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#5)]
 [!code-csharp[rfc28981#5](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#5)]
 [!code-vb[rfc28981#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="Salt">
      <MemberSignature Language="C#" Value="public byte[] Salt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Salt" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberSignature Language="VB.NET" Value="Public Property Salt As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Salt { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Salt : byte[] with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość zaburzająca klucza dla tej operacji.</summary>
        <value>Wartość zaburzająca klucza dla tej operacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ziarna, losowy zestaw bajtów, umożliwia nieautoryzowanych odszyfrowywania wiadomości trudniejsze. Atak słownikowy jest atak, w którym osoba atakująca próbuje odszyfrować zaszyfrowanego komunikatu przez porównanie wartości zaszyfrowane przy użyciu poprzednio obliczone wartości zaszyfrowanych kluczy najbardziej prawdopodobną. Ten rodzaj ataku składa się dużo bardziej skomplikowane przez wprowadzenie ziarna lub losowych bajtów, na końcu hasła przed klucza pochodnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określony rozmiar ziarna jest mniejszy niż 8 bajtów.</exception>
        <exception cref="T:System.ArgumentNullException">Ziarna jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
  </Members>
</Type>
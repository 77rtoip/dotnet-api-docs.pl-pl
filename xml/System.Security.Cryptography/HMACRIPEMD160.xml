<Type Name="HMACRIPEMD160" FullName="System.Security.Cryptography.HMACRIPEMD160">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8dbae615f73b276d9a73b731a30e0587151fc9c1" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30569212" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HMACRIPEMD160 : System.Security.Cryptography.HMAC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit HMACRIPEMD160 extends System.Security.Cryptography.HMAC" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.HMACRIPEMD160" />
  <TypeSignature Language="VB.NET" Value="Public Class HMACRIPEMD160&#xA;Inherits HMAC" />
  <TypeSignature Language="C++ CLI" Value="public ref class HMACRIPEMD160 : System::Security::Cryptography::HMAC" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.HMAC</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Oblicza Hash-based wiadomości kod uwierzytelniania (HMAC) przy użyciu <see cref="T:System.Security.Cryptography.RIPEMD160" /> funkcji generowania skrótów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.HMACRIPEMD160> jest typem algorytm skrótu z kluczem jest utworzone na podstawie RIPEMD 160 funkcji skrótu i używany jako Hash-based kodu (metoda HMAC Message Authentication). Proces HMAC łączy klucz tajny z danymi wiadomości, tworzy skrót wyniku przy użyciu funkcji skrótu, łączy skrót z kluczem tajnym ponownie, a następnie stosuje funkcję skrótu po raz drugi. Wynikowy skrót ma długość 160 bitów.  
  
 HMAC może służyć do określenia, czy została naruszona komunikatu wysłanego za pośrednictwem niezabezpieczonego kanału, pod warunkiem, że nadawca i odbiorca udostępnić klucz tajny. Nadawca oblicza wartość skrótu dla oryginalnych danych i wysyła zarówno oryginalnych danych i wartości skrótu jako pojedynczej wiadomości. Odbiornik ponownie oblicza wartość skrótu dla odebranego komunikatu i sprawdza, czy obliczona HMAC zgodny przesyłane HMAC.  
  
 Każda zmiana danych lub wartość skrótu powoduje niezgodność, ponieważ wiedzy klucz tajny musi zmienić komunikat i Odtwórz wartość skrótu poprawne. W związku z tym jeśli wartości skrótu oryginalny i obliczona zgodne, wiadomość została uwierzytelniona.  
  
 <xref:System.Security.Cryptography.HMACRIPEMD160> akceptuje klucze o dowolnej wielkości i tworzy sekwencję wyznaczania wartości skrótu, która jest 160 bitów.  
  
 Algorytm wyznaczania wartości skrótu RIPEMD oraz ich następców zostały opracowane przez DOJRZAŁE Europejskiego projektu. Algorytm RIPEMD oryginalnego zaprojektowano tak, aby zastąpić MD4 i MD5 i została wzmocniona później zmienić nazwę i RIPEMD 160. Algorytm wyznaczania wartości skrótu RIPEMD 160 generuje wartość skrótu 160-bitowy. Projektanci algorytm umieszczony go w domenie publicznej.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób podpisać plik za pomocą <xref:System.Security.Cryptography.HMACRIPEMD160> obiektu, a następnie sprawdź, czy plik jak.  
  
 [!code-cpp[HMACRIPEMD160#1](~/samples/snippets/cpp/VS_Snippets_CLR/HMACRIPEMD160/CPP/hmacripemd160.cpp#1)]
 [!code-csharp[HMACRIPEMD160#1](~/samples/snippets/csharp/VS_Snippets_CLR/HMACRIPEMD160/CS/hmacripemd160.cs#1)]
 [!code-vb[HMACRIPEMD160#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/HMACRIPEMD160/vb/hmacripemd160.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.HMACRIPEMD160" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HMACRIPEMD160 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HMACRIPEMD160.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HMACRIPEMD160();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.HMACRIPEMD160" /> klasy z losowo wygenerowany klucz 64 bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.HMACRIPEMD160> jest typem algorytm skrótu z kluczem jest utworzone na podstawie RIPEMD 160 funkcji skrótu i używany jako Hash-based kodu (metoda HMAC Message Authentication). Proces HMAC łączy klucz tajny z danymi wiadomości, tworzy skrót wyniku przy użyciu funkcji skrótu, łączy skrót z kluczem tajnym ponownie, a następnie stosuje funkcję skrótu po raz drugi. Wynikowy skrót ma długość 160 bajtów.  
  
 Ten konstruktor korzysta z 64-bajtowych, losowo wygenerowany klucz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HMACRIPEMD160 (byte[] key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HMACRIPEMD160.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HMACRIPEMD160(cli::array &lt;System::Byte&gt; ^ key);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="key">Klucz tajny dla <see cref="T:System.Security.Cryptography.HMACRIPEMD160" /> szyfrowania. Klucz może być dowolną długość, ale jeśli jest więcej niż 64 bajtów jego skrót jest tworzony (przy użyciu algorytmu SHA-1) do uzyskania klucza 64 bajtów. W związku z tym zalecany rozmiar klucz tajny jest 64 bajtów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.HMACRIPEMD160" /> klasy z określonymi danymi klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.HMACRIPEMD160> jest typem algorytm skrótu z kluczem jest utworzone na podstawie RIPEMD 160 funkcji skrótu i używany jako Hash-based kodu (metoda HMAC Message Authentication). Proces HMAC łączy klucz tajny z danymi wiadomości, tworzy skrót wyniku przy użyciu funkcji skrótu, łączy skrót z kluczem tajnym ponownie, a następnie stosuje funkcję skrótu po raz drugi. Wynikowy skrót ma długość 160 bajtów.  
  
   
  
## Examples  
 Na przykład sposobu używania tego konstruktora zobacz <xref:System.Security.Cryptography.HMACRIPEMD160> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
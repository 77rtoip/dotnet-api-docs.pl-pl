<Type Name="ECDiffieHellman" FullName="System.Security.Cryptography.ECDiffieHellman">
  <Metadata><Meta Name="ms.openlocfilehash" Value="742408668607a6fced5fb8fb705c8a182cc751de" /><Meta Name="ms.sourcegitcommit" Value="8544f14c8194a55eb22d46721b0bbe46f345c063" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/21/2019" /><Meta Name="ms.locfileid" Value="69669559" /></Metadata><TypeSignature Language="C#" Value="public abstract class ECDiffieHellman : System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ECDiffieHellman extends System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ECDiffieHellman&#xA;Inherits AsymmetricAlgorithm" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDiffieHellman abstract : System::Security::Cryptography::AsymmetricAlgorithm" />
  <TypeSignature Language="F#" Value="type ECDiffieHellman = class&#xA;    inherit AsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.AsymmetricAlgorithm</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="8b3a0-101">Dostarcza abstrakcyjną klasę bazową, która może dziedziczyć algorytmy algorytmu Diffie-Hellmana (ECDH).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-101">Provides an abstract base class that Elliptic Curve Diffie-Hellman (ECDH) algorithm implementations can derive from.</span></span> <span data-ttu-id="8b3a0-102">Ta klasa zawiera podstawowy zestaw operacji, które muszą obsługiwać wszystkie implementacje ECDH.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-102">This class provides the basic set of operations that all ECDH implementations must support.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-103">Ta klasa służy jako abstrakcyjna klasa bazowa dla implementacji ECDH.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-103">This class serves as the abstract base class for ECDH implementations.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ECDiffieHellman ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ECDiffieHellman();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b3a0-104">Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-104">Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-105">Ten konstruktor jest wywoływany przez klasy pochodne od <xref:System.Security.Cryptography.ECDiffieHellman> klasy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-105">This constructor is called by classes that derive from the <xref:System.Security.Cryptography.ECDiffieHellman> class.</span></span> <span data-ttu-id="8b3a0-106">Klasa jest jedyną implementacją, która jest obecnie uwzględniona [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]w. <xref:System.Security.Cryptography.ECDiffieHellmanCng></span><span class="sxs-lookup"><span data-stu-id="8b3a0-106">The <xref:System.Security.Cryptography.ECDiffieHellmanCng> class is the only implementation that is currently included in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span> <span data-ttu-id="8b3a0-107">Aby uzyskać informacje na temat sposobu tworzenia nowej implementacji algorytmu eliptyczna Diffie-Hellmana (ECDH), zobacz <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-107">For information about how to create a new implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm, see the <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b3a0-108">Tworzy nowe wystąpienie implementacji algorytmu krzywej eliptycznej Diffie-Hellmana (ECDH).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-108">Creates a new instance of an implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b3a0-109">Tworzy nowe wystąpienie domyślnego wdrożenia algorytmu krzywej eliptycznej Diffie-Hellmana (ECDH).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-109">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-110">Nowe wystąpienie domyślnej implementacji tej klasy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-110">A new instance of the default implementation of this class.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (curve As ECCurve) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECCurve -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="curve"><span data-ttu-id="8b3a0-111">Krzywa, która ma zostać użyta do wygenerowania nowej pary kluczy publicznych/prywatnych.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-111">The curve to use to generate a new public/private key-pair.</span></span></param>
        <summary><span data-ttu-id="8b3a0-112">Tworzy nowe wystąpienie domyślnego wdrożenia algorytmu krzywej eliptycznej Diffie-Hellmana (ECDH) z nową parą kluczy publicznego/prywatnego wygenerowanego na określonej krzywej.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-112">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with a new public/private key-pair generated over the specified curve.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-113">Nowe wystąpienie domyślnego wdrożenia algorytmu krzywej eliptycznej Diffie-Hellmana (ECDH).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-113">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-114">Krzywa musi sprawdzać poprawność (oznacza to, że musi zwrócić <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> wartość true, gdy zostanie przesłana do metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-114">curve must validate (that is, it must return true when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8b3a0-115">Krzywe charakterystyki 2 nie są obsługiwane w systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-115">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-116"><paramref name="curve" />nie sprawdza poprawności.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-116"><paramref name="curve" /> does not validate.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (parameters As ECParameters) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECParameters -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="parameters"><span data-ttu-id="8b3a0-117">Parametry algorytmu kryptografii krzywej eliptycznej (ECC).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-117">The parameters  for the elliptic curve cryptography (ECC) algorithm.</span></span></param>
        <summary><span data-ttu-id="8b3a0-118">Tworzy nowe wystąpienie domyślnego wdrożenia algorytmu krzywej eliptycznej Diffie-Hellmana (ECDH) z kluczem opisanym przez określony <see cref="T:System.Security.Cryptography.ECParameters" /> obiekt.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-118">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with the key described by the specified  <see cref="T:System.Security.Cryptography.ECParameters" /> object.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-119">Nowe wystąpienie domyślnego wdrożenia algorytmu krzywej eliptycznej Diffie-Hellmana (ECDH).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-119">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-120">`parameters`należy sprawdzić poprawność (oznacza to, `true`że musi zwrócić) podczas <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> przekazywania do metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-120">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b3a0-121">Parametry przekroczenia niejawnych krzywych nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-121">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="8b3a0-122">Krzywe charakterystyki 2 nie są obsługiwane w systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-122">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-123"><paramref name="parameters" />nie sprawdza poprawności.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-123"><paramref name="parameters" /> does not validate.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (string algorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(string algorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algorithm As String) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::String ^ algorithm);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create algorithm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algorithm" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="algorithm"><span data-ttu-id="8b3a0-124">Nazwa implementacji algorytmu ECDH.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-124">The name of an implementation of the ECDH algorithm.</span></span></param>
        <summary><span data-ttu-id="8b3a0-125">Tworzy nowe wystąpienie określonej implementacji algorytmu krzywej eliptyczna Diffie-Hellmana (ECDH).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-125">Creates a new instance of the specified implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-126">Nowe wystąpienie określonej implementacji tej klasy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-126">A new instance of the specified implementation of this class.</span></span> <span data-ttu-id="8b3a0-127">Jeśli określona nazwa algorytmu nie jest mapowana na implementację ECDH, Metoda ta zwraca wartość <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-127">If the specified algorithm name does not map to an ECDH implementation, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-128">W przypadku tworzenia własnej implementacji <xref:System.Security.Cryptography.ECDiffieHellman> obiektu można <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> użyć przeciążenia metody, aby utworzyć niestandardowy `algorithm` ciąg, który określa implementację.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-128">If you develop your own implementation of an <xref:System.Security.Cryptography.ECDiffieHellman> object, you can use the <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> method overload to create a custom `algorithm` string that specifies your implementation.</span></span>  
  
 <span data-ttu-id="8b3a0-129">`algorithm` Parametr określa nazwę implementacji algorytmu ECDH.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-129">The `algorithm` parameter specifies the name of an implementation of the ECDH algorithm.</span></span> <span data-ttu-id="8b3a0-130">Poniższe ciągi odnoszą się do tej samej implementacji, która jest jedyną implementacją aktualnie obsługiwaną w [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:</span><span class="sxs-lookup"><span data-stu-id="8b3a0-130">The following strings all refer to the same implementation, which is the only implementation currently supported in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:</span></span>  
  
-   <span data-ttu-id="8b3a0-131">ECDH</span><span class="sxs-lookup"><span data-stu-id="8b3a0-131">"ECDH"</span></span>  
  
-   <span data-ttu-id="8b3a0-132">"ECDiffieHellman"</span><span class="sxs-lookup"><span data-stu-id="8b3a0-132">"ECDiffieHellman"</span></span>  
  
-   <span data-ttu-id="8b3a0-133">"ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="8b3a0-133">"ECDiffieHellmanCng"</span></span>  
  
-   <span data-ttu-id="8b3a0-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="8b3a0-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span></span>  
  
 <span data-ttu-id="8b3a0-135">Możesz również podać nazwę niestandardowej implementacji ECDH dla `algorithm` parametru.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-135">You can also provide the name of a custom ECDH implementation for the `algorithm` parameter.</span></span> <span data-ttu-id="8b3a0-136">Jeśli to zrobisz, <xref:System.Security.Cryptography.CryptoConfig> obiekt będzie używać go do określenia, czy można utworzyć obiekt ECDH.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-136">If you do that, the <xref:System.Security.Cryptography.CryptoConfig> object will use it to determine whether an ECDH object can be created.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b3a0-137">Parametr ma wartość <see langword="null" />. <paramref name="algorithm" /></span><span class="sxs-lookup"><span data-stu-id="8b3a0-137">The <paramref name="algorithm" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHash">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b3a0-138">Tworzy bajty, które mogą być używane jako klucz przy użyciu funkcji skrótu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-138">Derives bytes that can be used as a key using a hash function .</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="8b3a0-139">Klucz publiczny innej strony.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-139">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="8b3a0-140">Algorytm wyznaczania wartości skrótu, który ma być używany do wyprowadzania materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-140">The hash algorithm  to use to derive the key material.</span></span></param>
        <summary><span data-ttu-id="8b3a0-141">Tworzy bajty, które mogą być używane jako klucz przy użyciu funkcji skrótu, z uwzględnieniem klucza publicznego i nazwy algorytmu wyznaczania wartości skrótu przez inną osobę.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-141">Derives bytes that can be used as a key using a hash function, given another party's public key and hash algorithm's name.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-142">Kluczowy materiał od wymiany klucza z kluczem publicznym innej firmy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-142">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-143">To Przeciążenie wywołuje <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> metodę przekazującą `null` wartości poprzedź i Append.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-143">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b3a0-144"><paramref name="otherPartyPublicKey" />znajduje się na innej krzywej niż ten klucz.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-144"><paramref name="otherPartyPublicKey" /> is over a different curve than this key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm, secretPrepend, secretAppend)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretAppend" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="8b3a0-145">Klucz publiczny innej strony.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-145">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="8b3a0-146">Algorytm wyznaczania wartości skrótu, który ma być używany do wyprowadzania materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-146">The hash algorithm  to use to derive the key material.</span></span></param>
        <param name="secretPrepend"><span data-ttu-id="8b3a0-147">Wartość, która ma zostać dołączona do pochodnego klucza tajnego przed mieszaniem.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-147">A value to prepend to the derived secret before hashing.</span></span></param>
        <param name="secretAppend"><span data-ttu-id="8b3a0-148">Wartość do dołączenia do pochodnego klucza tajnego przed mieszaniem.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-148">A value to append to the derived secret before hashing.</span></span></param>
        <summary><span data-ttu-id="8b3a0-149">W przypadku zaimplementowania w klasie pochodnej bajty, które mogą być używane jako klucz przy użyciu funkcji skrótu, podaną przez użytkownika klucz publiczny, nazwa algorytmu wyznaczania wartości skrótu, wartość dołączenia i wartość dołączania.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-149">When implemented in a derived class, derives bytes that can be used as a key using a hash function, given another party's public key, hash algorithm's name, a prepend value and an append value.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-150">Kluczowy materiał od wymiany klucza z kluczem publicznym innej firmy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-150">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8b3a0-151">Klasa pochodna musi przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-151">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b3a0-152"><paramref name="otherPartyPublicKey" />znajduje się na innej krzywej niż ten klucz.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-152"><paramref name="otherPartyPublicKey" /> is over a different curve than this key.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHmac">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b3a0-153">Tworzy bajty, które mogą być używane jako klucz przy użyciu kod uwierzytelniania wiadomości opartego na skrótach (HMAC).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-153">Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hmacKey" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="8b3a0-154">Klucz publiczny innej strony.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-154">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="8b3a0-155">Algorytm wyznaczania wartości skrótu, który ma być używany do wyprowadzania materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-155">The hash algorithm to use to derive the key material.</span></span></param>
        <param name="hmacKey"><span data-ttu-id="8b3a0-156">Klucz dla algorytmu HMAC.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-156">The key for the HMAC.</span></span></param>
        <summary><span data-ttu-id="8b3a0-157">Tworzy bajty, które mogą być używane jako klucz przy użyciu kod uwierzytelniania wiadomości opartego na skrótach (HMAC).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-157">Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span></span></summary>
        <returns><span data-ttu-id="8b3a0-158">Kluczowy materiał od wymiany klucza z kluczem publicznym innej firmy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-158">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-159">To Przeciążenie wywołuje <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> metodę przekazującą `null` wartości poprzedź i Append.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-159">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b3a0-160"><paramref name="otherPartyPublicKey" />znajduje się na innej krzywej niż ten klucz.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-160"><paramref name="otherPartyPublicKey" /> is over a different curve than this key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte(), secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey, secretPrepend, secretAppend)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hmacKey" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretAppend" Type="System.Byte[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="8b3a0-161">Klucz publiczny innej strony.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-161">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="8b3a0-162">Algorytm wyznaczania wartości skrótu, który ma być używany do wyprowadzania materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-162">The hash algorithm to use to derive the key material.</span></span></param>
        <param name="hmacKey"><span data-ttu-id="8b3a0-163">Klucz dla algorytmu HMAC.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-163">The key for the HMAC.</span></span></param>
        <param name="secretPrepend"><span data-ttu-id="8b3a0-164">Wartość, która ma zostać dołączona do pochodnego klucza tajnego przed mieszaniem.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-164">A value to prepend to the derived secret before hashing.</span></span></param>
        <param name="secretAppend"><span data-ttu-id="8b3a0-165">Wartość do dołączenia do pochodnego klucza tajnego przed mieszaniem.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-165">A value to append to the derived secret before hashing.</span></span></param>
        <summary><span data-ttu-id="8b3a0-166">W przypadku zaimplementowania w klasie pochodnej bajty, które mogą być używane jako klucz przy użyciu kod uwierzytelniania wiadomości opartego na skrótach (HMAC).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-166">When implemented in a derived class, derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span></span></summary>
        <returns><span data-ttu-id="8b3a0-167">Kluczowy materiał od wymiany klucza z kluczem publicznym innej firmy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-167">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8b3a0-168">Klasa pochodna musi przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-168">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b3a0-169"><paramref name="otherPartyPublicKey" />znajduje się na innej krzywej niż ten klucz.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-169"><paramref name="otherPartyPublicKey" /> is over a different curve than this key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]&#xA;override this.DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyMaterial otherPartyPublicKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="8b3a0-170">Klucz publiczny innej strony.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-170">The other party's public key.</span></span></param>
        <summary><span data-ttu-id="8b3a0-171">Tworzy bajty, które mogą być użyte jako klucz, przy podanym kluczu publicznym innej strony.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-171">Derives bytes that can be used as a key, given another party's public key.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-172">Kluczowy materiał od wymiany klucza z kluczem publicznym innej firmy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-172">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-173">Aby uzyskać więcej informacji na temat kluczy publicznych, <xref:System.Security.Cryptography.ECDiffieHellmanPublicKey> zobacz Klasa.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-173">For more information about public keys, see the <xref:System.Security.Cryptography.ECDiffieHellmanPublicKey> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyTls">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyTls (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyTls(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, unsigned int8[] prfLabel, unsigned int8[] prfSeed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyTls (otherPartyPublicKey As ECDiffieHellmanPublicKey, prfLabel As Byte(), prfSeed As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyTls(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, cli::array &lt;System::Byte&gt; ^ prfLabel, cli::array &lt;System::Byte&gt; ^ prfSeed);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyTls (otherPartyPublicKey, prfLabel, prfSeed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="prfLabel" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="prfSeed" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="8b3a0-174">Klucz publiczny innej strony.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-174">The other party's public key.</span></span></param>
        <param name="prfLabel"><span data-ttu-id="8b3a0-175">Etykieta PRF zakodowana w formacie ASCII.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-175">The ASCII-encoded PRF label.</span></span></param>
        <param name="prfSeed"><span data-ttu-id="8b3a0-176">64-bajtowy inicjator PRF.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-176">The 64-byte PRF seed.</span></span></param>
        <summary><span data-ttu-id="8b3a0-177">W przypadku zaimplementowania w klasie pochodnej bajty, które mogą być używane jako klucz przy Transport Layer Security użyciu algorytmu wyznaczania PRF (TLS).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-177">When implemented in a derived class, derives bytes that can be used as a key using a Transport Layer Security (TLS) Pseudo-Random Function (PRF) derivation algorithm.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-178">Kluczowy materiał od wymiany klucza z kluczem publicznym innej firmy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-178">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8b3a0-179">Klasa pochodna musi przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-179">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b3a0-180"><paramref name="otherPartyPublicKey" />znajduje się na innej krzywej niż ten klucz.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-180"><paramref name="otherPartyPublicKey" /> is over a different curve than this key.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b3a0-181"><paramref name="prfLabel" />lub <paramref name="prfSeed" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-181"><paramref name="prfLabel" /> or <paramref name="prfSeed" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-182"><paramref name="prfSeed" />nie ma dokładnie 64 bajtów.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-182"><paramref name="prfSeed" /> is not exactly 64 bytes in length.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual byte[] ExportECPrivateKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportECPrivateKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportECPrivateKey () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportECPrivateKey();" />
      <MemberSignature Language="F#" Value="abstract member ExportECPrivateKey : unit -&gt; byte[]&#xA;override this.ExportECPrivateKey : unit -&gt; byte[]" Usage="eCDiffieHellman.ExportECPrivateKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b3a0-183">Eksportuje bieżący klucz w formacie ECPrivateKey.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-183">Exports the current key in the ECPrivateKey format.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-184">Tablica bajtowa zawierająca reprezentację ECPrivateKey tego klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-184">A byte array containing the ECPrivateKey representation of this key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-185">Nie można wyeksportować klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-185">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportExplicitParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="8b3a0-186"><see langword="true" />Aby uwzględnić parametry prywatne; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="8b3a0-186"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="8b3a0-187">Gdy jest zastępowany w klasie pochodnej, eksportuje publiczny lub publiczny i prywatny klucz informacji przy użyciu jawnego formularza krzywej z klucza roboczego <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> <see cref="T:System.Security.Cryptography.ECParameters" /> do struktury, tak aby <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> można go było przesłać do metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-187">When overridden in a derived class, exports either the public or the public and private key information using the explicit curve form from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-188">Obiekt, który reprezentuje punkt na krzywej dla tego klucza, przy użyciu formatu krzywej jawnej.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-188">An object that represents the point on the curve for this key, using the explicit curve format.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8b3a0-189">Klasa pochodna musi przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-189">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="8b3a0-190"><see langword="true" />Aby uwzględnić parametry prywatne; w przeciwnym <see langword="false" /> razie, aby uwzględnić tylko parametry publiczne.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-190"><see langword="true" /> to include private parameters; otherwise, <see langword="false" /> to include public parameters only.</span></span></param>
        <summary><span data-ttu-id="8b3a0-191">Gdy jest zastępowany w klasie pochodnej, eksportuje publiczny lub publiczny i prywatny klucz informacji z klucza roboczego <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> <see cref="T:System.Security.Cryptography.ECParameters" /> do struktury, tak aby <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> można go było przesłać do metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-191">When overridden in a derived class, exports either the public or the public and private key information from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-192">Obiekt, który reprezentuje punkt na krzywej dla tego klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-192">An object that represents the point on the curve for this key.</span></span> <span data-ttu-id="8b3a0-193">Można go przesłać do <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-193">It can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-194">Jeśli krzywa ma nazwę, <xref:System.Security.Cryptography.ECParameters.Curve> Właściwość zawiera nazwane parametry krzywej; w przeciwnym razie będzie zawierać jawne parametry.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-194">If the curve has a name, the <xref:System.Security.Cryptography.ECParameters.Curve> property contains named curve parameters; otherwise, it will contain explicit parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8b3a0-195">Klasa pochodna musi przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-195">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberSignature Language="F#" Value="override this.FromXmlString : string -&gt; unit" Usage="eCDiffieHellman.FromXmlString xmlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="xmlString"><span data-ttu-id="8b3a0-196">Ciąg XML, który ma zostać użyty do odtworzenia <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-196">The XML string to use to reconstruct the <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> object.</span></span></param>
        <summary><span data-ttu-id="8b3a0-197">Ta metoda zgłasza we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-197">This method throws in all cases.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="System.NotImplementedException"><span data-ttu-id="8b3a0-198">We wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-198">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public virtual void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="abstract member GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit&#xA;override this.GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit" Usage="eCDiffieHellman.GenerateKey curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="curve"><span data-ttu-id="8b3a0-199">Krzywa użyta do wygenerowania pary kluczy publicznych/prywatnych.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-199">The curve used to generate an ephemeral public/private key pair.</span></span></param>
        <summary><span data-ttu-id="8b3a0-200">Gdy jest zastępowany w klasie pochodnej, generuje nową parę klucza publicznego/prywatnego dla określonej krzywej.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-200">When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-201">`curve`należy sprawdzić poprawność (oznacza to, `true`że musi zwrócić) <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> w przypadku przekazywania do metody) i nie może być niejawna.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-201">`curve` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method) and must not be implicit.</span></span>  
  
 <span data-ttu-id="8b3a0-202">Krzywe charakterystyki 2 nie są obsługiwane w systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-202">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-203"><paramref name="curve" />nie sprawdza poprawności.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-203"><paramref name="curve" /> does not validate.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8b3a0-204">Klasa pochodna musi przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-204">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual void ImportECPrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportECPrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportECPrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportECPrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="abstract member ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; *  -&gt; unit&#xA;override this.ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportECPrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="8b3a0-205">Bajty struktury ECPrivateKey w kodowaniu ASN. 1-w.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-205">The bytes of an ECPrivateKey structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="8b3a0-206">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-206">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="8b3a0-207">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-207">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="8b3a0-208">Importuje parę kluczy publiczny/prywatny z struktury ECPrivateKey, zastępując klucze dla tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-208">Imports the public/private keypair from an ECPrivateKey structure, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-209">Ta metoda obsługuje tylko kodowanie binarne (//CER/DER) ECPrivateKey.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-209">This method only supports the binary (BER/CER/DER) encoding of ECPrivateKey.</span></span>
<span data-ttu-id="8b3a0-210">Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-210">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-211">Zawartość <paramref name="source" /> nie reprezentuje struktury ECPrivateKey PKCS # 8 w formacie ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-211">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 ECPrivateKey structure.</span></span>

<span data-ttu-id="8b3a0-212">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-212">-or-</span></span>

<span data-ttu-id="8b3a0-213">Importowanie klucza nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-213">The key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (passwordBytes As ReadOnlySpan(Of Byte), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportEncryptedPkcs8PrivateKey (passwordBytes, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="passwordBytes"><span data-ttu-id="8b3a0-214">Bajty, które mają być używane jako hasło podczas odszyfrowywania materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-214">The bytes to use as a password when decrypting the key material.</span></span></param>
        <param name="source"><span data-ttu-id="8b3a0-215">Bajty struktury EncryptedPrivateKeyInfo PKCS # 8 w kodowaniu ASN. 1-w.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-215">The bytes of a PKCS#8 EncryptedPrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="8b3a0-216">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-216">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="8b3a0-217">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-217">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="8b3a0-218">Importuje parę kluczy publiczny/prywatny ze struktury EncryptedPrivateKeyInfo PKCS # 8 Po odszyfrowaniu przy użyciu hasła opartego na bajtach, zastępując klucze dla tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-218">Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a byte-based password, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-219">Bajty hasła są przesyłane bezpośrednio do funkcji wyprowadzania klucza (KDF) używanej przez algorytm wskazywany przez zawartość EncryptedPrivateKeyInfo.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-219">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by the EncryptedPrivateKeyInfo contents.</span></span>
<span data-ttu-id="8b3a0-220">Dzięki temu można zapewnić zgodność z innymi systemami, które używają kodowania tekstu innego niż UTF-8 podczas przetwarzania haseł z PBKDF2 (klucz oparty na haśle funkcja 2).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-220">This enables compatibility with other systems which use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>
<span data-ttu-id="8b3a0-221">Ta metoda obsługuje tylko kodowanie binarne (//CER/DER) EncryptedPrivateKeyInfo.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-221">This method only supports the binary (BER/CER/DER) encoding of EncryptedPrivateKeyInfo.</span></span>
<span data-ttu-id="8b3a0-222">Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-222">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-223">Hasło jest niepoprawne.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-223">The password is incorrect.</span></span>

<span data-ttu-id="8b3a0-224">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-224">-or-</span></span>

<span data-ttu-id="8b3a0-225">Zawartość <paramref name="source" /> wskaż funkcję wyprowadzania klucza (KDF), która ma zostać zastosowana, jest starszą wersją PKCS # 12 <see cref="T:System.Char" />KDF, która wymaga haseł opartych na plikach.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-225">The contents of <paramref name="source" /> indicate the Key Derivation Function (KDF) to apply is the legacy PKCS#12 KDF, which requires <see cref="T:System.Char" />-based passwords.</span></span>

<span data-ttu-id="8b3a0-226">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-226">-or-</span></span>

<span data-ttu-id="8b3a0-227">Zawartość <paramref name="source" /> nie reprezentuje struktury EncryptedPrivateKeyInfo PKCS # 8 w formacie ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-227">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="8b3a0-228">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-228">-or-</span></span>

<span data-ttu-id="8b3a0-229">Zawartość <paramref name="source" /> wskazuje, że klucz jest dla algorytmu innego niż algorytm reprezentowany przez to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-229">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="8b3a0-230">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-230">-or-</span></span>

<span data-ttu-id="8b3a0-231">Zawartość <paramref name="source" /> reprezentująca klucz w formacie, który nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-231">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="8b3a0-232">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-232">-or-</span></span>

<span data-ttu-id="8b3a0-233">Importowanie klucza specyficznego dla algorytmu nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-233">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (password As ReadOnlySpan(Of Char), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportEncryptedPkcs8PrivateKey (password, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="8b3a0-234">Hasło używane do odszyfrowywania materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-234">The password to use for decrypting the key material.</span></span></param>
        <param name="source"><span data-ttu-id="8b3a0-235">Bajty struktury EncryptedPrivateKeyInfo PKCS # 8 w kodowaniu ASN. 1-w.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-235">The bytes of a PKCS#8 EncryptedPrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="8b3a0-236">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-236">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="8b3a0-237">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-237">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="8b3a0-238">Importuje parę kluczy publiczny/prywatny ze struktury EncryptedPrivateKeyInfo PKCS # 8 Po odszyfrowaniu przy użyciu hasła opartego na znakach, zastępując klucze dla tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-238">Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a char-based password, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-239">Gdy zawartość `source` wskazuje algorytm używający funkcji PBKDF1 (klucza opartego na hasłach) lub PBKDF2 (klucz oparty na hasłach, funkcja 2), hasło jest konwertowane na bajty przy użyciu kodowania UTF-8.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-239">When the contents of `source` indicate an algorithm that uses PBKDF1 (Password-Based Key Derivation Function 1) or PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>
<span data-ttu-id="8b3a0-240">Ta metoda obsługuje tylko kodowanie binarne (//CER/DER) EncryptedPrivateKeyInfo.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-240">This method only supports the binary (BER/CER/DER) encoding of EncryptedPrivateKeyInfo.</span></span>
<span data-ttu-id="8b3a0-241">Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-241">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-242">Hasło jest niepoprawne.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-242">The password is incorrect.</span></span>

<span data-ttu-id="8b3a0-243">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-243">-or-</span></span>

<span data-ttu-id="8b3a0-244">Zawartość <paramref name="source" /> nie reprezentuje struktury EncryptedPrivateKeyInfo PKCS # 8 w formacie ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-244">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="8b3a0-245">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-245">-or-</span></span>

<span data-ttu-id="8b3a0-246">Zawartość <paramref name="source" /> wskazuje, że klucz jest dla algorytmu innego niż algorytm reprezentowany przez to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-246">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="8b3a0-247">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-247">-or-</span></span>

<span data-ttu-id="8b3a0-248">Zawartość <paramref name="source" /> reprezentująca klucz w formacie, który nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-248">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="8b3a0-249">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-249">-or-</span></span>

<span data-ttu-id="8b3a0-250">Importowanie klucza specyficznego dla algorytmu nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-250">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public virtual void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="abstract member ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit&#xA;override this.ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit" Usage="eCDiffieHellman.ImportParameters parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="parameters"><span data-ttu-id="8b3a0-251">Parametry krzywej do zaimportowania.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-251">The curve's parameters to import.</span></span></param>
        <summary><span data-ttu-id="8b3a0-252">Gdy jest zastępowany w klasie pochodnej, importuje określone parametry <see cref="T:System.Security.Cryptography.ECCurve" /> jako klucz tymczasowych do bieżącego <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-252">When overridden in a derived class, imports the specified parameters for an <see cref="T:System.Security.Cryptography.ECCurve" /> as an ephemeral key into the current <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-253">`parameters`należy sprawdzić poprawność (oznacza to, `true`że musi zwrócić) podczas <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> przekazywania do metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-253">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b3a0-254">Parametry przekroczenia niejawnych krzywych nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-254">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="8b3a0-255">Krzywe charakterystyki 2 nie są obsługiwane w systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-255">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-256"><paramref name="parameters" />nie sprawdza poprawności.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-256"><paramref name="parameters" /> does not validate.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8b3a0-257">Klasa pochodna musi przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-257">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportPkcs8PrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportPkcs8PrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="8b3a0-258">Bajty struktury PrivateKeyInfo PKCS # 8 w kodowaniu ASN. 1-w.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-258">The bytes of a PKCS#8 PrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="8b3a0-259">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-259">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="8b3a0-260">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-260">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="8b3a0-261">Importuje parę kluczy publiczny/prywatny ze struktury PrivateKeyInfo PKCS # 8 Po odszyfrowaniu, zastępując klucze dla tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-261">Imports the public/private keypair from a PKCS#8 PrivateKeyInfo structure after decryption, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-262">Ta metoda obsługuje tylko kodowanie binarne (//CER/DER) PrivateKeyInfo.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-262">This method only supports the binary (BER/CER/DER) encoding of PrivateKeyInfo.</span></span>
<span data-ttu-id="8b3a0-263">Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-263">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-264">Zawartość <paramref name="source" /> nie reprezentuje struktury PrivateKeyInfo PKCS # 8 w formacie ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-264">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 PrivateKeyInfo structure.</span></span>

<span data-ttu-id="8b3a0-265">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-265">-or-</span></span>

<span data-ttu-id="8b3a0-266">Zawartość <paramref name="source" /> wskazuje, że klucz jest dla algorytmu innego niż algorytm reprezentowany przez to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-266">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="8b3a0-267">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-267">-or-</span></span>

<span data-ttu-id="8b3a0-268">Zawartość <paramref name="source" /> reprezentująca klucz w formacie, który nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-268">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="8b3a0-269">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-269">-or-</span></span>

<span data-ttu-id="8b3a0-270">Importowanie klucza specyficznego dla algorytmu nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-270">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override void ImportSubjectPublicKeyInfo (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportSubjectPublicKeyInfo(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportSubjectPublicKeyInfo (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportSubjectPublicKeyInfo(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportSubjectPublicKeyInfo : ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportSubjectPublicKeyInfo (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="8b3a0-271">Bajty struktury SubjectPublicKeyInfo X. 509 w kodowaniu ASN. 1-DER.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-271">The bytes of an X.509 SubjectPublicKeyInfo structure in the ASN.1-DER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="8b3a0-272">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-272">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="8b3a0-273">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-273">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="8b3a0-274">Importuje klucz publiczny z struktury SubjectPublicKeyInfo X. 509 po odszyfrowaniu, zastępując klucze dla tego obiektu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-274">Imports the public key from an X.509 SubjectPublicKeyInfo structure after decryption, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-275">Ta metoda obsługuje tylko kodowanie binarne (DER) SubjectPublicKeyInfo.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-275">This method only supports the binary (DER) encoding of SubjectPublicKeyInfo.</span></span>
<span data-ttu-id="8b3a0-276">Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-276">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-277">Zawartość <paramref name="source" /> nie reprezentuje struktury SubjectPublicKeyInfo X. 509 w formacie ASN. 1-der.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-277">The contents of <paramref name="source" /> do not represent an ASN.1-DER-encoded X.509 SubjectPublicKeyInfo structure.</span></span>

<span data-ttu-id="8b3a0-278">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-278">-or-</span></span>

<span data-ttu-id="8b3a0-279">Zawartość <paramref name="source" /> wskazuje, że klucz jest dla algorytmu innego niż algorytm reprezentowany przez to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-279">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="8b3a0-280">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-280">-or-</span></span>

<span data-ttu-id="8b3a0-281">Zawartość <paramref name="source" /> reprezentująca klucz w formacie, który nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-281">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="8b3a0-282">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-282">-or-</span></span>

<span data-ttu-id="8b3a0-283">Importowanie klucza specyficznego dla algorytmu nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-283">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property KeyExchangeAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyExchangeAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8b3a0-284">Pobiera nazwę algorytmu wymiany kluczy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-284">Gets the name of the key exchange algorithm.</span></span></summary>
        <value><span data-ttu-id="8b3a0-285">Nazwa algorytmu wymiany kluczy.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-285">The name of the key exchange algorithm.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-286">Domyślna (niezastąpiona) implementacja tej właściwości zwraca ciąg "ECDiffieHellman".</span><span class="sxs-lookup"><span data-stu-id="8b3a0-286">The default (non-overridden) implementation of this property returns the string "ECDiffieHellman".</span></span>  
  
 <span data-ttu-id="8b3a0-287">Ta właściwość jest dziedziczona z <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-287">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PublicKey As ECDiffieHellmanPublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Security::Cryptography::ECDiffieHellmanPublicKey ^ PublicKey { System::Security::Cryptography::ECDiffieHellmanPublicKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PublicKey : System.Security.Cryptography.ECDiffieHellmanPublicKey" Usage="System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanPublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8b3a0-288">Pobiera klucz publiczny, który jest używany przez bieżące wystąpienie krzywej eliptycznej diff-Hellmana (ECDH).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-288">Gets the public key that is being used by the current Elliptic Curve Diffie-Hellman (ECDH) instance.</span></span></summary>
        <value><span data-ttu-id="8b3a0-289">Publiczna część pary kluczy ECDH, która jest używana przez to <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-289">The public part of the ECDH key pair that is being used by this <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> instance.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SignatureAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SignatureAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8b3a0-290">Pobiera nazwę algorytmu podpisu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-290">Gets the name of the signature algorithm.</span></span></summary>
        <value><span data-ttu-id="8b3a0-291">Zawsze <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-291">Always <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-292">Ta właściwość jest dziedziczona z <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-292">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 <span data-ttu-id="8b3a0-293">Algorytm eliptyczna Diffie-Hellmana (ECDH) jest używany do wyprowadzania klucza, a nie generowania podpisów cyfrowych.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-293">The Elliptic Curve Diffie-Hellman (ECDH) algorithm is used for key derivation, not digital signature generation.</span></span> <span data-ttu-id="8b3a0-294">W związku z tym ta `null`Właściwość zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-294">Therefore, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="override this.ToXmlString : bool -&gt; string" Usage="eCDiffieHellman.ToXmlString includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="8b3a0-295"><see langword="true" />Aby uwzględnić parametry prywatne; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="8b3a0-295"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="8b3a0-296">Ta metoda zgłasza we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-296">This method throws in all cases.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-297">Ta metoda nie zwraca wartości.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-297">This method does not return a value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="System.NotImplementedException"><span data-ttu-id="8b3a0-298">We wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-298">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual bool TryExportECPrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryExportECPrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryExportECPrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryExportECPrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryExportECPrivateKey : Span&lt;byte&gt; *  -&gt; bool&#xA;override this.TryExportECPrivateKey : Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportECPrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="8b3a0-299">Zakres bajtów do odbierania danych ECPrivateKey.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-299">The byte span to receive the ECPrivateKey data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="8b3a0-300">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-300">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="8b3a0-301">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-301">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="8b3a0-302">Próbuje wyeksportować bieżący klucz w formacie ECPrivateKey do podanego buforu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-302">Attempts to export the current key in the ECPrivateKey format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-303"><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-303"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-304">Nie można wyeksportować klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-304">The key could not be exported.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey()" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportEncryptedPkcs8PrivateKey (passwordBytes, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="passwordBytes"><span data-ttu-id="8b3a0-305">Bajty, które mają być używane jako hasło podczas szyfrowania materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-305">The bytes to use as a password when encrypting the key material.</span></span></param>
        <param name="pbeParameters"><span data-ttu-id="8b3a0-306">Parametry szyfrowania opartego na hasłach (PBE), które mają być używane podczas szyfrowania materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-306">The password-based encryption (PBE) parameters to use when encrypting the key material.</span></span></param>
        <param name="destination"><span data-ttu-id="8b3a0-307">Zakres bajtów do odbierania danych EncryptedPrivateKeyInfo PKCS # 8.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-307">The byte span to receive the PKCS#8 EncryptedPrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="8b3a0-308">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-308">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="8b3a0-309">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-309">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="8b3a0-310">Próbuje wyeksportować bieżący klucz w formacie EncryptedPrivateKeyInfo PKCS # 8 do podanego buforu przy użyciu hasła opartego na bajtach.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-310">Attempts to export the current key in the PKCS#8 EncryptedPrivateKeyInfo format into a provided buffer, using a byte-based password.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-311"><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-311"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-312">Bajty hasła są przesyłane bezpośrednio do funkcji wyprowadzania klucza (KDF) używanej przez algorytm wskazywany `pbeParameters`przez.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-312">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by `pbeParameters`.</span></span>
<span data-ttu-id="8b3a0-313">Dzięki temu można zapewnić zgodność z innymi systemami, które używają kodowania tekstu innego niż UTF-8 podczas przetwarzania haseł z PBKDF2 (klucz oparty na haśle funkcja 2).</span><span class="sxs-lookup"><span data-stu-id="8b3a0-313">This enables compatibility with other systems which use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-314">Nie można wyeksportować klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-314">The key could not be exported.</span></span>

<span data-ttu-id="8b3a0-315">—lub—</span><span class="sxs-lookup"><span data-stu-id="8b3a0-315">-or-</span></span>

<span data-ttu-id="8b3a0-316"><paramref name="pbeParameters" />wskazuje, <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> że powinny być używane, które <see cref="T:System.Char" />wymaga haseł opartych na.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-316"><paramref name="pbeParameters" /> indicates that <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> should be used, which requires <see cref="T:System.Char" />-based passwords.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportEncryptedPkcs8PrivateKey (password, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="8b3a0-317">Hasło, które ma być używane podczas szyfrowania materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-317">The password to use when encrypting the key material.</span></span></param>
        <param name="pbeParameters"><span data-ttu-id="8b3a0-318">Parametry szyfrowania opartego na hasłach (PBE), które mają być używane podczas szyfrowania materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-318">The password-based encryption (PBE) parameters to use when encrypting the key material.</span></span></param>
        <param name="destination"><span data-ttu-id="8b3a0-319">Zakres bajtów do odbierania danych EncryptedPrivateKeyInfo PKCS # 8.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-319">The byte span to receive the PKCS#8 EncryptedPrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="8b3a0-320">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-320">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="8b3a0-321">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-321">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="8b3a0-322">Próbuje wyeksportować bieżący klucz w formacie EncryptedPrivateKeyInfo PKCS # 8 do podanego buforu przy użyciu hasła opartego na znakach.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-322">Attempts to export the current key in the PKCS#8 EncryptedPrivateKeyInfo format into a provided buffer, using a char-based password.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-323"><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-323"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b3a0-324">Gdy `pbeParameters` wskazuje algorytm korzystający z PBKDF2 (klucz oparty na hasłach funkcja 2), hasło jest konwertowane na bajty przy użyciu kodowania UTF-8.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-324">When `pbeParameters` indicates an algorithm that uses PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-325">Nie można wyeksportować klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-325">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportPkcs8PrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportPkcs8PrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportPkcs8PrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportPkcs8PrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportPkcs8PrivateKey : Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportPkcs8PrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="8b3a0-326">Zakres bajtów do odbierania danych PrivateKeyInfo PKCS # 8.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-326">The byte span to receive the PKCS#8 PrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="8b3a0-327">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-327">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="8b3a0-328">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-328">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="8b3a0-329">Próbuje wyeksportować bieżący klucz w formacie PrivateKeyInfo PKCS # 8 do podanego buforu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-329">Attempts to export the current key in the PKCS#8 PrivateKeyInfo format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-330"><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-330"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-331">Nie można wyeksportować klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-331">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override bool TryExportSubjectPublicKeyInfo (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportSubjectPublicKeyInfo(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportSubjectPublicKeyInfo (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportSubjectPublicKeyInfo(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportSubjectPublicKeyInfo : Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportSubjectPublicKeyInfo (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="8b3a0-332">Zakres bajtów do odbierania danych SubjectPublicKeyInfo X. 509.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-332">The byte span to receive the X.509 SubjectPublicKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="8b3a0-333">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-333">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="8b3a0-334">Ten parametr jest traktowany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-334">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="8b3a0-335">Próbuje wyeksportować bieżący klucz w formacie X. 509 SubjectPublicKeyInfo do podanego buforu.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-335">Attempts to export the current key in the X.509 SubjectPublicKeyInfo format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="8b3a0-336"><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-336"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="8b3a0-337">Nie można wyeksportować klucza.</span><span class="sxs-lookup"><span data-stu-id="8b3a0-337">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportSubjectPublicKeyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="SymmetricAlgorithm" FullName="System.Security.Cryptography.SymmetricAlgorithm">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d20969f0f8dd5914901bf0c98eb58e2cfb3c5219" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30570874" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SymmetricAlgorithm : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SymmetricAlgorithm extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.SymmetricAlgorithm" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SymmetricAlgorithm&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SymmetricAlgorithm abstract : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje abstrakcyjna klasa podstawowa, w którym wszystkie implementacje symetryczne algorytmy musi dziedziczyć.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które pochodzą z <xref:System.Security.Cryptography.SymmetricAlgorithm> klasy użyj trybu CBC, cipher block chaining (CBC), nazywany co wymaga klucza (<xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A>) i wektor inicjowania (<xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A>) do wykonania kryptograficznych przekształcenia danych.  Do odszyfrowywania danych, która została zaszyfrowana przy użyciu jednej z <xref:System.Security.Cryptography.SymmetricAlgorithm> klasy, należy ustawić <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> właściwości i <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> właściwości na te same wartości, które były używane do szyfrowania.  Dla algorytmu symetrycznego powinna być użyteczna klucz tajny musi być znane tylko do nadawcy i odbiorcy.  
  
 <xref:System.Security.Cryptography.RijndaelManaged>, <xref:System.Security.Cryptography.DESCryptoServiceProvider>, <xref:System.Security.Cryptography.RC2CryptoServiceProvider>, i <xref:System.Security.Cryptography.TripleDESCryptoServiceProvider> są implementacje symetryczne algorytmy.  
  
 Należy pamiętać, że przy użyciu klasy pochodne nie ma wystarczającej ilości, z punktu widzenia zabezpieczeń, aby wymusić po prostu wyrzucania elementów bezużytecznych, po zakończeniu przy użyciu obiektu. Należy jawnie wywołać <xref:System.Security.Cryptography.SymmetricAlgorithm.Clear%2A> metody dla obiekt do zera się żadnych poufnych danych w obiekcie przed zwolnieniem. Pamiętaj, że pamięci nie jest zerowa poza zawartość zebranych obiektów, ale po prostu oznacza pamięci dostępnej dla; Ponowna alokacja. W związku z tym dane zawarte w obiekcie zebranych pamięci może nadal znajdować się w pamięci sterty w pamięci nieprzydzielonego. W przypadku obiektów kryptograficznych te dane mogą zawierać poufne informacje, takie jak dane klucza lub blok zwykłego tekstu.  
  
 Wszystkie kryptograficznych klas w programie .NET Framework, zawierających poufne dane wdrożenie `Clear` metody. Po wywołaniu `Clear` — metoda spowoduje zastąpienie wszystkich danych poufnych w obiekt zerami, a następnie zwalnia obiekt, dzięki czemu można bezpiecznie bezużytecznych. Gdy obiekt został mają być wyzerowane i opublikowany, powinny wywoływać `Dispose` metody z `disposing` ustawiona `True` zlikwidować wszystkie zarządzane i niezarządzane zasoby skojarzone z obiektem.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Security.Cryptography.RijndaelManaged> klasy z określonym <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> właściwości i wektora inicjowania (<xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A>) do zaszyfrowania pliku określonego przez `inName`i umieszcza wynik zaszyfrowany do pliku określonego przez `outName`. `desKey` i `desIV` parametry metody są tablice typu byte 8. Musi mieć zainstalowane do uruchamiania w tym przykładzie pakiet silnego szyfrowania.  
  
 [!code-cpp[Classic CryptoStream Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic CryptoStream Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CryptoStream Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic CryptoStream Example/CS/source.cs#1)]
 [!code-vb[Classic CryptoStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic CryptoStream Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Przy dziedziczeniu z <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> klasy, konieczne jest przesłonięcie następujących członków: <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor(System.Byte[],System.Byte[])" />, <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor(System.Byte[],System.Byte[])" />, <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV" />, i <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SymmetricAlgorithm ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SymmetricAlgorithm();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można utworzyć wystąpienia klasy abstrakcyjnej. Kod aplikacji tworzy nowe wystąpienie klasy pochodnej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Implementacja klasy pochodzące z algorytmu symetrycznego jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="BlockSize">
      <MemberSignature Language="C#" Value="public virtual int BlockSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BlockSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.BlockSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BlockSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int BlockSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar bloku w bitach operacji kryptograficznych.</summary>
        <value>Rozmiar bloku w bitach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar bloku jest podstawową jednostką danych, które mogą być szyfrowane lub odszyfrować w jednej operacji. Komunikaty dłużej niż rozmiar bloku są obsługiwane jako kolejnych bloków; krótszy niż rozmiar bloku komunikatów musi być wypełniane dodatkowe bity do osiągnięcia rozmiaru bloku. Nieprawidłowy blok rozmiary są określane przez algorytmu symetrycznego używane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Rozmiar bloku jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="BlockSizeValue">
      <MemberSignature Language="C#" Value="protected int BlockSizeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 BlockSizeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.BlockSizeValue" />
      <MemberSignature Language="VB.NET" Value="Protected BlockSizeValue As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int BlockSizeValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje rozmiar bloku, w bitach operacji kryptograficznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar bloku jest podstawową jednostką danych, które mogą być szyfrowane lub odszyfrować w jednej operacji. Komunikaty dłużej niż rozmiar bloku są obsługiwane jako kolejnych bloków; krótszy niż rozmiar bloku komunikatów musi być wypełniane dodatkowe bity do osiągnięcia rozmiaru bloku. Nieprawidłowy blok rozmiary są określane przez algorytmu symetrycznego używane.  
  
 To pole jest dostępny za pośrednictwem <xref:System.Security.Cryptography.SymmetricAlgorithm.BlockSize%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że przy użyciu klasy pochodne nie ma wystarczającej ilości, z punktu widzenia zabezpieczeń, aby wymusić po prostu wyrzucania elementów bezużytecznych, po zakończeniu przy użyciu obiektu. Należy jawnie wywołać <xref:System.Security.Cryptography.SymmetricAlgorithm.Clear%2A> metody dla obiekt do zera się żadnych poufnych danych w obiekcie przed zwolnieniem. Pamiętaj, że pamięci nie jest zerowa poza zawartość zebranych obiektów, ale po prostu oznacza pamięci dostępnej dla; Ponowna alokacja. W związku z tym dane zawarte w obiekcie zebranych pamięci może nadal znajdować się w pamięci sterty w pamięci nieprzydzielonego. W przypadku obiektów kryptograficznych te dane mogą zawierać poufne informacje, takie jak dane klucza lub blok zwykłego tekstu.  
  
 Wszystkie kryptograficznych klas w programie .NET Framework, zawierających poufne dane wdrożenie `Clear` metody. Po wywołaniu `Clear` — metoda spowoduje zastąpienie wszystkich danych poufnych w obiekt zerami, a następnie zwalnia obiekt, dzięki czemu można bezpiecznie bezużytecznych. Gdy obiekt został mają być wyzerowane i opublikowany, powinny wywoływać `Dispose` metody z `disposing` ustawiona `True` zlikwidować wszystkie zarządzane i niezarządzane zasoby skojarzone z obiektem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt kryptograficzne używane do wykonywania algorytmu symetrycznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.SymmetricAlgorithm Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.SymmetricAlgorithm Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As SymmetricAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::SymmetricAlgorithm ^ Create();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.SymmetricAlgorithm</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy domyślny obiekt kryptograficzne używane do wykonywania algorytmu symetrycznego.</summary>
        <returns>Domyślny obiekt kryptograficzne używane do wykonywania algorytmu symetrycznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Security.Cryptography.RijndaelManaged> klasy z określonym <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> właściwości i wektora inicjowania (<xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A>) do zaszyfrowania pliku określonego przez `inName`i umieszcza wynik zaszyfrowany do pliku określonego przez `outName`. `desKey` i `desIV` parametry metody są tablice typu byte 8. Musi mieć zainstalowane do uruchamiania w tym przykładzie pakiet silnego szyfrowania.  
  
 [!code-cpp[Classic CryptoStream Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic CryptoStream Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CryptoStream Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic CryptoStream Example/CS/source.cs#1)]
 [!code-vb[Classic CryptoStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic CryptoStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.SymmetricAlgorithm Create (string algName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.SymmetricAlgorithm Create(string algName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algName As String) As SymmetricAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::SymmetricAlgorithm ^ Create(System::String ^ algName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.SymmetricAlgorithm</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="algName">Nazwa określonej implementacji <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> klasy do użycia.</param>
        <summary>Tworzy określony obiekt kryptograficzne używane do wykonywania algorytmu symetrycznego.</summary>
        <returns>Obiekt kryptograficzne używane do wykonywania algorytmu symetrycznego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDecryptor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt deskryptora symetrycznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDecryptor">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ICryptoTransform CreateDecryptor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.ICryptoTransform CreateDecryptor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDecryptor () As ICryptoTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ICryptoTransform ^ CreateDecryptor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ICryptoTransform</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt deskryptora symetrycznego z bieżącym <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> właściwości i wektora inicjowania (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
        <returns>Obiekt deskryptora symetrycznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odszyfrowuje wiadomość zaszyfrowaną utworzone za pomocą <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor%2A> przeciążenia z tym samym podpisie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDecryptor">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ICryptoTransform CreateDecryptor (byte[] rgbKey, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.ICryptoTransform CreateDecryptor(unsigned int8[] rgbKey, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateDecryptor (rgbKey As Byte(), rgbIV As Byte()) As ICryptoTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::Cryptography::ICryptoTransform ^ CreateDecryptor(cli::array &lt;System::Byte&gt; ^ rgbKey, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ICryptoTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbKey" Type="System.Byte[]" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgbKey">Klucz tajny dla algorytmu symetrycznego.</param>
        <param name="rgbIV">Wektor inicjowania dla algorytmu symetrycznego.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy obiekt deskryptora symetrycznego z określonym <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> właściwości i wektora inicjowania (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
        <returns>Obiekt deskryptora symetrycznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odszyfrowuje wiadomość zaszyfrowaną utworzone za pomocą <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor%2A> przeciążenia z takimi samymi parametrami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEncryptor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt symetrycznego modułu szyfrującego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEncryptor">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ICryptoTransform CreateEncryptor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.ICryptoTransform CreateEncryptor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEncryptor () As ICryptoTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ICryptoTransform ^ CreateEncryptor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ICryptoTransform</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt symetrycznego modułu szyfrującego z bieżącym <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> właściwości i wektora inicjowania (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
        <returns>Obiekt symetrycznego modułu szyfrującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> właściwość jest `null`, <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey%2A> metoda jest wywoływana, aby utworzyć nową losowe <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A>. Jeśli bieżący <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> właściwość jest `null`, <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV%2A> metoda jest wywoływana, aby utworzyć nową losowe <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A>.  
  
 Użyj <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor%2A> przeciążenia o tej samej sygnaturze, aby odszyfrować wyniku tej metody.  
  
   
  
## Examples  
 Poniższy przykład szyfruje ciągu przy użyciu zwrócony z obiektu transform <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor%2A> metody.  
  
 [!code-cpp[System.Security.Cryptography.SymmetricAlgorithm#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm/cpp/encryptor.cpp#1)]
 [!code-csharp[System.Security.Cryptography.SymmetricAlgorithm#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm/cs/encryptor.cs#1)]
 [!code-vb[System.Security.Cryptography.SymmetricAlgorithm#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm/vb/encryptor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEncryptor">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ICryptoTransform CreateEncryptor (byte[] rgbKey, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.ICryptoTransform CreateEncryptor(unsigned int8[] rgbKey, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateEncryptor (rgbKey As Byte(), rgbIV As Byte()) As ICryptoTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::Cryptography::ICryptoTransform ^ CreateEncryptor(cli::array &lt;System::Byte&gt; ^ rgbKey, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ICryptoTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbKey" Type="System.Byte[]" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgbKey">Klucz tajny dla algorytmu symetrycznego.</param>
        <param name="rgbIV">Wektor inicjowania dla algorytmu symetrycznego.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy obiekt symetrycznego modułu szyfrującego z określonym <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" /> właściwości i wektora inicjowania (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
        <returns>Obiekt symetrycznego modułu szyfrującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor%2A> przeciążenia z takimi samymi parametrami odszyfrować wyniku tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie `Dispose` po zakończeniu przy użyciu <xref:System.Security.Cryptography.SymmetricAlgorithm>. `Dispose` Pozostawia metody <xref:System.Security.Cryptography.SymmetricAlgorithm> w stanie uniemożliwiającym jego używanie. Po wywołaniu `Dispose`, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Security.Cryptography.SymmetricAlgorithm> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.Security.Cryptography.SymmetricAlgorithm> klasy.  
  
 Aby uzyskać więcej informacji, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Wywoływanie zawsze `Dispose` przed zwolnieniem ostatniego odwołania do <xref:System.Security.Cryptography.SymmetricAlgorithm>. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.Security.Cryptography.SymmetricAlgorithm> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` — metoda i `Finalize` metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. `Finalize` wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Security.Cryptography.SymmetricAlgorithm> odwołania. Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" />, nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose(Boolean)" />, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see langword="Finalize" />, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FeedbackSize">
      <MemberSignature Language="C#" Value="public virtual int FeedbackSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FeedbackSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property FeedbackSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int FeedbackSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar opinii w bitach operacji kryptograficznych.</summary>
        <value>Rozmiar danych sprzężenia zwrotnego w bitach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar danych sprzężenia zwrotnego określa ilość danych, które są przekazywane do kolejnych szyfrowania lub odszyfrowywania operacji. Rozmiar danych sprzężenia zwrotnego nie może być większy niż rozmiar bloku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Rozmiar danych sprzężenia zwrotnego jest większy niż rozmiar bloku.</exception>
      </Docs>
    </Member>
    <Member MemberName="FeedbackSizeValue">
      <MemberSignature Language="C#" Value="protected int FeedbackSizeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 FeedbackSizeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSizeValue" />
      <MemberSignature Language="VB.NET" Value="Protected FeedbackSizeValue As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int FeedbackSizeValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje rozmiar danych sprzężenia zwrotnego, w bitach operacji kryptograficznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar danych sprzężenia zwrotnego określa ilość danych, które są przekazywane do kolejnych szyfrowania lub odszyfrowywania operacji. Rozmiar danych sprzężenia zwrotnego nie może być większy niż rozmiar bloku.  
  
 To pole jest dostępny za pośrednictwem <xref:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateIV">
      <MemberSignature Language="C#" Value="public abstract void GenerateIV ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateIV() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub GenerateIV ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void GenerateIV();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej generuje wektor inicjowania losowe (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) do użycia dla tego algorytmu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogólnie rzecz biorąc, nie istnieje przyczyna do używania tej metody, ponieważ `CreateEncryptor()` lub `CreateEncryptor(null, null)` automatycznie generuje zarówno wektor inicjowania i klucz. Jednak może zajść potrzeba użycia <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV%2A> metody ponowne użycie wystąpienia algorytmu symetrycznego o wektor inicjowania inny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public abstract void GenerateKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub GenerateKey ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void GenerateKey();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej generuje klucz losowy (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key" />) do użycia dla tego algorytmu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogólnie rzecz biorąc, nie istnieje przyczyna do używania tej metody, ponieważ `CreateEncryptor()` lub `CreateEncryptor(null, null)` automatycznie generuje zarówno wektor inicjowania i klucz. Jednak może zajść potrzeba użycia <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey%2A> metody ponowne użycie wystąpienia algorytmu symetrycznego za pomocą innego klucza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IV">
      <MemberSignature Language="C#" Value="public virtual byte[] IV { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] IV" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IV As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Byte&gt; ^ IV { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wektor inicjowania (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) dla algorytmu symetrycznego.</summary>
        <value>Wektor inicjowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> Właściwość jest automatycznie ustawiana wartość losowe podczas tworzenia nowego wystąpienia jednego z <xref:System.Security.Cryptography.SymmetricAlgorithm> klas lub ręcznie wywołanie <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV%2A> metody.  Rozmiar <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> właściwość musi być taka sama jak <xref:System.Security.Cryptography.SymmetricAlgorithm.BlockSize%2A> właściwości podzielić przez 8.  
  
 Klasy, które pochodzą z <xref:System.Security.Cryptography.SymmetricAlgorithm> klasy użyj trybu CBC, cipher block chaining (CBC), nazywany co wymaga klucza i wektor inicjowania wykonania kryptograficznych przekształcenia danych.  Do odszyfrowywania danych, która została zaszyfrowana przy użyciu jednej z <xref:System.Security.Cryptography.SymmetricAlgorithm> klasy, należy ustawić <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> właściwości i <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> właściwości na te same wartości, które były używane do szyfrowania.  
  
 Dla danego klucza tajnego *k*, szyfrowania Prosty blok, który nie używa wektor inicjowania są szyfrowane tego samego bloku wejściowych zwykłego tekstu w tym samym bloku danych wyjściowych tekst zaszyfrowany. Jeśli masz zduplikowanych bloków w postaci zwykłego tekstu strumienia, konieczne będzie zduplikowanych bloków w ramach strumienia tekstu szyfrowania. Jeśli nieautoryzowani użytkownicy niczego wiedzieć o strukturze bloku zwykłego tekstu, może użyć tych informacji odszyfrować bloku tekstu znane szyfrowania i prawdopodobnie odzyskać klucza. Zwalczania ten problem, informacje z poprzedniego bloku jest łączony z procesem szyfrowania kolejnego bloku. W związku z tym różni się dane wyjściowe dwa bloki identyczne zwykłego tekstu. Ponieważ ta metoda używa poprzedniego bloku do szyfrowania kolejnego bloku, wektor inicjowania jest potrzebne do szyfrowania pierwszego bloku danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Próbowano ustawić wektor inicjowania <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Próbowano ustawić wektor inicjowania nieprawidłowy rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="IVValue">
      <MemberSignature Language="C#" Value="protected byte[] IVValue;" />
      <MemberSignature Language="ILAsm" Value=".field family unsigned int8[] IVValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.IVValue" />
      <MemberSignature Language="VB.NET" Value="Protected IVValue As Byte() " />
      <MemberSignature Language="C++ CLI" Value="protected: cli::array &lt;System::Byte&gt; ^ IVValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje wektor inicjowania (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />) dla algorytmu symetrycznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole jest dostępny za pośrednictwem <xref:System.Security.Cryptography.SymmetricAlgorithm.IV%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Key">
      <MemberSignature Language="C#" Value="public virtual byte[] Key { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Key" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.Key" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Key As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Byte&gt; ^ Key { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz tajny dla algorytmu symetrycznego.</summary>
        <value>Klucz tajny dla algorytmu symetrycznego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz tajny jest używany do szyfrowania i odszyfrowywania. Dla algorytmu symetrycznego było pomyślne klucz tajny musi być znane tylko do nadawcy i odbiorcy. Prawidłowe rozmiary klucza są określone przez implementację konkretnego algorytmu symetrycznego i znajduje się w <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> właściwości.  
  
 Jeśli ta właściwość jest `null` gdy jest używany, <xref:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey%2A> metoda jest wywoływana w celu utworzenia nowej wartości losowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Próbowano ustawić klucz <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Rozmiar klucza jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="KeySize">
      <MemberSignature Language="C#" Value="public virtual int KeySize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeySize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.KeySize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property KeySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeySize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar w bitach, używany przez algorytmu symetrycznego klucza tajnego.</summary>
        <value>Rozmiar w bitach, używany przez algorytmu symetrycznego klucza tajnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe rozmiary klucza są określone przez implementację konkretnego algorytmu symetrycznego i znajduje się w <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Rozmiar klucza jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="KeySizeValue">
      <MemberSignature Language="C#" Value="protected int KeySizeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 KeySizeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.KeySizeValue" />
      <MemberSignature Language="VB.NET" Value="Protected KeySizeValue As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int KeySizeValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje rozmiar w bitach używane przez algorytmu symetrycznego klucza tajnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe rozmiary klucza są określone przez implementację konkretnego algorytmu symetrycznego i znajduje się w <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> właściwości.  
  
 To pole jest dostępny za pośrednictwem <xref:System.Security.Cryptography.SymmetricAlgorithm.KeySize%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyValue">
      <MemberSignature Language="C#" Value="protected byte[] KeyValue;" />
      <MemberSignature Language="ILAsm" Value=".field family unsigned int8[] KeyValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.KeyValue" />
      <MemberSignature Language="VB.NET" Value="Protected KeyValue As Byte() " />
      <MemberSignature Language="C++ CLI" Value="protected: cli::array &lt;System::Byte&gt; ^ KeyValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje klucz tajny dla algorytmu symetrycznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz tajny jest używany do szyfrowania i odszyfrowywania. Dla algorytmu symetrycznego było pomyślne klucz tajny musi być znane tylko do nadawcy i odbiorcy. Prawidłowe rozmiary klucza są określone przez implementację konkretnego algorytmu symetrycznego i znajduje się w <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> właściwości.  
  
 To pole jest dostępny za pośrednictwem <xref:System.Security.Cryptography.SymmetricAlgorithm.Key%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LegalBlockSizes">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.KeySizes[] LegalBlockSizes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.KeySizes[] LegalBlockSizes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.LegalBlockSizes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LegalBlockSizes As KeySizes()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalBlockSizes { cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiary bloków w bitach, które są obsługiwane przez algorytmu symetrycznego.</summary>
        <value>Tablica zawiera rozmiary bloków obsługiwaną przez algorytm.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytmu symetrycznego obsługuje tylko rozmiary bloków, które pasują do wpisu w tej macierzy.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wartości <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalBlockSizes%2A> dla symetryczne algorytmy.  
  
 [!code-csharp[System.Security.Cryptography.SymmetricAlgorithm.BlockSize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm.blocksize/cs/program.cs#1)]
 [!code-vb[System.Security.Cryptography.SymmetricAlgorithm.BlockSize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm.blocksize/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LegalBlockSizesValue">
      <MemberSignature Language="C#" Value="protected System.Security.Cryptography.KeySizes[] LegalBlockSizesValue;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Security.Cryptography.KeySizes[] LegalBlockSizesValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.LegalBlockSizesValue" />
      <MemberSignature Language="VB.NET" Value="Protected LegalBlockSizesValue As KeySizes() " />
      <MemberSignature Language="C++ CLI" Value="protected: cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalBlockSizesValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa rozmiary bloków w bitach, które są obsługiwane przez algorytmu symetrycznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytmu symetrycznego obsługuje tylko rozmiary bloków, które pasują do wpisu w tej macierzy.  
  
 To pole jest dostępny za pośrednictwem <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalBlockSizes%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LegalKeySizes">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.KeySizes[] LegalKeySizes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.KeySizes[] LegalKeySizes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LegalKeySizes As KeySizes()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalKeySizes { cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klucze kryptograficzne w bitach, które są obsługiwane przez algorytmu symetrycznego.</summary>
        <value>Tablica, która zawiera klucze kryptograficzne obsługiwaną przez algorytm.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytmu symetrycznego obsługuje tylko klucze kryptograficzne, które pasują do wpisu w tej macierzy.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wartości <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> dla symetryczne algorytmy.  
  
 [!code-csharp[System.Security.Cryptography.SymmetricAlgorithm.BlockSize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm.blocksize/cs/program.cs#1)]
 [!code-vb[System.Security.Cryptography.SymmetricAlgorithm.BlockSize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.security.cryptography.symmetricalgorithm.blocksize/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LegalKeySizesValue">
      <MemberSignature Language="C#" Value="protected System.Security.Cryptography.KeySizes[] LegalKeySizesValue;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Security.Cryptography.KeySizes[] LegalKeySizesValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizesValue" />
      <MemberSignature Language="VB.NET" Value="Protected LegalKeySizesValue As KeySizes() " />
      <MemberSignature Language="C++ CLI" Value="protected: cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalKeySizesValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa rozmiary klucza w bitach, które są obsługiwane przez algorytmu symetrycznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytmu symetrycznego obsługuje tylko klucze kryptograficzne, które pasują do wpisu w tej macierzy.  
  
 To pole jest dostępny za pośrednictwem <xref:System.Security.Cryptography.SymmetricAlgorithm.LegalKeySizes%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mode">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.CipherMode Mode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.CipherMode Mode" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.Mode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Mode As CipherMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::CipherMode Mode { System::Security::Cryptography::CipherMode get(); void set(System::Security::Cryptography::CipherMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb operacji algorytmu symetrycznego.</summary>
        <value>Tryb operacji algorytmu symetrycznego. Wartość domyślna to <see cref="F:System.Security.Cryptography.CipherMode.CBC" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Security.Cryptography.CipherMode> wyliczenie opis określone tryby.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Tryb szyfrowania nie jest jednym z <see cref="T:System.Security.Cryptography.CipherMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="ModeValue">
      <MemberSignature Language="C#" Value="protected System.Security.Cryptography.CipherMode ModeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family valuetype System.Security.Cryptography.CipherMode ModeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.ModeValue" />
      <MemberSignature Language="VB.NET" Value="Protected ModeValue As CipherMode " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Security::Cryptography::CipherMode ModeValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje tryb szyfrowania używany w algorytmu symetrycznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Security.Cryptography.CipherMode> wyliczenie opis określone tryby.  
  
 To pole jest dostępny za pośrednictwem <xref:System.Security.Cryptography.SymmetricAlgorithm.Mode%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.PaddingMode Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.PaddingMode Padding" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.SymmetricAlgorithm.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Padding As PaddingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::PaddingMode Padding { System::Security::Cryptography::PaddingMode get(); void set(System::Security::Cryptography::PaddingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.PaddingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb uzupełniania używane w algorytmu symetrycznego.</summary>
        <value>Tryb uzupełniania używane w algorytmu symetrycznego. Wartość domyślna to <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość wiadomości tekstowe składa się z liczbą bajtów, które wypełnia całkowicie bloków. Często nie ma wystarczającej liczby bajtów do wypełnienia ostatniego bloku. W takim przypadku ciąg uzupełnienie jest dodawany do tekstu. Na przykład jeśli długość bloku jest 64-bitowy, ostatniego bloku zawiera tylko 40 bitów 24 bity uzupełnienia zostaną dodane. Zobacz <xref:System.Security.Cryptography.PaddingMode> wyliczenie opis określone tryby.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Tryb uzupełniania nie jest jednym z <see cref="T:System.Security.Cryptography.PaddingMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="PaddingValue">
      <MemberSignature Language="C#" Value="protected System.Security.Cryptography.PaddingMode PaddingValue;" />
      <MemberSignature Language="ILAsm" Value=".field family valuetype System.Security.Cryptography.PaddingMode PaddingValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.SymmetricAlgorithm.PaddingValue" />
      <MemberSignature Language="VB.NET" Value="Protected PaddingValue As PaddingMode " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Security::Cryptography::PaddingMode PaddingValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.PaddingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje tryb uzupełniania używane w algorytmu symetrycznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość wiadomości tekstowe składa się z liczbą bajtów, które wypełnia całkowicie bloków. Często nie ma wystarczającej liczby bajtów do wypełnienia ostatniego bloku. W takim przypadku ciąg uzupełnienie jest dodawany do tekstu. Na przykład jeśli długość bloku jest 64-bitowy, ostatniego bloku zawiera tylko 40 bitów 24 bity uzupełnienia zostaną dodane. Zobacz <xref:System.Security.Cryptography.PaddingMode> wyliczenie opis określone tryby.  
  
 To pole jest dostępny za pośrednictwem <xref:System.Security.Cryptography.SymmetricAlgorithm.Padding%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidKeySize">
      <MemberSignature Language="C#" Value="public bool ValidKeySize (int bitLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValidKeySize(int32 bitLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.SymmetricAlgorithm.ValidKeySize(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ValidKeySize (bitLength As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValidKeySize(int bitLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bitLength">Długość w bitach, aby sprawdzić, czy prawidłowy rozmiar klucza.</param>
        <summary>Określa, czy określony rozmiar klucza jest nieprawidłowy dla bieżącego algorytmu.</summary>
        <returns>
          <see langword="true" /> Jeśli określony rozmiar klucza jest nieprawidłowy dla bieżącego algorytmu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
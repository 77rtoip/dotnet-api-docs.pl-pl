<Type Name="AsymmetricAlgorithm" FullName="System.Security.Cryptography.AsymmetricAlgorithm">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b46a0ce03d3cf16b63dd1222e9cd55bd6d66393d" /><Meta Name="ms.sourcegitcommit" Value="8544f14c8194a55eb22d46721b0bbe46f345c063" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/21/2019" /><Meta Name="ms.locfileid" Value="69670385" /></Metadata><TypeSignature Language="C#" Value="public abstract class AsymmetricAlgorithm : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AsymmetricAlgorithm extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AsymmetricAlgorithm&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class AsymmetricAlgorithm abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type AsymmetricAlgorithm = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje abstrakcyjną klasę bazową, z której wszystkie implementacje algorytmów asymetrycznych muszą dziedziczyć.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asymetryczne algorytmy kryptograficzne, znane także jako algorytmy klucza publicznego, wymagają, aby nadawca i odbiornik utrzymują parę powiązanych kluczy: klucz prywatny i klucz publiczny. Oba klucze są unikatowe dla jednostki. Klucz publiczny można udostępnić każdemu użytkownikowi; Ten klucz służy do kodowania danych wysyłanych do odbiornika. Klucz prywatny musi być przechowywany przez odbiornik jako prywatny; Ten klucz służy do dekodowania komunikatów zakodowanych przy użyciu klucza publicznego odbiorcy. <xref:System.Security.Cryptography.RSACryptoServiceProvider> Klasa jest implementacją algorytmu klucza publicznego. Szczegółowe omówienie szyfrowania i algorytmów klucza publicznego można znaleźć w sekcji "szyfrowanie klucza publicznego" w [usługach kryptograficznych](~/docs/standard/security/cryptographic-services.md). Aby uzyskać informacje o sposobach tworzenia par kluczy za pomocą narzędzia silnej nazwy (SN. exe), [zobacz How to: Utwórz parę](~/docs/framework/app-domains/how-to-create-a-public-private-key-pair.md)kluczy publiczny-prywatny.  
  
 Do tworzenia podpisów cyfrowych można używać systemów z kluczami publicznymi. Podpisy cyfrowe są używane do ochrony integralności danych. Na przykład, aby użyć systemu klucza publicznego do cyfrowego podpisywania wiadomości, nadawca najpierw stosuje funkcję skrótu do komunikatu w celu utworzenia skrótu wiadomości. Nadawca szyfruje następnie skrót wiadomości z kluczem prywatnym nadawcy w celu utworzenia podpisu osobistego nadawcy. Po odebraniu komunikatu i podpisu odbiorca odszyfrowuje podpis przy użyciu klucza publicznego nadawcy w celu odzyskania skrótu wiadomości i mieszania komunikatu przy użyciu tego samego algorytmu wyznaczania wartości skrótu, który został użyty przez nadawcę. Jeśli skrót wiadomości, który jest obliczany przez odbiorcę, jest zgodny z komunikatem otrzymanym od nadawcy, odbiorca może założyć, że wiadomość nie została zmieniona podczas przesyłania. Należy pamiętać, że każdy może zweryfikować podpis, ponieważ klucz publiczny nadawcy jest powszechną wiedzą. Ta technika nie zachowuje tajemnicy wiadomości; Aby komunikat był tajny, musi również być zaszyfrowany.  
  
 .NET Framework udostępnia następujące klasy, które implementują algorytmy podpisu cyfrowego <xref:System.Security.Cryptography.DSACryptoServiceProvider>: <xref:System.Security.Cryptography.RSACryptoServiceProvider>, <xref:System.Security.Cryptography.ECDsa> , (klasa bazowa) i <xref:System.Security.Cryptography.ECDsaCng>.  
  
 Przestrzeń nazw zawiera konkretne klasy tylko <xref:System.Security.Cryptography.RSA> dla <xref:System.Security.Cryptography.DSA>i. <xref:System.Security.Cryptography>  
  
 Aby dowiedzieć się, jak używać algorytmu RSA do szyfrowania i odszyfrowywania danych XML oraz tworzenia i weryfikowania podpisów cyfrowych XML, zobacz następujące artykuły:  
  
-   [Instrukcje: Szyfruj elementy XML przy użyciu kluczy asymetrycznych](~/docs/standard/security/how-to-encrypt-xml-elements-with-asymmetric-keys.md)  
  
-   [Instrukcje: Odszyfruj elementy XML przy użyciu kluczy asymetrycznych](~/docs/standard/security/how-to-decrypt-xml-elements-with-asymmetric-keys.md)  
  
-   [Instrukcje: Podpisywanie dokumentów XML za pomocą podpisów cyfrowych](~/docs/standard/security/how-to-sign-xml-documents-with-digital-signatures.md)  
  
-   [Instrukcje: Weryfikowanie podpisów cyfrowych dokumentów XML](~/docs/standard/security/how-to-verify-the-digital-signatures-of-xml-documents.md)  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób implementacji niestandardowego algorytmu asymetrycznego dziedziczonego z <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy.  Podano dodatkową klasę, która pokazuje, jak używać klasy niestandardowej.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcrypto.cpp#2)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#2)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#2)]  
  
 Oto dodatkowa Klasa, która pokazuje, jak używać klasy niestandardowej.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcryptoimpl.cpp#3)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#3)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#3)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
    <related type="Article" href="https://msdn.microsoft.com/library/05026813-f3bd-4d7c-9e0b-fc588eb3d114">Instrukcje: Tworzenie pary kluczy publicznych/prywatnych</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AsymmetricAlgorithm ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AsymmetricAlgorithm();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można utworzyć wystąpienia klasy abstrakcyjnej. Kod aplikacji tworzy nowe wystąpienie klasy pochodnej. Klasy <xref:System.Security.Cryptography.RSACryptoServiceProvider> i<xref:System.Security.Cryptography.DSACryptoServiceProvider> są jedynymi obsługiwanymi implementacjami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Implementacja klasy pochodnej jest nieprawidłowa.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="asymmetricAlgorithm.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> klasę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest prostym wywołaniem <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metody.  
  
 Wywołanie `Dispose` zezwala na przydzielenie zasobów używanych <xref:System.Security.Cryptography.AsymmetricAlgorithm> przez klasę do innych celów. Aby uzyskać więcej informacji `Dispose`na temat, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Security.Cryptography.AsymmetricAlgorithm.Clear%2A> jak wywołać metodę w celu zwolnienia zasobów bieżącego `customCrypto` obiektu. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcryptoimpl.cpp#1)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#1)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt kryptograficzny używany do wykonywania algorytmu asymetrycznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.AsymmetricAlgorithm Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.AsymmetricAlgorithm Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As AsymmetricAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::AsymmetricAlgorithm ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Security.Cryptography.AsymmetricAlgorithm" Usage="System.Security.Cryptography.AsymmetricAlgorithm.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.AsymmetricAlgorithm</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy domyślny obiekt kryptograficzny używany do wykonywania algorytmu asymetrycznego.</summary>
        <returns>Nowe <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> wystąpienie, chyba że ustawienia domyślne zostały zmienione [ &lt;przy użyciu elementu cryptoClass&gt; ](~/docs/framework/configure-apps/file-schema/cryptography/cryptoclass-element.md).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób implementacji <xref:System.Security.Cryptography.AsymmetricAlgorithm.Create%2A> metody w klasie rozszerzonej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcrypto.cpp#11)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#11)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#11)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.AsymmetricAlgorithm Create (string algName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.AsymmetricAlgorithm Create(string algName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algName As String) As AsymmetricAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::AsymmetricAlgorithm ^ Create(System::String ^ algName);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Security.Cryptography.AsymmetricAlgorithm" Usage="System.Security.Cryptography.AsymmetricAlgorithm.Create algName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.AsymmetricAlgorithm</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="algName">Implementacja algorytmu asymetrycznego do użycia. W poniższej tabeli przedstawiono prawidłowe wartości <paramref name="algName" /> parametru i algorytmy, do których są mapowane.  
  
 <list type="table"><listheader><term> Wartość parametru 
 </term><description> Implements 
 </description></listheader><item><term> System.Security.Cryptography.AsymmetricAlgorithm 
 </term><description><see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /></description></item><item><term> RSA 
 </term><description><see cref="T:System.Security.Cryptography.RSA" /></description></item><item><term> System.Security.Cryptography.RSA 
 </term><description><see cref="T:System.Security.Cryptography.RSA" /></description></item><item><term> DSA 
 </term><description><see cref="T:System.Security.Cryptography.DSA" /></description></item><item><term> System.Security.Cryptography.DSA 
 </term><description><see cref="T:System.Security.Cryptography.DSA" /></description></item><item><term> ECDsa 
 </term><description><see cref="T:System.Security.Cryptography.ECDsa" /></description></item><item><term> ECDsaCng 
 </term><description><see cref="T:System.Security.Cryptography.ECDsaCng" /></description></item><item><term> System.Security.Cryptography.ECDsaCng 
 </term><description><see cref="T:System.Security.Cryptography.ECDsaCng" /></description></item><item><term> ECDH 
 </term><description><see cref="T:System.Security.Cryptography.ECDiffieHellman" /></description></item><item><term> ECDiffieHellman 
 </term><description><see cref="T:System.Security.Cryptography.ECDiffieHellman" /></description></item><item><term> ECDiffieHellmanCng 
 </term><description><see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /></description></item><item><term> System.Security.Cryptography.ECDiffieHellmanCng 
 </term><description><see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /></description></item></list></param>
        <summary>Tworzy wystąpienie określonej implementacji algorytmu asymetrycznego.</summary>
        <returns>Nowe wystąpienie określonej implementacji algorytmu asymetrycznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób implementacji <xref:System.Security.Cryptography.AsymmetricAlgorithm.Create%2A> metody w klasie rozszerzonej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcrypto.cpp#12)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#12)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#12)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="asymmetricAlgorithm.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj `Dispose` po zakończeniu korzystania z <xref:System.Security.Cryptography.AsymmetricAlgorithm>. `Dispose` Metoda<xref:System.Security.Cryptography.AsymmetricAlgorithm> pozostawia w stanie niezdatnym do użytku. Po wywołaniu `Dispose`należy wydać wszystkie odwołania <xref:System.Security.Cryptography.AsymmetricAlgorithm> do, aby moduł wyrzucania elementów bezużytecznych mógł odwoływać pamięć <xref:System.Security.Cryptography.AsymmetricAlgorithm> , którą zajmował.  
  
 Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj `Dispose` przed wydaniem ostatniego odwołania <xref:System.Security.Cryptography.AsymmetricAlgorithm>do. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.Security.Cryptography.AsymmetricAlgorithm> `Finalize` metody obiektu przez moduł zbierający elementy bezużyteczne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="asymmetricAlgorithm.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> klasę i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` `Finalize` i metodę. `Dispose()`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na. `Finalize`wywołuje `Dispose` `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Security.Cryptography.AsymmetricAlgorithm> których odwołują się te odwołania. `disposing` Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see langword="Dispose(Boolean)" />należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej <see langword="Dispose" />usunięte we wcześniejszej wywołaniu. Aby uzyskać więcej informacji na temat sposobu <see langword="Dispose(Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see langword="Dispose" /> na <see langword="Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="ExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public virtual byte[] ExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, class System.Security.Cryptography.PbeParameters pbeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, System::Security::Cryptography::PbeParameters ^ pbeParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters -&gt; byte[]&#xA;override this.ExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters -&gt; byte[]" Usage="asymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey (passwordBytes, pbeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="passwordBytes">Bajty, które mają być używane jako hasło podczas szyfrowania materiału klucza.</param>
        <param name="pbeParameters">Parametry szyfrowania opartego na hasłach (PBE), które mają być używane podczas szyfrowania materiału klucza.</param>
        <summary>Eksportuje bieżący klucz w formacie EncryptedPrivateKeyInfo PKCS # 8 z hasłem opartym na bajcie.</summary>
        <returns>Tablica bajtowa zawierająca reprezentację EncryptedPrivateKeyInfo tego klucza PKCS # 8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bajty hasła są przesyłane bezpośrednio do funkcji wyprowadzania klucza (KDF) używanej przez algorytm wskazywany `pbeParameters`przez.
Dzięki temu można zapewnić zgodność z innymi systemami, które używają kodowania tekstu innego niż UTF-8 podczas przetwarzania haseł z PBKDF2 (klucz oparty na haśle funkcja 2).

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można wyeksportować klucza.

—lub—

<paramref name="pbeParameters" />wskazuje, <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> że powinny być używane, które <see cref="T:System.Char" />wymaga haseł opartych na.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.TryExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="ExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public virtual byte[] ExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters pbeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, class System.Security.Cryptography.PbeParameters pbeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, System::Security::Cryptography::PbeParameters ^ pbeParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters -&gt; byte[]&#xA;override this.ExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters -&gt; byte[]" Usage="asymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey (password, pbeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="password">Hasło, które ma być używane podczas szyfrowania materiału klucza.</param>
        <param name="pbeParameters">Parametry szyfrowania opartego na hasłach (PBE), które mają być używane podczas szyfrowania materiału klucza.</param>
        <summary>Eksportuje bieżący klucz w formacie EncryptedPrivateKeyInfo PKCS # 8 przy użyciu hasła opartego na znakach.</summary>
        <returns>Tablica bajtowa zawierająca reprezentację EncryptedPrivateKeyInfo tego klucza PKCS # 8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `pbeParameters` wskazuje algorytm korzystający z PBKDF2 (klucz oparty na hasłach funkcja 2), hasło jest konwertowane na bajty przy użyciu kodowania UTF-8.

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można wyeksportować klucza.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.TryExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="ExportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public virtual byte[] ExportPkcs8PrivateKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportPkcs8PrivateKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.ExportPkcs8PrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportPkcs8PrivateKey () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportPkcs8PrivateKey();" />
      <MemberSignature Language="F#" Value="abstract member ExportPkcs8PrivateKey : unit -&gt; byte[]&#xA;override this.ExportPkcs8PrivateKey : unit -&gt; byte[]" Usage="asymmetricAlgorithm.ExportPkcs8PrivateKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eksportuje bieżący klucz w formacie PrivateKeyInfo PKCS # 8.</summary>
        <returns>Tablica bajtowa zawierająca reprezentację PrivateKeyInfo tego klucza PKCS # 8.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można wyeksportować klucza.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.TryExportPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="ExportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public virtual byte[] ExportSubjectPublicKeyInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportSubjectPublicKeyInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.ExportSubjectPublicKeyInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportSubjectPublicKeyInfo () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportSubjectPublicKeyInfo();" />
      <MemberSignature Language="F#" Value="abstract member ExportSubjectPublicKeyInfo : unit -&gt; byte[]&#xA;override this.ExportSubjectPublicKeyInfo : unit -&gt; byte[]" Usage="asymmetricAlgorithm.ExportSubjectPublicKeyInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eksportuje część klucza publicznego bieżącego klucza w formacie X. 509 SubjectPublicKeyInfo.</summary>
        <returns>Tablica bajtowa zawierająca reprezentację SubjectPublicKeyInfoa X. 509 klucza publicznego tego klucza.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.TryExportSubjectPublicKeyInfo" />
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public virtual void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void FromXmlString(System::String ^ xmlString);" />
      <MemberSignature Language="F#" Value="abstract member FromXmlString : string -&gt; unit&#xA;override this.FromXmlString : string -&gt; unit" Usage="asymmetricAlgorithm.FromXmlString xmlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="xmlString">Ciąg XML, który ma zostać użyty do odtworzenia <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> obiektu.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rekonstruuje <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> obiekt z ciągu XML. W przeciwnym razie zgłasza <see cref="T:System.NotImplementedException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób implementacji <xref:System.Security.Cryptography.AsymmetricAlgorithm.FromXmlString%2A> metody w celu przeanalizowania określonego ciągu XML w celu wypełnienia bieżącego <xref:System.Security.Cryptography.CspParameters> obiektu. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcrypto.cpp#4)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#4)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public virtual void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportEncryptedPkcs8PrivateKey (passwordBytes As ReadOnlySpan(Of Byte), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="abstract member ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; *  -&gt; unit&#xA;override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="asymmetricAlgorithm.ImportEncryptedPkcs8PrivateKey (passwordBytes, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="passwordBytes">Bajty, które mają być używane jako hasło podczas odszyfrowywania materiału klucza.</param>
        <param name="source">Bajty struktury EncryptedPrivateKeyInfo PKCS # 8 w kodowaniu ASN. 1-w.</param>
        <param name="bytesRead">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, importuje parę klucza publicznego/prywatnego ze struktury EncryptedPrivateKeyInfo PKCS # 8 Po odszyfrowaniu przy użyciu hasła opartego na bajtach, zastępując klucze dla tego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bajty hasła są przesyłane bezpośrednio do funkcji wyprowadzania klucza (KDF) używanej przez algorytm wskazywany `pbeParameters`przez.
Dzięki temu można zapewnić zgodność z innymi systemami, które używają kodowania tekstu innego niż UTF-8 podczas przetwarzania haseł z PBKDF2 (klucz oparty na haśle funkcja 2).

 Ta metoda obsługuje tylko kodowanie binarne (//CER/DER) EncryptedPrivateKeyInfo.
Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.

 Ze względu na to, że obsługa specyficzna dla algorytmu jest wymagana do interpretacji zawartości <xref:System.NotImplementedException> tego formatu danych, <xref:System.Security.Cryptography.AsymmetricAlgorithm.ImportEncryptedPkcs8PrivateKey%2A> domyślnie generuje wartość.

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Hasło jest niepoprawne.

—lub—

Zawartość <paramref name="source" /> wskaż funkcję wyprowadzania klucza (KDF), która ma zostać zastosowana, jest starszą wersją PKCS # 12 <see cref="T:System.Char" />KDF, która wymaga haseł opartych na plikach.

—lub—

Zawartość <paramref name="source" /> nie reprezentuje struktury EncryptedPrivateKeyInfo PKCS # 8 w formacie ASN. 1.

—lub—

Zawartość <paramref name="source" /> wskazuje, że klucz jest dla algorytmu innego niż algorytm reprezentowany przez to wystąpienie.

—lub—

Zawartość <paramref name="source" /> reprezentująca klucz w formacie, który nie jest obsługiwany.

—lub—

Importowanie klucza specyficznego dla algorytmu nie powiodło się.</exception>
        <exception cref="T:System.NotImplementedException">Typ pochodny nie przesłonięta tego elementu członkowskiego.</exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public virtual void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportEncryptedPkcs8PrivateKey (password As ReadOnlySpan(Of Char), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="abstract member ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; *  -&gt; unit&#xA;override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="asymmetricAlgorithm.ImportEncryptedPkcs8PrivateKey (password, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="password">Hasło używane do odszyfrowywania materiału klucza.</param>
        <param name="source">Bajty struktury EncryptedPrivateKeyInfo PKCS # 8 w kodowaniu ASN. 1-w.</param>
        <param name="bytesRead">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, importuje parę klucza publicznego/prywatnego ze struktury EncryptedPrivateKeyInfo PKCS # 8 Po odszyfrowaniu przy użyciu hasła opartego na znakach, zastępując klucze dla tego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zawartość `source` wskazuje algorytm używający funkcji PBKDF1 (klucza opartego na hasłach) lub PBKDF2 (klucz oparty na hasłach, funkcja 2), hasło jest konwertowane na bajty przy użyciu kodowania UTF-8.

 Ta metoda obsługuje tylko kodowanie binarne (//CER/DER) EncryptedPrivateKeyInfo.
Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.

 Ze względu na to, że obsługa specyficzna dla algorytmu jest wymagana do interpretacji zawartości <xref:System.NotImplementedException> tego formatu danych, <xref:System.Security.Cryptography.AsymmetricAlgorithm.ImportEncryptedPkcs8PrivateKey%2A> domyślnie generuje wartość.

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Hasło jest niepoprawne.

—lub—

Zawartość <paramref name="source" /> nie reprezentuje struktury EncryptedPrivateKeyInfo PKCS # 8 w formacie ASN. 1.

—lub—

Zawartość <paramref name="source" /> wskazuje, że klucz jest dla algorytmu innego niż algorytm reprezentowany przez to wystąpienie.

—lub—

Zawartość <paramref name="source" /> reprezentująca klucz w formacie, który nie jest obsługiwany.

—lub—

Importowanie klucza specyficznego dla algorytmu nie powiodło się.</exception>
        <exception cref="T:System.NotImplementedException">Typ pochodny nie przesłonięta tego elementu członkowskiego.</exception>
      </Docs>
    </Member>
    <Member MemberName="ImportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public virtual void ImportPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportPkcs8PrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="abstract member ImportPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; *  -&gt; unit&#xA;override this.ImportPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="asymmetricAlgorithm.ImportPkcs8PrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source">Bajty struktury PrivateKeyInfo PKCS # 8 w kodowaniu ASN. 1-w.</param>
        <param name="bytesRead">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Gdy przesłonięta w klasie pochodnej, importuje parę klucza publicznego/prywatnego ze struktury PrivateKeyInfo PKCS # 8 Po odszyfrowaniu, zastępując klucze dla tego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje tylko kodowanie binarne (//CER/DER) PrivateKeyInfo.
Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.

 Ze względu na to, że obsługa specyficzna dla algorytmu jest wymagana do interpretacji zawartości <xref:System.NotImplementedException> tego formatu danych, <xref:System.Security.Cryptography.AsymmetricAlgorithm.ImportPkcs8PrivateKey%2A> domyślnie generuje wartość.

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zawartość <paramref name="source" /> nie reprezentuje struktury PrivateKeyInfo PKCS # 8 w formacie ASN. 1.

—lub—

Zawartość <paramref name="source" /> wskazuje, że klucz jest dla algorytmu innego niż algorytm reprezentowany przez to wystąpienie.

—lub—

Zawartość <paramref name="source" /> reprezentująca klucz w formacie, który nie jest obsługiwany.

—lub—

Importowanie klucza specyficznego dla algorytmu nie powiodło się.</exception>
        <exception cref="T:System.NotImplementedException">Typ pochodny nie przesłonięta tego elementu członkowskiego.</exception>
      </Docs>
    </Member>
    <Member MemberName="ImportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public virtual void ImportSubjectPublicKeyInfo (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportSubjectPublicKeyInfo(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportSubjectPublicKeyInfo (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="abstract member ImportSubjectPublicKeyInfo : ReadOnlySpan&lt;byte&gt; *  -&gt; unit&#xA;override this.ImportSubjectPublicKeyInfo : ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="asymmetricAlgorithm.ImportSubjectPublicKeyInfo (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source">Bajty struktury SubjectPublicKeyInfo X. 509 w kodowaniu ASN. 1-DER.</param>
        <param name="bytesRead">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Gdy przesłonięta w klasie pochodnej, importuje klucz publiczny z struktury SubjectPublicKeyInfo X. 509 po odszyfrowaniu, zastępując klucze dla tego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje tylko kodowanie binarne (DER) SubjectPublicKeyInfo.
Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.

 Ze względu na to, że obsługa specyficzna dla algorytmu jest wymagana do interpretacji zawartości <xref:System.NotImplementedException> tego formatu danych, <xref:System.Security.Cryptography.AsymmetricAlgorithm.ImportSubjectPublicKeyInfo%2A> domyślnie generuje wartość.
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zawartość <paramref name="source" /> nie reprezentuje struktury SubjectPublicKeyInfo X. 509 w formacie ASN. 1-der.

—lub—

Zawartość <paramref name="source" /> wskazuje, że klucz jest dla algorytmu innego niż algorytm reprezentowany przez to wystąpienie.

—lub—

Zawartość <paramref name="source" /> reprezentująca klucz w formacie, który nie jest obsługiwany.

—lub—

Importowanie klucza specyficznego dla algorytmu nie powiodło się.</exception>
        <exception cref="T:System.NotImplementedException">Typ pochodny nie przesłonięta tego elementu członkowskiego.</exception>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public virtual string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.AsymmetricAlgorithm.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyExchangeAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : string" Usage="System.Security.Cryptography.AsymmetricAlgorithm.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera nazwę algorytmu wymiany kluczy. W przeciwnym razie zgłasza <see cref="T:System.NotImplementedException" />.</summary>
        <value>Nazwa algorytmu wymiany kluczy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Security.Cryptography.AsymmetricAlgorithm.KeyExchangeAlgorithm%2A> jak zastąpić właściwość w celu zwrócenia nazwy algorytmu wymiany kluczy. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcrypto.cpp#6)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#6)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="KeySize">
      <MemberSignature Language="C#" Value="public virtual int KeySize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeySize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.AsymmetricAlgorithm.KeySize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property KeySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeySize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.KeySize : int with get, set" Usage="System.Security.Cryptography.AsymmetricAlgorithm.KeySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar (w bitach) modułu klucza używanego przez algorytm asymetryczny.</summary>
        <value>Rozmiar, w bitach, modułu klucza używanego przez algorytm asymetryczny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe rozmiary kluczy są określone przez określoną implementację algorytmu asymetrycznego i są wymienione we <xref:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak zastąpić <xref:System.Security.Cryptography.AsymmetricAlgorithm.KeySize%2A> właściwość, aby sprawdzić, czy znajduje się w zakresie określonym w lokalnej `keySizes` zmiennej członkowskiej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcrypto.cpp#9)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#9)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Rozmiar modułu klucza jest nieprawidłowy.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="KeySizeValue">
      <MemberSignature Language="C#" Value="protected int KeySizeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 KeySizeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.AsymmetricAlgorithm.KeySizeValue" />
      <MemberSignature Language="VB.NET" Value="Protected KeySizeValue As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int KeySizeValue;" />
      <MemberSignature Language="F#" Value="val mutable KeySizeValue : int" Usage="System.Security.Cryptography.AsymmetricAlgorithm.KeySizeValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje rozmiar (w bitach) modułu klucza używanego przez algorytm asymetryczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe rozmiary kluczy są określone przez określoną implementację algorytmu asymetrycznego i są wymienione we <xref:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes%2A> właściwości.  
  
 Dostęp do tego pola uzyskuje <xref:System.Security.Cryptography.AsymmetricAlgorithm.KeySize%2A> się za pomocą właściwości.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="LegalKeySizes">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.KeySizes[] LegalKeySizes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.KeySizes[] LegalKeySizes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LegalKeySizes As KeySizes()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalKeySizes { cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LegalKeySizes : System.Security.Cryptography.KeySizes[]" Usage="System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiary kluczy, które są obsługiwane przez algorytm asymetryczny.</summary>
        <value>Tablica zawierająca rozmiary kluczy obsługiwane przez algorytm asymetryczny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytm asymetryczny obsługuje tylko rozmiary kluczy, które pasują do wpisu w tej tablicy.  
  
   
  
## Examples  
 <xref:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes%2A> Poniższy przykład kodu demonstruje <xref:System.Security.Cryptography.KeySizes.MinSize%2A>, jak wywołać właściwość w celu pobrania właściwości, <xref:System.Security.Cryptography.KeySizes.MaxSize%2A>i <xref:System.Security.Cryptography.KeySizes.SkipSize%2A> . Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcryptoimpl.cpp#10)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#10)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#10)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="LegalKeySizesValue">
      <MemberSignature Language="C#" Value="protected System.Security.Cryptography.KeySizes[] LegalKeySizesValue;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Security.Cryptography.KeySizes[] LegalKeySizesValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizesValue" />
      <MemberSignature Language="VB.NET" Value="Protected LegalKeySizesValue As KeySizes() " />
      <MemberSignature Language="C++ CLI" Value="protected: cli::array &lt;System::Security::Cryptography::KeySizes ^&gt; ^ LegalKeySizesValue;" />
      <MemberSignature Language="F#" Value="val mutable LegalKeySizesValue : System.Security.Cryptography.KeySizes[]" Usage="System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizesValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa rozmiary kluczy, które są obsługiwane przez algorytm asymetryczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytm asymetryczny obsługuje tylko rozmiary kluczy, które pasują do wpisu w tej tablicy.  
  
 Dostęp do tego pola uzyskuje <xref:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes%2A> się za pomocą właściwości.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public virtual string SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.AsymmetricAlgorithm.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SignatureAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SignatureAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : string" Usage="System.Security.Cryptography.AsymmetricAlgorithm.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej pobiera nazwę algorytmu podpisu. W przeciwnym razie zawsze zgłasza <see cref="T:System.NotImplementedException" />.</summary>
        <value>Nazwa algorytmu podpisu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Security.Cryptography.AsymmetricAlgorithm.SignatureAlgorithm%2A> jak zastąpić właściwość w celu zwrócenia nazwy algorytmu podpisu. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcrypto.cpp#7)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#7)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.IDisposable.Dispose" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Security.Cryptography.AsymmetricAlgorithm> gdy wystąpienie jest rzutowane <xref:System.IDisposable> do interfejsu.

]]></format>
        </remarks>
        <forInternalUseOnly />
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public virtual string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ToXmlString : bool -&gt; string&#xA;override this.ToXmlString : bool -&gt; string" Usage="asymmetricAlgorithm.ToXmlString includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><see langword="true" />Aby uwzględnić parametry prywatne; w przeciwnym razie. <see langword="false" /></param>
        <summary>Gdy jest zastępowany w klasie pochodnej, tworzy i zwraca reprezentację ciągu XML bieżącego <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> obiektu. W przeciwnym razie zgłasza <see cref="T:System.NotImplementedException" />.</summary>
        <returns>Kodowanie ciągu XML bieżącego <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje, jak wywołać metodę, <xref:System.Security.Cryptography.AsymmetricAlgorithm.ToXmlString%2A> aby utworzyć reprezentację XML parametrów w bieżącym <xref:System.Security.Cryptography.AsymmetricAlgorithm> obiekcie. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.Cryptography.AsymmetricAlgorithm> klasy.  
  
 [!code-cpp[System.Security.Cryptography.AsymmetricAlgorithm#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/cpp/customcrypto.cpp#5)]
 [!code-csharp[System.Security.Cryptography.AsymmetricAlgorithm#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/CS/customcrypto.cs#5)]
 [!code-vb[System.Security.Cryptography.AsymmetricAlgorithm#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.AsymmetricAlgorithm/VB/customcrypto.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Usługi kryptograficzne</related>
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public virtual bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; *  -&gt; bool&#xA;override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; *  -&gt; bool" Usage="asymmetricAlgorithm.TryExportEncryptedPkcs8PrivateKey (passwordBytes, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="passwordBytes">Bajty, które mają być używane jako hasło podczas szyfrowania materiału klucza.</param>
        <param name="pbeParameters">Parametry szyfrowania opartego na hasłach (PBE), które mają być używane podczas szyfrowania materiału klucza.</param>
        <param name="destination">Zakres bajtów do odbierania danych EncryptedPrivateKeyInfo PKCS # 8.</param>
        <param name="bytesWritten">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, próbuje eksportować bieżący klucz w formacie EncryptedPrivateKeyInfo PKCS # 8 do podanego buforu przy użyciu hasła opartego na bajcie.</summary>
        <returns><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bajty hasła są przesyłane bezpośrednio do funkcji wyprowadzania klucza (KDF) używanej przez algorytm wskazywany `pbeParameters`przez.
Dzięki temu można zapewnić zgodność z innymi systemami, które używają kodowania tekstu innego niż UTF-8 podczas przetwarzania haseł z PBKDF2 (klucz oparty na haśle funkcja 2).

 Ze względu na to, że obsługa specyficzna dla algorytmu jest <xref:System.Security.Cryptography.AsymmetricAlgorithm.TryExportEncryptedPkcs8PrivateKey%2A> wymagana do <xref:System.NotImplementedException> utworzenia tego formatu danych, generuje domyślnie wartość domyślną.

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można wyeksportować klucza.

—lub—

<paramref name="pbeParameters" />wskazuje, <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> że powinny być używane, które <see cref="T:System.Char" />wymaga haseł opartych na.</exception>
        <exception cref="T:System.NotImplementedException">Typ pochodny nie przesłonięta tego elementu członkowskiego.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public virtual bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; *  -&gt; bool&#xA;override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; *  -&gt; bool" Usage="asymmetricAlgorithm.TryExportEncryptedPkcs8PrivateKey (password, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="password">Hasło, które ma być używane podczas szyfrowania materiału klucza.</param>
        <param name="pbeParameters">Parametry szyfrowania opartego na hasłach (PBE), które mają być używane podczas szyfrowania materiału klucza.</param>
        <param name="destination">Zakres bajtów do odbierania danych EncryptedPrivateKeyInfo PKCS # 8.</param>
        <param name="bytesWritten">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Gdy przesłonięta w klasie pochodnej, próbuje eksportować bieżący klucz w formacie PKCS # 8 EncryptedPrivateKeyInfo do podanego buforu przy użyciu hasła opartego na znakach.</summary>
        <returns><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `pbeParameters` wskazuje algorytm korzystający z PBKDF2 (klucz oparty na hasłach funkcja 2), hasło jest konwertowane na bajty przy użyciu kodowania UTF-8.

 Ze względu na to, że obsługa specyficzna dla algorytmu jest <xref:System.Security.Cryptography.AsymmetricAlgorithm.TryExportEncryptedPkcs8PrivateKey%2A> wymagana do <xref:System.NotImplementedException> utworzenia tego formatu danych, generuje domyślnie wartość domyślną.

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można wyeksportować klucza.</exception>
        <exception cref="T:System.NotImplementedException">Typ pochodny nie przesłonięta tego elementu członkowskiego.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public virtual bool TryExportPkcs8PrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryExportPkcs8PrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryExportPkcs8PrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryExportPkcs8PrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryExportPkcs8PrivateKey : Span&lt;byte&gt; *  -&gt; bool&#xA;override this.TryExportPkcs8PrivateKey : Span&lt;byte&gt; *  -&gt; bool" Usage="asymmetricAlgorithm.TryExportPkcs8PrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">Zakres bajtów do odbierania danych PrivateKeyInfo PKCS # 8.</param>
        <param name="bytesWritten">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, próbuje eksportować bieżący klucz w formacie PrivateKeyInfo PKCS # 8 do podanego buforu.</summary>
        <returns><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ze względu na to, że obsługa specyficzna dla algorytmu jest <xref:System.Security.Cryptography.AsymmetricAlgorithm.TryExportPkcs8PrivateKey%2A> wymagana do <xref:System.NotImplementedException> utworzenia tego formatu danych, generuje domyślnie wartość domyślną.

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można wyeksportować klucza.</exception>
        <exception cref="T:System.NotImplementedException">Typ pochodny nie przesłonięta tego elementu członkowskiego.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public virtual bool TryExportSubjectPublicKeyInfo (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryExportSubjectPublicKeyInfo(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.AsymmetricAlgorithm.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryExportSubjectPublicKeyInfo (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryExportSubjectPublicKeyInfo(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryExportSubjectPublicKeyInfo : Span&lt;byte&gt; *  -&gt; bool&#xA;override this.TryExportSubjectPublicKeyInfo : Span&lt;byte&gt; *  -&gt; bool" Usage="asymmetricAlgorithm.TryExportSubjectPublicKeyInfo (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">Zakres bajtów do odbierania danych SubjectPublicKeyInfo X. 509.</param>
        <param name="bytesWritten">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, próbuje eksportować bieżący klucz w formacie X. 509 SubjectPublicKeyInfo do podanego buforu.</summary>
        <returns><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ze względu na to, że obsługa specyficzna dla algorytmu jest <xref:System.Security.Cryptography.AsymmetricAlgorithm.TryExportSubjectPublicKeyInfo%2A> wymagana do <xref:System.NotImplementedException> utworzenia tego formatu danych, generuje domyślnie wartość domyślną.

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można wyeksportować klucza.</exception>
        <exception cref="T:System.NotImplementedException">Typ pochodny nie przesłonięta tego elementu członkowskiego.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportSubjectPublicKeyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>

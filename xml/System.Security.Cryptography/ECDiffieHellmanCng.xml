<Type Name="ECDiffieHellmanCng" FullName="System.Security.Cryptography.ECDiffieHellmanCng">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="286bf918255ea8d29ba319f459e569551d533740" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30570823" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ECDiffieHellmanCng : System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ECDiffieHellmanCng extends System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellmanCng" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ECDiffieHellmanCng&#xA;Inherits ECDiffieHellman" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDiffieHellmanCng sealed : System::Security::Cryptography::ECDiffieHellman" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.ECDiffieHellman</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia implementację kryptografii nowej generacji (CNG) algorytmu Diffie-Hellman krzywej eliptycznej (ECDH). Ta klasa jest używana do wykonywania operacji kryptograficznych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.ECDiffieHellmanCng> Klasa umożliwia obie strony do programu exchange materiału klucza prywatnego, nawet wtedy, gdy komunikują się za pośrednictwem publicznego kanału.  Obie strony można obliczyć tej samej wartość tajna nazywa się *tajnej umowy* zarządzanych klas Diffie-Hellman. Następnie można tajnej umowy do różnych celów, w tym jako klucza symetrycznego. Jednak zamiast bezpośrednio, udostępnianie tajnej umowy <xref:System.Security.Cryptography.ECDiffieHellmanCng> klasy jest niektórych przetwarzania końcowego na umowie przed podawania wartości. To przetwarzanie post jest określany jako *klucza funkcja wyprowadzania (KDF)*; można wybrać KDF, którego chcesz użyć i ustaw jego parametrów za pomocą zestawu właściwości w wystąpieniu obiektu algorytmu Diffie-Hellmana.  
  
|Funkcja wyprowadzania klucza|Właściwości|  
|-----------------------------|----------------|  
|<xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash>|<xref:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm%2A> Algorytmu wyznaczania wartości skrótu, który służy do przetwarzania tajnej umowy.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend%2A> -Tablica opcjonalne bajtów do dołączana do tajnej umowy przed jej wyznaczania wartości skrótu.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend%2A> -Tablica bajtów opcjonalne, aby dołączyć do tajnej umowy przed jej wyznaczania wartości skrótu.|  
|<xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac>|<xref:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm%2A> Algorytmu wyznaczania wartości skrótu, który służy do przetwarzania tajnej umowy.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend%2A>-Tablica opcjonalne bajtów do dołączana do tajnej umowy przed jej wyznaczania wartości skrótu.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend%2A> -Tablica bajtów opcjonalne, aby dołączyć do tajnej umowy przed jej wyznaczania wartości skrótu.|  
|<xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls>|<xref:System.Security.Cryptography.ECDiffieHellmanCng.Label%2A> — Etykieta klucza pochodnego.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.Seed%2A> -Inicjatora dla klucza pochodnego.|  
  
 Wynik przekazywanie tajnej Umowy za pośrednictwem funkcja wyprowadzania klucza jest tablica bajtów, które mogą być używane jako materiału klucza dla aplikacji. Liczba bajtów materiał kluczy, generowane jest zależny od funkcji klucza pochodnego; na przykład algorytmu SHA-256 wygeneruje 256 bitów materiał kluczy, podczas gdy SHA-512 wygeneruje 512 bitów materiału klucza. Podstawowy przepływ ECDH wymiany kluczy jest następujący:  
  
1.  Alicja i Robert utworzyć pary kluczy do użycia dla operacji wymiana kluczy Diffie-Hellman  
  
2.  Alicja i Robert skonfiguruj KDF przy użyciu parametrów Zgadzam się na.  
  
3.  Alicja wysyła Bob swojego klucza publicznego.  
  
4.  Robert wysyła Alicja jego klucza publicznego.  
  
5.  Alicja Roberta, który umożliwia generowanie tajnej umowy siebie nawzajem kluczy publicznych i dotyczą KDF tajnej umowy do wygenerowania materiału klucza.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Security.Cryptography.ECDiffieHellmanCng> klasy ustanowienie wymiany kluczy i sposobu użycia tego klucza szyfrowania wiadomości, które mogą być wysłane za pośrednictwem kanału publicznego i odszyfrowywane przez odbiorcę.  
  
 [!code-csharp[ECDiffieHellmanCng#1](~/samples/snippets/csharp/VS_Snippets_CLR/ecdiffiehellmancng/cs/program.cs#1)]
 [!code-vb[ECDiffieHellmanCng#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ecdiffiehellmancng/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> klasy przy użyciu losowego pary kluczy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Losowe pary kluczy ma domyślnego publicznego klucz o długości 521 bitów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng (int keySize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 keySize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keySize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng(int keySize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keySize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keySize">Rozmiar klucza. Nieprawidłowy rozmiar klucza to 256, 384 i 521 usługi bits.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> klasy z pary kluczy losowych, używając określonego rozmiaru klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Losowe pary kluczy mają długość klucza publicznego, zdefiniowane przez `keySize` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySize" /> Określa nieprawidłową długość.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Klasy kryptografii nowej generacji (CNG) nie są obsługiwane w tym systemie.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng (System.Security.Cryptography.CngKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.CngKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Security.Cryptography.CngKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As CngKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng(System::Security::Cryptography::CngKey ^ key);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="key" Type="System.Security.Cryptography.CngKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który będzie używany jako dane wejściowe, aby operacje kryptograficzne wykonywane przez bieżący obiekt.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> przy użyciu określonego <see cref="T:System.Security.Cryptography.CngKey" /> obiektu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> nie określono grupę algorytmu Diffie-Hellman krzywej eliptycznej (ECDH).</exception>
        <exception cref="T:System.PlatformNotSupportedException">Klasy kryptografii nowej generacji (CNG) nie są obsługiwane w tym systemie.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng(System::Security::Cryptography::ECCurve curve);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" />
      </Parameters>
      <Docs>
        <param name="curve">Krzywej służący do generowania pary kluczy publiczny/prywatny.</param>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> którego pary kluczy publiczny/prywatny jest generowany krzywej określonej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `curve` należy sprawdzić poprawność (czyli musi zwracać `true`) przekazany do <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> — metoda i musi być prime nazwanych lub jawnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="curve" /> Nie można zweryfikować.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHash">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pochodzi bajtów, które mogą być używane jako klucz przy użyciu funkcji skrótu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" />
        <Parameter Name="secretAppend" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Klucz publiczny z drugiej strony.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu do użycia do uzyskania materiału klucza.</param>
        <param name="secretPrepend">Wartość dołączana do pochodnej klucz tajny przed wyznaczania wartości skrótu.</param>
        <param name="secretAppend">Wartość do dołączenia do pochodnej klucz tajny przed wyznaczania wartości skrótu.</param>
        <summary>Pochodzi bajtów, które mogą być używane jako klucz przy użyciu funkcji skrótu danego klucza publicznego innej firmy, nazwę algorytmu wyznaczania wartości skrótu, wartość prepend i wartość dołączania.</summary>
        <returns>Materiał klucza z wymiany kluczy z użyciem klucza publicznego z drugiej strony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `secretPrepend` lub `secretAppend` jest `null`, są traktowane jako puste tablice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> nie jest kluczem ECDH lub nie jest odpowiedni rozmiar.  
  
 —lub—  
  
 <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> jest <see langword="null" /> lub <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Inne błędy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHmac">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pochodzi bajtów, które mogą być używane jako klucz przy użyciu skrótu na podstawie komunikatu kod uwierzytelniania (HMAC).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte(), secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="hmacKey" Type="System.Byte[]" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" />
        <Parameter Name="secretAppend" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Klucz publiczny z drugiej strony.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu do użycia do uzyskania materiału klucza.</param>
        <param name="hmacKey">Klucz dla HMAC.</param>
        <param name="secretPrepend">Wartość dołączana do pochodnej klucz tajny przed wyznaczania wartości skrótu.</param>
        <param name="secretAppend">Wartość do dołączenia do pochodnej klucz tajny przed wyznaczania wartości skrótu.</param>
        <summary>Pochodzi bajtów, które mogą być używane jako klucz przy użyciu skrótu na podstawie komunikatu kod uwierzytelniania (HMAC).</summary>
        <returns>Materiał klucza z wymiany kluczy z użyciem klucza publicznego z drugiej strony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość `secretPrepend` lub `secretAppend` jest `null`, są traktowane jako puste tablice. Jeśli wartość `hmacKey` jest `null`, wyniki algorytmu Diffie-Hellman krzywej eliptycznej (ECDH) będzie używany jako klucz HMAC.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> nie jest kluczem ECDH lub nie jest odpowiedni rozmiar.  
  
 —lub—  
  
 <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> jest <see langword="null" /> lub <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Inne błędy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyMaterial">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pochodzi materiał kluczy, które są generowane na podstawie tajnej Umowy między dwiema stronami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytmu Diffie-Hellman krzywej eliptycznej (ECDH) akceptuje klucza prywatnego i innych firm klucza publicznego jako dane wejściowe i tworzy tajnej umowy jako dane wyjściowe. Funkcja wyprowadzania klucza (KDF) następnie przyjmuje tajnej umowy i tworzy materiału klucza jako dane wyjściowe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyMaterial (System.Security.Cryptography.CngKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.CngKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyMaterial(System.Security.Cryptography.CngKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyMaterial (otherPartyPublicKey As CngKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::CngKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.CngKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Obiekt, który zawiera publiczne częścią klucza Diffie-Hellman krzywej eliptycznej (ECDH) od drugiej strony wymiany kluczy.</param>
        <summary>Pochodzi materiał kluczy, które są generowane na podstawie tajnej Umowy między dwiema stronami podane <see cref="T:System.Security.Cryptography.CngKey" /> obiekt, który zawiera klucz publiczny z drugiej strony.</summary>
        <returns>Tablica bajtów, który zawiera materiału klucza. Informacje te są generowane z tajnej umowy, która jest obliczana na podstawie bieżącego obiektu klucza prywatnego i określony klucz publiczny.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> jest nieprawidłowy. Albo jego <see cref="P:System.Security.Cryptography.CngKey.AlgorithmGroup" /> nie określa właściwości <see cref="P:System.Security.Cryptography.CngAlgorithmGroup.ECDiffieHellman" /> lub jego rozmiar klucza jest niezgodna z rozmiar klucza dla tego wystąpienia.</exception>
        <exception cref="T:System.InvalidOperationException">Ten obiekt <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction" /> właściwość określa <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" /> funkcja wyprowadzania klucza, ale albo <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" /> lub <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Inne błędy.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Klucz publiczny z drugiej strony wymiany kluczy.</param>
        <summary>Pochodzi materiał kluczy, które są generowane na podstawie tajnej Umowy między dwiema stronami podane <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> obiekt, który zawiera klucz publiczny z drugiej strony.</summary>
        <returns>Tablica bajtów, który zawiera materiału klucza. Informacje te są generowane z tajnej umowy, która jest obliczana na podstawie bieżącego obiektu klucza prywatnego i określony klucz publiczny.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> nie jest <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" /> klucza.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyTls">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyTls (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyTls(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, unsigned int8[] prfLabel, unsigned int8[] prfSeed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyTls (otherPartyPublicKey As ECDiffieHellmanPublicKey, prfLabel As Byte(), prfSeed As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyTls(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, cli::array &lt;System::Byte&gt; ^ prfLabel, cli::array &lt;System::Byte&gt; ^ prfSeed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="prfLabel" Type="System.Byte[]" />
        <Parameter Name="prfSeed" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Klucz publiczny z drugiej strony.</param>
        <param name="prfLabel">Etykieta PRF kodowany w formacie ASCII.</param>
        <param name="prfSeed">Seed PRF 64 bajtów.</param>
        <summary>Pochodzi bajtów, które mogą być używane jako klucz przy użyciu algorytmu wyliczającego funkcja Pseudo-Random zabezpieczeń TLS (Transport Layer) (PRF).</summary>
        <returns>Materiał klucza z wymiany kluczy z użyciem klucza publicznego z drugiej strony.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="prfLabel" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="prfSeed" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> nie jest kluczem ECDH lub nie jest odpowiedni rozmiar.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="prfSeed" /> nie jest dokładnie 64 bajtów długości.  
  
 —lub—  
  
 Wszystkie inne błędy kryptograficznych.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveSecretAgreementHandle">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera dojścia do tajnej umowy wygenerowane między stronami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle%2A> Przeciążenia metody są dla użytkowników zaawansowanych, którzy potrzebują dojścia do nieprzetworzonej tajnej umowy zamiast materiału klucza. Dojście tajnej umowy mogą być używane w platformie wywołania wywołania może wykonywać wszystkie zadania nie opatrzona <xref:System.Security.Cryptography.ECDiffieHellmanCng> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveSecretAgreementHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle (System.Security.Cryptography.CngKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle(class System.Security.Cryptography.CngKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle(System.Security.Cryptography.CngKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveSecretAgreementHandle (otherPartyPublicKey As CngKey) As SafeNCryptSecretHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::SafeHandles::SafeNCryptSecretHandle ^ DeriveSecretAgreementHandle(System::Security::Cryptography::CngKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.CngKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Obiekt, który zawiera publiczne częścią klucza Diffie-Hellman krzywej eliptycznej (ECDH) od drugiej strony wymiany kluczy.</param>
        <summary>Pobiera dojścia do tajnej umowy wygenerowane między stronami, podane <see cref="T:System.Security.Cryptography.CngKey" /> obiekt, który zawiera klucz publiczny z drugiej strony.</summary>
        <returns>Dojście do tajnej umowy. Informacja ta jest obliczana na podstawie bieżącego obiektu klucza prywatnego i określony klucz publiczny.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> nie jest kluczem ECDH lub nie jest odpowiedni rozmiar.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Inne błędy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeriveSecretAgreementHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveSecretAgreementHandle (otherPartyPublicKey As ECDiffieHellmanPublicKey) As SafeNCryptSecretHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::SafeHandles::SafeNCryptSecretHandle ^ DeriveSecretAgreementHandle(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Klucz publiczny z drugiej strony wymiany kluczy.</param>
        <summary>Pobiera dojścia do tajnej umowy wygenerowane między stronami, podane <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> obiekt, który zawiera klucz publiczny z drugiej strony.</summary>
        <returns>Dojście do tajnej umowy. Informacja ta jest obliczana na podstawie bieżącego obiektu klucza prywatnego i określony klucz publiczny.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> nie jest <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> klucza.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <see langword="true" /> Aby uwzględnić parametry prywatny; w przeciwnym razie <see langword="false" />.</param>
        <summary>Eksportuje klucza i krzywej jawne parametry używane przez <see cref="T:System.Security.Cryptography.ECCurve" /> obiekt do <see cref="T:System.Security.Cryptography.ECParameters" /> obiektu.</summary>
        <returns>Klucza i jawne parametry używane przez krzywą <see cref="T:System.Security.Cryptography.ECCurve" /> obiektu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Metoda nie może uzyskać krzywej wartości.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jawne eksportowanie jest nieobsługiwane przez tę platformę. Wymagany jest system Windows 10 lub nowszej.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <see langword="true" /> Aby uwzględnić parametry prywatny; w przeciwnym razie <see langword="false" />.</param>
        <summary>Eksportuje klucz używany przez <see cref="T:System.Security.Cryptography.ECCurve" /> obiekt do <see cref="T:System.Security.Cryptography.ECParameters" /> obiektu.</summary>
        <returns>Klucz i nazwane parametry używane przez krzywą <see cref="T:System.Security.Cryptography.ECCurve" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz został utworzony jako krzywą nazwane <xref:System.Security.Cryptography.ECParameters.Curve?displayProperty=nameWithType> pole zawiera parametry nazwane krzywej;          w przeciwnym razie zawiera jawne parametry.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Metoda nie może uzyskać krzywej wartości.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromXmlString">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deserializuje dane klucza z ciągu XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlString">Informacje klucza opartych na języku XML do zdeserializowania.</param>
        <summary>Ta metoda nie jest zaimplementowana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby deserializować klucza XML, użyj <xref:System.Security.Cryptography.ECDiffieHellmanCng.FromXmlString%28System.String%2CSystem.Security.Cryptography.ECKeyXmlFormat%29> zamiast tego przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ta metoda nie została zastąpiona dla tego wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public void FromXmlString (string xml, System.Security.Cryptography.ECKeyXmlFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FromXmlString(string xml, valuetype System.Security.Cryptography.ECKeyXmlFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.FromXmlString(System.String,System.Security.Cryptography.ECKeyXmlFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FromXmlString (xml As String, format As ECKeyXmlFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FromXmlString(System::String ^ xml, System::Security::Cryptography::ECKeyXmlFormat format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
        <Parameter Name="format" Type="System.Security.Cryptography.ECKeyXmlFormat" />
      </Parameters>
      <Docs>
        <param name="xml">Informacje klucza opartych na języku XML do zdeserializowania.</param>
        <param name="format">Jedna z wartości wyliczenia, które określa format ciągu XML. To jedyny obecnie akceptowane format jest <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</param>
        <summary>Deserializuje dane klucza z ciągu XML przy użyciu określonego formatu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xml" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="xml" /> jest nieprawidłowo sformułowany.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="format" /> Określa nieprawidłowy format. Jest to jedyna wartość zaakceptowane <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Inne błędy.</exception>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public override void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" />
      </Parameters>
      <Docs>
        <param name="curve">Krzywej służący do generowania tymczasowych pary kluczy publiczny/prywatny.</param>
        <summary>Generuje nowy tymczasowych publicznego i prywatnego pary kluczy dla określonej krzywej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `curve` należy zweryfikować (czyli musi zwrócić wartość true, gdy dane są przekazywane do <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> metody) i nie może być niejawna.  
  
 Krzywe cech-2 nie są obsługiwane w systemie Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="curve" /> Nie można zweryfikować.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CngAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CngAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As CngAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CngAlgorithm ^ HashAlgorithm { System::Security::Cryptography::CngAlgorithm ^ get(); void set(System::Security::Cryptography::CngAlgorithm ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia algorytmu wyznaczania wartości skrótu do użycia podczas generowania materiału klucza.</summary>
        <value>Obiekt, który określa algorytm wyznaczania wartości skrótu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana przez obiekty kryptografii nowej generacji (CNG) tylko wtedy, gdy <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash> lub <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac> wartość jest ustawiana w <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> właściwości.  
  
 Ta właściwość akceptuje następujących algorytmów: <xref:System.Security.Cryptography.CngAlgorithm.MD5%2A>, <xref:System.Security.Cryptography.CngAlgorithm.Sha1%2A>, <xref:System.Security.Cryptography.CngAlgorithm.Sha256%2A>, <xref:System.Security.Cryptography.CngAlgorithm.Sha384%2A>, i <xref:System.Security.Cryptography.CngAlgorithm.Sha512%2A>.  
  
 Inne algorytmy wyznaczania wartości skrótu niestandardowy może być również.  
  
 Domyślnym algorytmem jest <xref:System.Security.Cryptography.CngAlgorithm.Sha256%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość jest <see langword="null." /></exception>
      </Docs>
    </Member>
    <Member MemberName="HmacKey">
      <MemberSignature Language="C#" Value="public byte[] HmacKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] HmacKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.HmacKey" />
      <MemberSignature Language="VB.NET" Value="Public Property HmacKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ HmacKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz Hash-based kodu (metoda HMAC Message Authentication) do użycia podczas wyprowadzania materiału klucza.</summary>
        <value>Klucz Hash-based kodu (metoda HMAC Message Authentication) do użycia podczas wyprowadzania materiału klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość ma zastosowanie tylko wtedy, gdy <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac> wartość jest ustawiana w <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> właściwości oraz <xref:System.Security.Cryptography.ECDiffieHellmanCng.UseSecretAgreementAsHmacKey%2A> jest właściwość `false`. Domyślna wartość to `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public override void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">Parametry krzywej do zaimportowania.</param>
        <summary>Importuje określone parametry dla <see cref="T:System.Security.Cryptography.ECCurve" /> obiektu jako klucza do bieżącego wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.ECDiffieHellmanCng.ImportParameters%2A> Metoda zastępuje istniejący klucz ten obiekt jest praca z przez utworzenie nowej <xref:System.Security.Cryptography.CngKey> obiektu. Jeśli `parameters` zawiera tylko <xref:System.Security.Cryptography.ECParameters.Q> pola, a następnie jest importowany tylko klucz publiczny.         Jeśli `parameters` zawiera także <xref:System.Security.Cryptography.ECParameters.D>, a następnie zaimportowaniu pary kluczy pełnej. `parameter` <xref:System.Security.Cryptography.ECParameters.Curve> Wartość określa typ krzywej do zaimportowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="parameters" /> Nie można zweryfikować.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="parameters" /> odwołuje się do krzywej, którego nie można zaimportować.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <paramref name="parameters" /> odwołuje się do krzywej, która nie jest obsługiwana przez tę platformę.</exception>
      </Docs>
    </Member>
    <Member MemberName="Key">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CngKey Key { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CngKey Key" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.Key" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Key As CngKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CngKey ^ Key { System::Security::Cryptography::CngKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa <see cref="T:System.Security.Cryptography.CngKey" /> używany przez bieżący obiekt dla operacji kryptograficznych.</summary>
        <value>Pary kluczy używanych przez ten obiekt do wykonywania operacji kryptograficznych.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDerivationFunction">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyDerivationFunction As ECDiffieHellmanKeyDerivationFunction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { System::Security::Cryptography::ECDiffieHellmanKeyDerivationFunction get(); void set(System::Security::Cryptography::ECDiffieHellmanKeyDerivationFunction value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia funkcję wyprowadzania klucza dla <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> klasy.</summary>
        <value>Jeden z <see cref="T:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction" /> wartości wyliczenia: <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />, <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" />, lub <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />. Wartość domyślna to <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość określa funkcja wyprowadzania klucza, który jest używany do transformacji w materiału klucza tajnego umowy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość wyliczenia jest poza zakresem.</exception>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public byte[] Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Label" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Label { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość etykiety, która jest używana dla klucza pochodnego.</summary>
        <value>Wartość etykiety.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest używana dla klucza pochodnego, jeśli <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls> wartość jest ustawiana w <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> właściwości. Domyślnie jest `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PublicKey As ECDiffieHellmanPublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::ECDiffieHellmanPublicKey ^ PublicKey { System::Security::Cryptography::ECDiffieHellmanPublicKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanPublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klucz publiczny używany przez inny <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> obiekt, aby wygenerować udostępnionego tajnej umowy.</summary>
        <value>Klucz publiczny, który jest skojarzony z tym wystąpieniem <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecretAppend">
      <MemberSignature Language="C#" Value="public byte[] SecretAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SecretAppend" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property SecretAppend As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SecretAppend { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która zostanie dołączona do tajnej umowy podczas generowania materiału klucza.</summary>
        <value>Wartość, która jest dołączona do tajnej umowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest używana dla klucza pochodnego, jeśli <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash> lub <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac> jest używana funkcja wyprowadzania klucza (KDF). Wartość jest dołączona do tajnej umowy, a wartość łączna jest przekazywana do KDF do generowania materiału klucza. Domyślna wartość to `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecretPrepend">
      <MemberSignature Language="C#" Value="public byte[] SecretPrepend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SecretPrepend" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend" />
      <MemberSignature Language="VB.NET" Value="Public Property SecretPrepend As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SecretPrepend { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która zostanie dodana do początku tajnej umowy podczas wyprowadzania materiału klucza.</summary>
        <value>Wartość, która jest dołączany na początku tajnej umowy podczas wyprowadzania klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest używana dla klucza pochodnego, jeśli <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> właściwość jest ustawiona na jeden z następujących wartości:  
  
-   <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash>  
  
-   <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac>  
  
 Wartość jest dołączany na tajnej umowy początku, a wartość łączna jest przekazywany do funkcji klucza pochodnego (KDF) do generowania materiału klucza. Domyślna wartość to `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seed">
      <MemberSignature Language="C#" Value="public byte[] Seed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Seed" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" />
      <MemberSignature Language="VB.NET" Value="Public Property Seed As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Seed { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość początkową, który będzie używany w przypadku tworzenia klasy pochodnej materiału klucza.</summary>
        <value>Wartości początkowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest używana dla klucza pochodnego, jeśli <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> właściwość jest ustawiona na <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls>. Domyślna wartość to `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToXmlString">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serializuje dane klucza do ciągu XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <see langword="true" /> Aby uwzględnić parametry prywatny; w przeciwnym razie <see langword="false" />.</param>
        <summary>Ta metoda nie jest zaimplementowana.</summary>
        <returns>Nie dotyczy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby przekonwertować bieżącego klucza reprezentację XML, użyj <xref:System.Security.Cryptography.ECDiffieHellmanCng.ToXmlString%28System.Security.Cryptography.ECKeyXmlFormat%29> zamiast tego przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ta metoda nie została zastąpiona dla tego wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public string ToXmlString (System.Security.Cryptography.ECKeyXmlFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToXmlString(valuetype System.Security.Cryptography.ECKeyXmlFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ToXmlString(System.Security.Cryptography.ECKeyXmlFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXmlString (format As ECKeyXmlFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToXmlString(System::Security::Cryptography::ECKeyXmlFormat format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Security.Cryptography.ECKeyXmlFormat" />
      </Parameters>
      <Docs>
        <param name="format">Jedna z wartości wyliczenia, które określa format ciągu XML. To jedyny obecnie akceptowane format jest <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</param>
        <summary>Serializuje dane klucza do ciągu XML przy użyciu określonego formatu.</summary>
        <returns>Obiekt ciągu zawierający informacje o kluczu, uszeregować w ciągu XML zgodnie z żądany format.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="format" /> Określa nieprawidłowy format. Jest to jedyna wartość zaakceptowane <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSecretAgreementAsHmacKey">
      <MemberSignature Language="C#" Value="public bool UseSecretAgreementAsHmacKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSecretAgreementAsHmacKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.UseSecretAgreementAsHmacKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UseSecretAgreementAsHmacKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSecretAgreementAsHmacKey { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy tajnej umowy jest używany jako klawisz skrótu na podstawie kodu (metoda HMAC Message Authentication) do uzyskania materiału klucza.</summary>
        <value>
          <see langword="true" /> Jeśli tajnej umowy jest używany jako klawisz HMAC do uzyskania materiału klucza; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Ta wartość jest używana dla klucza pochodnego, jeśli <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> właściwość jest ustawiona na <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac>. Domyślna wartość to `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
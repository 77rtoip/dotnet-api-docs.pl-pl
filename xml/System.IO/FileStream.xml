<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3b7dad0f3782ac2f1b42a376cfb673662429b6cf" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68541164" /></Metadata><TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia plik <see cref="T:System.IO.Stream" /> do obsługi synchronicznych i asynchronicznych operacji odczytu i zapisu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream> Użyj klasy, aby odczytywać, zapisywać w, otwierać i zamykać pliki w systemie plików oraz manipulować innymi dojściami do systemu operacyjnego związanymi z plikami, w tym potokami, standardowym wejściem i wyjściem standardowym. Można <xref:System.IO.FileStream.Read%2A>użyć <xref:System.IO.FileStream.FlushAsync%2A> metod, <xref:System.IO.FileStream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A> <xref:System.IO.FileStream.ReadAsync%2A>,, i <xref:System.IO.FileStream.Flush%2A> do wykonywania operacji synchronicznych lub,,, i metody do wykonywania asynchronicznego <xref:System.IO.Stream.CopyTo%2A> <xref:System.IO.FileStream.Write%2A> składowa. Używaj metod asynchronicznych do wykonywania operacji na plikach intensywnie korzystających z zasobów bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. <xref:System.IO.FileStream>buforuje dane wejściowe i wyjściowe w celu zapewnienia lepszej wydajności.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejs. Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio. Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `catch` w bloku. Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.  
  
 <xref:System.IO.FileStream.IsAsync%2A> Właściwość wykrywa, czy dojście do pliku zostało otwarte asynchronicznie. Ta wartość jest <xref:System.IO.FileStream> określana podczas tworzenia wystąpienia klasy przy użyciu konstruktora, który `isAsync`ma parametr, `useAsync`lub `options` . Gdy właściwość ma `true`wartość, strumień wykorzystuje nakładające się operacje we/wy na asynchroniczne wykonywanie operacji na plikach. `true` <xref:System.IO.FileStream.ReadAsync%2A> <xref:System.IO.FileStream.WriteAsync%2A>Jednak właściwość nie musi być wywołanie metody,, lub <xref:System.IO.Stream.CopyToAsync%2A>. <xref:System.IO.FileStream.IsAsync%2A> Gdy właściwość jest `false` i wywołuje asynchroniczne operacje odczytu i zapisu, wątek interfejsu użytkownika nadal nie jest blokowany, ale rzeczywista operacja we/wy jest wykonywana synchronicznie. <xref:System.IO.FileStream.IsAsync%2A>  
  
 <xref:System.IO.FileStream.Seek%2A> Metoda obsługuje losowy dostęp do plików. <xref:System.IO.FileStream.Seek%2A>zezwala na przeniesienie położenia do odczytu/zapisu do dowolnej pozycji w pliku. Jest to realizowane za pomocą parametrów punktu odniesienia przesunięcia bajtowego. Przesunięcie bajtu jest względem punktu odwołania wyszukiwania, który może być początkiem, bieżącą pozycją lub końcem pliku bazowego, reprezentowane przez trzy elementy członkowskie <xref:System.IO.SeekOrigin> wyliczenia.  
  
> [!NOTE]
>  Pliki dysków zawsze obsługują dostęp losowy. W czasie konstruowania <xref:System.IO.FileStream.CanSeek%2A> wartość właściwości jest ustawiona na `true` lub `false` w zależności od typu pliku źródłowego. Jeśli typ pliku bazowego to FILE_TYPE_DISK, zgodnie z definicją w Winbase. h <xref:System.IO.FileStream.CanSeek%2A> , wartość właściwości `true`to. W przeciwnym razie wartość `false` Właściwościto.<xref:System.IO.FileStream.CanSeek%2A>  
  
 Jeśli proces kończy się częścią pliku zablokowany lub zamyka plik, który ma oczekujące blokady, zachowanie jest niezdefiniowane.  
  
 W przypadku operacji dotyczących katalogu i innych operacji na plikach <xref:System.IO.File>, <xref:System.IO.Directory>Zobacz klasy <xref:System.IO.Path> , i. Klasa jest klasą narzędzi, która ma metody statyczne głównie do <xref:System.IO.FileStream> tworzenia obiektów na podstawie ścieżek plików. <xref:System.IO.File> Klasa tworzy strumień z tablicy bajtów i jest podobny <xref:System.IO.FileStream> do klasy. <xref:System.IO.MemoryStream>  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Wykrycie zmiany pozycji strumienia  
 <xref:System.IO.FileStream> Gdy obiekt nie ma blokady na wyłączność, inny wątek może uzyskać dostęp do dojścia do pliku współbieżnie i zmienić położenie wskaźnika pliku systemu operacyjnego, który jest skojarzony z dojściem do pliku. W takim przypadku można złamane miejsce w pamięci <xref:System.IO.FileStream> podręcznej w obiekcie i w pamięci podręcznej w buforze. Obiekt rutynowo sprawdza metody, które uzyskują dostęp do bufora pamięci podręcznej, aby upewnić się, że pozycja dojścia systemu operacyjnego jest taka sama <xref:System.IO.FileStream> jak pozycja w pamięci podręcznej używana przez obiekt. <xref:System.IO.FileStream>  
  
 Jeśli Nieoczekiwana zmiana w położeniu dojścia zostanie wykryta w wywołaniu <xref:System.IO.FileStream.Read%2A> metody, .NET Framework odrzuca zawartość buforu i ponownie odczytuje strumień z pliku. Może to mieć wpływ na wydajność, w zależności od rozmiaru pliku i innych procesów, które mogą wpływać na położenie strumienia pliku.  
  
 Jeśli Nieoczekiwana zmiana w położeniu dojścia zostanie wykryta w wywołaniu <xref:System.IO.FileStream.Write%2A> metody, zawartość buforu zostanie odrzucona <xref:System.IO.IOException> i zostanie zgłoszony wyjątek.  
  
 Obiekt nie będzie miał blokady na wyłączność w jego obsłudze, gdy <xref:System.IO.FileStream.SafeFileHandle%2A> zostanie uzyskany dostęp do tej właściwości w celu <xref:System.IO.FileStream> uwidocznienia uchwytu <xref:System.IO.FileStream.SafeFileHandle%2A> lub obiekt uzyskuje właściwość w jego konstruktorze. <xref:System.IO.FileStream>  
  
   
  
## Examples  
 Poniższy przykład demonstruje niektóre <xref:System.IO.FileStream> konstruktory.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 Poniższy przykład pokazuje, jak zapisywać do pliku asynchronicznie. Ten kod jest uruchamiany w aplikacji WPF, która ma blok TextBlock o nazwie UserInput i podłączany do procedury obsługi zdarzeń kliknięcia o nazwie Button_Click. Ścieżka do pliku musi zostać zmieniona na plik, który istnieje na komputerze.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
    <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku, które zostanie hermetyzowane <see langword="FileStream" /> przez bieżący obiekt.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy dla określonego dojścia do pliku z określonym uprawnieniem do odczytu/zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.IO.Stream.Close%2A> jest wywoływana, uchwyt jest również zamknięty, a Licznik dojść pliku jest zmniejszany.  
  
 `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojściem. Odczyt, zapis lub wyszukiwanie w czasie, `FileStream` w którym znajduje się również dojście może spowodować uszkodzenie danych. W celu zapewnienia bezpieczeństwa danych <xref:System.IO.FileStream.Flush%2A> Wywołaj przed użyciem uchwytu i unikaj wywoływania jakichkolwiek metod `Close` innych niż po zakończeniu korzystania z dojścia.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 `FileShare.Read`jest wartością domyślną dla tych <xref:System.IO.FileStream> konstruktorów `FileShare` bez parametru.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" />nie jest polem <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, taki jak błąd dysku.  
  
 —lub—  
  
 Strumień został zamknięty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany plik nie jest dozwolony przez system operacyjny dla określonego dojścia do pliku, na przykład gdy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> , a dojście do pliku jest ustawione na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku, które zostanie hermetyzowane <see langword="FileStream" /> przez bieżący obiekt.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy dla określonego dojścia do pliku z określonym uprawnieniem do odczytu/zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.IO.Stream.Close%2A> jest wywoływana, uchwyt jest również zamknięty, a Licznik dojść pliku jest zmniejszany.  
  
 `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojściem. Odczyt, zapis lub wyszukiwanie w czasie, `FileStream` w którym znajduje się również dojście może spowodować uszkodzenie danych. W celu zapewnienia bezpieczeństwa danych <xref:System.IO.FileStream.Flush%2A> Wywołaj przed użyciem uchwytu i unikaj wywoływania jakichkolwiek metod `Close` innych niż po zakończeniu korzystania z dojścia.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 `FileShare.Read`jest wartością domyślną dla tych <xref:System.IO.FileStream> konstruktorów `FileShare` bez parametru.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" />nie jest polem <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, taki jak błąd dysku.  
  
 —lub—  
  
 Strumień został zamknięty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany plik nie jest dozwolony przez system operacyjny dla określonego dojścia do pliku, na przykład gdy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> , a dojście do pliku jest ustawione na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, który <see langword="FileStream" /> będzie hermetyzowany bieżący obiekt.</param>
        <param name="mode">Stała określająca sposób otwierania lub tworzenia pliku.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy z określoną ścieżką i trybem tworzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwami urządzeń, takimi\\jak "\\.\PHYSICALDRIVE0".  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 Konstruktor uzyskuje dostęp do odczytu/zapisu do pliku i otwiera dostęp do odczytu (czyli żądania otwarcia pliku do zapisu przez ten lub inny proces zakończy się niepowodzeniem, dopóki `FileStream` obiekt nie zostanie zamknięty, ale próby odczytu zakończą się pomyślnie).  
  
 Tego konstruktora nie można używać do otwierania plików tylko do odczytu; Zamiast tego należy użyć konstruktora, który akceptuje `FileAccess` parametr z wartością ustawioną na. `FileAccess.Read`  
  
 Rozmiar buforu jest ustawiony na domyślny rozmiar 4096 bajtów (4 KB).  
  
> [!NOTE]
>  `path`nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni. Na przykład w zależności od systemu Ta klasa może uzyskać dostęp do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A>dotyczy `true` wszystkich<xref:System.IO.FileStream> obiektów, które hermetyzują pliki. Jeśli `path` wskazuje urządzenie, które nie obsługuje wyszukiwania <xref:System.IO.FileStream.CanSeek%2A> , właściwość w wyniku <xref:System.IO.FileStream> ma `false`wartość. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanSeek%2A>Zobacz.  
  
 `FileShare.Read`jest wartością domyślną dla tych <xref:System.IO.FileStream> konstruktorów `FileShare` bez parametru.  
  
 W przypadku konstruktorów <xref:System.IO.FileAccess> bez parametru, `mode` Jeśli parametr jest ustawiony na <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> jest domyślnym dostępem. W przeciwnym razie dostęp jest ustawiany na <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zapisywać dane do pliku, bajty przez bajty, a następnie sprawdzać poprawność zapisu danych.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem (""), zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
—lub— 
 <paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="mode" /> , takiego jak when <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, i plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />Określa plik, który jest tylko do odczytu.</exception>
        <exception cref="T:System.IO.IOException">Błąd we/wy, taki jak określenie <see langword="FileMode.CreateNew" /> , kiedy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  
  
—lub— 
Strumień został zamknięty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />zawiera nieprawidłową wartość.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku, które zostanie hermetyzowane <see langword="FileStream" /> przez bieżący obiekt.</param>
        <param name="access">Stała, która <see cref="P:System.IO.FileStream.CanRead" /> ustawia <see cref="P:System.IO.FileStream.CanWrite" /> właściwości<see langword="FileStream" />iobiektu. <see cref="T:System.IO.FileAccess" /></param>
        <param name="bufferSize">Wartość dodatnia <see cref="T:System.Int32" /> większa niż 0 wskazuje rozmiar buforu. Domyślny rozmiar buforu to 4096.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy dla określonego dojścia do pliku z określonym uprawnieniem do odczytu/zapisu i rozmiarem buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojściem. Odczyt, zapis lub wyszukiwanie w czasie, `FileStream` w którym znajduje się również dojście może spowodować uszkodzenie danych. W celu zapewnienia bezpieczeństwa danych <xref:System.IO.FileStream.Flush%2A> Wywołaj przed użyciem uchwytu i unikaj wywoływania jakichkolwiek metod `Close` innych niż po zakończeniu korzystania z dojścia. Alternatywnie Odczytaj i Zapisz do dojścia przed wywołaniem tego `FileStream` konstruktora.  
  
 `FileShare.Read`jest wartością domyślną dla tych <xref:System.IO.FileStream> konstruktorów `FileShare` bez parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" /> Parametr jest nieprawidłowym dojściem.  
  
—lub— 
<paramref name="handle" /> Parametr jest dojściem synchronicznym i został użyty asynchronicznie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> Parametr jest ujemny.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, taki jak błąd dysku.  
  
 —lub—  
  
 Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany plik nie jest dozwolony przez system operacyjny dla określonego dojścia do pliku, na przykład gdy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> , a dojście do pliku jest ustawione na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Skojarzone wyliczenia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku, które zostanie hermetyzowane <see langword="FileStream" /> przez bieżący obiekt.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu.</param>
        <param name="ownsHandle"><see langword="true" />Jeśli dojście do pliku będzie własnością tego <see langword="FileStream" /> wystąpienia; w przeciwnym razie,. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy dla określonego dojścia do pliku z określonym uprawnieniem do odczytu/zapisu i <see langword="FileStream" /> własnością wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` Obiekt uzyskuje określony dostęp do pliku. Własność dojścia zostanie określona. Jeśli ten proces jest właścicielem dojścia, wywołanie <xref:System.IO.Stream.Close%2A> metody również zamknie uchwytu, a liczba dojść pliku zostanie zmniejszona. `FileStream` Obiekt ma domyślny rozmiar buforu wynoszący 4096 bajtów.  
  
 `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojściem. Odczyt, zapis lub wyszukiwanie w czasie, `FileStream` w którym znajduje się również dojście może spowodować uszkodzenie danych. W celu zapewnienia bezpieczeństwa danych <xref:System.IO.FileStream.Flush%2A> Wywołaj przed użyciem uchwytu i unikaj wywoływania metod `Close` innych niż po zakończeniu korzystania z dojścia.  
  
 `FileShare.Read`jest wartością domyślną dla tych <xref:System.IO.FileStream> konstruktorów `FileShare` bez parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" />nie jest polem <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, taki jak błąd dysku.  
  
 —lub—  
  
 Strumień został zamknięty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany plik nie jest dozwolony przez system operacyjny dla określonego dojścia do pliku, na przykład gdy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> , a dojście do pliku jest ustawione na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, który <see langword="FileStream" /> będzie hermetyzowany bieżący obiekt.</param>
        <param name="mode">Stała określająca sposób otwierania lub tworzenia pliku.</param>
        <param name="access">Stała określająca sposób dostępu do pliku przez <see langword="FileStream" /> obiekt. Określa również wartości zwracane przez <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu. <see cref="P:System.IO.FileStream.CanSeek" />jest <see langword="true" /> Jeśli<paramref name="path" /> określa plik dysku.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy z określoną ścieżką, trybem tworzenia i uprawnieniem do odczytu/zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwami urządzeń, takimi\\jak "\\.\PHYSICALDRIVE0".  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 Konstruktor uzyskuje dostęp do odczytu/zapisu do pliku i otwiera dostęp do odczytu (czyli żądania otwarcia pliku do zapisu przez ten lub inny proces zakończy się niepowodzeniem, dopóki `FileStream` obiekt nie zostanie zamknięty, ale próby odczytu zakończą się pomyślnie). Rozmiar buforu jest ustawiony na domyślny rozmiar 4096 bajtów (4 KB).  
  
> [!NOTE]
>  `path`nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni. Na przykład w zależności od systemu Ta klasa może uzyskać dostęp do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A>dotyczy `true` wszystkich<xref:System.IO.FileStream> obiektów, które hermetyzują pliki. Jeśli `path` wskazuje urządzenie, które nie obsługuje wyszukiwania <xref:System.IO.FileStream.CanSeek%2A> , właściwość w wyniku <xref:System.IO.FileStream> ma `false`wartość. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanSeek%2A>Zobacz.  
  
 `FileShare.Read`jest wartością domyślną dla tych <xref:System.IO.FileStream> konstruktorów `FileShare` bez parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem (""), zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
—lub— 
 <paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku innym niż NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="mode" /> , takiego jak when <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, i plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Błąd we/wy, taki jak określenie <see langword="FileMode.CreateNew" /> , kiedy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  
  
—lub— 
Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> <paramref name="path" /> <see langword="ReadWrite" /> <see langword="Write" /> Żądany system operacyjny nie jest dozwolony dla danego elementu, na przykład gdy jest lub, a plik lub katalog jest ustawiony na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />zawiera nieprawidłową wartość.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku, które będzie hermetyzowane przez ten <see langword="FileStream" /> obiekt.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu.</param>
        <param name="bufferSize">Wartość dodatnia <see cref="T:System.Int32" /> większa niż 0 wskazuje rozmiar buforu. Domyślny rozmiar buforu to 4096.</param>
        <param name="isAsync"><see langword="true" />Jeśli dojście zostało otwarte asynchronicznie (czyli w trybie we/wy); w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy dla określonego dojścia do pliku, z określonym uprawnieniem do odczytu/zapisu, rozmiarem buforu i stanem synchronicznym lub asynchronicznym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `isAsync` Ustaw`true` parametr na, aby otworzyć dojście do pliku asynchronicznie. Gdy parametr ma `true`wartość, strumień wykorzystuje nakładające się operacje we/wy na asynchroniczne wykonywanie operacji na plikach. Jednak `true` parametr nie musi być <xref:System.IO.FileStream.ReadAsync%2A>wywołaniem metody, <xref:System.IO.FileStream.WriteAsync%2A>, lub <xref:System.IO.Stream.CopyToAsync%2A> . Gdy parametr jest `false` i wywołuje asynchroniczne operacje odczytu i zapisu, wątek interfejsu użytkownika nadal nie jest blokowany, ale rzeczywista operacja we/wy jest wykonywana synchronicznie. `isAsync`  
  
 `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojściem. Odczyt, zapis lub wyszukiwanie w czasie, `FileStream` w którym znajduje się również dojście może spowodować uszkodzenie danych. W celu zapewnienia bezpieczeństwa danych <xref:System.IO.FileStream.Flush%2A> Wywołaj przed użyciem uchwytu i unikaj wywoływania jakichkolwiek metod `Close` innych niż po zakończeniu korzystania z dojścia. Alternatywnie Odczytaj i Zapisz do dojścia przed wywołaniem tego `FileStream` konstruktora.  
  
 `FileShare.Read`jest wartością domyślną dla tych <xref:System.IO.FileStream> konstruktorów `FileShare` bez parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" /> Parametr jest nieprawidłowym dojściem.  
  
—lub— 
<paramref name="handle" /> Parametr jest dojściem synchronicznym i został użyty asynchronicznie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> Parametr jest ujemny.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, taki jak błąd dysku.  
  
 —lub—  
  
 Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany plik nie jest dozwolony przez system operacyjny dla określonego dojścia do pliku, na przykład gdy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> , a dojście do pliku jest ustawione na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Skojarzone wyliczenia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku, które będzie hermetyzowane przez ten <see langword="FileStream" /> obiekt.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu.</param>
        <param name="ownsHandle"><see langword="true" />Jeśli dojście do pliku będzie własnością tego <see langword="FileStream" /> wystąpienia; w przeciwnym razie,. <see langword="false" /></param>
        <param name="bufferSize">Wartość dodatnia <see cref="T:System.Int32" /> większa niż 0 wskazuje rozmiar buforu. Domyślny rozmiar buforu to 4096.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy dla określonego dojścia do pliku, z określonym uprawnieniem do odczytu/zapisu, <see langword="FileStream" /> własnością wystąpienia i rozmiarem buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` Obiekt uzyskuje określony dostęp do pliku. Własność dojścia zostanie określona. Jeśli jest `FileStream` to uchwyt, wywołanie <xref:System.IO.Stream.Close%2A> metody również zamknie uchwytu. W szczególności Licznik dojść pliku jest zmniejszany. `FileStream` Obiekt ma określony rozmiar buforu.  
  
 `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojściem. Odczyt, zapis lub wyszukiwanie w czasie, `FileStream` w którym znajduje się również dojście może spowodować uszkodzenie danych. W celu zapewnienia bezpieczeństwa danych <xref:System.IO.FileStream.Flush%2A> Wywołaj przed użyciem uchwytu i unikaj wywoływania jakichkolwiek metod `Close` innych niż po zakończeniu korzystania z dojścia. Alternatywnie Odczytaj i Zapisz do dojścia przed wywołaniem tego `FileStream` konstruktora.  
  
 `FileShare.Read`jest wartością domyślną dla tych <xref:System.IO.FileStream> konstruktorów `FileShare` bez parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" />jest wartością ujemną.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, taki jak błąd dysku.  
  
 —lub—  
  
 Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany plik nie jest dozwolony przez system operacyjny dla określonego dojścia do pliku, na przykład gdy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> , a dojście do pliku jest ustawione na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, który <see langword="FileStream" /> będzie hermetyzowany bieżący obiekt.</param>
        <param name="mode">Stała określająca sposób otwierania lub tworzenia pliku.</param>
        <param name="access">Stała określająca sposób dostępu do pliku przez <see langword="FileStream" /> obiekt. Określa również wartości zwracane przez <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu. <see cref="P:System.IO.FileStream.CanSeek" />jest <see langword="true" /> Jeśli<paramref name="path" /> określa plik dysku.</param>
        <param name="share">Stała określająca sposób, w jaki plik będzie współużytkowany przez procesy.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy z określoną ścieżką, trybem tworzenia, uprawnieniem do odczytu/zapisu i uprawnieniami udostępniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwami urządzeń, takimi\\jak "\\.\PHYSICALDRIVE0".  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 Konstruktor uzyskuje dostęp do odczytu/zapisu do pliku i otwiera dostęp do odczytu (czyli żądania otwarcia pliku do zapisu przez ten lub inny proces zakończy się niepowodzeniem, dopóki `FileStream` obiekt nie zostanie zamknięty, ale próby odczytu zakończą się pomyślnie). Rozmiar buforu jest ustawiony na domyślny rozmiar 4096 bajtów (4 KB).  
  
> [!NOTE]
>  `path`nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni. Na przykład w zależności od systemu Ta klasa może uzyskać dostęp do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A>dotyczy `true` wszystkich<xref:System.IO.FileStream> obiektów, które hermetyzują pliki. Jeśli `path` wskazuje urządzenie, które nie obsługuje wyszukiwania <xref:System.IO.FileStream.CanSeek%2A> , właściwość w wyniku <xref:System.IO.FileStream> ma `false`wartość. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanSeek%2A>Zobacz.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.FileStream.Lock%2A> metody.  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem (""), zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
—lub— 
 <paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku innym niż NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="mode" /> , takiego jak when <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, i plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Błąd we/wy, taki jak określenie <see langword="FileMode.CreateNew" /> , kiedy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  
  
—lub— 
System działa w systemie Windows 98 lub Windows 98 Second Edition i <paramref name="share" /> ma <see langword="FileShare.Delete" />ustawioną wartość.  
  
—lub— 
Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> <paramref name="path" /> <see langword="ReadWrite" /> <see langword="Write" /> Żądany system operacyjny nie jest dozwolony dla danego elementu, na przykład gdy jest lub, a plik lub katalog jest ustawiony na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />zawiera nieprawidłową wartość.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku, które będzie hermetyzowane przez ten <see langword="FileStream" /> obiekt.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu.</param>
        <param name="ownsHandle"><see langword="true" />Jeśli dojście do pliku będzie własnością tego <see langword="FileStream" /> wystąpienia; w przeciwnym razie,. <see langword="false" /></param>
        <param name="bufferSize">Wartość dodatnia <see cref="T:System.Int32" /> większa niż 0 wskazuje rozmiar buforu. Domyślny rozmiar buforu to 4096.</param>
        <param name="isAsync"><see langword="true" />Jeśli dojście zostało otwarte asynchronicznie (czyli w trybie we/wy); w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy dla określonego dojścia do pliku z określonym uprawnieniem odczyt/zapis, <see langword="FileStream" /> własność wystąpienia, rozmiar buforu i stan synchroniczny lub asynchroniczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` Obiekt uzyskuje określony dostęp do pliku. Własność dojścia zostanie określona. Jeśli jest `FileStream` to uchwyt, wywołanie <xref:System.IO.Stream.Close%2A> metody również zamknie uchwytu. W szczególności Licznik dojść pliku jest zmniejszany. `FileStream` Obiekt ma określony rozmiar buforu.  
  
 `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojściem. Odczyt, zapis lub wyszukiwanie w czasie, `FileStream` w którym znajduje się również dojście może spowodować uszkodzenie danych. W celu zapewnienia bezpieczeństwa danych <xref:System.IO.FileStream.Flush%2A> Wywołaj przed użyciem uchwytu i unikaj wywoływania jakichkolwiek metod `Close` innych niż po zakończeniu korzystania z dojścia. Alternatywnie Odczytaj i Zapisz do dojścia przed wywołaniem tego `FileStream` konstruktora.  
  
 `FileShare.Read`jest wartością domyślną dla tych <xref:System.IO.FileStream> konstruktorów `FileShare` bez parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="access" />jest mniejsza <see langword="FileAccess.Read" /> lub <see langword="FileAccess.ReadWrite" /> równa0lubmniejszaodzera<paramref name="bufferSize" /> .</exception>
        <exception cref="T:System.ArgumentException">Dojście jest nieprawidłowe.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, taki jak błąd dysku.  
  
 —lub—  
  
 Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany plik nie jest dozwolony przez system operacyjny dla określonego dojścia do pliku, na przykład gdy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> , a dojście do pliku jest ustawione na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania dostępu do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, który <see langword="FileStream" /> będzie hermetyzowany bieżący obiekt.</param>
        <param name="mode">Stała określająca sposób otwierania lub tworzenia pliku.</param>
        <param name="access">Stała określająca sposób dostępu do pliku przez <see langword="FileStream" /> obiekt. Określa również wartości zwracane przez <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu. <see cref="P:System.IO.FileStream.CanSeek" />jest <see langword="true" /> Jeśli<paramref name="path" /> określa plik dysku.</param>
        <param name="share">Stała określająca sposób, w jaki plik będzie współużytkowany przez procesy.</param>
        <param name="bufferSize">Wartość dodatnia <see cref="T:System.Int32" /> większa niż 0 wskazuje rozmiar buforu. Domyślny rozmiar buforu to 4096.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy z określoną ścieżką, trybem tworzenia, uprawnieniem do odczytu/zapisu i udostępniania oraz rozmiarem buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwami urządzeń, takimi\\jak "\\.\PHYSICALDRIVE0".  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path`nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni. Na przykład w zależności od systemu Ta klasa może uzyskać dostęp do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A>dotyczy `true` wszystkich<xref:System.IO.FileStream> obiektów, które hermetyzują pliki. Jeśli `path` wskazuje urządzenie, które nie obsługuje wyszukiwania <xref:System.IO.FileStream.CanSeek%2A> , właściwość w wyniku <xref:System.IO.FileStream> ma `false`wartość. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanSeek%2A>Zobacz.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem (""), zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
—lub— 
 <paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" />jest ujemna lub równa zero.  
  
—lub— 
 <paramref name="mode" />, <paramref name="access" /> lub<paramref name="share" /> zawierają nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="mode" /> , takiego jak when <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, i plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Błąd we/wy, taki jak określenie <see langword="FileMode.CreateNew" /> , kiedy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  
  
—lub— 
System działa w systemie Windows 98 lub Windows 98 Second Edition i <paramref name="share" /> ma <see langword="FileShare.Delete" />ustawioną wartość.  
  
—lub— 
Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> <paramref name="path" /> <see langword="ReadWrite" /> <see langword="Write" /> Żądany system operacyjny nie jest dozwolony dla danego elementu, na przykład gdy jest lub, a plik lub katalog jest ustawiony na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, który <see langword="FileStream" /> będzie hermetyzowany bieżący obiekt.</param>
        <param name="mode">Stała określająca sposób otwierania lub tworzenia pliku.</param>
        <param name="access">Stała określająca sposób dostępu do pliku przez <see langword="FileStream" /> obiekt. Określa również wartości zwracane przez <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu. <see cref="P:System.IO.FileStream.CanSeek" />jest <see langword="true" /> Jeśli<paramref name="path" /> określa plik dysku.</param>
        <param name="share">Stała określająca sposób, w jaki plik będzie współużytkowany przez procesy.</param>
        <param name="bufferSize">Wartość dodatnia <see cref="T:System.Int32" /> większa niż 0 wskazuje rozmiar buforu. Domyślny rozmiar buforu to 4096.</param>
        <param name="useAsync">Określa, czy ma być używane asynchroniczne operacje we/wy czy synchroniczne operacje we/wy. Należy jednak pamiętać, że podstawowy system operacyjny może nie obsługiwać asynchronicznych operacji we/wy, więc <see langword="true" />w przypadku określenia, uchwyt może być otwarty synchronicznie w zależności od platformy. Po otwarciu asynchronicznej <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> metody i <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> działają lepiej przy dużych operacjach odczytu i zapisu, ale mogą one być znacznie wolniejsze w przypadku małych odczytów lub zapisów. Jeśli aplikacja została zaprojektowana tak, aby korzystała z asynchronicznej operacji we <paramref name="useAsync" /> /wy <see langword="true" />, ustaw parametr na. Poprawne używanie operacji we/wy może przyspieszyć działanie aplikacji o ile nie jest to czynnik 10, ale bez konieczności ponownego projektowania aplikacji asynchronicznych operacji we/wy może zmniejszyć wydajność o tyle, ile wynosi 10.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy z określoną ścieżką, trybem tworzenia, uprawnieniem do odczytu/zapisu i udostępniania, rozmiarem buforu i stanem synchronicznym lub asynchronicznym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwami urządzeń, takimi\\jak "\\.\PHYSICALDRIVE0".  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path`nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni. Na przykład w zależności od systemu Ta klasa może uzyskać dostęp do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A>dotyczy `true` wszystkich<xref:System.IO.FileStream> obiektów, które hermetyzują pliki. Jeśli `path` wskazuje urządzenie, które nie obsługuje wyszukiwania <xref:System.IO.FileStream.CanSeek%2A> , właściwość w wyniku <xref:System.IO.FileStream> ma `false`wartość. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanSeek%2A>Zobacz.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak asynchronicznie zapisywać dane do pliku, a następnie sprawdzać poprawność zapisu danych. Obiekt jest tworzony w celu przekazywania informacji z wątku głównego `EndReadCallback` do metod i `EndWriteCallback`. `State`  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem (""), zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
—lub— 
 <paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" />jest ujemna lub równa zero.  
  
—lub— 
 <paramref name="mode" />, <paramref name="access" /> lub<paramref name="share" /> zawierają nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="mode" /> , takiego jak when <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, i plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Błąd we/wy, taki jak określenie <see langword="FileMode.CreateNew" /> , kiedy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  
  
—lub— 
System działa w systemie Windows 98 lub Windows 98 Second Edition i <paramref name="share" /> ma <see langword="FileShare.Delete" />ustawioną wartość.  
  
—lub— 
Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> <paramref name="path" /> <see langword="ReadWrite" /> <see langword="Write" /> Żądany system operacyjny nie jest dozwolony dla danego elementu, na przykład gdy jest lub, a plik lub katalog jest ustawiony na dostęp tylko do odczytu. <paramref name="access" /></exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="T:System.IO.File" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, który <see langword="FileStream" /> będzie hermetyzowany bieżący obiekt.</param>
        <param name="mode">Stała określająca sposób otwierania lub tworzenia pliku.</param>
        <param name="access">Stała określająca sposób dostępu do pliku przez <see langword="FileStream" /> obiekt. Określa również wartości zwracane przez <see cref="P:System.IO.FileStream.CanRead" /> właściwości <see langword="FileStream" /> i <see cref="P:System.IO.FileStream.CanWrite" /> obiektu. <see cref="P:System.IO.FileStream.CanSeek" />jest <see langword="true" /> Jeśli<paramref name="path" /> określa plik dysku.</param>
        <param name="share">Stała określająca sposób, w jaki plik będzie współużytkowany przez procesy.</param>
        <param name="bufferSize">Wartość dodatnia <see cref="T:System.Int32" /> większa niż 0 wskazuje rozmiar buforu. Domyślny rozmiar buforu to 4096.</param>
        <param name="options">Wartość, która określa dodatkowe opcje plików.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy z określoną ścieżką, trybem tworzenia, uprawnieniem do odczytu/zapisu i udostępniania, dostęp innych FILESTREAM może mieć taki sam plik, rozmiar buforu i dodatkowe opcje plików.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwami urządzeń, takimi\\jak "\\.\PHYSICALDRIVE0".  
  
 Ten `fileOptions` parametr służy do zapewnienia dostępu do bardziej zaawansowanych operacji, których można użyć podczas <xref:System.IO.FileStream> tworzenia obiektu.  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path`nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni. Na przykład w zależności od systemu Ta klasa może uzyskać dostęp do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A>dotyczy `true` wszystkich<xref:System.IO.FileStream> obiektów, które hermetyzują pliki. Jeśli `path` wskazuje urządzenie, które nie obsługuje wyszukiwania <xref:System.IO.FileStream.CanSeek%2A> , właściwość w wyniku <xref:System.IO.FileStream> ma `false`wartość. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanSeek%2A>Zobacz.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zapisuje dane do pliku, a następnie odczytuje dane przy użyciu <xref:System.IO.FileStream> obiektu.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem (""), zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
—lub— 
 <paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" />jest ujemna lub równa zero.  
  
—lub— 
 <paramref name="mode" />, <paramref name="access" /> lub<paramref name="share" /> zawierają nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="mode" /> , takiego jak when <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, i plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Błąd we/wy, taki jak określenie <see langword="FileMode.CreateNew" /> , kiedy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  
  
—lub— 
Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> <paramref name="path" /> <see langword="ReadWrite" /> <see langword="Write" /> Żądany system operacyjny nie jest dozwolony dla danego elementu, na przykład gdy jest lub, a plik lub katalog jest ustawiony na dostęp tylko do odczytu. <paramref name="access" />  
  
—lub— 
 <see cref="F:System.IO.FileOptions.Encrypted" />jest określony dla <paramref name="options" />, ale szyfrowanie plików nie jest obsługiwane na bieżącej platformie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, który <see cref="T:System.IO.FileStream" /> będzie hermetyzowany bieżący obiekt.</param>
        <param name="mode">Stała określająca sposób otwierania lub tworzenia pliku.</param>
        <param name="rights">Stała określająca prawa dostępu do użycia podczas tworzenia reguł dostępu i inspekcji dla pliku.</param>
        <param name="share">Stała określająca sposób, w jaki plik będzie współużytkowany przez procesy.</param>
        <param name="bufferSize">Wartość dodatnia <see cref="T:System.Int32" /> większa niż 0 wskazuje rozmiar buforu. Domyślny rozmiar buforu to 4096.</param>
        <param name="options">Stała, która określa dodatkowe opcje plików.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy z określoną ścieżką, trybem tworzenia, prawami dostępu i uprawnieniem do udostępniania, rozmiarem buforu i dodatkowymi opcjami plików.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwami urządzeń, takimi\\jak "\\.\PHYSICALDRIVE0".  
  
 Użyj tego <xref:System.IO.FileStream.%23ctor%2A> konstruktora, aby zastosować prawa dostępu w momencie tworzenia pliku. Aby uzyskać dostęp do lub zmodyfikować prawa do istniejącego pliku, należy rozważyć <xref:System.IO.File.GetAccessControl%2A> użycie <xref:System.IO.File.SetAccessControl%2A> metod i.  
  
 Ten `fileOptions` parametr służy do zapewnienia dostępu do bardziej zaawansowanych operacji, których można użyć podczas <xref:System.IO.FileStream> tworzenia obiektu.  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path`nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni. Na przykład w zależności od systemu Ta klasa może uzyskać dostęp do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A>dotyczy `true` wszystkich<xref:System.IO.FileStream> obiektów, które hermetyzują pliki. Jeśli `path` wskazuje urządzenie, które nie obsługuje wyszukiwania <xref:System.IO.FileStream.CanSeek%2A> , właściwość w wyniku <xref:System.IO.FileStream> ma `false`wartość. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanSeek%2A>Zobacz.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem (""), zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
—lub— 
 <paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" />jest ujemna lub równa zero.  
  
—lub— 
 <paramref name="mode" />, <paramref name="access" /> lub<paramref name="share" /> zawierają nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="mode" /> , takiego jak when <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, i plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows NT lub nowszym.</exception>
        <exception cref="T:System.IO.IOException">Błąd we/wy, taki jak określenie <see langword="FileMode.CreateNew" /> , kiedy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  
  
—lub— 
Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> <paramref name="path" /> <see langword="ReadWrite" /> <see langword="Write" /> Żądany system operacyjny nie jest dozwolony dla danego elementu, na przykład gdy jest lub, a plik lub katalog jest ustawiony na dostęp tylko do odczytu. <paramref name="access" />  
  
—lub— 
 <see cref="F:System.IO.FileOptions.Encrypted" />jest określony dla <paramref name="options" />, ale szyfrowanie plików nie jest obsługiwane na bieżącej platformie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona <paramref name="path" />nazwa pliku lub obie te wartości przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna dla pliku, który <see cref="T:System.IO.FileStream" /> będzie hermetyzowany bieżący obiekt.</param>
        <param name="mode">Stała określająca sposób otwierania lub tworzenia pliku.</param>
        <param name="rights">Stała określająca prawa dostępu do użycia podczas tworzenia reguł dostępu i inspekcji dla pliku.</param>
        <param name="share">Stała określająca sposób, w jaki plik będzie współużytkowany przez procesy.</param>
        <param name="bufferSize">Wartość dodatnia <see cref="T:System.Int32" /> większa niż 0 wskazuje rozmiar buforu. Domyślny rozmiar buforu to 4096.</param>
        <param name="options">Stała, która określa dodatkowe opcje plików.</param>
        <param name="fileSecurity">Stała określająca kontrolę dostępu i zabezpieczenia inspekcji dla pliku.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileStream" /> klasy z określoną ścieżką, trybem tworzenia, prawami dostępu i uprawnieniami do udostępniania, rozmiarem buforu, dodatkowymi opcjami plików, kontrolą dostępu i zabezpieczeniami inspekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwami urządzeń, takimi\\jak "\\.\PHYSICALDRIVE0".  
  
 Użyj tego <xref:System.IO.FileStream.%23ctor%2A> konstruktora, aby zastosować prawa dostępu w momencie tworzenia pliku. Aby uzyskać dostęp do lub zmodyfikować prawa do istniejącego pliku, należy rozważyć <xref:System.IO.File.GetAccessControl%2A> użycie <xref:System.IO.File.SetAccessControl%2A> metod i.  
  
 Ten `fileOptions` parametr służy do zapewnienia dostępu do bardziej zaawansowanych operacji, których można użyć podczas <xref:System.IO.FileStream> tworzenia obiektu.  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path`nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni. Na przykład w zależności od systemu Ta klasa może uzyskać dostęp do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A>dotyczy `true` wszystkich<xref:System.IO.FileStream> obiektów, które hermetyzują pliki. Jeśli `path` wskazuje urządzenie, które nie obsługuje wyszukiwania <xref:System.IO.FileStream.CanSeek%2A> , właściwość w wyniku <xref:System.IO.FileStream> ma `false`wartość. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanSeek%2A>Zobacz.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zapisuje dane do pliku, a następnie odczytuje dane przy użyciu <xref:System.IO.FileStream> obiektu.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem (""), zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
—lub— 
 <paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />odnosi się do urządzenia niebędącego plikiem, takiego jak "con:", "COM1:", "LPT1:" itp. w środowisku innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" />jest ujemna lub równa zero.  
  
—lub— 
 <paramref name="mode" />, <paramref name="access" /> lub<paramref name="share" /> zawierają nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku <paramref name="mode" /> , takiego jak when <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, i plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Błąd we/wy, taki jak określenie <see langword="FileMode.CreateNew" /> , kiedy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  
  
—lub— 
Strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> <paramref name="path" /> <see langword="ReadWrite" /> <see langword="Write" /> Żądany system operacyjny nie jest dozwolony dla danego elementu, na przykład gdy jest lub, a plik lub katalog jest ustawiony na dostęp tylko do odczytu. <paramref name="access" />  
  
—lub— 
 <see cref="F:System.IO.FileOptions.Encrypted" />jest określony dla <paramref name="options" />, ale szyfrowanie plików nie jest obsługiwane na bieżącej platformie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona <paramref name="path" />nazwa pliku lub obie te wartości przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows NT lub nowszym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania, zapisywania i dołączania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, callback, state)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netcore-2.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">Bufor, do którego mają zostać odczytane dane.</param>
        <param name="buffer">Bufor, do którego mają zostać odczytane dane.</param>
        <param name="offset">Przesunięcie bajtu w <paramref name="array" /> czasie, w którym ma zostać rozpoczęte odczytywanie.</param>
        <param name="numBytes">Maksymalna liczba bajtów do odczytania.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu asynchronicznej operacji odczytu.</param>
        <param name="userCallback">Metoda, która ma być wywoływana po zakończeniu asynchronicznej operacji odczytu.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie odczytu z innych żądań.</param>
        <param name="stateObject">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie odczytu z innych żądań.</param>
        <summary>Rozpoczęcie asynchronicznej operacji odczytu. Rozważ użycie <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast tego.</summary>
        <returns>Obiekt, który odwołuje się do odczytu asynchronicznego.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Długość tablicy minus <paramref name="offset" /> jest mniejsza niż <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="numBytes" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Podjęto próbę odczytu asynchronicznego poza końcem pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, callback, state)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netcore-2.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">Bufor zawierający dane do zapisu w bieżącym strumieniu.</param>
        <param name="buffer">Bufor zawierający dane do zapisu w bieżącym strumieniu.</param>
        <param name="offset">Przesunięcie bajtu (liczony od zera <paramref name="array" /> ), w którym rozpocznie się kopiowanie bajtów do bieżącego strumienia.</param>
        <param name="numBytes">Maksymalna liczba bajtów do zapisania.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu asynchronicznej operacji zapisu.</param>
        <param name="userCallback">Metoda, która ma być wywoływana po zakończeniu asynchronicznej operacji zapisu.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie zapisu z innych żądań.</param>
        <param name="stateObject">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie zapisu z innych żądań.</param>
        <summary>Rozpoczyna asynchroniczne operacje zapisu. Rozważ użycie <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast tego.</summary>
        <returns>Obiekt, który odwołuje się do zapisu asynchronicznego.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="array" />Długość minus <paramref name="offset" /> jest mniejsza niż <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="numBytes" /> jest ujemna.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje odczytywanie.</summary>
        <value><see langword="true" />Jeśli strumień obsługuje odczytywanie; <see langword="false" /> Jeśli strumień jest zamknięty lub został otwarty z dostępem tylko do zapisu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> Jeśli klasa pochodna nie obsługuje odczytywania, wywołania <xref:System.NotSupportedException> <xref:System.IO.FileStream.Read%2A>metod, <xref:System.IO.FileStream.ReadByte%2A>i <xref:System.IO.FileStream.BeginRead%2A> .  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie `CanRead` właściwości. Danymi wyjściowymi tego kodu jest "plik. txt nie jest możliwy do zapisu". Aby uzyskać komunikat wyjściowy "plik. txt może być zarówno zapisany w, jak i odczytywany.", Zmień `FileAccess` parametr na `ReadWrite` w `FileStream` konstruktorze.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje wyszukiwanie.</summary>
        <value><see langword="true" />Jeśli strumień obsługuje wyszukiwanie; Jeśli strumień jest zamknięty lub <see langword="FileStream" /> jeśli został skonstruowany z dojścia systemu operacyjnego, takiego jak potok lub dane wyjściowe do konsoli. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> Jeśli klasa pochodna nie obsługuje wyszukiwania, wywołania do <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A> <xref:System.IO.FileStream.Position%2A>, i <xref:System.IO.FileStream.Seek%2A> throw <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład używa właściwości, `CanSeek` aby sprawdzić, czy strumień obsługuje wyszukiwanie.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje zapisywanie.</summary>
        <value><see langword="true" />Jeśli strumień obsługuje zapis; <see langword="false" /> Jeśli strumień jest zamknięty lub został otwarty z dostępem tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> Jeśli klasa pochodna nie obsługuje pisania, wywołanie do <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A> <xref:System.IO.FileStream.BeginWrite%2A>,, lub <xref:System.IO.FileStream.WriteByte%2A> zgłasza <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład używa właściwości, `CanWrite` aby sprawdzić, czy strumień obsługuje zapisywanie.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 Poniżej przedstawiono przykład użycia `CanWrite` właściwości. Danymi wyjściowymi tego kodu jest "plik. txt jest możliwy do zapisu". Aby uzyskać komunikat wyjściowy "plik. txt może być zarówno zapisany w, jak i odczytywany.", Zmień `FileAccess` parametr na `ReadWrite` w `FileStream` konstruktorze.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżący strumień i zwalnia wszystkie zasoby (takie jak gniazda i uchwyty plików) skojarzone z bieżącym strumieniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Aby <xref:System.IO.Stream.Close?displayProperty=nameWithType> uzyskać więcej informacji na temat tej metody, zobacz.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostanie skopiowana zawartość bieżącego strumienia plików.</param>
        <param name="bufferSize">Rozmiar bufora (w bajtach). Ta wartość musi być większa od zera. Domyślny rozmiar to 81920.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie odczytuje bajty z bieżącego strumienia plików i zapisuje je w innym strumieniu przy użyciu określonego rozmiaru buforu i tokenu anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację kopiowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`CopyToAsync` Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.

Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> wartość <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> właściwości.

Kopiowanie rozpoczyna się od bieżącego położenia w bieżącym strumieniu pliku.

Aby zapoznać się z przykładem kopiowania między dwoma strumieniami <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> , zapoznaj się z przeciążeniem.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.IO.FileStream" /> program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A> i metodę. <xref:System.ComponentModel.Component.Dispose%2A>wywołuje metodę chronioną <xref:System.IO.FileStream.Dispose%2A> `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje <xref:System.IO.FileStream.Dispose%2A> `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.IO.FileStream> których odwołują się te odwołania. `disposing` Ta metoda wywołuje <xref:System.ComponentModel.Component.Dispose%2A> metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" />może być wywoływana wiele razy przez inne obiekty. W przypadku <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> przesłaniania należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały <see cref="M:System.ComponentModel.Component.Dispose" />wcześniej usunięte w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see cref="M:System.ComponentModel.Component.Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie zwalnia niezarządzane zasoby używane przez <see cref="T:System.IO.FileStream" />.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację Dispose.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`DisposeAsync` Metoda umożliwia wykonywanie operacji Dispose intensywnie korzystających z zasobów bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.

Ta metoda usuwa strumień przez zapisanie zmian w magazynie zapasowym i zamknięcie strumienia w celu zwolnienia zasobów.

Wywołanie `DisposeAsync` zezwala na przydzielenie zasobów używanych <xref:System.IO.FileStream> przez program do innych celów. Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekującego żądania asynchronicznego oczekiwania.</param>
        <summary>Czeka na zakończenie oczekującej asynchronicznej operacji odczytu. (Rozważ użycie <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast niego).</summary>
        <returns>Liczba bajtów odczytanych ze strumienia, z zakresu od 0 do liczby żądanych bajtów. Strumienie zwracają tylko 0 na końcu strumienia, w przeciwnym razie powinny być blokowane do momentu, gdy jest dostępny co najmniej 1 bajt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework 4 i starszych wersjach trzeba użyć metod, takich jak <xref:System.IO.FileStream.BeginRead%2A> i <xref:System.IO.FileStream.EndRead%2A> , aby zaimplementować asynchroniczne operacje na plikach. Te metody są nadal dostępne w programie [!INCLUDE[net_v45](~/includes/net-v45-md.md)] , aby obsługiwały starszy kod, jednak nowe metody asynchroniczne, takie jak <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A>, ułatwiają wdrażanie asynchronicznych operacji na plikach.  
  
 <xref:System.IO.FileStream.EndRead%2A>musi być wywoływana dokładnie dla każdego wywołania do <xref:System.IO.FileStream.BeginRead%2A>. Zakończenie procesu odczytu nie powiedzie się przed rozpoczęciem innego odczytu może spowodować niepożądane zachowanie, takie jak zakleszczenie.  
  
 Ta metoda przesłania <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A>może być wywoływana dla każdego <xref:System.IAsyncResult> z <xref:System.IO.FileStream.BeginRead%2A>. Wywołanie <xref:System.IO.FileStream.EndRead%2A> informuje o liczbie bajtów odczytanych ze strumienia. <xref:System.IO.FileStream.EndRead%2A>zostanie zablokowany do momentu zakończenia operacji we/wy.  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ten <see cref="T:System.IAsyncResult" /> obiekt nie został utworzony przez wywołanie <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> tej klasy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />jest wywoływana wiele razy.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">Asynchroniczne We/Wy pliku</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące asynchroniczne żądanie we/wy.</param>
        <summary>Kończy asynchroniczne operacje zapisu i bloki do momentu zakończenia operacji we/wy. (Rozważ użycie <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast niego).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework 4 i starszych wersjach trzeba użyć metod, takich jak <xref:System.IO.FileStream.BeginWrite%2A> i <xref:System.IO.FileStream.EndWrite%2A> , aby zaimplementować asynchroniczne operacje na plikach. Te metody są nadal dostępne w programie [!INCLUDE[net_v45](~/includes/net-v45-md.md)] , aby obsługiwały starszy kod, jednak nowe metody asynchroniczne, takie jak <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A>, ułatwiają wdrażanie asynchronicznych operacji na plikach.  
  
 Ta metoda przesłania <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A>musi być wywoływana dokładnie raz w każdym <xref:System.IAsyncResult> z <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A>zostanie zablokowany do momentu zakończenia operacji we/wy.  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ten <see cref="T:System.IAsyncResult" /> obiekt nie został utworzony przez wywołanie <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> tej klasy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />jest wywoływana wiele razy.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">Asynchroniczne We/Wy pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że zasoby są zwolnione i inne operacje czyszczenia są wykonywane, gdy moduł zbierający <see langword="FileStream" />elementy bezużyteczne odzyskuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł zbierający elementy `Finalize` bezużyteczne wywołuje, kiedy bieżący obiekt jest gotowy do sfinalizowania. `Finalize``FileStream`zamyka.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Po wywołaniu <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> metody bufor we/wy systemu operacyjnego jest również opróżniany.  
  
 Koder strumienia nie jest opróżniany, chyba że jawnie wywołuje <xref:System.IO.FileStream.Flush%2A> lub usuwa obiekt. Ustawienie <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> oznacza, że dane zostaną opróżnione z bufora do strumienia, ale stan kodera nie zostanie opróżniony. `true` Dzięki temu koder może zachować swój stan (częściowe znaki), aby można było poprawnie zakodować następny blok znaków. Ten scenariusz ma wpływ na kodowanie UTF8 i UTF7, gdzie niektóre znaki mogą być kodowane tylko po odebraniu sąsiadujących znaków.  
  
 Ponieważ bufor może być używany do odczytu lub zapisu, program <xref:System.IO.FileStream.Flush> wykonuje następujące dwie funkcje:  
  
-   Wszystkie dane wcześniej zapisywane w buforze są kopiowane do pliku, a bufor jest wyczyszczony z wyjątkiem stanu kodera.  
  
-   Jeśli <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> jest`true` i dane zostały wcześniej skopiowane z pliku do bufora do odczytu, bieżąca pozycja w pliku jest zmniejszana o liczbę nieprzeczytanych bajtów w buforze. Bufor zostanie wyczyszczony.  
  
 Użyj przeciążenia <xref:System.IO.FileStream.Flush%28System.Boolean%29> metody, aby upewnić się, że wszystkie dane buforowane w buforach plików pośrednich są zapisywane na dysku.  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.FileStream.Lock%2A> metody.  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień jest zamknięty.</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="flushToDisk"><see langword="true" />Aby opróżnić wszystkie pośrednie bufory plików; w przeciwnym razie. <see langword="false" /></param>
        <summary>Czyści bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku, a także czyści wszystkie pośrednie bufory plików.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby upewnić się, że wszystkie dane buforowane w buforach plików pośrednich są zapisywane na dysku.  
  
 Po wywołaniu <xref:System.IO.FileStream.Flush%2A> metody bufor we/wy systemu operacyjnego jest również opróżniany.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie czyści wszystkie bufory dla tego strumienia, powoduje, że wszystkie buforowane dane są zapisywane na podstawowym urządzeniu i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację opróżniania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości. Jeśli dojście do pliku zostanie usunięte, zwrócone zadanie zawiera <xref:System.ObjectDisposedException> wyjątek <xref:System.Threading.Tasks.Task.Exception%2A> we właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Anulowanie</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt, który hermetyzuje wpisy listy kontroli dostępu (ACL) dla pliku opisanego przez bieżący <see cref="T:System.IO.FileStream" /> obiekt. <see cref="T:System.Security.AccessControl.FileSecurity" /></summary>
        <returns>Obiekt, który hermetyzuje ustawienia kontroli dostępu dla pliku opisanego przez bieżący <see cref="T:System.IO.FileStream" /> obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas gdy <xref:System.IO.FileStream.GetAccessControl%2A>Klasai może służyć do pobierania wpisów listy kontroli dostępu (ACL) istniejącego pliku, należy rozważyć użycie <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> metody, ponieważ jest to łatwiejsze w użyciu. <xref:System.IO.FileStream>  
  
 <xref:System.IO.FileStream.GetAccessControl%2A> Użyj metody, aby pobrać wpisy listy ACL dla pliku.  
  
 Lista ACL opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych działań w danym pliku. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Plik jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście do pliku systemu operacyjnego dla pliku, który jest <see langword="FileStream" /> hermetyzowany z bieżącym obiektem.</summary>
        <value>Dojście do pliku systemu operacyjnego dla pliku hermetyzowane przez ten <see langword="FileStream" /> obiekt lub-1, <see langword="FileStream" /> jeśli zostało zamknięte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość to dojście systemu operacyjnego do użycia z wywołaniami systemowymi udostępnianymi przez system operacyjny ( `ReadFile` na przykład w systemie Windows). Nie będzie działać z funkcjami biblioteki języka C, które oczekują deskryptora pliku, `fread`na przykład.  
  
 Dojście systemu operacyjnego mogło zostać otwarte synchronicznie lub asynchronicznie, w zależności od tego `FileStream` , który Konstruktor został wywołany. Użyj właściwości <xref:System.IO.FileStream.IsAsync%2A> , aby stwierdzić, czy to dojście zostało otwarte asynchronicznie. W systemie Win32 oznacza to, że dojście zostało otwarte dla nakładających się operacji we/wy i `ReadFile` wymaga `WriteFile`innych parametrów do i.  
  
> [!CAUTION]
>  Uszkodzenie danych może wystąpić, gdy `FileStream` zostanie utworzony, jego uchwyt zostanie przesunięty, a `FileStream` następnie przesunie wskaźnik pliku dojścia, a następnie zostanie użyty ponownie. Wiele wątków nie może bezpiecznie zapisywać jednocześnie w tym samym pliku, `FileStream` a buforowanie kodu zakłada, że tylko kontroluje dojście. `FileStream`może zgłosić <xref:System.IO.IOException> , jeśli `FileStream` wykryje, że jakiś inny proces przeniósł wskaźnik pliku. Aby tego uniknąć, nie należy zapisywać żadnych danych w części pliku, który `FileStream` może być zbuforowany, i przywrócić wskaźnik pliku do lokalizacji, w `FileStream`której zostały ostatnio wywołane metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwość uzyskania dostępu do kodu niezarządzanego. Skojarzone Wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see langword="FileStream" /> została otwarta asynchronicznie czy synchronicznie.</summary>
        <value><see langword="true" />Jeśli został otwarty asynchronicznie; w przeciwnym <see langword="false" />razie,. <see langword="FileStream" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość wykrywa, `FileStream` czy dojście zostało otwarte asynchronicznie, co pozwala na prawidłowe użycie <xref:System.IO.FileStream.Handle%2A> właściwości. `IsAsync` W systemie Win32 `IsAsync` wartość true oznacza, że dojście zostało otwarte dla nakładających się operacji we/wy i w związku `ReadFile` z `WriteFile`tym wymaga innych parametrów do i.  
  
 Ta wartość jest <xref:System.IO.FileStream> określana podczas tworzenia wystąpienia klasy przy użyciu konstruktora, który `isAsync`ma parametr, `useAsync`lub `options` . Gdy właściwość ma `true`wartość, strumień wykorzystuje nakładające się operacje we/wy na asynchroniczne wykonywanie operacji na plikach. `true` <xref:System.IO.FileStream.ReadAsync%2A> <xref:System.IO.FileStream.WriteAsync%2A>Jednak właściwość nie musi być wywołanie metody,, lub <xref:System.IO.Stream.CopyToAsync%2A>. <xref:System.IO.FileStream.IsAsync%2A> Gdy właściwość jest `false` i wywołuje asynchroniczne operacje odczytu i zapisu, wątek interfejsu użytkownika nadal nie jest blokowany, ale rzeczywista operacja we/wy jest wykonywana synchronicznie. <xref:System.IO.FileStream.IsAsync%2A>  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość w bajtach strumienia.</summary>
        <value>Długa wartość reprezentująca długość strumienia w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano `Length` właściwości `Position` i, aby sprawdzić warunek końca pliku.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="P:System.IO.FileStream.CanSeek" />dla tego strumienia jest <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, taki jak zamykany plik.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">Początek zakresu do zablokowania. Wartość tego parametru musi być równa lub większa od zera (0).</param>
        <param name="length">Zakres, który ma być zablokowany.</param>
        <summary>Uniemożliwia innym procesom odczytywanie z lub zapisywanie do <see cref="T:System.IO.FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zablokowanie zakresu strumienia plików zapewnia wątki procesu blokowania wyłącznego dostępu do tego zakresu strumienia plików.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak zablokować część pliku, aby inny proces nie mógł uzyskać dostępu do tej części pliku, nawet jeśli ma dostęp do odczytu/zapisu do pliku. Uruchom program jednocześnie w różnych oknach poleceń i zbadaj przy użyciu różnych opcji wprowadzania konsoli.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" />lub <paramref name="length" /> jest ujemna.</exception>
        <exception cref="T:System.ObjectDisposedException">Plik jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Proces nie może uzyskać dostępu do pliku, ponieważ inny proces zablokował część pliku.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bezwzględną ścieżkę pliku otwartego w <see langword="FileStream" />.</summary>
        <value>Ciąg, który jest ścieżką bezwzględną pliku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Jeśli ścieżka bezwzględna jest nieznana, ta właściwość zwraca ciąg podobny do "[nieznany]".

 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do ścieżki. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą pozycję tego strumienia.</summary>
        <value>Bieżąca pozycja tego strumienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie w dowolnej lokalizacji poza długością strumienia jest obsługiwane.  Podczas wyszukiwania poza długością pliku rozmiar pliku rośnie.  W systemie Microsoft Windows NT i nowszych dowolnych danych dodawanych na końcu pliku jest ustawiona na zero.  W systemie Microsoft Windows 98 lub starszym wszystkie dane dodane na końcu pliku nie są ustawione na zero, co oznacza, że wcześniej usunięte dane są widoczne dla strumienia. Ustawienie pozycji strumienia do dużej wartości poza końcem strumienia w systemie Windows 98 lub starszym może spowodować wystąpienie wyjątku.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano `Length` właściwości `Position` i, aby sprawdzić warunek końca pliku.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje operacji wyszukiwania.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.  
  
—lub—
  
 Pozycja została ustawiona na bardzo dużą wartość poza końcem strumienia w systemie Windows 98 lub starszym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Podjęto próbę ustawienia wartości ujemnej na pozycji.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Podjęto próbę wyszukiwania poza końcem strumienia, który nie obsługuje tego elementu.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="fileStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Region pamięci. Gdy ta metoda zwraca, zawartość tego regionu jest zastępowana przez Bajty odczytane z bieżącego strumienia pliku.</param>
        <summary>Odczytuje sekwencję bajtów z bieżącego strumienia plików i postępuje zgodnie z pozycją w strumieniu pliku przez liczbę odczytanych bajtów.</summary>
        <returns>Całkowita liczba bajtów odczytywanych w buforze. Wartość ta może być mniejsza niż liczba bajtów przypadających w buforze, jeśli wiele bajtów nie jest obecnie dostępna lub zero (0), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.IO.FileStream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie. Użyj metody <xref:System.IO.FileStream.ReadAsync%2A> , aby odczytywać asynchronicznie z bieżącego strumienia.

Ta metoda odczytuje maksymalnie `buffer.Length` bajtów z bieżącego strumienia plików i zapisuje je w. `buffer` Bieżąca pozycja w strumieniu pliku jest zaawansowana przez liczbę odczytanych bajtów; Jeśli jednak wystąpi wyjątek, bieżąca pozycja w strumieniu pliku pozostaje niezmieniona. Metoda zostanie Zablokowani do momentu odczytania co najmniej jednego bajtu danych, w przypadku, gdy żadne dane nie są dostępne. `Read`Zwraca wartość 0 tylko wtedy, gdy nie ma więcej danych w strumieniu pliku i nie ma więcej oczekiwanych (takich jak zamknięte gniazdo lub koniec pliku). Metoda jest bezpłatna, aby zwrócić mniejszą liczbę bajtów niż żądana, nawet jeśli nie osiągnięto końca strumienia pliku.

Służy <xref:System.IO.BinaryReader> do odczytywania typów danych pierwotnych.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Gdy ta metoda zwraca, zawiera określoną tablicę bajtową z wartościami między <paramref name="offset" /> i (<paramref name="offset" />  +  <paramref name="count" /> -1<c>)</c> zastąpione przez Bajty odczytane z bieżącego źródła.</param>
        <param name="offset">Przesunięcie bajtu w <paramref name="array" /> czasie, w którym zostaną umieszczone bajty odczytu.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <summary>Odczytuje blok bajtów ze strumienia i zapisuje dane w danym buforze.</summary>
        <returns>Całkowita liczba bajtów odczytywanych w buforze. Może to być mniejsze niż liczba bajtów żądana, jeśli liczba bajtów jest obecnie niedostępna lub zero, jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.IO.Stream.Read%2A>.  
  
 Parametr przekazuje przesunięcie `array` bajtu (indeks buforu), od którego ma się `count` zacząć odczytywanie, a parametr daje maksymalną liczbę bajtów, które mają być odczytane z tego strumienia. `offset` Zwracana wartość to rzeczywista liczba odczytanych bajtów lub zero, jeśli osiągnięto koniec strumienia. Jeśli operacja odczytu zakończy się pomyślnie, bieżąca pozycja strumienia jest zaawansowana przez liczbę odczytanych bajtów. Jeśli wystąpi wyjątek, bieżąca pozycja strumienia nie jest zmieniana.  
  
 <xref:System.IO.FileStream.Read%2A> Metoda zwraca zero tylko po osiągnięciu końca strumienia. W przeciwnym razie zawsze odczytuje co najmniej jeden bajt ze strumienia przed zwróceniem. <xref:System.IO.FileStream.Read%2A> Jeśli nie są dostępne żadne dane ze strumienia po wywołaniu <xref:System.IO.FileStream.Read%2A>metody, Metoda zostanie zablokowana do momentu zwrócenia co najmniej jednego bajtu danych. Implementacja może zwrócić mniejszą liczbę bajtów niż żądana, nawet jeśli koniec strumienia nie został osiągnięty.  
  
 Służy <xref:System.IO.BinaryReader> do odczytywania typów danych pierwotnych.  
  
 Nie przerywaj wątku wykonującego operację odczytu. Mimo że aplikacja może być uruchamiana pomyślnie po odblokowaniu wątku, przerwanie może obniżyć wydajność i niezawodność aplikacji.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład odczytuje zawartość z <xref:System.IO.FileStream> i zapisuje ją w innej. <xref:System.IO.FileStream>  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytywania.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />i <paramref name="count" /> opisz nieprawidłowy zakres w <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, w którym mają zostać zapisane dane.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie odczytuje sekwencję bajtów z bieżącego strumienia plików i zapisuje je w regionie pamięci, przesuwa pozycję w strumieniu pliku o liczbę odczytanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu i otacza całkowitą liczbę bajtów odczytywanych w buforze. Wartość wynikowa może być mniejsza niż liczba żądanych bajtów, jeśli liczba aktualnie dostępnych bajtów jest mniejsza niż żądana liczba, lub może być równa 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Metoda `ReadAsync` ta umożliwia wykonywanie operacji na plikach intensywnie korzystających z zasobów bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.

<xref:System.IO.FileStream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie.

Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> wartość <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithtype> właściwości. Jeśli dojście do pliku zostanie usunięte, zwrócone zadanie zawiera <xref:System.ObjectDisposedException> wyjątek <xref:System.Threading.Tasks.Task.Exception?displayProperty=nameWithType> we właściwości.

## Examples

Poniższy przykład pokazuje, jak odczytywać asynchronicznie z pliku.  

[!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
[!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, w którym mają zostać zapisane dane.</param>
        <param name="offset">Przesunięcie bajtu, <paramref name="buffer" /> w którym rozpocznie się zapisywanie danych ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie odczytuje sekwencję bajtów z bieżącego strumienia plików i zapisuje je w tablicy bajtów Zaczynając od określonego przesunięcia, przesuwa pozycję w strumieniu pliku o liczbę odczytanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu i otacza całkowitą liczbę bajtów odczytywanych w buforze. Wartość wynikowa może być mniejsza niż liczba żądanych bajtów, jeśli liczba aktualnie dostępnych bajtów jest mniejsza niż żądana liczba, lub może być równa 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Metoda `ReadAsync` ta umożliwia wykonywanie operacji na plikach intensywnie korzystających z zasobów bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.

<xref:System.IO.FileStream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie.

Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> wartość <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> właściwości. Jeśli dojście do pliku zostanie usunięte, zwrócone zadanie zawiera <xref:System.ObjectDisposedException> wyjątek <xref:System.Threading.Tasks.Task.Exception?displayProperty=nameWithType> we właściwości.

## Examples

Poniższy przykład pokazuje, jak odczytywać asynchronicznie z pliku.

[!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
[!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i<paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację odczytu.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Anulowanie</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bajt z pliku i przesuwa pozycję Odczytaj o jeden bajt.</summary>
        <returns>Bajt, Rzutowanie na <see cref="T:System.Int32" />lub-1, jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  <xref:System.IO.FileStream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanRead%2A>Zobacz.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zapisywać dane do pliku, bajty przez bajty, a następnie sprawdzać poprawność zapisu danych.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżący strumień jest zamknięty.</exception>
        <block subset="none" type="overrides"><para>Domyślna implementacja w <see langword="Stream" /> programie tworzy nową tablicę jednobajtową, a następnie <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />wywołuje metodę. Chociaż jest to prawidłowe rozwiązanie, jest niewydajne. Każdy strumień z wewnętrznym buforem powinien przesłonić tę metodę i zapewnić znacznie bardziej wydajną wersję, która odczytuje bufor bezpośrednio, unikając dodatkowej alokacji tablicy dla każdego wywołania.  
  
Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który reprezentuje dojście do pliku systemu operacyjnego dla pliku, który jest <see cref="T:System.IO.FileStream" /> hermetyzowany bieżący obiekt. <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /></summary>
        <value>Obiekt, który reprezentuje dojście do pliku systemu operacyjnego dla pliku, który jest <see cref="T:System.IO.FileStream" /> hermetyzowany przez bieżący obiekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.SafeFileHandle%2A> Właściwość automatycznie opróżnia strumień i ustawia bieżącą pozycję strumienia na 0.  Pozwala to na przeniesienie pliku lub zmianę położenia strumienia przez inny strumień przy użyciu <xref:System.IO.FileStream.SafeFileHandle%2A> zwróconego przez tę właściwość.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego.  
  
Akcja zabezpieczeń: Żądanie linku 
Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Punkt odnoszący <paramref name="origin" /> się do, od którego należy zacząć odszukać.</param>
        <param name="origin">Określa początek, koniec lub bieżącą pozycję jako punkt odniesienia dla <paramref name="offset" />, przy użyciu wartości typu. <see cref="T:System.IO.SeekOrigin" /></param>
        <summary>Ustawia bieżącą pozycję tego strumienia na daną wartość.</summary>
        <returns>Nowa pozycja w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje wyszukiwanie. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>Zobacz.  
  
 Możesz przejść do dowolnej lokalizacji poza długością strumienia. Podczas wyszukiwania poza długością pliku rozmiar pliku rośnie. W systemie Windows NT i nowszych wersjach dane dodane na końcu pliku są ustawione na zero. W systemie Windows 98 lub starszych wersjach dane dodane na końcu pliku nie są ustawione na zero, co oznacza, że wcześniej usunięte dane są widoczne dla strumienia.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zapisywać dane do pliku, bajty przez bajty, a następnie sprawdzać poprawność zapisu danych.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 Poniższy przykład odczytuje tekst w odwrotnym kierunku, od końca pliku do początku pliku, przy użyciu różnych <xref:System.IO.SeekOrigin> wartości <xref:System.IO.FileStream.Seek%2A> z metodą.  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje wyszukiwania, na przykład jeśli <see langword="FileStream" /> jest konstruowany z potoku lub danych wyjściowych konsoli.</exception>
        <exception cref="T:System.ArgumentException">Podjęto próbę wyszukiwania przed początkiem strumienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Obiekt opisujący wpis listy kontroli dostępu, który ma zostać zastosowany do bieżącego pliku.</param>
        <summary>Stosuje wpisy listy kontroli dostępu (ACL) opisane przez <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt do pliku opisanego przez bieżący <see cref="T:System.IO.FileStream" /> obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas gdy <xref:System.IO.FileStream.SetAccessControl%2A>Klasai może być używana w istniejącym <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> pliku, rozważ użycie metody, która jest łatwiejsza do użycia. <xref:System.IO.FileStream>  
  
 <xref:System.IO.FileStream.SetAccessControl%2A> Metoda stosuje wpisy listy kontroli dostępu (ACL) do pliku, który reprezentuje niedziedziczoną listę ACL.  
  
> [!CAUTION]
>  Lista ACL określona dla `fileSecurity` parametru zastępuje istniejącą listę ACL dla tego pliku. Aby dodać uprawnienia dla nowego użytkownika, użyj <xref:System.IO.FileStream.GetAccessControl%2A> metody w celu uzyskania istniejącej listy ACL, zmodyfikuj ją, a następnie użyj <xref:System.IO.FileStream.SetAccessControl%2A> do jej zastosowania z powrotem do pliku.  
  
 Lista ACL opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych działań w danym pliku. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Plik jest zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="fileSecurity" /></exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć lub zmodyfikować pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący proces nie ma dostępu do otwierania pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nowa długość strumienia.</param>
        <summary>Ustawia długość tego strumienia na daną wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.IO.Stream.SetLength%2A>.  
  
 Jeśli dana wartość jest mniejsza niż bieżąca długość strumienia, strumień zostanie obcięty. W tym scenariuszu, jeśli bieżąca pozycja jest większa niż nowa długość, bieżąca pozycja jest przenoszona do ostatniego bajtu strumienia. Jeśli dana wartość jest większa niż bieżąca długość strumienia, strumień jest rozwinięty, a bieżąca pozycja pozostaje taka sama. Jeśli strumień jest rozwinięty, zawartość strumienia między starą i nową długością nie jest zdefiniowana.  
  
 Strumień musi obsługiwać operacje pisania i wyszukiwania `SetLength` .  
  
> [!NOTE]
>  Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje pisanie, <xref:System.IO.FileStream.CanSeek%2A> i właściwość, aby określić, czy wyszukiwanie jest obsługiwane. <xref:System.IO.FileStream.CanWrite%2A> Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanWrite%2A> zobacz <xref:System.IO.Stream.CanSeek%2A>i.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje operacji pisania i wyszukiwania.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Podjęto próbę ustawienia <paramref name="value" /> wartości mniejszej niż 0.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">Początek zakresu do odblokowania.</param>
        <param name="length">Zakres, który ma zostać odblokowany.</param>
        <summary>Zezwala na dostęp przez inne procesy do całości lub części pliku, który został wcześniej zablokowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak zablokować część pliku, aby inny proces nie mógł uzyskać dostępu do tej części pliku, nawet jeśli ma dostęp do odczytu/zapisu do pliku, a następnie odblokowuje określoną część pliku. Uruchom program jednocześnie w różnych oknach poleceń i zbadaj przy użyciu różnych opcji wprowadzania konsoli.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" />lub <paramref name="length" /> jest ujemna.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="fileStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Region pamięci. Ta metoda kopiuje zawartość tego regionu do bieżącego strumienia pliku.</param>
        <summary>Zapisuje sekwencję bajtów z zakresu tylko do odczytu do bieżącego strumienia plików i postępuje bieżącą pozycję w tym strumieniu plików przez liczbę zapisanych bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.IO.FileStream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie. Użyj metody <xref:System.IO.FileStream.WriteAsync%2A> , aby zapisać asynchronicznie w bieżącym strumieniu.

W przypadku pomyślnego wykonania operacji zapisu pozycja w strumieniu pliku jest zapisywana przez liczbę zapisanych bajtów. Jeśli wystąpi wyjątek, pozycja w strumieniu pliku pozostaje niezmieniona.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Bufor zawierający dane do zapisu w strumieniu.</param>
        <param name="offset">Przesunięcie bajtu (liczony <paramref name="array" /> od zera), od którego należy rozpocząć kopiowanie bajtów do strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Zapisuje blok bajtów w strumieniu pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.IO.Stream.Write%2A>.  
  
 Parametr przekazuje przesunięcie bajtu w `array` (indeks buforu), od którego ma się `count` zacząć kopiowanie, a parametr daje liczbę bajtów, które będą zapisywane w strumieniu. `offset` Jeśli operacja zapisu powiedzie się, bieżąca pozycja strumienia jest zaawansowana przez liczbę zapisanych bajtów. Jeśli wystąpi wyjątek, bieżąca pozycja strumienia nie jest zmieniana.  
  
> [!NOTE]
>  <xref:System.IO.FileStream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanWrite%2A>Zobacz.  
  
 Nie przerywaj wątku wykonującego operację zapisu. Mimo że aplikacja może być uruchamiana pomyślnie po odblokowaniu wątku, przerwanie może obniżyć wydajność i niezawodność aplikacji.  
  
 Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.FileStream.Lock%2A> metody.  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />i <paramref name="count" /> opisz nieprawidłowy zakres w <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.  
  
—lub—
  
 Inny wątek może być spowodowany nieoczekiwaną zmianą w położeniu dojścia do pliku systemu operacyjnego.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżące wystąpienie strumienia nie obsługuje zapisu.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Region pamięci, z której mają zostać zapisane dane.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie zapisuje sekwencję bajtów z regionu pamięci do bieżącego strumienia plików, przesuwa bieżącą pozycję w tym strumieniu plików o liczbę zapisanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`WriteAsync` Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.

<xref:System.IO.FileStream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.

Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> wartość <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> właściwości.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, z którego mają zostać zapisane dane.</param>
        <param name="offset">Przesunięcie bajtu (liczony <paramref name="buffer" /> od zera), od którego należy rozpocząć kopiowanie bajtów do strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie zapisuje sekwencję bajtów do bieżącego strumienia, przesuwa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.IO.FileStream.WriteAsync%2A> ta umożliwia wykonywanie operacji na plikach intensywnie korzystających z zasobów bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 <xref:System.IO.FileStream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.  
  
 Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości. Jeśli dojście do pliku zostanie usunięte, zwrócone zadanie zawiera <xref:System.ObjectDisposedException> wyjątek <xref:System.Threading.Tasks.Task.Exception%2A> we właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zapisywać asynchronicznie w pliku.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i<paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację zapisu.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Anulowanie</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Bajt do zapisu w strumieniu.</param>
        <summary>Zapisuje bajt w bieżącym położeniu w strumieniu pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.IO.Stream.WriteByte%2A>.  
  
 Użyj `WriteByte` do `FileStream` wydajnego napisania bajtów. Jeśli strumień jest zamknięty lub nie można go zapisać, zostanie zgłoszony wyjątek.  
  
> [!NOTE]
>  <xref:System.IO.FileStream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie. Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanWrite%2A>Zobacz.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zapisywać dane do pliku, bajty przez bajty, a następnie sprawdzać poprawność zapisu danych.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisu.</exception>
        <block subset="none" type="overrides"><para>Domyślna implementacja w <see langword="Stream" /> programie tworzy nową tablicę jednobajtową, a następnie <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />wywołuje metodę. Chociaż jest to prawidłowe rozwiązanie, jest niewydajne. Każdy strumień z wewnętrznym buforem powinien przesłonić tę metodę i zapewnić znacznie bardziej wydajną wersję, która odczytuje bufor bezpośrednio, unikając dodatkowej alokacji tablicy dla każdego wywołania.  
  
Aby uzyskać listę typowych operacji związanych z plikami i katalogami, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
  </Members>
</Type>
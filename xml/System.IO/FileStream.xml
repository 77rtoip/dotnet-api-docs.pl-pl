<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="58f5a4e086d522af21fb819b0d4270088ef151f8" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36298989" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia <see cref="T:System.IO.Stream" /> dla pliku, obsługa synchroniczne i asynchroniczne operacje odczytu i zapisu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileStream> klasy do odczytu, zapisu do otwierania i zamykania plików w systemie plików, a także do manipulowania inne uchwyty związany z plikami systemu operacyjnego, w tym potoków, standardowego wejścia i wyjścia standardowego. Można użyć <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, i <xref:System.IO.FileStream.Flush%2A> metod w celu wykonania operacji synchronicznych lub <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A> metody służące do wykonywania asynchronicznych operacje. Użycie metod asynchronicznych do wykonywania operacji na plikach obciąża bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. <xref:System.IO.FileStream> buforów danych wejściowych i wyjściowych w celu poprawy wydajności.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 <xref:System.IO.FileStream.IsAsync%2A> Właściwość wykrywa, czy dojście do pliku zostało otwarte asynchronicznie. Tę wartość można określić podczas tworzenia wystąpienia <xref:System.IO.FileStream> przy użyciu konstruktora, który ma `isAsync`, `useAsync`, lub `options` parametru. Gdy ta właściwość jest `true`, strumienia wykorzystuje pokrywającej się z inną operacji We/Wy do wykonywania operacji na plikach asynchronicznie. Jednak <xref:System.IO.FileStream.IsAsync%2A> właściwość nie ma być `true` do wywołania <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, lub <xref:System.IO.Stream.CopyToAsync%2A> metody. Gdy <xref:System.IO.FileStream.IsAsync%2A> jest właściwość `false` wywołania asynchronicznego odczytu i zapisu, wątku interfejsu użytkownika nie nadal jest zablokowany, ale rzeczywisty operacji We/Wy jest wykonywana synchronicznie.  
  
 <xref:System.IO.FileStream.Seek%2A> Metoda obsługuje dostępie do plików. <xref:System.IO.FileStream.Seek%2A> Umożliwia pozycji odczytu/zapisu do przeniesienia do każdej pozycji w pliku. Jest to zrobić za pomocą parametrów punktu odniesienia przesunięcia bajtów. Przesunięcie bajtów jest względem punktu odwołanie wyszukiwania, które mogą być początku bieżącego położenia i na końcu pliku źródłowego, reprezentowany przez trzech elementów członkowskich <xref:System.IO.SeekOrigin> wyliczenia.  
  
> [!NOTE]
>  Pliki dysku zawsze obsługuje dostępie. Podczas konstruowania <xref:System.IO.FileStream.CanSeek%2A> ma ustawioną wartość właściwości `true` lub `false` w zależności od podstawowego typu pliku. Jeśli podstawowy typ pliku jest FILE_TYPE_DISK, zgodnie z definicją w winbase.h, <xref:System.IO.FileStream.CanSeek%2A> wartość właściwości jest `true`. W przeciwnym razie <xref:System.IO.FileStream.CanSeek%2A> wartość właściwości jest `false`.  
  
 Jeśli proces kończy się częścią pliku zablokowane lub zamknięcie pliku, który ma oczekujące blokad, zachowanie jest niezdefiniowany.  
  
 Dla operacji katalogu i inne operacje na plikach, zobacz <xref:System.IO.File>, <xref:System.IO.Directory>, i <xref:System.IO.Path> klasy. <xref:System.IO.File> Klasy to klasa narzędzia, która ma metody statyczne głównie w celu utworzenia <xref:System.IO.FileStream> obiektów oparte na ścieżkach do pliku. <xref:System.IO.MemoryStream> Klasy tworzy strumień z tablicy bajtów i jest podobny do <xref:System.IO.FileStream> klasy.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Wykrycie zmiany pozycji strumienia  
 Gdy <xref:System.IO.FileStream> obiekt nie ma wyłącznej blokady na jego uchwytu, inny wątek można jednocześnie dostęp dojście do pliku i zmianę położenia wskaźnika pliku systemu operacyjnego, który jest skojarzony z dojście do pliku. W tym przypadku pozycja pamięci podręcznej w <xref:System.IO.FileStream> obiekt i buforowane dane w buforze może być zagrożone. <xref:System.IO.FileStream> Obiektu sprawdza rutynowo metod, które uzyskują dostęp do pamięci podręcznej buforu upewnij się, że pozycja dojścia systemu operacyjnego jest taka sama jak pozycja pamięci podręcznej, używane przez <xref:System.IO.FileStream> obiektu.  
  
 Jeśli nieoczekiwane zmiany w położeniu dojścia zostanie wykryty w wywołaniu <xref:System.IO.FileStream.Read%2A> metody, .NET Framework odrzuca zawartości buforu i ponownie odczytuje strumienia z pliku. Może to mieć wpływ na wydajność, w zależności od rozmiaru pliku i inne procesy, które mogą wpłynąć na pozycji strumienia pliku.  
  
 Jeśli nieoczekiwane zmiany w położeniu dojścia zostanie wykryty w wywołaniu <xref:System.IO.FileStream.Write%2A> metody, zawartość buforów zostaną odrzucone i <xref:System.IO.IOException> wyjątku.  
  
 A <xref:System.IO.FileStream> obiekt nie będzie miał wyłącznej blokady na uchwytu podczas albo <xref:System.IO.FileStream.SafeFileHandle%2A> dostępu do właściwości do udostępnienia dojście lub <xref:System.IO.FileStream> znajduje się obiekt <xref:System.IO.FileStream.SafeFileHandle%2A> właściwości w jego konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano niektóre <xref:System.IO.FileStream> konstruktorów.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 Poniższy przykład przedstawia sposób zapisania pliku asynchronicznie. Ten kod jest uruchamiany w aplikacji WPF, który ma blok tekstu o nazwie UserInput i podłączonymi do o nazwie Button_Click obsługi zdarzeń kliknięcia przycisku. Ścieżka pliku musi zostać zmienione w pliku nie kończy się na komputerze.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku dla pliku który bieżącego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy dla określone dojście do pliku, z uprawnieniami do odczytu/zapisu w określonym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.IO.Stream.Close%2A> jest wywoływana, dojście jest również zamknięte, a liczba dojście do pliku jest zmniejszany.  
  
 `FileStream` przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A> przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 `FileShare.Read` Wartość domyślna to tych <xref:System.IO.FileStream> konstruktorów bez `FileShare` parametru.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> nie jest polem z <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak awaria dysku.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i dojście do pliku jest ustawiony na dostęp tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku dla pliku który bieżącego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy dla określone dojście do pliku, z uprawnieniami do odczytu/zapisu w określonym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.IO.Stream.Close%2A> jest wywoływana, dojście jest również zamknięte, a liczba dojście do pliku jest zmniejszany.  
  
 `FileStream` przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A> przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 `FileShare.Read` Wartość domyślna to tych <xref:System.IO.FileStream> konstruktorów bez `FileShare` parametru.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> nie jest polem z <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak awaria dysku.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i dojście do pliku jest ustawiony na dostęp tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku który bieżącego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="mode">Stała, która określa sposób otwarcia lub utworzenia pliku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy z określonym trybem ścieżkę i tworzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "\\\\. \PHYSICALDRIVE0".  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 Konstruktor otrzymuje dostęp do odczytu/zapisu do pliku i jest otwarty, dostęp do odczytu do udostępniania (czyli żądań do otwierania pliku do pisania przez ten lub inny proces zakończy się niepowodzeniem, dopóki `FileStream` obiekt został zamknięty, ale będzie próby odczytu powiedzie się).  
  
 Ten konstruktor nie można użyć do otwierania plików tylko do odczytu; Zamiast tego należy użyć konstruktora akceptującego `FileAccess` parametru z wartością ustawioną na `FileAccess.Read`.  
  
 Rozmiar buforu ustawiono domyślny rozmiar 4096 bajtów (4 KB).  
  
> [!NOTE]
>  `path` nie jest wymagana jest plikiem przechowywane na dysku; może być dowolną część system, który obsługuje dostęp za pośrednictwem strumieni. Na przykład w zależności od systemu, tej klasy można uzyskać dostępu do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A> jest `true` dla wszystkich <xref:System.IO.FileStream> obiektów, które hermetyzują plików. Jeśli `path` wskazuje urządzenie nie obsługuje wyszukiwania, <xref:System.IO.FileStream.CanSeek%2A> właściwość powstałe w ten sposób <xref:System.IO.FileStream> jest `false`. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` Wartość domyślna to tych <xref:System.IO.FileStream> konstruktorów bez `FileShare` parametru.  
  
 Dla konstruktorów bez <xref:System.IO.FileAccess> parametru, jeśli `mode` ustawiono parametr <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> jest dostęp do domyślnej. W przeciwnym razie ma ustawioną wartość dostępu <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zapisać danych do pliku bajtów za bajtem, a następnie sprawdź, czy dane zostały poprawnie zapisane.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty (""), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.  - lub - <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku systemu plików NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku z systemem innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku, takie jak kiedy <paramref name="mode" /> jest <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, a plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak określanie <see langword="FileMode.CreateNew" /> gdy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku dla pliku który bieżącego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="access">A <see cref="T:System.IO.FileAccess" /> stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu.</param>
        <param name="bufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większą niż 0, rozmiar buforu wskazująca. Domyślny rozmiar buforu to 4096.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy dla określone dojście do pliku, z uprawnieniami określonego odczytu/zapisu, a rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A> przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia. Alternatywnie do odczytu i zapisu dojście przed wywołaniem to `FileStream` konstruktora.  
  
 `FileShare.Read` Wartość domyślna to tych <xref:System.IO.FileStream> konstruktorów bez `FileShare` parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> Parametr jest nieprawidłowy uchwyt.  - lub - <paramref name="handle" /> parametr ma uchwyt synchroniczne i użyto asynchronicznie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> Parametr jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak awaria dysku.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i dojście do pliku jest ustawiony na dostęp tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Wyliczenia skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku dla pliku który bieżącego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu.</param>
        <param name="ownsHandle">
          <see langword="true" /> Jeśli dojście do pliku są własnością to <see langword="FileStream" /> wystąpienia; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy dla określone dojście do pliku, z uprawnieniami do odczytu/zapisu w określonym i <see langword="FileStream" /> wystąpienie własności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` Obiektu znajduje określony dostępu do pliku. Własność dojście będzie jak określono. Jeśli ten proces jest właścicielem dojście wywołania <xref:System.IO.Stream.Close%2A> metoda zostaną także zamknięte dojście i liczby dojść pliku zostanie zmniejszona. `FileStream` Obiektu podano domyślny rozmiar buforu 4096 bajtów.  
  
 `FileStream` przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A> przed przy użyciu dojścia i unikaj wywoływania metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia.  
  
 `FileShare.Read` Wartość domyślna to tych <xref:System.IO.FileStream> konstruktorów bez `FileShare` parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> nie jest polem z <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak awaria dysku.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i dojście do pliku jest ustawiony na dostęp tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku który bieżącego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="mode">Stała, która określa sposób otwarcia lub utworzenia pliku.</param>
        <param name="access">Stała, która określa, jak można uzyskać dostępu do pliku <see langword="FileStream" /> obiektu. Wartości zwracane przez określa również <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu. <see cref="P:System.IO.FileStream.CanSeek" /> jest <see langword="true" /> Jeśli <c>ścieżki</c> Określa plik dysku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy z określonej ścieżki, tryb tworzenia oraz uprawnienia odczytu/zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "\\\\. \PHYSICALDRIVE0".  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 Konstruktor otrzymuje dostęp do odczytu/zapisu do pliku i jest otwarty, dostęp do odczytu do udostępniania (czyli żądań do otwierania pliku do pisania przez ten lub inny proces zakończy się niepowodzeniem, dopóki `FileStream` obiekt został zamknięty, ale będzie próby odczytu powiedzie się). Rozmiar buforu ustawiono domyślny rozmiar 4096 bajtów (4 KB).  
  
> [!NOTE]
>  `path` nie jest wymagana jest plikiem przechowywane na dysku; może być dowolną część system, który obsługuje dostęp za pośrednictwem strumieni. Na przykład w zależności od systemu, tej klasy można uzyskać dostępu do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A> jest `true` dla wszystkich <xref:System.IO.FileStream> obiektów, które hermetyzują plików. Jeśli `path` wskazuje urządzenie nie obsługuje wyszukiwania, <xref:System.IO.FileStream.CanSeek%2A> właściwość powstałe w ten sposób <xref:System.IO.FileStream> jest `false`. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` Wartość domyślna to tych <xref:System.IO.FileStream> konstruktorów bez `FileShare` parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty (""), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.  - lub - <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku systemu plików NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku z systemem innym niż NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku, takie jak kiedy <paramref name="mode" /> jest <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, a plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak określanie <see langword="FileMode.CreateNew" /> gdy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny dla określonego <paramref name="path" />, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i plik lub katalog jest ustawiony na dostęp tylko do odczytu.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku dla pliku tego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu.</param>
        <param name="bufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większą niż 0, rozmiar buforu wskazująca. Domyślny rozmiar buforu to 4096.</param>
        <param name="isAsync">
          <see langword="true" /> Jeśli dojście zostało otwarte asynchronicznie (to znaczy w pokrywający się trybie We/Wy); w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy dla określone dojście do pliku, uprawnienia odczytu/zapisu w określonym, rozmiar buforu i stan synchroniczna lub asynchroniczna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz ustawić `isAsync` parametr `true` można otworzyć dojścia do pliku asynchronicznie. Jeśli parametr jest `true`, strumienia wykorzystuje pokrywającej się z inną operacji We/Wy do wykonywania operacji na plikach asynchronicznie. Jednak parametr nie ma być `true` do wywołania <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, lub <xref:System.IO.Stream.CopyToAsync%2A> metody. Gdy `isAsync` parametr jest `false` wywołania asynchronicznego odczytu i zapisu, wątku interfejsu użytkownika nie nadal jest zablokowany, ale rzeczywisty operacji We/Wy jest wykonywana synchronicznie.  
  
 `FileStream` przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A> przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia. Alternatywnie do odczytu i zapisu dojście przed wywołaniem to `FileStream` konstruktora.  
  
 `FileShare.Read` Wartość domyślna to tych <xref:System.IO.FileStream> konstruktorów bez `FileShare` parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> Parametr jest nieprawidłowy uchwyt.  - lub - <paramref name="handle" /> parametr ma uchwyt synchroniczne i użyto asynchronicznie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> Parametr jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak awaria dysku.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i dojście do pliku jest ustawiony na dostęp tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Wyliczenia skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku dla pliku tego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu.</param>
        <param name="ownsHandle">
          <see langword="true" /> Jeśli dojście do pliku są własnością to <see langword="FileStream" /> wystąpienia; w przeciwnym razie <see langword="false" />.</param>
        <param name="bufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większą niż 0, rozmiar buforu wskazująca. Domyślny rozmiar buforu to 4096.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy dla określone dojście do pliku, z uprawnieniami odczytu/zapisu w określonym <see langword="FileStream" /> wystąpienia własność oraz rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` Obiektu znajduje określony dostępu do pliku. Własność dojście będzie jak określono. Jeśli `FileStream` właścicielem dojście wywołania <xref:System.IO.Stream.Close%2A> metoda zostaną także zamknięte dojście. W szczególności liczby dojść pliku zostanie zmniejszona. `FileStream` Obiektu znajduje określony rozmiar buforu.  
  
 `FileStream` przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A> przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia. Alternatywnie do odczytu i zapisu dojście przed wywołaniem to `FileStream` konstruktora.  
  
 `FileShare.Read` Wartość domyślna to tych <xref:System.IO.FileStream> konstruktorów bez `FileShare` parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak awaria dysku.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i dojście do pliku jest ustawiony na dostęp tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku który bieżącego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="mode">Stała, która określa sposób otwarcia lub utworzenia pliku.</param>
        <param name="access">Stała, która określa, jak można uzyskać dostępu do pliku <see langword="FileStream" /> obiektu. Wartości zwracane przez określa również <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu. <see cref="P:System.IO.FileStream.CanSeek" /> jest <see langword="true" /> Jeśli <c>ścieżki</c> Określa plik dysku.</param>
        <param name="share">Stała określającą, jak plik zostanie udostępniony przez procesy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> z określonej ścieżki, tryb tworzenia, uprawnienia odczytu/zapisu i uprawnienia udostępniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "\\\\. \PHYSICALDRIVE0".  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 Konstruktor otrzymuje dostęp do odczytu/zapisu do pliku i jest otwarty, dostęp do odczytu do udostępniania (czyli żądań do otwierania pliku do pisania przez ten lub inny proces zakończy się niepowodzeniem, dopóki `FileStream` obiekt został zamknięty, ale będzie próby odczytu powiedzie się). Rozmiar buforu ustawiono domyślny rozmiar 4096 bajtów (4 KB).  
  
> [!NOTE]
>  `path` nie jest wymagana jest plikiem przechowywane na dysku; może być dowolną część system, który obsługuje dostęp za pośrednictwem strumieni. Na przykład w zależności od systemu, tej klasy można uzyskać dostępu do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A> jest `true` dla wszystkich <xref:System.IO.FileStream> obiektów, które hermetyzują plików. Jeśli `path` wskazuje urządzenie nie obsługuje wyszukiwania, <xref:System.IO.FileStream.CanSeek%2A> właściwość powstałe w ten sposób <xref:System.IO.FileStream> jest `false`. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.FileStream.Lock%2A> metody.  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty (""), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.  - lub - <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku systemu plików NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku z systemem innym niż NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku, takie jak kiedy <paramref name="mode" /> jest <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, a plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak określanie <see langword="FileMode.CreateNew" /> gdy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  w systemie Windows 98 lub Windows 98 Wydanie drugie - lub - i <paramref name="share" /> ma ustawioną wartość <see langword="FileShare.Delete" />.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny dla określonego <paramref name="path" />, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i plik lub katalog jest ustawiony na dostęp tylko do odczytu.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do pliku dla pliku tego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="access">Stała, która ustawia <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu.</param>
        <param name="ownsHandle">
          <see langword="true" /> Jeśli dojście do pliku są własnością to <see langword="FileStream" /> wystąpienia; w przeciwnym razie <see langword="false" />.</param>
        <param name="bufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większą niż 0, rozmiar buforu wskazująca. Domyślny rozmiar buforu to 4096.</param>
        <param name="isAsync">
          <see langword="true" /> Jeśli dojście zostało otwarte asynchronicznie (to znaczy w pokrywający się trybie We/Wy); w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy dla określone dojście do pliku, z uprawnieniami odczytu/zapisu w określonym <see langword="FileStream" /> wystąpienie własność, rozmiar buforu i stan synchroniczna lub asynchroniczna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` Obiektu znajduje określony dostępu do pliku. Własność dojście będzie jak określono. Jeśli `FileStream` właścicielem dojście wywołania <xref:System.IO.Stream.Close%2A> metoda zostaną także zamknięte dojście. W szczególności liczby dojść pliku zostanie zmniejszona. `FileStream` Obiektu znajduje określony rozmiar buforu.  
  
 `FileStream` przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A> przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia. Alternatywnie do odczytu i zapisu dojście przed wywołaniem to `FileStream` konstruktora.  
  
 `FileShare.Read` Wartość domyślna to tych <xref:System.IO.FileStream> konstruktorów bez `FileShare` parametru.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="access" /> jest mniejsza niż <see langword="FileAccess.Read" /> lub większa niż <see langword="FileAccess.ReadWrite" /> lub <paramref name="bufferSize" /> jest mniejsza niż lub równa 0.</exception>
        <exception cref="T:System.ArgumentException">Dojście jest nieprawidłowe.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak awaria dysku.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i dojście do pliku jest ustawiony na dostęp tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku który bieżącego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="mode">Stała, która określa sposób otwarcia lub utworzenia pliku.</param>
        <param name="access">Stała, która określa, jak można uzyskać dostępu do pliku <see langword="FileStream" /> obiektu. Wartości zwracane przez określa również <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu. <see cref="P:System.IO.FileStream.CanSeek" /> jest <see langword="true" /> Jeśli <c>ścieżki</c> Określa plik dysku.</param>
        <param name="share">Stała określającą, jak plik zostanie udostępniony przez procesy.</param>
        <param name="bufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większą niż 0, rozmiar buforu wskazująca. Domyślny rozmiar buforu to 4096.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy z określonej ścieżki, tryb tworzenia, odczytu i zapisu oraz udostępniania tych uprawnień, a rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "\\\\. \PHYSICALDRIVE0".  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path` nie jest wymagana jest plikiem przechowywane na dysku; może być dowolną część system, który obsługuje dostęp za pośrednictwem strumieni. Na przykład w zależności od systemu, tej klasy można uzyskać dostępu do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A> jest `true` dla wszystkich <xref:System.IO.FileStream> obiektów, które hermetyzują plików. Jeśli `path` wskazuje urządzenie nie obsługuje wyszukiwania, <xref:System.IO.FileStream.CanSeek%2A> właściwość powstałe w ten sposób <xref:System.IO.FileStream> jest `false`. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty (""), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.  - lub - <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku systemu plików NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku z systemem innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ma wartość ujemną lub wartość zero.  - lub - <paramref name="mode" />, <paramref name="access" />, lub <paramref name="share" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku, takie jak kiedy <paramref name="mode" /> jest <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, a plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak określanie <see langword="FileMode.CreateNew" /> gdy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  w systemie Windows 98 lub Windows 98 Wydanie drugie - lub - i <paramref name="share" /> ma ustawioną wartość <see langword="FileShare.Delete" />.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny dla określonego <paramref name="path" />, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i plik lub katalog jest ustawiony na dostęp tylko do odczytu.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku który bieżącego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="mode">Stała, która określa sposób otwarcia lub utworzenia pliku.</param>
        <param name="access">Stała, która określa, jak można uzyskać dostępu do pliku <see langword="FileStream" /> obiektu. Wartości zwracane przez określa również <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu. <see cref="P:System.IO.FileStream.CanSeek" /> jest <see langword="true" /> Jeśli <c>ścieżki</c> Określa plik dysku.</param>
        <param name="share">Stała określającą, jak plik zostanie udostępniony przez procesy.</param>
        <param name="bufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większą niż 0, rozmiar buforu wskazująca. Domyślny rozmiar buforu to 4096.</param>
        <param name="useAsync">Określa, czy używać asynchroniczne We/Wy lub synchroniczne we/wy. Jednak należy pamiętać, że system operacyjny może nie obsługiwać asynchroniczne We/Wy, dlatego podczas określania <see langword="true" />, dojście może być otwarte synchronicznie, w zależności od platformy. Po otwarciu asynchronicznie, <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> i <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> metody lepiej na duże odczyty lub zapisy, ale są znacznie wolniejsze dla małych odczytów i zapisów. Jeśli aplikacja jest przeznaczony do zalet asynchroniczne We/Wy, ustaw <c>useAsync</c> parametr <see langword="true" />. Przy użyciu asynchroniczne We/Wy poprawnie przyspieszyć aplikacji przez jak współczynnik 10, ale przy użyciu jego bez zmiany projektu aplikacji dla asynchroniczne We/Wy może obniżyć wydajność przez tyle jako 10.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy z określonej ścieżki, tryb tworzenia, odczytu/zapisu i zezwolenia na udostępnienie, buforować stanu rozmiarze, a synchroniczna lub asynchroniczna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "\\\\. \PHYSICALDRIVE0".  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path` nie jest wymagana jest plikiem przechowywane na dysku; może być dowolną część system, który obsługuje dostęp za pośrednictwem strumieni. Na przykład w zależności od systemu, tej klasy można uzyskać dostępu do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A> jest `true` dla wszystkich <xref:System.IO.FileStream> obiektów, które hermetyzują plików. Jeśli `path` wskazuje urządzenie nie obsługuje wyszukiwania, <xref:System.IO.FileStream.CanSeek%2A> właściwość powstałe w ten sposób <xref:System.IO.FileStream> jest `false`. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób asynchronicznego zapisu danych do pliku, a następnie sprawdź, czy dane zostały poprawnie zapisane. A `State` obiekt jest tworzony w celu przekazywania informacji z wątku głównego do `EndReadCallback` i `EndWriteCallback` metody.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty (""), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.  - lub - <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku systemu plików NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku z systemem innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ma wartość ujemną lub wartość zero.  - lub - <paramref name="mode" />, <paramref name="access" />, lub <paramref name="share" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku, takie jak kiedy <paramref name="mode" /> jest <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, a plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak określanie <see langword="FileMode.CreateNew" /> gdy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  w systemie Windows 98 lub Windows 98 Wydanie drugie - lub - i <paramref name="share" /> ma ustawioną wartość <see langword="FileShare.Delete" />.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny dla określonego <paramref name="path" />, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i plik lub katalog jest ustawiony na dostęp tylko do odczytu.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="T:System.IO.File" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku który bieżącego <see langword="FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="mode">Stała, która określa sposób otwarcia lub utworzenia pliku.</param>
        <param name="access">Stała, która określa, jak można uzyskać dostępu do pliku <see langword="FileStream" /> obiektu. Wartości zwracane przez określa również <see cref="P:System.IO.FileStream.CanRead" /> i <see cref="P:System.IO.FileStream.CanWrite" /> właściwości <see langword="FileStream" /> obiektu. <see cref="P:System.IO.FileStream.CanSeek" /> jest <see langword="true" /> Jeśli <c>ścieżki</c> Określa plik dysku.</param>
        <param name="share">Stała określającą, jak plik zostanie udostępniony przez procesy.</param>
        <param name="bufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większą niż 0, rozmiar buforu wskazująca. Domyślny rozmiar buforu to 4096.</param>
        <param name="options">Wartość, która określa dodatkowe opcje pliku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> przy użyciu określonej ścieżki, tryb tworzenia, odczytu/zapisu i udostępnianie uprawnienia dostępu do tego samego pliku, rozmiar buforu i dodatkowe opcje pliku może mieć inne FileStreams.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "\\\\. \PHYSICALDRIVE0".  
  
 `fileOptions` Parametr jest używany w celu zapewnienia dostępu do bardziej zaawansowanych operacje, których można użyć podczas tworzenia <xref:System.IO.FileStream> obiektu.  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path` nie jest wymagana jest plikiem przechowywane na dysku; może być dowolną część system, który obsługuje dostęp za pośrednictwem strumieni. Na przykład w zależności od systemu, tej klasy można uzyskać dostępu do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A> jest `true` dla wszystkich <xref:System.IO.FileStream> obiektów, które hermetyzują plików. Jeśli `path` wskazuje urządzenie nie obsługuje wyszukiwania, <xref:System.IO.FileStream.CanSeek%2A> właściwość powstałe w ten sposób <xref:System.IO.FileStream> jest `false`. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zapisuje dane do pliku, a następnie odczytuje danych przy użyciu <xref:System.IO.FileStream> obiektu.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty (""), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.  - lub - <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku systemu plików NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku z systemem innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ma wartość ujemną lub wartość zero.  - lub - <paramref name="mode" />, <paramref name="access" />, lub <paramref name="share" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku, takie jak kiedy <paramref name="mode" /> jest <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, a plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak określanie <see langword="FileMode.CreateNew" /> gdy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny dla określonego <paramref name="path" />, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i plik lub katalog jest ustawiony na dostęp tylko do odczytu.  - lub - <see cref="F:System.IO.FileOptions.Encrypted" /> określono <paramref name="options" />, ale szyfrowania plików nie jest obsługiwane na bieżącej platformie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku który bieżącego <see cref="T:System.IO.FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="mode">Stała, która określa sposób otwarcia lub utworzenia pliku.</param>
        <param name="rights">Stała, który określa prawa dostępu do użycia podczas tworzenia reguł dostępu i inspekcji dla pliku.</param>
        <param name="share">Stała określającą, jak plik zostanie udostępniony przez procesy.</param>
        <param name="bufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większą niż 0, rozmiar buforu wskazująca. Domyślny rozmiar buforu to 4096.</param>
        <param name="options">Stała, który określa dodatkowe opcje pliku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy z określonej ścieżki, tryb tworzenia, prawa dostępu i uprawnienia udostępniania, opcje rozmiarze i dodatkowe pliku buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "\\\\. \PHYSICALDRIVE0".  
  
 Użyj tej <xref:System.IO.FileStream.%23ctor%2A> konstruktora, aby zastosować dostępu praw w punkcie utworzenie pliku. Dostępu lub modyfikacji praw na istniejący plik, należy rozważyć użycie <xref:System.IO.File.GetAccessControl%2A> i <xref:System.IO.File.SetAccessControl%2A> metody.  
  
 `fileOptions` Parametr jest używany w celu zapewnienia dostępu do bardziej zaawansowanych operacje, których można użyć podczas tworzenia <xref:System.IO.FileStream> obiektu.  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path` nie jest wymagana jest plikiem przechowywane na dysku; może być dowolną część system, który obsługuje dostęp za pośrednictwem strumieni. Na przykład w zależności od systemu, tej klasy można uzyskać dostępu do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A> jest `true` dla wszystkich <xref:System.IO.FileStream> obiektów, które hermetyzują plików. Jeśli `path` wskazuje urządzenie nie obsługuje wyszukiwania, <xref:System.IO.FileStream.CanSeek%2A> właściwość powstałe w ten sposób <xref:System.IO.FileStream> jest `false`. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty (""), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.  - lub - <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku systemu plików NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku z systemem innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ma wartość ujemną lub wartość zero.  - lub - <paramref name="mode" />, <paramref name="access" />, lub <paramref name="share" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku, takie jak kiedy <paramref name="mode" /> jest <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, a plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak określanie <see langword="FileMode.CreateNew" /> gdy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny dla określonego <paramref name="path" />, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i plik lub katalog jest ustawiony na dostęp tylko do odczytu.  - lub - <see cref="F:System.IO.FileOptions.Encrypted" /> określono <paramref name="options" />, ale szyfrowania plików nie jest obsługiwane na bieżącej platformie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określony <paramref name="path" />, nazwa pliku albo oba przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do pliku który bieżącego <see cref="T:System.IO.FileStream" /> będzie Hermetyzowanie obiektu.</param>
        <param name="mode">Stała, która określa sposób otwarcia lub utworzenia pliku.</param>
        <param name="rights">Stała, który określa prawa dostępu do użycia podczas tworzenia reguł dostępu i inspekcji dla pliku.</param>
        <param name="share">Stała określającą, jak plik zostanie udostępniony przez procesy.</param>
        <param name="bufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większą niż 0, rozmiar buforu wskazująca. Domyślny rozmiar buforu to 4096.</param>
        <param name="options">Stała, który określa dodatkowe opcje pliku.</param>
        <param name="fileSecurity">Stała, który określa kontroli dostępu i inspekcji zabezpieczeń dla pliku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileStream" /> klasy z określonej ścieżki, tryb tworzenia, prawa dostępu i udostępniania uprawnień, rozmiar buforu, dodatkowe opcje pliku, kontroli dostępu i inspekcji zabezpieczeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "\\\\. \PHYSICALDRIVE0".  
  
 Użyj tej <xref:System.IO.FileStream.%23ctor%2A> konstruktora, aby zastosować dostępu praw w punkcie utworzenie pliku. Dostępu lub modyfikacji praw na istniejący plik, należy rozważyć użycie <xref:System.IO.File.GetAccessControl%2A> i <xref:System.IO.File.SetAccessControl%2A> metody.  
  
 `fileOptions` Parametr jest używany w celu zapewnienia dostępu do bardziej zaawansowanych operacje, których można użyć podczas tworzenia <xref:System.IO.FileStream> obiektu.  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path` nie jest wymagana jest plikiem przechowywane na dysku; może być dowolną część system, który obsługuje dostęp za pośrednictwem strumieni. Na przykład w zależności od systemu, tej klasy można uzyskać dostępu do urządzenia fizycznego.  
  
 <xref:System.IO.Stream.CanSeek%2A> jest `true` dla wszystkich <xref:System.IO.FileStream> obiektów, które hermetyzują plików. Jeśli `path` wskazuje urządzenie nie obsługuje wyszukiwania, <xref:System.IO.FileStream.CanSeek%2A> właściwość powstałe w ten sposób <xref:System.IO.FileStream> jest `false`. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zapisuje dane do pliku, a następnie odczytuje danych przy użyciu <xref:System.IO.FileStream> obiektu.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty (""), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.  - lub - <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku systemu plików NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> odwołuje się do urządzenia z systemem innym niż plik, takich jak "con:", "com1:", "lpt1:", etc. w środowisku z systemem innym niż NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ma wartość ujemną lub wartość zero.  - lub - <paramref name="mode" />, <paramref name="access" />, lub <paramref name="share" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku, takie jak kiedy <paramref name="mode" /> jest <see langword="FileMode.Truncate" /> lub <see langword="FileMode.Open" />, a plik określony przez <paramref name="path" /> nie istnieje. Plik musi już istnieć w tych trybach.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak określanie <see langword="FileMode.CreateNew" /> gdy plik określony przez <paramref name="path" /> już istnieje, wystąpił.  - lub - strumień został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> Żądanie nie jest dozwolona przez system operacyjny dla określonego <paramref name="path" />, takie jak kiedy <paramref name="access" /> jest <see langword="Write" /> lub <see langword="ReadWrite" /> i plik lub katalog jest ustawiony na dostęp tylko do odczytu.  - lub - <see cref="F:System.IO.FileOptions.Encrypted" /> określono <paramref name="options" />, ale szyfrowania plików nie jest obsługiwane na bieżącej platformie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określony <paramref name="path" />, nazwa pliku albo oba przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie, zapisywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Bufor do wczytania danych.</param>
        <param name="buffer">To be added.</param>
        <param name="offset">Przesunięcie bajtów w <c>tablicy</c> w którym ma rozpocząć się odczyt.</param>
        <param name="numBytes">Maksymalna liczba bajtów do odczytania.</param>
        <param name="count">To be added.</param>
        <param name="userCallback">Metoda wywoływana, gdy operacja odczytu asynchronicznego zostanie ukończona.</param>
        <param name="callback">To be added.</param>
        <param name="stateObject">Obiekt dostarczane przez użytkownika, która odróżnia to asynchroniczne żądanie odczytu z innych żądań.</param>
        <param name="state">To be added.</param>
        <summary>Rozpoczyna operację asynchroniczną odczytu. (Rozważ użycie <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast.)</summary>
        <returns>Obiekt, który odwołuje się do odczytu asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody takie jak <xref:System.IO.FileStream.BeginRead%2A> i <xref:System.IO.FileStream.EndRead%2A> do wykonania operacji na plikach asynchronicznego. Te metody są nadal dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.  
  
 <xref:System.IO.FileStream.EndRead%2A> musi zostać wywołana tylko raz dla każdego wywołania <xref:System.IO.FileStream.BeginRead%2A>. Nie można zakończyć proces odczytu przed rozpoczęciem innego odczytu może spowodować niepożądane zachowanie, takie jak zakleszczenia.  
  
 <xref:System.IO.FileStream> udostępnia dwa różne tryby działania: We/Wy synchroniczne i asynchroniczne We/Wy. Chociaż albo mogą być używane, zasobów systemu operacyjnego mogą zezwalać na dostęp tylko jednej z tych trybów. Domyślnie <xref:System.IO.FileStream> synchronicznie zostanie otwarte dojście systemu operacyjnego. W systemie Windows to spowalnia metod asynchronicznych. Jeśli używane są metod asynchronicznych, użyj <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
> [!NOTE]
>  Użyj <xref:System.IO.FileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanRead%2A>.  
  
 Jeśli strumień jest zamknięty lub Przekaż nieprawidłowy argument, istnieją wyjątki zgłaszane bezpośrednio z <xref:System.IO.FileStream.BeginRead%2A>. Błędów występujących podczas odczytu żądania asynchronicznego, takiej jak awaria dysku podczas wykonywania żądania We/Wy wystąpić w wątku puli wątków i stają się widoczne po wywołaniu <xref:System.IO.FileStream.EndRead%2A>.  
  
 <xref:System.IO.Stream.EndRead%2A> musi zostać wywołany z tym <xref:System.IAsyncResult> Aby dowiedzieć się, odczytano liczbę bajtów.  
  
 Wiele równoczesnych żądań asynchronicznych renderowania wiedzą kolejności wykonania żądania.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość tablicy minus <paramref name="offset" /> jest mniejsza niż <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="numBytes" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Podjęto próbę asynchroniczny odczyt poza końcem pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Bufor zawierający dane do zapisania bieżącego strumienia.</param>
        <param name="buffer">To be added.</param>
        <param name="offset">Zerze przesunięcie w <c>tablicy</c> jaką należy zacząć kopiowanie bajtów do bieżącego strumienia.</param>
        <param name="numBytes">Maksymalna liczba bajtów do zapisania.</param>
        <param name="count">To be added.</param>
        <param name="userCallback">Metoda wywoływana po zakończeniu operacji zapis asynchroniczny.</param>
        <param name="callback">To be added.</param>
        <param name="stateObject">Obiekt dostarczane przez użytkownika, która odróżnia to żądanie określonego zapis asynchroniczny od innych żądań.</param>
        <param name="state">To be added.</param>
        <summary>Rozpoczyna operację asynchronicznego zapisu. (Rozważ użycie <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast.)</summary>
        <returns>Obiekt, który odwołuje się do asynchronicznego zapisu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody takie jak <xref:System.IO.FileStream.BeginWrite%2A> i <xref:System.IO.FileStream.EndWrite%2A> do wykonania operacji na plikach asynchronicznego. Te metody są nadal dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.  
  
 <xref:System.IO.FileStream.EndWrite%2A> musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult> z <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> blokuje dopiero po ukończeniu operacji We/Wy.  
  
 Ta metoda zastępuje <xref:System.IO.Stream.BeginWrite%2A>.  
  
 <xref:System.IO.FileStream> udostępnia dwa różne tryby działania: We/Wy synchroniczne i asynchroniczne We/Wy. Chociaż albo mogą być używane, zasobów systemu operacyjnego mogą zezwalać na dostęp tylko jednej z tych trybów. Domyślnie <xref:System.IO.FileStream> synchronicznie zostanie otwarte dojście systemu operacyjnego. W systemie Windows to spowalnia metod asynchronicznych. Jeśli używane są metod asynchronicznych, użyj <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 Jeśli strumień jest zamknięty lub Przekaż nieprawidłowy argument, istnieją wyjątki zgłaszane bezpośrednio z <xref:System.IO.FileStream.BeginWrite%2A>. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy wystąpić w wątku puli wątków i stają się widoczne po wywołaniu <xref:System.IO.FileStream.EndWrite%2A>.  
  
 Wiele równoczesnych żądań asynchronicznych renderowania wiedzą kolejności wykonania żądania.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> Długość minus <paramref name="offset" /> jest mniejsza niż <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="numBytes" /> jest ujemna.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli strumień nie udostępnia możliwości czytania; <see langword="false" /> strumień jest zamknięty lub została otwarta z dostępem tylko do zapisu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasą pochodną <xref:System.IO.Stream> nie obsługuje operacji odczytu, wywołań <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, i <xref:System.IO.FileStream.BeginRead%2A> throw metody <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca `false`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano korzystanie z `CanRead` właściwości. Dane wyjściowe tego kodu jest "Mojplik.txt nie jest zapisywalny." Można pobrać komunikatu wyjściowego "mojplik.txt może być zarówno zapisywane odczytywać.", zmiana i `FileAccess` parametr `ReadWrite` w `FileStream` konstruktora.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje operacji wyszukiwania.</summary>
        <value>
          <see langword="true" /> w przypadku strumienia obsługuje operacji wyszukiwania; <see langword="false" /> Jeśli strumień jest zamknięty lub <see langword="FileStream" /> został skonstruowany na podstawie dojścia systemu operacyjnego, takich jak potoku lub dane wyjściowe do konsoli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasą pochodną <xref:System.IO.Stream> nie obsługuje wyszukiwania, wywołań <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, i <xref:System.IO.FileStream.Seek%2A> throw <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca `false`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `CanSeek` właściwość, aby sprawdzić, czy strumień obsługuje operacji wyszukiwania.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje zapisu.</summary>
        <value>
          <see langword="true" /> Jeśli strumienia obsługuje zapis; <see langword="false" /> strumień jest zamknięty lub została otwarta z dostępem tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasą pochodną <xref:System.IO.Stream> nie obsługuje zapisywania wywołanie <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, lub <xref:System.IO.FileStream.WriteByte%2A> zgłasza <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca `false`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `CanWrite` właściwość do sprawdzenia, czy strumień obsługuje zapis.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 Poniżej przedstawiono przykład przy użyciu `CanWrite` właściwości. Dane wyjściowe tego kodu jest "Mojplik.txt jest zapisywalna." Można pobrać komunikatu wyjściowego "mojplik.txt może być zarówno zapisywane odczytywać.", zmiana i `FileAccess` parametr `ReadWrite` w `FileStream` konstruktora.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.FileStream" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A> — metoda i <xref:System.Object.Finalize%2A> metody. <xref:System.ComponentModel.Component.Dispose%2A> wywołuje chronioną metodę <xref:System.IO.FileStream.Dispose%2A> metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje <xref:System.IO.FileStream.Dispose%2A> z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.IO.FileStream> odwołania. Ta metoda wywołuje <xref:System.ComponentModel.Component.Dispose%2A> metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see cref="M:System.ComponentModel.Component.Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see cref="M:System.ComponentModel.Component.Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia się niezarządzane Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekujące żądania asynchronicznego oczekiwania.</param>
        <summary>Czeka na ukończenie oczekujących operacji odczytu asynchronicznego. (Rozważ użycie <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast.)</summary>
        <returns>Liczba odczytanych bajtów ze strumienia, między 0 a liczba bajtów, żądana. Strumienie zwracać tylko 0 na koniec strumienia, w przeciwnym razie należy zablokować, dopóki nie będzie dostępne co najmniej 1 bajt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody takie jak <xref:System.IO.FileStream.BeginRead%2A> i <xref:System.IO.FileStream.EndRead%2A> do wykonania operacji na plikach asynchronicznego. Te metody są nadal dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.  
  
 <xref:System.IO.FileStream.EndRead%2A> musi zostać wywołana dokładnie dla każdego wywołania <xref:System.IO.FileStream.BeginRead%2A>. Nie można zakończyć proces odczytu przed rozpoczęciem innego odczytu może spowodować niepożądane zachowanie, takie jak zakleszczenia.  
  
 Ta metoda zastępuje <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A> może być wywoływana dla każdej <xref:System.IAsyncResult> z <xref:System.IO.FileStream.BeginRead%2A>. Wywoływanie <xref:System.IO.FileStream.EndRead%2A> pozwalają określić liczbę bajtów zostały odczytane ze strumienia. <xref:System.IO.FileStream.EndRead%2A> blokuje dopiero po ukończeniu operacji We/Wy.  
  
   
  
## Examples  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">To <see cref="T:System.IAsyncResult" /> obiektu nie została utworzona przez wywołanie <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> od tej klasy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> jest wywołana wiele razy.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądania We/Wy asynchronicznego.</param>
        <summary>Kończy operację asynchronicznego zapisu i bloków, aż do zakończenia operacji We/Wy. (Rozważ użycie <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody takie jak <xref:System.IO.FileStream.BeginWrite%2A> i <xref:System.IO.FileStream.EndWrite%2A> do wykonania operacji na plikach asynchronicznego. Te metody są nadal dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.  
  
 Ta metoda zastępuje <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A> musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult> z <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> blokuje dopiero po ukończeniu operacji We/Wy.  
  
   
  
## Examples  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">To <see cref="T:System.IAsyncResult" /> obiektu nie została utworzona przez wywołanie <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> od tej klasy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> jest wywołana wiele razy.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gwarantuje, że zasoby są zwalniane i inne operacje oczyszczania są wykonywane, gdy moduł garbage collector zwraca <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania modułu zbierającego elementy bezużyteczne `Finalize` Jeśli bieżący obiekt jest gotowy do przetwarzania. `Finalize` Zamyka `FileStream`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Podczas wywoływania <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> również jest opróżniany metody buforu systemu operacyjnego we/wy.  
  
 Koder strumienia nie jest opróżniany, chyba że jawnie wywołać <xref:System.IO.FileStream.Flush%2A> lub usunięcia obiektu. Ustawienie <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> do `true` oznacza, że dane zostaną opróżnione z buforu w strumieniu, ale nie zostaną opróżnione kodera stanu. Dzięki temu koder ma zachowywać stan (częściowe znaki), aby ją poprawnie kodowania kolejny blok znaków. Ten scenariusz dotyczy UTF8 i UTF7, w której niektóre znaki mogą być kodowane tylko po otrzymaniu koder sąsiedniego znaku ani znaków.  
  
 Ponieważ bufor może służyć do odczytu lub zapisu, <xref:System.IO.FileStream.Flush> wykonuje następujące dwie funkcje:  
  
-   Wszystkie dane zapisane wcześniej w buforze jest kopiowana do pliku, a bufor jest wyczyszczone z wyjątkiem stanu kodera.  
  
-   Jeśli <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> jest `true` i danych został wcześniej skopiowany z pliku do buforu odczytu, czy bieżące położenie w pliku jest zmniejszany przez liczbę nieprzeczytana bajtów w buforze. Bufor jest następnie wyczyszczone.  
  
 Użyj <xref:System.IO.FileStream.Flush%28System.Boolean%29> przeciążenie metody, gdy chcesz zapewnić wszystkie buforowane dane w pliku pośredniego buforów są zapisywane na dysku.  
  
   
  
## Examples  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.FileStream.Lock%2A> metody.  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień jest zamknięty.</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> Aby opróżnić wszystkie bufory pliku pośredniego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku, a także czyści wszystkie bufory pośredniego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, gdy chcesz zapewnić wszystkie buforowane dane w pliku pośredniego buforów są zapisywane na dysku.  
  
 Podczas wywoływania <xref:System.IO.FileStream.Flush%2A> również jest opróżniany metody buforu systemu operacyjnego we/wy.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie usuwa wszystkie bufory dla tego strumienia, powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia i monitoruje żądania anulowania.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operację opróżniania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wywoływania <xref:System.IO.FileStream.FlushAsync%2A> również jest opróżniany metody buforu systemu operacyjnego we/wy.  
  
 Jeśli operacja została anulowana przed ukończeniem działania, zwrócone zadania zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości. Jeśli zostanie usunięty, dojście do pliku, zwrócone zadania zawiera <xref:System.ObjectDisposedException> wyjątek w <xref:System.Threading.Tasks.Task.Exception%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt hermetyzujący listę kontroli dostępu (ACL) wpisy kontroli dostępu dla pliku opisanego przez bieżący <see cref="T:System.IO.FileStream" /> obiektu.</summary>
        <returns>Obiekt hermetyzujący ustawienia kontroli dostępu dla pliku opisanego przez bieżący <see cref="T:System.IO.FileStream" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.IO.FileStream> klasy i <xref:System.IO.FileStream.GetAccessControl%2A> można pobrać listę kontroli dostępu (ACL) wpisy kontroli dostępu do istniejącego pliku, należy rozważyć użycie <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> metody, w jakiej jest łatwiejsza w użyciu.  
  
 Użyj <xref:System.IO.FileStream.GetAccessControl%2A> metoda pobierania wpisów list ACL dla pliku.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji na dany plik. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten plik będzie zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Ta operacja nie jest obsługiwane na bieżącej platformie.  - lub - obiekt wywołujący nie ma wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście do pliku systemu operacyjnego dla pliku bieżącego <see langword="FileStream" /> hermetyzuje obiektu.</summary>
        <value>Dojście do pliku systemu operacyjnego dla pliku hermetyzowany to <see langword="FileStream" /> obiektu lub wartość-1, jeśli <see langword="FileStream" /> został zamknięty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest dojścia systemu operacyjnego do użycia z wywołań systemu operacyjnego — dostarczane przez system (takich jak `ReadFile` w systemie Windows). Nie będą działać funkcje biblioteki C, które oczekują deskryptorów plików, takich jak `fread`.  
  
 Dojście systemu operacyjnego może być otwarte synchronicznie lub asynchronicznie, w zależności od tego, który `FileStream` konstruktor został wywołany. Użyj <xref:System.IO.FileStream.IsAsync%2A> właściwości, aby dowiedzieć się, czy to dojście zostało otwarte asynchronicznie. W Win32, oznacza, że dojście zostało otwarte dla pokrywającej się z inną operacji We/Wy i wymaga różnych parametrów do `ReadFile` i `WriteFile`.  
  
> [!CAUTION]
>  Może spowodować uszkodzenie danych, jeśli `FileStream` jest utworzony, jest przekazywany uchwytu, niektórych operacji przesunie wskaźnik pliku uchwytu, a następnie `FileStream` jest używane ponownie. Wiele wątków nie może bezpiecznie zapisać do tego samego pliku jednocześnie, oraz `FileStream` buforowanie kodu zakłada, że wyłącznie kontroluje dojście. `FileStream` może zgłosić <xref:System.IO.IOException> Jeśli `FileStream` wykryje, że w innym procesie przeniósł wskaźnika pliku. Aby tego uniknąć, nie zapisuj żadnych danych do części pliku, który `FileStream` może mieć buforowane i przywrócić wskaźnika pliku lokalizacji miał zostały ostatnio wywołanego metod na `FileStream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> akcji zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see langword="FileStream" /> zostało otwarte asynchronicznie lub synchronicznie.</summary>
        <value>
          <see langword="true" /> Jeśli <see langword="FileStream" /> zostało otwarte asynchronicznie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsAsync` Właściwości wykrywa, czy `FileStream` dojście zostało otwarte asynchronicznie, włączanie kod, aby używał <xref:System.IO.FileStream.Handle%2A> właściwości poprawnie. W systemie Win32 `IsAsync` jest wartość PRAWDA oznacza, że dojście zostało otwarte dla pokrywającej się z inną operacji We/Wy i w związku z tym wymaga różnych parametrów do `ReadFile` i `WriteFile`.  
  
 Tę wartość można określić podczas tworzenia wystąpienia <xref:System.IO.FileStream> przy użyciu konstruktora, który ma `isAsync`, `useAsync`, lub `options` parametru. Gdy ta właściwość jest `true`, strumienia wykorzystuje pokrywającej się z inną operacji We/Wy do wykonywania operacji na plikach asynchronicznie. Jednak <xref:System.IO.FileStream.IsAsync%2A> właściwość nie ma być `true` do wywołania <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, lub <xref:System.IO.Stream.CopyToAsync%2A> metody. Gdy <xref:System.IO.FileStream.IsAsync%2A> jest właściwość `false` wywołania asynchronicznego odczytu i zapisu, wątku interfejsu użytkownika nie nadal jest zablokowany, ale rzeczywisty operacji We/Wy jest wykonywana synchronicznie.  
  
   
  
## Examples  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość w bajtach strumienia.</summary>
        <value>Wartość typu long reprezentujący długość strumienia w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `Length` i `Position` właściwości, aby sprawdzić warunku końca pliku.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.FileStream.CanSeek" /> Ten strumień jest <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak plik zostanie zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Początek zakresu do zablokowania. Wartość tego parametru musi być równa lub większa niż zero (0).</param>
        <param name="length">Zakres do zablokowania.</param>
        <summary>Zapobiega inne procesy Odczyt lub zapis do <see cref="T:System.IO.FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Blokowanie zakresu strumień pliku daje wątki blokowania wyłącznego dostępu procesu do tego zakresu strumienia pliku.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można zablokować części pliku, tak aby inny proces nie ma dostępu do części pliku, nawet jeśli ma dostęp do odczytu/zapisu do pliku. Uruchom program jednocześnie w różnych polecenia systemu windows i zbadać za pomocą opcji wejściowych konsoli inną.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> lub <paramref name="length" /> jest ujemna.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten plik będzie zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Proces nie może uzyskać dostępu do pliku, ponieważ inny proces zablokował część pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę <see langword="FileStream" /> przekazany do konstruktora.</summary>
        <value>Ciąg znaków będący nazwą <see langword="FileStream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> konstruktora.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą pozycję tego strumienia.</summary>
        <value>Bieżąca pozycja tego strumienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie w dowolne miejsce powyżej długość strumienia jest obsługiwana.  Podczas wyszukiwania powyżej długość pliku zwiększania rozmiaru pliku.  W systemie Microsoft Windows NT i nowszych danymi, które zostały dodane na końcu pliku zostaje ustawiony na zero.  W systemie Microsoft Windows 98 lub starszym danymi, które zostały dodane na końcu pliku nie ustawiono na wartość 0, co oznacza, że wcześniej usunięty danych jest widoczny w strumieniu. Ustawienie pozycji strumienia duża wartość za końcem strumienia w systemie Windows 98 lub starszym może spowodować wyjątek.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `Length` i `Position` właściwości, aby sprawdzić warunku końca pliku.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje wyszukiwania.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.  \- lub - pozycja została ustawiona na bardzo dużą wartość za końcem strumienia w systemie Windows 98 lub wcześniej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Podjęto próbę ustawienia pozycji w wartości ujemnej.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Nastąpiła próba znalezienia poza koniec strumienia, który nie jest to obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Po powrocie z tej metody zawiera określonej tablicy bajtów z wartością pomiędzy <c>przesunięcie</c> i (<c>przesunięcie</c> + <c>liczba</c> - 1<c>)</c> zastępuje Bajty odczytane z bieżącego źródła.</param>
        <param name="offset">Przesunięcie bajtów w <c>tablicy</c> , w której zostaną umieszczone odczytywanych bajtów.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <summary>Odczytuje blok bajtów ze strumienia i zapisuje dane w buforze danego.</summary>
        <returns>Całkowita liczba bajtów odczytanych w buforze. Przyczyną może być mniejsza niż żądana liczba bajtów podanej liczby bajtów nie są obecnie dostępne, czy zero, jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.Stream.Read%2A>.  
  
 `offset` Parametru zapewnia Przesunięcie bajtów w `array` (indeks bufora) w którym ma rozpocząć się odczyt i `count` parametru zapewnia maksymalną liczbę bajtów do odczytu tego strumienia. Zwrócona wartość jest rzeczywista liczba bajtów odczytanych lub zero, jeśli zostanie osiągnięty koniec strumienia. Jeśli operacja odczytu zakończy się pomyślnie, bieżącej pozycji strumienia jest zaawansowane przez liczbę bajtów do odczytu. Jeśli wystąpi wyjątek, bieżącej pozycji strumienia jest bez zmian.  
  
 <xref:System.IO.FileStream.Read%2A> Metoda zwraca zero tylko po dojściu do końca strumienia. W przeciwnym razie <xref:System.IO.FileStream.Read%2A> ma zawsze wartość co najmniej jednego bajtu ze strumienia przed zwróceniem. Jeśli dane są niedostępne, ze strumienia po wywołaniu <xref:System.IO.FileStream.Read%2A>, metoda zablokuje dopóki co najmniej jednego bajtu danych może być zwracany. Implementacja jest bezpłatna do zwrócenia mniej bajtów niż żądana, nawet jeżeli nie osiągnięto koniec strumienia.  
  
 Użyj <xref:System.IO.BinaryReader> do odczytywania typy pierwotne danych.  
  
 Nie przerywają pracy wątku, który wykonuje operację odczytu. Mimo że aplikacja może pojawić się działał poprawnie, gdy wątek jest odblokowany, przerwanie może spowodować spadek wydajności i niezawodności aplikacji.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład odczytuje zawartość z <xref:System.IO.FileStream> i zapisuje go w innym <xref:System.IO.FileStream>.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> i <paramref name="count" /> opisano nieprawidłowy zakres w <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zapisu danych do.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> jaką rozpocząć pisanie danych ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie odczytuje sekwencję bajtów ze strumienia bieżącego zmienia pozycję w strumieniu przez liczbę bajtów odczytanych i monitoruje żądań anulowania.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametr zawiera całkowitą liczbę bajtów odczytanych w buforze. Wartość wyniku może być mniejsza niż żądana liczba bajtów Liczba dostępnych bajtów jest mniejsza niż żądany numer, czy może być 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.ReadAsync%2A> Metody umożliwia wykonywanie operacji na plikach obciążający zasoby bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.  
  
 Użyj <xref:System.IO.FileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.  
  
 Jeśli operacja została anulowana przed ukończeniem działania, zwrócone zadania zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości. Jeśli zostanie usunięty, dojście do pliku, zwrócone zadania zawiera <xref:System.ObjectDisposedException> wyjątek w <xref:System.Threading.Tasks.Task.Exception%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można odczytać z pliku asynchronicznie.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bajt z pliku i zwiększa położenie odczytu jednego bajtu.</summary>
        <returns>Byte, rzutować <see cref="T:System.Int32" />, lub wartość -1, jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Użyj <xref:System.IO.FileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zapisać danych do pliku bajtów za bajtem, a następnie sprawdź, czy dane zostały poprawnie zapisane.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżący strumień jest zamknięty.</exception>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja na <see langword="Stream" /> tworzy nową macierz jednobajtowe, a następnie wywołuje <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Jest to poprawny formalnie, jest nieefektywne. Strumieniem z buforu wewnętrznego należy przesłonić tę metodę i zapewnić bardziej efektywnego wersji, która odczytuje buforu bezpośrednio, unikając alokacji dodatkowe tablicy przy każdym wywołaniu.  Listę typowych plików i operacje katalogu Zobacz [Tasks](~/docs/standard/io/common-i-o-tasks.md) typowych operacji We/Wy.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> obiekt, który reprezentuje dojście do pliku systemu operacyjnego dla pliku który bieżącego <see cref="T:System.IO.FileStream" /> hermetyzuje obiektu.</summary>
        <value>Obiekt reprezentujący dojście do pliku systemu operacyjnego dla pliku który bieżącego <see cref="T:System.IO.FileStream" /> hermetyzuje obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.SafeFileHandle%2A> Właściwość opróżnienia strumienia i automatycznie ustawia bieżącej pozycji strumienia na 0.  Dzięki temu można przenieść pliku lub pozycji strumienia można zresetować za pomocą innego strumienia <xref:System.IO.FileStream.SafeFileHandle%2A> zwracane przez tę właściwość.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.  Akcja zabezpieczeń: wyliczenie skojarzone żądanie łącza: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Punkt względem <c>pochodzenia</c> w której chcesz rozpocząć wyszukiwanie.</param>
        <param name="origin">Określa początek, końcu lub bieżącą pozycję jako punkt odniesienia dla <c>przesunięcie</c>, za pomocą wartości typu <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Ustawia bieżącą pozycję tego strumienia podanej wartości.</summary>
        <returns>Nowa pozycja w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Użyj <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> właściwości w celu określenia, czy bieżące wystąpienie obsługuje operacji wyszukiwania. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 Można wyszukiwać, w dowolnej lokalizacji poza długość strumienia. Podczas wyszukiwania powyżej długość pliku zwiększania rozmiaru pliku. W systemie Windows NT i nowszych wersjach danych dodawane na końcu pliku jest równa zero. Windows 98 lub starszych wersji danych dodawane na końcu pliku nie ustawiono na wartość 0, co oznacza, że wcześniej usunięty danych jest widoczny w strumieniu.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zapisać danych do pliku bajtów za bajtem, a następnie sprawdź, czy dane zostały poprawnie zapisane.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 Poniższy przykład odczytuje tekst w kierunku odwrotnym od końca pliku na początku pliku przy użyciu różnych <xref:System.IO.SeekOrigin> wartości z <xref:System.IO.FileStream.Seek%2A> metody.  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje wyszukiwania, np. Jeśli <see langword="FileStream" /> jest tworzony z potoku lub konsola danych wyjściowych.</exception>
        <exception cref="T:System.ArgumentException">Wyszukiwanie nastąpiła przed początkiem strumienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Obiekt wpisu na liście ACL, aby zastosować do bieżącego pliku.</param>
        <summary>Stosuje listę kontroli dostępu (ACL) wpisów kontroli dostępu, opisanego przez <see cref="T:System.Security.AccessControl.FileSecurity" /> obiektu do pliku opisanego przez bieżący <see cref="T:System.IO.FileStream" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas <xref:System.IO.FileStream> klasy i <xref:System.IO.FileStream.SetAccessControl%2A> mogą być używane na istniejący plik, należy rozważyć użycie <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> metody, w jakiej jest łatwiejsza w użyciu.  
  
 <xref:System.IO.FileStream.SetAccessControl%2A> Metoda stosowana wpisów listę kontroli dostępu (ACL) kontroli dostępu do pliku, który reprezentuje noninherited listy ACL.  
  
> [!CAUTION]
>  Określona lista ACL dla `fileSecurity` parametru zastępuje istniejące listy ACL dla pliku. Aby dodać uprawnienia dla nowego użytkownika, należy użyć <xref:System.IO.FileStream.GetAccessControl%2A> metodę, aby uzyskać istniejące listy ACL, zmodyfikuj go, a następnie użyj <xref:System.IO.FileStream.SetAccessControl%2A> powrót do pliku.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji na dany plik. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten plik będzie zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileSecurity" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć lub modyfikacji pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący proces nie ma dostępu do otwierania pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nowe długość strumienia.</param>
        <summary>Ustawia długości tego strumienia podanej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.Stream.SetLength%2A>.  
  
 Jeśli dana wartość jest mniejsza niż bieżąca długość strumienia, zostanie obcięta strumienia. W tym scenariuszu jeśli bieżące położenie jest większa niż długość nowego bieżące położenie jest przenoszony do ostatniego bajtu strumienia. Jeśli dana wartość jest większa niż bieżąca długość strumienia, strumień jest rozwinięty, a bieżące położenie jest taka sama. Jeśli strumień jest rozwinięty, zawartość strumienia między stary i nowy długość jest niezdefiniowany.  
  
 Strumień musi obsługiwać zarówno zapisu i wyszukiwania dla `SetLength` do pracy.  
  
> [!NOTE]
>  Użyj <xref:System.IO.FileStream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis i <xref:System.IO.FileStream.CanSeek%2A> właściwości w celu określenia, czy wyszukiwanie jest obsługiwane. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanWrite%2A> i <xref:System.IO.Stream.CanSeek%2A>.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zarówno zapisu i wyszukiwania.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Podjęto próbę ustawienia <paramref name="value" /> parametr mniejszy niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Początek zakresu do odblokowania.</param>
        <param name="length">Zakres do odblokowania.</param>
        <summary>Umożliwia dostęp przez inne procesy do całości lub części pliku, który wcześniej był zablokowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można zablokować części pliku, inny proces nie może uzyskać dostępu do części pliku, nawet jeśli ma dostęp do odczytu/zapisu do pliku i odblokowania określonej części pliku. Uruchom program jednocześnie w różnych polecenia systemu windows i zbadać za pomocą opcji wejściowych konsoli inną.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> lub <paramref name="length" /> jest ujemna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Bufor zawierający dane do zapisania w strumieniu.</param>
        <param name="offset">Zerze przesunięcie w <c>tablicy</c> z którego należy zacząć kopiowanie bajtów do strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Zapisuje blok bajtów do strumienia pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.Stream.Write%2A>.  
  
 `offset` Parametru zapewnia Przesunięcie bajtów w `array` (indeks bufora) od którego należy zacząć kopiowanie i `count` parametru zapewnia liczba bajtów, które zostaną zapisane w strumieniu. Jeśli operacja zapisu zakończy się pomyślnie, bieżącej pozycji strumienia jest zaawansowane przez liczba zapisanych bajtów. Jeśli wystąpi wyjątek, bieżącej pozycji strumienia jest bez zmian.  
  
> [!NOTE]
>  Użyj <xref:System.IO.FileStream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanWrite%2A>.  
  
 Nie przerywają pracy wątku, który wykonuje operację zapisu. Mimo że aplikacja może pojawić się działał poprawnie, gdy wątek jest odblokowany, przerwanie może spowodować spadek wydajności i niezawodności aplikacji.  
  
 Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.IO.FileStream.Lock%2A> metody.  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> i <paramref name="count" /> opisano nieprawidłowy zakres w <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.  \- lub - inny wątek spowodował nieoczekiwane zmiany w pozycji dojście do pliku systemu operacyjnego.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżące wystąpienie strumień nie obsługuje zapisywania.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zapisywania danych z.</param>
        <param name="offset">Zerze przesunięcie w <c>buforu</c> z którego należy zacząć kopiowanie bajtów do strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie zapisuje sekwencję bajtów do strumienia bieżącego przesuwa bieżącą pozycję w tym strumieniu przez liczba zapisanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.WriteAsync%2A> Metody umożliwia wykonywanie operacji na plikach obciążający zasoby bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.  
  
 Użyj <xref:System.IO.FileStream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 Jeśli operacja została anulowana przed ukończeniem działania, zwrócone zadania zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości. Jeśli zostanie usunięty, dojście do pliku, zwrócone zadania zawiera <xref:System.ObjectDisposedException> wyjątek w <xref:System.Threading.Tasks.Task.Exception%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób zapisania asynchronicznie do pliku.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Bajtów do zapisania w strumieniu.</param>
        <summary>Zapisuje bajt bieżącą pozycję w strumieniu plików.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.Stream.WriteByte%2A>.  
  
 Użyj `WriteByte` do bajtów do zapisania `FileStream` wydajnie. Jeśli strumień jest zamknięty lub nie jest zapisywalny, zostanie wygenerowany wyjątek.  
  
> [!NOTE]
>  Użyj <xref:System.IO.FileStream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zapisać danych do pliku bajtów za bajtem, a następnie sprawdź, czy dane zostały poprawnie zapisane.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania.</exception>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja na <see langword="Stream" /> tworzy nową macierz jednobajtowe, a następnie wywołuje <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Jest to poprawny formalnie, jest nieefektywne. Strumieniem z buforu wewnętrznego należy przesłonić tę metodę i zapewnić bardziej efektywnego wersji, która odczytuje buforu bezpośrednio, unikając alokacji dodatkowe tablicy przy każdym wywołaniu.  Listę typowych plików i operacje katalogu Zobacz [Tasks](~/docs/standard/io/common-i-o-tasks.md) typowych operacji We/Wy.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
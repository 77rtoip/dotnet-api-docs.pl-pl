<Type Name="BufferedStream" FullName="System.IO.BufferedStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="844e045e034922791bd6f5c66770ed7166f90a00" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52255084" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class BufferedStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BufferedStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.BufferedStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BufferedStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class BufferedStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type BufferedStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Dodaje buforowania warstwę do odczytu i zapisu w innej usłudze stream. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bufor to blok bajtów pamięci używanej do buforowania danych, zmniejszając liczbę wezwań do systemu operacyjnego. Bufory poprawić odczytu i zapisu wydajności. Bufor może służyć odczytu lub zapisu, ale nigdy nie obu jednocześnie. <xref:System.IO.BufferedStream.Read%2A> i <xref:System.IO.BufferedStream.Write%2A> metody `BufferedStream` automatycznie Obsługa buforu.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niej. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> method in Class metoda `try` / `catch` bloku. Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.  
  
 `BufferedStream` może składać się wokół niektórych rodzajów strumieni. Oferuje ona implementacji Odczyt i zapis bajtów do bazowego źródła danych lub repozytorium. Użyj <xref:System.IO.BinaryReader> i <xref:System.IO.BinaryWriter> do odczytywania i zapisywania inne typy danych. `BufferedStream` jest przeznaczony do uniemożliwić spowalniania dane wejściowe i wyjściowe, gdy bufor nie jest potrzebne w buforze. Jeśli zawsze odczytu i zapisu dla o rozmiarze większym niż rozmiar wewnętrznego buforu następnie `BufferedStream` nawet nie może przydzielić buforu wewnętrznego. `BufferedStream` również buforuje operacji odczytu i zapisu do udostępnionego buforu. Zakłada się, że będzie prawie zawsze można wykonać szereg odczyty lub zapisy, ale rzadko zamiennie dwa z nich.  
  
   
  
## Examples  
 W poniższych przykładach kodu pokazano sposób użycia `BufferedStream` klasy za pośrednictwem `NetworkStream` klasy, aby zwiększyć wydajność niektórych operacji We/Wy. Uruchom serwer na komputerze zdalnym przed uruchomieniem klienta. Określ nazwę komputera zdalnego jako argument wiersza polecenia, podczas uruchamiania klienta. Różnią się `dataArraySize` i `streamBufferSize` stałe, aby wyświetlić ich wpływ na wydajność.  
  
 Pierwszy przykład pokazuje kod, który jest uruchamiany na kliencie, a drugi przykład przedstawia kod, który jest uruchamiany na serwerze.  
  
 **Przykład 1: Kod uruchamiany na kliencie**  
  
 [!code-cpp[System.IO.BufferedStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#1)]
 [!code-csharp[System.IO.BufferedStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#1)]
 [!code-vb[System.IO.BufferedStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#1)]  
  
 **Przykład 2: Kod, który działa na serwerze**  
  
 [!code-cpp[System.IO.BufferedStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CPP/server.cpp#1)]
 [!code-csharp[System.IO.BufferedStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CS/server.cs#1)]
 [!code-vb[System.IO.BufferedStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream2/VB/server.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.Stream" />
    <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.BufferedStream" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Bieżący strumień.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.BufferedStream" /> klasy za pomocą domyślny rozmiar buforu 4096 bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Buforu udostępnionego odczytu/zapisu jest przydzielany po raz pierwszy `BufferedStream` obiekt jest inicjowany za pomocą tego konstruktora. Buforu udostępnionego nie jest używane, jeśli wszystkie odczyty i zapisy są większe niż lub równa `bufferSize`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream * int -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream (stream, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Bieżący strumień.</param>
        <param name="bufferSize">Rozmiar buforu w bajtach.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.BufferedStream" /> klasy przy użyciu określony rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Buforu udostępnionego odczytu/zapisu jest przydzielany po raz pierwszy `BufferedStream` obiekt jest inicjowany za pomocą tego konstruktora. Buforu udostępnionego nie jest używane, jeśli wszystkie odczyty i zapisy są większe niż lub równa `bufferSize`.  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.IO.BufferedStream> klasy.  
  
 [!code-cpp[System.IO.BufferedStream1#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#2)]
 [!code-csharp[System.IO.BufferedStream1#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#2)]
 [!code-vb[System.IO.BufferedStream1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ma wartość ujemną.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do wczytania danych.</param>
        <param name="offset">Przesunięcie w bajtach w <paramref name="buffer" /> od którego należy rozpocząć pisanie dane odczytane ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana, gdy odczytu zostało zakończone.</param>
        <param name="state">Obiekt dostarczony przez użytkownika, który odróżnia to asynchroniczne żądanie odczytu od innych żądań.</param>
        <summary>Rozpoczyna operację odczytu asynchronicznego. (Należy wziąć pod uwagę przy użyciu <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast.)</summary>
        <returns>Obiekt, który reprezentuje odczyt asynchroniczny, co może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework 4 i starszych wersjach, należy używać metod takich jak <xref:System.IO.Stream.BeginRead%2A> i <xref:System.IO.Stream.EndRead%2A> do zaimplementowania asynchroniczne operacje na plikach. Te metody są wciąż dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, i <xref:System.IO.BufferedStream.FlushAsync%2A>, pomoc, aby łatwiej implementować asynchroniczne operacje na plikach.  
  
 <xref:System.IO.BufferedStream.EndWrite%2A> musi zostać wywołana tylko raz dla każdego wywołania <xref:System.IO.BufferedStream.BeginRead%2A>. Kończy się niepowodzeniem zakończyć proces odczytu przed rozpoczęciem innego odczytu może spowodować niepożądane zachowanie, takich jak zakleszczenia.  
  
> [!NOTE]
>  Użyj <xref:System.IO.BufferedStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje Odczyt.  
  
 <xref:System.IO.BufferedStream.EndRead%2A> musi zostać wywołany z tym <xref:System.IAsyncResult> Aby dowiedzieć się, ile bajtów zostały wczytane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Podjęto próbę odczyt asynchroniczny poza koniec strumienia.</exception>
        <exception cref="T:System.ArgumentException">Długość buforu pomniejszona o <paramref name="offset" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje operacji odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zawierający dane do zapisu do bieżącego strumienia.</param>
        <param name="offset">Zerze przesunięcie w <paramref name="buffer" /> od którego należy zacząć kopiowanie bajtów do bieżącego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="callback">Metoda wywoływana po zakończeniu asynchroniczny zapis operacji.</param>
        <param name="state">Obiekt dostarczony przez użytkownika, który odróżnia to żądanie określonego asynchroniczny zapis od innych żądań.</param>
        <summary>Rozpoczyna operację asynchronicznego zapisu. (Należy wziąć pod uwagę przy użyciu <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast.)</summary>
        <returns>Obiekt, który odwołuje się do asynchronicznego zapisu, co może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework 4 i starszych wersjach, należy używać metod takich jak <xref:System.IO.Stream.BeginWrite%2A> i <xref:System.IO.Stream.EndWrite%2A> do zaimplementowania asynchroniczne operacje na plikach. Te metody są wciąż dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, i <xref:System.IO.BufferedStream.FlushAsync%2A>, pomoc, aby łatwiej implementować asynchroniczne operacje na plikach.  
  
 <xref:System.IO.BufferedStream.EndWrite%2A> musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult> z <xref:System.IO.BufferedStream.BeginWrite%2A>. <xref:System.IO.BufferedStream.EndWrite%2A> blokuje, dopóki nie zakończy się operacji We/Wy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffer" /> Długość minus <paramref name="offset" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferSize">
      <MemberSignature Language="C#" Value="public int BufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.BufferSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BufferSize : int" Usage="System.IO.BufferedStream.BufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.BufferedStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje Odczyt.</summary>
        <value>
          <see langword="true" /> Jeśli strumień obsługuje Odczyt; <see langword="false" /> Jeśli strumień jest zamknięty lub został otwarty z dostępem tylko do zapisu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasa jest pochodną <xref:System.IO.Stream> nie obsługuje odczytu, wywołania <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>i `Peek` metody <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, i <xref:System.IO.TextReader> throw <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, właściwość ta zwraca `false`.  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.IO.BufferedStream> klasy.  
  
 [!code-cpp[System.IO.BufferedStream1#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#5)]
 [!code-csharp[System.IO.BufferedStream1#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#5)]
 [!code-vb[System.IO.BufferedStream1#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.BufferedStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje wyszukiwanie.</summary>
        <value>
          <see langword="true" /> Jeśli strumień obsługuje wyszukiwanie; <see langword="false" /> czy strumień jest zamknięty, czy strumień został zbudowany z dojście systemu operacyjnego, takie jak potoku lub dane wyjściowe do konsoli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasa jest pochodną <xref:System.IO.Stream> nie obsługuje wyszukiwania, wywołania <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, i <xref:System.IO.BufferedStream.Seek%2A> throw <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, właściwość ta zwraca `false`.  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.IO.BufferedStream> klasy.  
  
 [!code-cpp[System.IO.BufferedStream1#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#3)]
 [!code-csharp[System.IO.BufferedStream1#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#3)]
 [!code-vb[System.IO.BufferedStream1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.SetLength(System.Int64)" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.BufferedStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje zapis.</summary>
        <value>
          <see langword="true" /> Jeśli strumień obsługuje pisanie; <see langword="false" /> Jeśli strumień jest zamknięty lub został otwarty z dostępem tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasa jest pochodną <xref:System.IO.Stream> nie obsługuje zapisywania wywołanie <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, lub <xref:System.IO.BufferedStream.WriteByte%2A> zgłasza <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, właściwość ta zwraca `false`.  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.IO.BufferedStream> klasy.  
  
 [!code-cpp[System.IO.BufferedStream1#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#4)]
 [!code-csharp[System.IO.BufferedStream1#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#4)]
 [!code-vb[System.IO.BufferedStream1#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="bufferedStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="bufferedStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="bufferedStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekującego żądania asynchronicznego oczekiwania.</param>
        <summary>Czeka na zakończenie oczekujących operacji odczytu asynchronicznego. (Należy wziąć pod uwagę przy użyciu <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast.)</summary>
        <returns>Liczba odczytanych bajtów ze strumienia, od 0 (zero) oraz liczbę bajtów, której szukasz. Strumienie tylko zwracają 0 tylko na końcu strumienia, w przeciwnym razie należy zablokować do czasu udostępnienia co najmniej 1 bajt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework 4 i starszych wersjach, należy używać metod takich jak <xref:System.IO.Stream.BeginRead%2A> i <xref:System.IO.Stream.EndRead%2A> do zaimplementowania asynchroniczne operacje na plikach. Te metody są wciąż dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, i <xref:System.IO.BufferedStream.FlushAsync%2A>, pomoc, aby łatwiej implementować asynchroniczne operacje na plikach.  
  
 <xref:System.IO.BufferedStream.EndRead%2A> musi zostać wywołany z tym <xref:System.IAsyncResult> Aby dowiedzieć się, ile bajtów zostały wczytane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">To <see cref="T:System.IAsyncResult" /> nie można utworzyć obiektu przez wywołanie metody <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> od tej klasy.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="bufferedStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądania asynchronicznego.</param>
        <summary>Kończy operację asynchronicznego zapisu i bloki, aż do zakończenia operacji We/Wy. (Należy wziąć pod uwagę przy użyciu <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> zamiast.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework 4 i starszych wersjach, należy używać metod takich jak <xref:System.IO.Stream.BeginWrite%2A> i <xref:System.IO.Stream.EndWrite%2A> do zaimplementowania asynchroniczne operacje na plikach. Te metody są wciąż dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, i <xref:System.IO.BufferedStream.FlushAsync%2A>, pomoc, aby łatwiej implementować asynchroniczne operacje na plikach.  
  
 <xref:System.IO.BufferedStream.EndWrite%2A> musi zostać wywołana tylko raz dla każdego wywołania <xref:System.IO.BufferedStream.BeginRead%2A>. Kończy się niepowodzeniem zakończyć proces odczytu przed rozpoczęciem inna operacja odczytu może spowodować zakleszczenia lub inne niepożądane zachowanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">To <see cref="T:System.IAsyncResult" /> nie można utworzyć obiektu przez wywołanie metody <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> od tej klasy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="bufferedStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie bufory tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w odpowiednie urządzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opróżnianie strumienia nie opróżnić jego podstawowej kodera, chyba że jawnie wywołać `Flush` lub <xref:System.IO.Stream.Close%2A>.  
  
 Jeśli używasz <xref:System.IO.BufferedStream.%23ctor%2A> konstruktora, w związku z tym określający rozmiar bufora podczas tworzenia `BufferedStream` obiektów i zawartości jest opróżniany, gdy osiągnie rozmiar buforu. Na przykład kod taki jak `BufferedStream bs = new BufferedStream(bs, 5)` opróżniania zawartość, gdy rozmiar buforu osiągnie 5 bajtów.  
  
 Wszystkie metody odczytu i zapisu z `BufferedStream` automatycznie zachować bufor, więc nie trzeba wywołać `Flush` podczas przełączania do i z powrotem między odczytu i zapisu.  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.IO.BufferedStream> klasy.  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.IO.IOException">Źródła danych lub repozytorium nie jest otwarty.</exception>
        <altmember cref="M:System.IO.Stream.Close" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie usuwa wszystkie bufory tego strumienia, powoduje, że wszystkie buforowane dane są zapisywane w odpowiednie urządzenia i monitoruje żądania anulowania.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operację opróżniania.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.BufferedStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość strumienia bajtów.</summary>
        <value>Długość strumienia, w bajtach.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Zasadniczy strumień jest <see langword="null" /> "lub" zamknięte.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje wyszukiwania.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po strumień został zamknięty.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.BufferedStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera położenie w obrębie bieżącego strumienia.</summary>
        <value>Położenie w obrębie bieżącego strumienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `get` Wywołuje metody dostępu <xref:System.IO.BufferedStream.Seek%2A> uzyskać bieżącą pozycję w zasadniczy strumień i ustala tę wartość, zgodnie z bieżącą pozycję w buforze.  
  
 `set` Dostępu kopiuje wszystkie dane, które wcześniej zostały zapisane w buforze do źródłowego strumienia, a następnie wywołuje <xref:System.IO.BufferedStream.Seek%2A>.  
  
 Wyszukiwanie w dowolne miejsce poza długość strumienia jest obsługiwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość przekazana do <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy, takich jak strumień jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje wyszukiwania.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po strumień został zamknięty.</exception>
        <altmember cref="P:System.IO.BufferedStream.CanSeek" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="bufferedStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Bufor, do którego mają zostać skopiowane bajtów.</param>
        <param name="offset">Przesunięcie bajtów w buforze, od którego ma zostać rozpoczęte odczytywanie bajtów.</param>
        <param name="count">Liczba bajtów do odczytania.</param>
        <summary>Kopie bajtów z buforowanego strumienia bieżącej tablicy.</summary>
        <returns>Całkowita liczba bajtów jest wczytywany <paramref name="array" />. Może to być mniejsza niż żądana liczba bajtów, jeśli czy liczby bajtów nie są obecnie dostępne, lub 0, jeśli osiągnięto koniec strumienia, zanim wszystkie dane mogą być odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Read` Metoda zwróci wartość 0 tylko wtedy, gdy osiągnięty zostanie koniec strumienia. We wszystkich innych przypadkach `Read` ma zawsze wartość co najmniej jednego bajtu ze strumienia przed zwróceniem. Zgodnie z definicją, jeśli żadne dane nie są dostępne ze strumienia po wywołaniu `Read`, `Read` metoda zwróci wartość 0 (koniec strumienia osiągnięciu automatycznie). Implementacja jest bezpłatny do zwrócenia mniej bajtów niż żądany, nawet jeżeli nie osiągnięto koniec strumienia.  
  
 Użyj <xref:System.IO.BinaryReader> do odczytywania pierwotne typy danych.  
  
   
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.IO.BufferedStream> klasy.  
  
 [!code-cpp[System.IO.BufferedStream1#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#7)]
 [!code-csharp[System.IO.BufferedStream1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#7)]
 [!code-vb[System.IO.BufferedStream1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="array" /> minus <paramref name="offset" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest otwarty lub <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po strumień został zamknięty.</exception>
        <altmember cref="M:System.Buffer.BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="P:System.IO.BufferedStream.CanRead" />
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zapisu danych do.</param>
        <param name="offset">Przesunięcie w bajtach w <paramref name="buffer" /> od którego należy rozpocząć zapisywanie danych ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie odczytuje sekwencji bajtów ze strumienia bieżącego przesuwa do przodu pozycję w strumieniu przez liczbę odczytanych bajtów i monitoruje żądań anulowania.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametr zawiera całkowitą liczbę bajtów odczytanych w buforze. Wartość wyniku może być mniejsza niż żądana liczba bajtów, jeśli liczba obecnie dostępnych bajtów jest mniejsza niż żądana liczba lub może być 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz utworzyć token anulowania, tworzenia wystąpienia obiektu <xref:System.Threading.CancellationTokenSource> klasy i przekazywanie <xref:System.Threading.CancellationTokenSource.Token%2A> właściwość jako `cancellationToken` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="bufferedStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zasadniczy strumień bajtów i zwraca bajt rzutować <see langword="int" />, lub zwraca wartość -1, jeśli podczas odczytywania z koniec strumienia.</summary>
        <returns>Bajt rzutować <see langword="int" />, lub wartość -1, jeśli podczas odczytywania z koniec strumienia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy, takich jak strumień jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po strumień został zamknięty.</exception>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja na <see langword="Stream" /> tworzy nową tablicę pojedynczych bajtów, a następnie wywołuje <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Chociaż formalnie tak jest, jest nieefektywne. Dowolny strumień z buforu wewnętrznego należy przesłonić tę metodę i zapewnia znacznie bardziej efektywne wersję, która odczytuje buforu bezpośrednio, unikając alokacji dodatkowe tablicy przy każdym wywołaniu.</para>
        </block>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="bufferedStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie bajtów, względem <paramref name="origin" />.</param>
        <param name="origin">Wartości typu <see cref="T:System.IO.SeekOrigin" /> wskazujące punkt odniesienia, z którego można uzyskać nowe miejsce.</param>
        <summary>Ustawia położenie w obrębie bieżącego buforowanego strumienia.</summary>
        <returns>Nowa pozycja w ciągu bieżącej buforowanego strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `offset` jest ujemna, nowe miejsce będzie poprzedzać pozycji określonej przez `origin` przez liczbę bajtów określoną przez `offset`. Jeśli `offset` wynosi 0, nowe miejsce będzie pozycji określonej przez `origin`. Jeśli `offset` jest dodatnia, pozycji określonej przez będą się odbywać w nowym położeniu `origin` przez liczbę bajtów określoną przez `offset`.  
  
 Gdy <xref:System.IO.BufferedStream> obiekt jest strumienia podstawowego dla <xref:System.IO.StreamReader> obiektu, wywołanie <xref:System.IO.BufferedStream.Seek%2A> metody może spowodować, że pozycja strumienia nie jest już odpowiadający pozycja buforu wewnętrznego w czytniku. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> metody; Jednakże, ta metoda zmniejsza wydajność i powinna być wywoływana tylko wtedy, gdy jest to absolutnie konieczne.  
  
 Wyszukiwanie w dowolne miejsce poza długość strumienia jest obsługiwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Strumień jest otwarty lub <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje wyszukiwania.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po strumień został zamknięty.</exception>
        <altmember cref="T:System.IO.SeekOrigin" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="bufferedStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Liczba całkowita wskazująca wymagana długość bieżącej buforowanego strumienia w bajtach.</param>
        <summary>Ustawia długość buforowanego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bufor jest opróżniany przed ustawieniem długość bazowego źródła danych lub repozytorium. Jeśli określona wartość jest mniejsza niż bieżąca długość buforowanego strumienia, zostanie obcięta buforowanego strumienia. Jeśli określona wartość jest większa niż bieżąca długość buforowanego strumienia, jest rozwinięta buforowanego strumienia. Buforowanego strumienia jest rozwinięta, zawartość buforowanego strumienia między stary i nowy długości, nie są zdefiniowane.  
  
 `SetLength` Opróżnia wszelkich zapisów buforowanego, jeśli to konieczne.  
  
 Strumień musi obsługiwać zarówno pisanie i znalezienia dla `SetLength` do pracy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> ma wartość ujemną.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest otwarty lub <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania i wyszukiwanie.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po strumień został zamknięty.</exception>
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream UnderlyingStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream UnderlyingStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.UnderlyingStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ UnderlyingStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingStream : System.IO.Stream" Usage="System.IO.BufferedStream.UnderlyingStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="bufferedStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica bajtów do skopiowania <paramref name="count" /> bajtów do bieżącego buforowanego strumienia.</param>
        <param name="offset">Przesunięcie w buforze, od którego należy zacząć kopiowanie bajtów do bieżącego buforowanego strumienia.</param>
        <param name="count">Liczba bajtów do zapisania bieżącego buforowanego strumienia.</param>
        <summary>Kopiuje bajtów do buforowanego strumienia i przesuwa bieżącą pozycję w buforowanego strumienia, liczba zapisanych bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.IO.BufferedStream> klasy.  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="array" /> minus <paramref name="offset" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po strumień został zamknięty.</exception>
        <altmember cref="P:System.IO.BufferedStream.CanWrite" />
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do zapisywania danych z.</param>
        <param name="offset">Zerze przesunięcie w <paramref name="buffer" /> z którego należy zacząć kopiowanie bajtów do strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie zapisuje sekwencję bajtów w strumieniu bieżącego bieżącą pozycję w tym strumieniu jest przesuwany o liczba zapisanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz utworzyć token anulowania, tworzenia wystąpienia obiektu <xref:System.Threading.CancellationTokenSource> klasy i przekazywanie <xref:System.Threading.CancellationTokenSource.Token%2A> właściwość jako `cancellationToken` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="bufferedStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Bajtów do zapisu do strumienia.</param>
        <summary>Zapisuje bajt bieżąca pozycja w buforowanego strumienia.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po strumień został zamknięty.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Porady: odczyt tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Porady: wpisywanie tekstu do pliku</related>
      </Docs>
    </Member>
  </Members>
</Type>
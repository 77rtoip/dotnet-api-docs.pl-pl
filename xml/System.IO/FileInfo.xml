<Type Name="FileInfo" FullName="System.IO.FileInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="02b15f53b39b1bf9a9c371680550a7121690bdf9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36484070" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit FileInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type FileInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia właściwości i metody tworzenia, kopiowanie, usuwanie, przenoszenie i otwieranie plików, wystąpienia i pomaga w tworzeniu <see cref="T:System.IO.FileStream" /> obiektów. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileInfo> klasy dla typowych operacji, takich jak kopiowanie, przenoszenie, zmiana nazwy, tworzenie, otwieranie, usuwanie i dołączanie do plików.  
  
 Jeśli przeprowadzasz wiele operacji na tym samym pliku, może być bardziej wydajne, aby użyć <xref:System.IO.FileInfo> wystąpienia metody zamiast odpowiednich metod statycznych <xref:System.IO.File> klasy, ponieważ kontrola zabezpieczeń nie zawsze jest konieczne.  
  
 Duża liczba <xref:System.IO.FileInfo> metody zwracają inne typy operacji We/Wy podczas tworzenia lub otwierania plików. Można używać innych typów je do dalszego modyfikowania pliku. Aby uzyskać więcej informacji, zobacz określonych <xref:System.IO.FileInfo> elementów członkowskich, takich jak <xref:System.IO.FileInfo.Open%2A>, <xref:System.IO.FileInfo.OpenRead%2A>, <xref:System.IO.FileInfo.OpenText%2A>, <xref:System.IO.FileInfo.CreateText%2A>, lub <xref:System.IO.FileInfo.Create%2A>.  
  
 Domyślnie pełna odczytu/zapisu do nowych plików dostęp do wszystkich użytkowników.  
  
 W poniższej tabeli opisano wyliczenia, które są używane, aby dostosować zachowanie różnych <xref:System.IO.FileInfo> metody.  
  
|Wyliczenie|Opis|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Określa odczytu i zapisu do pliku.|  
|<xref:System.IO.FileShare>|Określa poziom dostępu do pliku, który jest już używana.|  
|<xref:System.IO.FileMode>|Określa, czy zachowana lub zastąpienie zawartość istniejącego pliku i określa, czy żądania utworzenia istniejący plik spowodowało wyjątku.|  
  
> [!NOTE]
>  W elementach członkowskich, które akceptują ścieżki jako ciąg wejściowy że ścieżka musi być poprawnie sformułowany lub zgłoszony wyjątek. Na przykład jeśli ścieżka jest w pełni kwalifikowana, ale rozpoczyna się od spacji, ścieżka nie jest usuwane w metody klasy. W związku z tym ścieżka jest nieprawidłowo sformułowany i zgłoszony wyjątek. Podobnie ścieżkę lub kombinację ścieżki nie może być w pełni kwalifikowana dwa razy. Na przykład "c:\temp c:\windows" również zgłasza wyjątek w większości przypadków. Upewnij się, czy z ścieżki są poprawnie sformułowany, gdy przy użyciu metod, które przyjmują ciąg ścieżki.  
  
 W elementach członkowskich, które akceptują ścieżką ścieżka może odwoływać się do pliku lub po prostu katalogu. Określona ścieżka znajdują się ścieżką względną lub ścieżką Universal Naming Convention (UNC) dla nazwy serwera i udziału. Na przykład następujące są dopuszczalne ścieżki:  
  
-   "c:\\\MyDir\\\MyFile.txt" w języku C# lub "c:\MyDir\MyFile.txt" w języku Visual Basic.  
  
-   "c:\\\MyDir" w języku C# lub "c:\MyDir" w języku Visual Basic.  
  
-   "MyDir\\\MySubdir" w języku C# lub "MyDir\MySubDir" w języku Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" w języku C# lub "\\\MyServer\MyShare" w języku Visual Basic.  
  
 <xref:System.IO.FileInfo> Klasa udostępnia następujące właściwości, które umożliwiają pobieranie informacji o pliku. Na przykład sposobu używania każdej właściwości, zobacz strony właściwości.  
  
-   <xref:System.IO.FileInfo.Directory%2A> Właściwość pobiera obiekt reprezentujący plik w katalogu nadrzędnym.  
  
-   <xref:System.IO.FileInfo.DirectoryName%2A> Właściwość pobiera pełną ścieżkę pliku w katalogu nadrzędnym.  
  
-   <xref:System.IO.FileInfo.Exists%2A> Właściwość sprawdza obecność pliku przed wykonywaniem operacji na nim.  
  
-   <xref:System.IO.FileInfo.IsReadOnly%2A> Właściwość pobiera lub ustawia wartość określającą, czy plik może być modyfikowana.  
  
-   <xref:System.IO.FileInfo.Length%2A> Pobiera rozmiar pliku.  
  
-   <xref:System.IO.FileInfo.Name%2A> Pobiera nazwę pliku.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano niektóre główne członków `FileInfo` klasy.  
  
 W przypadku właściwości najpierw są pobierane, <xref:System.IO.FileInfo> wywołania <xref:System.IO.FileSystemInfo.Refresh%2A> — metoda i pamięci podręczne informacje o pliku. W kolejnych wywołaniach, należy wywołać <xref:System.IO.FileSystemInfo.Refresh%2A> Aby uzyskać najnowszą kopię informacji.  
  
 [!code-cpp[FInfo Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Class/CPP/finfo class.cpp#1)]
 [!code-csharp[FInfo Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Class/CS/finfo class.cs#1)]
 [!code-vb[FInfo Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Class/VB/finfo class.vb#1)]  
  
 W tym przykładzie generuje dane wyjściowe podobne do następującego.  
  
```  
Hello  
And  
Welcome  
C:\Users\userName\AppData\Local\Temp\tmp70AB.tmp was copied to C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp.  
C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp was successfully deleted.  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.DriveInfo" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileInfo(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.IO.FileInfo : string -&gt; System.IO.FileInfo" Usage="new System.IO.FileInfo fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">W pełni kwalifikowana nazwa nowego pliku lub nazwa pliku względną. Kończy się znakiem separatora katalogu ścieżkę.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileInfo" /> klasy, która działa jako otoki dla ścieżki pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić w pełni kwalifikowaną lub względną nazwę, ale kontrola zabezpieczeń pobiera w pełni kwalifikowana nazwa.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tego konstruktora, aby utworzyć dwa pliki, które następnie są zapisywane do odczytu, skopiować i usunięte.  
  
 [!code-cpp[finfo ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Ctor/CPP/finfo ctor.cpp#1)]
 [!code-csharp[finfo ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Ctor/CS/finfo ctor.cs#1)]
 [!code-vb[finfo ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Ctor/VB/finfo ctor.vb#1)]  
  
 Poniższy przykład otwiera istniejący plik lub tworzy plik dołącza tekstu do pliku i wyświetla wyniki.  
  
 [!code-cpp[fileinfomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfomain/CPP/fileinfomain.cpp#1)]
 [!code-csharp[fileinfomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfomain/CS/fileinfomain.cs#1)]
 [!code-vb[fileinfomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfomain/VB/fileinfomain.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">Nazwa pliku jest pusta, zawiera tylko białe znaki lub zawiera nieprawidłowe znaki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Dostęp do <paramref name="fileName" /> jest zabroniony.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="fileName" /> zawiera dwukropek (:) w środku ciągu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter AppendText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter AppendText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.AppendText" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ AppendText();" />
      <MemberSignature Language="F#" Value="member this.AppendText : unit -&gt; System.IO.StreamWriter" Usage="fileInfo.AppendText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.IO.StreamWriter" /> który dołącza tekstu do pliku reprezentowany przez to wystąpienie elementu <see cref="T:System.IO.FileInfo" />.</summary>
        <returns>Nowy <see langword="StreamWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie dołącza tekstu do pliku i odczytuje z pliku.  
  
 [!code-cpp[finfo appendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo AppendText/CPP/finfo appendtext.cpp#1)]
 [!code-csharp[finfo appendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo AppendText/CS/finfo appendtext.cs#1)]
 [!code-vb[finfo appendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo AppendText/VB/finfo appendtext.vb#1)]  
  
 Poniższy przykład przedstawia dołączanie tekst na końcu pliku oraz wyświetla również wynik operacji dołączania do konsoli. Ta procedura jest wywoływana, po raz pierwszy plik jest tworzony, jeśli nie istnieje. Po wykonaniu tej określony tekst jest dołączany do pliku.  
  
 [!code-cpp[fileinfoappendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoappendtext/CPP/fileinfoappendtext.cpp#1)]
 [!code-csharp[fileinfoappendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoappendtext/CS/fileinfoappendtext.cs#1)]
 [!code-vb[fileinfoappendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoappendtext/VB/fileinfoappendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Odczytywanie i dołączanie do plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje istniejący plik do nowego pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string -&gt; System.IO.FileInfo" Usage="fileInfo.CopyTo destFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">Nazwę można skopiować do nowego pliku.</param>
        <summary>Kopiuje istniejący plik do nowego pliku, brak zezwolenia zastępowanie istniejącego pliku.</summary>
        <returns>Nowy plik z w pełni kwalifikowana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileInfo.CopyTo%2A> metody, aby umożliwić zastępowanie istniejącego pliku.  
  
> [!CAUTION]
>  Jeśli to możliwe, należy unikać krótkich nazw plików (na przykład XXXXXX~1.XXX) przy użyciu tej metody. Jeśli dwa pliki mają równoważne krótkich nazw plików, a następnie ta metoda może zakończyć się niepowodzeniem i Zgłoś wyjątek i/lub spowodować niepożądane zachowanie  
  
   
  
## Examples  
 W poniższym przykładzie pokazano zarówno przeciążeń `CopyTo` metody.  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 W poniższym przykładzie pokazano kopiowanie plików do innego pliku, zgłoszeniu wyjątku, jeśli plik docelowy już istnieje.  
  
 [!code-cpp[FileInfoCopyTo1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileInfoCopyTo1/CPP/fileinfocopyto1.cpp#1)]
 [!code-csharp[FileInfoCopyTo1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileInfoCopyTo1/CS/fileinfocopyto1.cs#1)]
 [!code-vb[FileInfoCopyTo1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileInfoCopyTo1/VB/fileinfocopyto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> jest pusta, zawiera tylko białe znaki lub zawiera nieprawidłowe znaki.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd lub plik docelowy już istnieje.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Ścieżka katalogu jest przekazywany w lub plik jest przenoszony do innego dysku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog określony w <paramref name="destFileName" /> nie istnieje.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> zawiera dwukropek (:) w ciągu, ale nie określa woluminu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String, overwrite As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string * bool -&gt; System.IO.FileInfo" Usage="fileInfo.CopyTo (destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destFileName">Nazwę można skopiować do nowego pliku.</param>
        <param name="overwrite">
          <see langword="true" /> Aby umożliwić istniejącego pliku zostaną zastąpione; w przeciwnym razie <see langword="false" />.</param>
        <summary>Kopiuje istniejący plik do nowego pliku, co pozwala na zastępowanie istniejącego pliku.</summary>
        <returns>Nowy plik lub zastąpić istniejący plik, jeśli <paramref name="overwrite" /> jest <see langword="true" />. Jeśli plik istnieje i <paramref name="overwrite" /> jest <see langword="false" />, <see cref="T:System.IO.IOException" /> jest generowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby umożliwić lub uniemożliwić zastępowanie istniejącego pliku. Użyj <xref:System.IO.FileInfo.CopyTo%2A> metodę, aby zapobiec zastąpieniu istniejącego pliku domyślnie.  
  
> [!CAUTION]
>  Jeśli to możliwe, należy unikać krótkich nazw plików (na przykład XXXXXX~1.XXX) przy użyciu tej metody. Jeśli dwa pliki mają równoważne krótkich nazw plików, a następnie ta metoda może zakończyć się niepowodzeniem i Zgłoś wyjątek i/lub spowodować niepożądane zachowanie  
  
   
  
## Examples  
 W poniższym przykładzie pokazano zarówno przeciążeń `CopyTo` metody.  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 W poniższym przykładzie pokazano kopiowanie plików do innego pliku, określająca, czy zastąpić plik, który już istnieje.  
  
 [!code-cpp[fileinfocopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfocopyto/CPP/fileinfocopyto.cpp#1)]
 [!code-csharp[fileinfocopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfocopyto/CS/fileinfocopyto.cs#1)]
 [!code-vb[fileinfocopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfocopyto/VB/fileinfocopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> jest pusta, zawiera tylko białe znaki lub zawiera nieprawidłowe znaki.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd lub plik docelowy już istnieje i <paramref name="overwrite" /> jest <see langword="false" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog określony w <paramref name="destFileName" /> nie istnieje.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Ścieżka katalogu jest przekazywany w lub plik jest przenoszony do innego dysku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> zawiera dwukropek (:) w środku ciągu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Function Create () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; System.IO.FileStream" Usage="fileInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy plik.</summary>
        <returns>Nowy plik.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie pełna odczytu/zapisu do nowych plików dostęp do wszystkich użytkowników.  
  
 Ta metoda jest otoki dla funkcje udostępniane przez <xref:System.IO.File.Create%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład tworzy odwołanie do pliku, a następnie tworzy plik na dysku za pomocą `FileInfo.Create()`.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 Poniższy przykład tworzy plik, dodaje tekst i odczytuje z pliku.  
  
 [!code-cpp[finfo create#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Create/CPP/finfo create.cpp#1)]
 [!code-csharp[finfo create#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Create/CS/finfo create.cs#1)]
 [!code-vb[finfo create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Create/VB/finfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter CreateText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter CreateText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CreateText" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ CreateText();" />
      <MemberSignature Language="F#" Value="member this.CreateText : unit -&gt; System.IO.StreamWriter" Usage="fileInfo.CreateText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.IO.StreamWriter" /> który zapisuje nowy plik tekstowy.</summary>
        <returns>Nowy <see langword="StreamWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie pełna odczytu/zapisu do nowych plików dostęp do wszystkich użytkowników.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `CreateText` metody.  
  
 [!code-cpp[finfo createtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CreateText/CPP/finfo createtext.cpp#1)]
 [!code-csharp[finfo createtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CreateText/CS/finfo createtext.cs#1)]
 [!code-vb[finfo createtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CreateText/VB/finfo createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Nazwa pliku jest katalogiem.</exception>
        <exception cref="T:System.IO.IOException">Dysk jest tylko do odczytu.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public void Decrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Decrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Decrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Decrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Decrypt();" />
      <MemberSignature Language="F#" Value="member this.Decrypt : unit -&gt; unit" Usage="fileInfo.Decrypt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odszyfrowuje pliku, która została zaszyfrowana przy użyciu bieżącego konta <see cref="M:System.IO.FileInfo.Encrypt" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Decrypt%2A> Metoda służy do odszyfrowywania plików, która została zaszyfrowana przy użyciu <xref:System.IO.FileInfo.Encrypt%2A> metody.  <xref:System.IO.FileInfo.Decrypt%2A> Metody może odszyfrować tylko pliki, które zostały zaszyfrowane przy użyciu bieżącego konta użytkownika.  
  
 Zarówno <xref:System.IO.FileInfo.Encrypt%2A> — metoda i <xref:System.IO.FileInfo.Decrypt%2A> metoda korzysta z dostawcy usług kryptograficznych (CSP) zainstalowany na komputerze i kluczy szyfrowania pliku procesu podczas wywoływania metody.  
  
 Bieżący system plików musi być sformatowany jako NTFS i bieżący system operacyjny musi być systemu Microsoft Windows NT lub nowszego.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.FileInfo.Encrypt%2A> — metoda i <xref:System.IO.FileInfo.Decrypt%2A> metody do szyfrowania i odszyfrowywania następnie pliku.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">Określono nieprawidłowy dysk.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> nie można odnaleźć obiektu.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">System plików nie jest systemu plików NTFS.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Microsoft Windows NT lub nowszego.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Plik opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> obiekt jest tylko do odczytu.  - lub - tej operacji nie jest obsługiwane na bieżącej platformie.  - lub - obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" /> akcji zabezpieczeń: żądanie.  Uprawnienia do odczytu i zapisu do pliku opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> obiektu.</permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="fileInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Trwale usuwa plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli plik nie istnieje, ta metoda nie działa.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `Delete` metody.  
  
 [!code-cpp[finfo delete#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Delete/CPP/finfo delete.cpp#1)]
 [!code-csharp[finfo delete#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Delete/CS/finfo delete.cs#1)]
 [!code-vb[finfo delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Delete/VB/finfo delete.vb#1)]  
  
 Poniższy przykład tworzy, zamyka i usuwa plik.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Plik docelowy jest otwarte lub mapowanych na pamięć na komputerze z systemem Microsoft Windows NT.  - lub - brak otwarte dojście do pliku, a systemem operacyjnym jest Windows XP lub starszym. Ta otwarte dojście może wynikać z wyliczanie katalogów i plików. Aby uzyskać więcej informacji, zobacz [jak: Wyliczanie katalogów i Files](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Ścieżka jest katalogiem.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Directory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Directory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Directory" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Directory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Directory As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Directory { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Directory : System.IO.DirectoryInfo" Usage="System.IO.FileInfo.Directory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wystąpienie katalogu nadrzędnego.</summary>
        <value>A <see cref="T:System.IO.DirectoryInfo" /> obiekt reprezentujący ten plik katalogu nadrzędnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać katalogu nadrzędnego jako ciąg, użyj <xref:System.IO.FileInfo.DirectoryName%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład powoduje otwarcie lub tworzy plik, określa jego pełną ścieżkę i określa i wyświetla całą zawartość katalogu.  
  
 [!code-cpp[fileinfodirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodirectory/CPP/fileinfodirectory.cpp#1)]
 [!code-csharp[fileinfodirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodirectory/CS/fileinfodirectory.cs#1)]
 [!code-vb[fileinfodirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodirectory/VB/fileinfodirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DirectoryName">
      <MemberSignature Language="C#" Value="public string DirectoryName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryName" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.DirectoryName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectoryName : string" Usage="System.IO.FileInfo.DirectoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg reprezentujący pełną ścieżkę katalogu.</summary>
        <value>Ciąg reprezentujący pełną ścieżkę katalogu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać katalogu nadrzędnego jako <xref:System.IO.DirectoryInfo> obiektów, użyj <xref:System.IO.FileInfo.Directory%2A> właściwości.  
  
 Po pierwsze, <xref:System.IO.FileInfo> wywołania <xref:System.IO.FileSystemInfo.Refresh%2A> i przechowuje informacje o pliku. W kolejnych wywołaniach, należy wywołać <xref:System.IO.FileSystemInfo.Refresh%2A> Aby uzyskać najnowszą kopię informacji.  
  
   
  
## Examples  
 Poniższy przykład pobiera pełną ścieżkę pliku.  
  
 [!code-cpp[System.IO.FileInfo members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileInfo members/CPP/fileinfomembers.cpp#3)]
 [!code-csharp[System.IO.FileInfo members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileInfo members/CS/fileinfomembers.cs#3)]
 [!code-vb[System.IO.FileInfo members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileInfo members/VB/fileinfomembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see langword="null" /> została przekazana dla nazwy katalogu.</exception>
        <exception cref="T:System.IO.PathTooLongException">W pełni kwalifikowana nazwa przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public void Encrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Encrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Encrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Encrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Encrypt();" />
      <MemberSignature Language="F#" Value="member this.Encrypt : unit -&gt; unit" Usage="fileInfo.Encrypt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Szyfruje pliku, dzięki czemu można go odszyfrować tylko konto używane do szyfrowania pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Encrypt%2A> — Metoda umożliwia zaszyfrowanie pliku, dzięki czemu można go odszyfrować tylko konto używane do wywołania tej metody.  Użyj <xref:System.IO.FileInfo.Decrypt%2A> metody do odszyfrowania zaszyfrowanych przez plik <xref:System.IO.FileInfo.Encrypt%2A> metody.  
  
 Zarówno <xref:System.IO.FileInfo.Encrypt%2A> — metoda i <xref:System.IO.FileInfo.Decrypt%2A> metoda korzysta z dostawcy usług kryptograficznych (CSP) zainstalowany na komputerze i kluczy szyfrowania pliku procesu podczas wywoływania metody.  
  
 Bieżący system plików musi być sformatowany jako NTFS i bieżący system operacyjny musi być systemu Microsoft Windows NT lub nowszego.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.FileInfo.Encrypt%2A> — metoda i <xref:System.IO.FileInfo.Decrypt%2A> metodę, aby zaszyfrować plik, a następnie jego odszyfrowanie.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">Określono nieprawidłowy dysk.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> nie można odnaleźć obiektu.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">System plików nie jest systemu plików NTFS.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Microsoft Windows NT lub nowszego.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Plik opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> obiekt jest tylko do odczytu.  - lub - tej operacji nie jest obsługiwane na bieżącej platformie.  - lub - obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" /> akcji zabezpieczeń: żądanie.  Uprawnienia do odczytu i zapisu do pliku opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> obiektu.</permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.FileInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy plik istnieje.</summary>
        <value>
          <see langword="true" /> Jeśli plik istnieje; <see langword="false" /> Jeśli plik nie istnieje lub plik jest katalogiem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po pierwsze, <xref:System.IO.FileInfo> wywołania <xref:System.IO.FileSystemInfo.Refresh%2A> i przechowuje informacje o pliku. W kolejnych wywołaniach, należy wywołać <xref:System.IO.FileSystemInfo.Refresh%2A> Aby uzyskać najnowszą kopię informacji.  
  
 <xref:System.IO.FileInfo.Exists%2A> Zwraca `false` przypadku wystąpieniu błędu podczas próby określenia, czy istnieje określony plik. Taka sytuacja może wystąpić w sytuacji, które powodują wystąpienie wyjątków, takich jak przekazanie nazwę pliku z nieprawidłowe znaki lub zbyt wiele znaków, wystąpił błąd lub Brak dysku, lub jeśli element wywołujący nie ma uprawnienia do odczytu pliku.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.FileInfo.Exists%2A> właściwości upewnij się, istnieje plik przed jego otwarciem.  Ta metoda umożliwia throw niestandardowy wyjątek, jeśli plik nie został znaleziony.  
  
 [!code-cpp[IO.FileInfo.Exists#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Exists/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Exists/cs/sample.cs#1)]
 [!code-vb[IO.FileInfo.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Exists/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt hermetyzujący listę kontroli dostępu (ACL) wpisy kontroli dostępu dla pliku opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileInfo.GetAccessControl%2A> metody do pobierania dostępu kontrolują wpisy listę kontroli dostępu (ACL) dla bieżącego pliku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt hermetyzujący listę kontroli dostępu (ACL) wpisy kontroli dostępu dla pliku opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> obiektu.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt hermetyzujący regułami kontroli dostępu dla bieżącego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileInfo.GetAccessControl%2A> metodę, aby pobrać listę kontroli dostępu (ACL) wpisy kontroli dostępu dla bieżącego pliku.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji na dany plik. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.FileInfo.GetAccessControl%2A> — metoda i <xref:System.IO.FileInfo.SetAccessControl%2A> metodę, aby dodać, a następnie usuń listę kontroli dostępu (ACL) wpisu kontroli dostępu z pliku.  Należy podać prawidłowe konto użytkownika lub grupy do uruchomienia tego przykładu.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest Microsoft Windows 2000 lub nowszym.</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">Bieżące konto system nie ma uprawnień administracyjnych.</exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Ta operacja nie jest obsługiwane na bieżącej platformie.  - lub - obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> akcji zabezpieczeń: żądanie.  Aby uzyskać uprawnienia do odczytu listy kontroli dostępu.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.FileSecurity" Usage="fileInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">Jeden z <see cref="T:System.Security.AccessControl.AccessControlSections" /> wpisów można pobrać kontroli wartości, które określa grupę dostępu.</param>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt hermetyzujący określonego typu z kontroli dostępu listę kontroli dostępu (ACL) dla pliku opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> obiektu.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt hermetyzujący regułami kontroli dostępu dla bieżącego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileInfo.GetAccessControl%2A> metodę, aby pobrać listę kontroli dostępu (ACL) wpisy kontroli dostępu dla bieżącego pliku.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji na dany plik. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest Microsoft Windows 2000 lub nowszym.</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">Bieżące konto system nie ma uprawnień administracyjnych.</exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Ta operacja nie jest obsługiwane na bieżącej platformie.  - lub - obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> akcji zabezpieczeń: żądanie.  Aby uzyskać uprawnienia do odczytu listy kontroli dostępu.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool with get, set" Usage="System.IO.FileInfo.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy bieżący plik jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący plik jest tylko do odczytu. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileInfo.IsReadOnly%2A> właściwość, aby szybko określić, lub określ, czy bieżący plik jest tylko do odczytu.  
  
 Po pierwsze, <xref:System.IO.FileInfo> wywołania <xref:System.IO.FileSystemInfo.Refresh%2A> i przechowuje informacje o pliku. W kolejnych wywołaniach, należy wywołać <xref:System.IO.FileSystemInfo.Refresh%2A> Aby uzyskać najnowszą kopię informacji.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.FileInfo.IsReadOnly%2A> właściwości plik oznaczony jako tylko do odczytu i oznacz ją jako odczytu i zapisu.  
  
 [!code-cpp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.IsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.isReadOnly/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Plik opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> nie można odnaleźć obiektu.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Ta operacja nie jest obsługiwane na bieżącej platformie.  - lub - obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">Użytkownik nie ma uprawnień do zapisu, ale próba, aby ustawić tę właściwość na <see langword="false" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" /> akcji zabezpieczeń: żądanie.  Uprawnienia do odczytu i zapisu do pliku opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> obiektu.</permission>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileInfo.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar w bajtach bieżący plik.</summary>
        <value>Rozmiar bieżącego pliku w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.IO.FileInfo.Length%2A> właściwość jest wstępnie pamięci podręcznej, jeśli bieżące wystąpienie klasy <xref:System.IO.FileInfo> obiekt zwrócony od następujących <xref:System.IO.DirectoryInfo> metod:  
  
-   <xref:System.IO.DirectoryInfo.GetDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>  
  
 Aby uzyskać najnowszą wartość, należy wywołać <xref:System.IO.FileSystemInfo.Refresh%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono rozmiar określonych plików.  
  
 [!code-cpp[FileLength#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileLength/CPP/filelength.cpp#1)]
 [!code-csharp[FileLength#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileLength/CS/filelength.cs#1)]
 [!code-vb[FileLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileLength/VB/filelength.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <see cref="M:System.IO.FileSystemInfo.Refresh" /> Nie można zaktualizować stanu pliku lub katalogu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.  - lub - <see langword="Length" /> właściwości jest wywoływana dla katalogu.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="fileInfo.MoveTo destFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">Ścieżka do przenieść plik, który można określić inną nazwę pliku.</param>
        <summary>Przenosi określony plik do nowej lokalizacji, zapewniając opcję, aby określić nową nazwę pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na woluminach dysku. Na przykład c:\MyFile.txt pliku mogą zostać przeniesione do d:\Publiczne i zmienić jej nazwy NowyPlik.txt.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przenoszenie plików do innej lokalizacji i zmiana nazwy pliku.  
  
 [!code-csharp[IO.FileInfo.MoveTo#1](~/samples/snippets/csharp/VS_Snippets_Misc/IO.FileInfo.MoveTo/CS/Program.cs#1)]
 [!code-vb[IO.FileInfo.MoveTo#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/IO.FileInfo.MoveTo/VB/Program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy, takich jak plik docelowy już istnieje, lub urządzenie docelowe nie jest gotowy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> jest pusta, zawiera tylko białe znaki lub zawiera nieprawidłowe znaki.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="destFileName" /> jest tylko do odczytu lub katalogu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> zawiera dwukropek (:) w środku ciągu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę pliku.</summary>
        <value>Nazwa pliku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po pierwsze, <xref:System.IO.FileInfo> wywołania <xref:System.IO.FileSystemInfo.Refresh%2A> i przechowuje informacje o pliku. W kolejnych wywołaniach, należy wywołać <xref:System.IO.FileSystemInfo.Refresh%2A> Aby uzyskać najnowszą kopię informacji.  
  
 Nazwa pliku zawiera rozszerzenie pliku.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `Name` właściwość, aby wyświetlić nazwy plików w bieżącym katalogu.  
  
 [!code-cpp[fileinfoname#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoname/CPP/fileinfoname.cpp#1)]
 [!code-csharp[fileinfoname#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoname/CS/fileinfoname.cs#1)]
 [!code-vb[fileinfoname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoname/VB/fileinfoname.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umożliwia otwarcie pliku z różnych odczytu/zapisu i uprawnienia udostępniania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode -&gt; System.IO.FileStream" Usage="fileInfo.Open mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">A <see cref="T:System.IO.FileMode" /> stała Określanie trybu (na przykład <see langword="Open" /> lub <see langword="Append" />) do otwarcia pliku.</param>
        <summary>Otwiera plik w określonym trybie.</summary>
        <returns>Plik otwarty w określonym trybie, z dostępem do odczytu/zapisu i anulować.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład otwiera plik, niektóre informacje dodane do pliku i odczytuje plik.  
  
 [!code-cpp[finfo open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open1/CPP/finfo open1.cpp#1)]
 [!code-csharp[finfo open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open1/CS/finfo open1.cs#1)]
 [!code-vb[finfo open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open1/VB/finfo open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Plik jest tylko do odczytu lub katalogu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">Plik jest już otwarty.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania i Odczyt z plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="fileInfo.Open (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">A <see cref="T:System.IO.FileMode" /> stała Określanie trybu (na przykład <see langword="Open" /> lub <see langword="Append" />) do otwarcia pliku.</param>
        <param name="access">A <see cref="T:System.IO.FileAccess" /> Stała określająca, czy można otworzyć pliku z <see langword="Read" />, <see langword="Write" />, lub <see langword="ReadWrite" /> dostęp do plików.</param>
        <summary>Otwiera plik w określonym trybie odczytu, zapisu lub odczytu i zapisu.</summary>
        <returns>A <see cref="T:System.IO.FileStream" /> obiektu otwarty w określonym trybie i dostęp i anulować.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład powoduje otwarcie pliku jako tylko do odczytu i odczytuje z pliku.  
  
 [!code-cpp[finfo open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open2/CPP/finfo open2.cpp#1)]
 [!code-csharp[finfo open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open2/CS/finfo open2.cs#1)]
 [!code-vb[finfo open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open2/VB/finfo open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> jest tylko do odczytu lub katalogu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">Plik jest już otwarty.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania i Odczyt z plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="fileInfo.Open (mode, access, share)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="mode">A <see cref="T:System.IO.FileMode" /> stała Określanie trybu (na przykład <see langword="Open" /> lub <see langword="Append" />) do otwarcia pliku.</param>
        <param name="access">A <see cref="T:System.IO.FileAccess" /> Stała określająca, czy można otworzyć pliku z <see langword="Read" />, <see langword="Write" />, lub <see langword="ReadWrite" /> dostęp do plików.</param>
        <param name="share">A <see cref="T:System.IO.FileShare" /> stała określenie typu dostęp do innych <see langword="FileStream" /> obiekty mają do tego pliku.</param>
        <summary>Otwiera plik w określonym trybie z odczytu, zapisu, lub dostęp do odczytu/zapisu i określona opcja udostępniania.</summary>
        <returns>A <see cref="T:System.IO.FileStream" /> otworzyć określony tryb dostępu, a następnie opcje udostępniania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano otwierania pliku do odczytu i zapisu, ale brak zezwolenia dostęp do innych użytkownikami lub procesami.  
  
 [!code-cpp[fileinfoopen#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoopen/CPP/fileinfoopen.cpp#1)]
 [!code-csharp[fileinfoopen#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoopen/CS/fileinfoopen.cs#1)]
 [!code-vb[fileinfoopen#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoopen/VB/fileinfoopen.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> jest tylko do odczytu lub katalogu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">Plik jest już otwarty.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania i Odczyt z plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenRead" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenRead () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenRead();" />
      <MemberSignature Language="F#" Value="member this.OpenRead : unit -&gt; System.IO.FileStream" Usage="fileInfo.OpenRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy tylko do odczytu <see cref="T:System.IO.FileStream" />.</summary>
        <returns>Nowy tylko do odczytu <see cref="T:System.IO.FileStream" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca wartość tylko do odczytu <xref:System.IO.FileStream> obiekt z <xref:System.IO.FileShare> tryb <xref:System.IO.FileShare.Read>.  
  
   
  
## Examples  
 Poniższy przykład powoduje otwarcie pliku jako tylko do odczytu i odczytuje z niego.  
  
 [!code-cpp[finfo openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenRead/CPP/finfo openread.cpp#1)]
 [!code-csharp[finfo openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenRead/CS/finfo openread.cs#1)]
 [!code-vb[finfo openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenRead/VB/finfo openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> jest tylko do odczytu lub katalogu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">Plik jest już otwarty.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamReader OpenText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenText" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenText () As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenText();" />
      <MemberSignature Language="F#" Value="member this.OpenText : unit -&gt; System.IO.StreamReader" Usage="fileInfo.OpenText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.IO.StreamReader" /> z kodowaniem UTF8, która odczytuje z istniejącego pliku tekstowego.</summary>
        <returns>Nowy <see langword="StreamReader" /> z kodowaniem UTF8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład odczytuje tekst z pliku.  
  
 [!code-cpp[finfo opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[finfo opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenText/CS/file opentext.cs#1)]
 [!code-vb[finfo opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> jest tylko do odczytu lub katalogu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenWrite ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenWrite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenWrite" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenWrite () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenWrite();" />
      <MemberSignature Language="F#" Value="member this.OpenWrite : unit -&gt; System.IO.FileStream" Usage="fileInfo.OpenWrite " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy tylko do zapisu <see cref="T:System.IO.FileStream" />.</summary>
        <returns>Tylko do zapisu cofnięto <see cref="T:System.IO.FileStream" /> obiekt do nowego lub istniejącego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.OpenWrite%2A> Metody otwiera plik, jeśli już istnieje dla ścieżki pliku lub tworzy nowy plik, jeśli jeszcze nie istnieje. Dla istniejącego pliku jego nie Dołącz nowy tekst do istniejącego tekstu. Zamiast tego zastępuje on istniejące znaki znakami nowego. W przypadku zastąpienia dłuższy ciąg (takie jak "To jest test metody OpenWrite") z krótszego ciągu (na przykład "Uruchom drugi"), ten plik zawiera mieszane ciągów ("drugi runtest metody OpenWrite").  
  
   
  
## Examples  
 Poniższy przykład powoduje otwarcie pliku do zapisu i następnie odczytuje z pliku.  
  
 [!code-cpp[finfo openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[finfo openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[finfo openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Ścieżka określona podczas tworzenia wystąpienia <see cref="T:System.IO.FileInfo" /> obiekt jest tylko do odczytu lub jest katalogiem.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona podczas tworzenia wystąpienia <see cref="T:System.IO.FileInfo" /> obiektu jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zastępuje zawartość określonego pliku opisanego przez bieżący plik <see cref="T:System.IO.FileInfo" /> obiektu, usunięcie oryginalnego pliku, a tworzenie kopii zapasowej pliku zastąpionego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileInfo.Replace%2A> metod, gdy chcesz szybko Zastąp zawartość pliku opisanego przez bieżącego pliku <xref:System.IO.FileInfo> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.IO.FileInfo" Usage="fileInfo.Replace (destinationFileName, destinationBackupFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">Nazwa pliku, aby zastąpić bieżący plik.</param>
        <param name="destinationBackupFileName">Nazwa pliku, z którym chcesz utworzyć kopię zapasową pliku opisanego przez <c>destFileName</c> parametru.</param>
        <summary>Zastępuje zawartość określonego pliku opisanego przez bieżący plik <see cref="T:System.IO.FileInfo" /> obiektu, usunięcie oryginalnego pliku, a tworzenie kopii zapasowej pliku zastąpionego.</summary>
        <returns>A <see cref="T:System.IO.FileInfo" /> obiekt hermetyzujący informacje o pliku opisanego przez <paramref name="destFileName" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Replace%2A> Metoda zastępuje zawartość pliku opisanego przez bieżącą zawartość określonego pliku <xref:System.IO.FileInfo> obiektu.  Tworzy kopię zapasową pliku, który został zastąpiony.  Na koniec zwraca nową <xref:System.IO.FileInfo> obiektu, który opisuje plików zastąpione.  
  
> [!CAUTION]
>  Ta metoda powiedzie się w środowisku systemu Windows 2000, jeśli `destFileName` jest tylko do odczytu i nie zgłosi wyjątku. Użyj <xref:System.IO.FileInfo.IsReadOnly%2A> właściwość do sprawdzenia, czy plik docelowy nie jest tylko do odczytu przed podjęciem próby go zastąpić.  
  
 Przekaż `null` do `destBackupFileName` parametru, jeśli nie chcesz utworzyć kopię zapasową pliku figury geometrycznej.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.File.Replace%2A> metody w celu zastąpienia pliku z innego pliku i utworzyć kopię zapasową pliku zastąpionego.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka opisanego przez <paramref name="destFileName" /> niedozwolony format nie został parametr.  - lub - ścieżka opisanego przez <paramref name="destBackupFileName" /> niedozwolony format nie został parametr.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> nie można odnaleźć obiektu.  - lub - opisanego przez plik <paramref name="destinationFileName" /> nie można odnaleźć parametru.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Microsoft Windows NT lub nowszego.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> akcji zabezpieczeń: żądanie.  Aby uzyskać uprawnienia do zapisu do pliku opisanego przez <paramref name="destBackupFileName" /> parametru, jeśli został określony.</permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool -&gt; System.IO.FileInfo" Usage="fileInfo.Replace (destinationFileName, destinationBackupFileName, ignoreMetadataErrors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">Nazwa pliku, aby zastąpić bieżący plik.</param>
        <param name="destinationBackupFileName">Nazwa pliku, z którym chcesz utworzyć kopię zapasową pliku opisanego przez <c>destFileName</c> parametru.</param>
        <param name="ignoreMetadataErrors">
          <see langword="true" /> Aby zignorować błędy seryjnego (takich jak atrybuty i listy kontroli dostępu) z pliku zastąpionego do pliku wymiany; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zastępuje zawartość określonego pliku opisanego przez bieżący plik <see cref="T:System.IO.FileInfo" /> obiektu, usunięcie oryginalnego pliku, a tworzenie kopii zapasowej pliku zastąpionego.  Ponadto określa, czy Ignoruj błędy seryjnego.</summary>
        <returns>A <see cref="T:System.IO.FileInfo" /> obiekt hermetyzujący informacje o pliku opisanego przez <paramref name="destFileName" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Replace%2A> Metoda zastępuje zawartość pliku opisanego przez bieżącą zawartość określonego pliku <xref:System.IO.FileInfo> obiektu.  Tworzy kopię zapasową pliku, który został zastąpiony.  Na koniec zwraca nową <xref:System.IO.FileInfo> obiektu, który opisuje plików zastąpione.  
  
> [!CAUTION]
>  Ta metoda powiedzie się w środowisku systemu Windows 2000, jeśli `destFileName` jest tylko do odczytu i nie zgłosi wyjątku. Użyj <xref:System.IO.FileInfo.IsReadOnly%2A> właściwość do sprawdzenia, czy plik docelowy nie jest tylko do odczytu przed podjęciem próby go zastąpić.  
  
 Przekaż `null` do `destBackupFileName` parametru, jeśli nie chcesz utworzyć kopię zapasową pliku figury geometrycznej.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.File.Replace%2A> metody w celu zastąpienia pliku z innego pliku i utworzyć kopię zapasową pliku zastąpionego.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka opisanego przez <paramref name="destFileName" /> niedozwolony format nie został parametr.  - lub - ścieżka opisanego przez <paramref name="destBackupFileName" /> niedozwolony format nie został parametr.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> nie można odnaleźć obiektu.  - lub - opisanego przez plik <paramref name="destinationFileName" /> nie można odnaleźć parametru.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Microsoft Windows NT lub nowszego.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> akcji zabezpieczeń: żądanie.  Aby uzyskać uprawnienia do zapisu do pliku opisanego przez <paramref name="destBackupFileName" /> parametru, jeśli został określony.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileInfo.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">A <see cref="T:System.Security.AccessControl.FileSecurity" /> obiektu, który opisuje wpisu listę kontroli dostępu (ACL) kontroli dostępu do zastosowania do bieżącego pliku.</param>
        <summary>Stosuje listę kontroli dostępu (ACL) wpisów kontroli dostępu, opisanego przez <see cref="T:System.Security.AccessControl.FileSecurity" /> obiektu do pliku opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.SetAccessControl%2A> Metoda stosowana wpisów listę kontroli dostępu (ACL) kontroli dostępu do bieżącego pliku, który reprezentuje noninherited listy ACL.  
  
 Użyj <xref:System.IO.FileInfo.SetAccessControl%2A> metody, gdy należy dodać lub usunąć wpisy listy ACL z pliku.  
  
> [!CAUTION]
>  Określona lista ACL dla `fileSecurity` parametru zastępuje istniejące listy ACL dla pliku. Aby dodać uprawnienia dla nowego użytkownika, należy użyć <xref:System.IO.Directory.GetAccessControl%2A> metodę, aby uzyskać istniejące listy ACL, zmodyfikuj go, a następnie użyj <xref:System.IO.FileInfo.SetAccessControl%2A> powrót do pliku.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji na dany plik. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 <xref:System.IO.FileInfo.SetAccessControl%2A> Metody tylko będzie się powtarzał <xref:System.Security.AccessControl.FileSecurity> obiektów, które zostały zmodyfikowane po utworzeniu obiektu.  Jeśli <xref:System.Security.AccessControl.FileSecurity> obiektu nie został zmodyfikowany, nie będzie można utrwalone w pliku.  W związku z tym nie jest możliwe do pobrania <xref:System.Security.AccessControl.FileSecurity> obiektu z jednego pliku i ponownie zastosuj ten sam obiekt do innego pliku.  
  
 Aby skopiować informacje listy ACL z jednego pliku do innego:  
  
1.  Użyj <xref:System.IO.FileInfo.GetAccessControl%2A> metoda pobierania <xref:System.Security.AccessControl.FileSecurity> obiektów z pliku źródłowego.  
  
2.  Utwórz nową <xref:System.Security.AccessControl.FileSecurity> obiektu dla pliku docelowego.  
  
3.  Użyj <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> lub <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metody źródła <xref:System.Security.AccessControl.FileSecurity> obiekt, aby pobrać listę kontroli dostępu.  
  
4.  Użyj <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> lub <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metodę, aby skopiować dane pobierane w kroku 3 do miejsca docelowego <xref:System.Security.AccessControl.FileSecurity> obiektu.  
  
5.  Skonfiguruj docelowego <xref:System.Security.AccessControl.FileSecurity> obiektu przy użyciu pliku docelowego <xref:System.IO.FileInfo.SetAccessControl%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.FileInfo.GetAccessControl%2A> — metoda i <xref:System.IO.FileInfo.SetAccessControl%2A> metodę, aby dodać, a następnie usuń wpis listy ACL z pliku.  Należy podać prawidłowe konto użytkownika lub grupy do uruchomienia tego przykładu.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileSecurity" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć lub modyfikacji pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący proces nie ma dostępu do otwierania pliku.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest Microsoft Windows 2000 lub nowszym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" /> akcji zabezpieczeń: żądanie dla uprawnień dostępu do tego pliku.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="fileInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ścieżkę jako ciąg.</summary>
        <returns>Ciąg reprezentujący ścieżkę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość ciągu zwróconego przez <xref:System.IO.FileInfo.ToString%2A> metody reprezentuje ścieżkę, który został przekazany do konstruktora.  Po utworzeniu <xref:System.IO.FileInfo> przy użyciu konstruktorów, <xref:System.IO.FileInfo.ToString%2A> — metoda zwraca w pełni kwalifikowaną ścieżkę.  Istnieją jednak przypadki, w którym ciąg zwrócony przez <xref:System.IO.FileInfo.ToString%2A> — metoda nie reprezentuje pełną ścieżkę.  Na przykład podczas tworzenia <xref:System.IO.FileInfo> przy użyciu <xref:System.IO.DirectoryInfo.GetFiles%2A> metody <xref:System.IO.FileInfo.ToString%2A> — metoda nie reprezentuje pełną ścieżkę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>